// Copyright (c) Tech Soft 3D, Inc.
//
// The information contained herein is confidential and proprietary to Tech Soft 3D, Inc.,
// and considered a trade secret as defined under civil and criminal statutes.
// Tech Soft 3D, Inc. shall pursue its civil and criminal remedies in the event of
// unauthorized use or misappropriation of its trade secrets.  Use of this information
// by anyone other than authorized employees of Tech Soft 3D, Inc. is granted only under
// a written non-disclosure agreement, expressly prescribing the scope and manner of such use.

#ifndef HPS_H
#define HPS_H

#ifdef _MSC_VER
#	ifndef STATIC_APP
#		ifdef HPS_CORE_BUILD
#			define HPS_API __declspec (dllexport)
#			define EXPIMP_TEMPLATE
#		else
#			define HPS_API __declspec (dllimport)
#			define EXPIMP_TEMPLATE extern
#		endif
#		define HPS_TEMPLATE_API __declspec (dllexport)
#	endif
#	ifdef _WINDOWS_
#		undef Ellipse
#		undef Polyline
#		undef Polygon
#		undef Rectangle
#		undef min
#		undef max
#	endif
#	pragma warning(push)
#	pragma warning(disable: 4251) //Not an issue as long as debug and release libraries aren't mixed
#else
#	include <limits.h>
#	include <stddef.h>
#	ifdef LINUX_SYSTEM
#		ifndef STATIC_APP
#			ifdef HPS_CORE_BUILD
#				define HPS_API __attribute__ ((visibility ("default")))
#				define EXPIMP_TEMPLATE
#			else
#				define EXPIMP_TEMPLATE extern
#			endif
#			define HPS_TEMPLATE_API __attribute__ ((visibility ("default")))
#		endif
#	endif
#endif
#ifndef HPS_API
#	define HPS_API
#endif
#ifndef HPS_TEMPLATE_API
#	define HPS_TEMPLATE_API
#endif
#ifndef EXPIMP_TEMPLATE
#	define EXPIMP_TEMPLATE
#endif
#ifndef ENUM_CLASS
#	define ENUM_CLASS enum class
#endif

#define NO_HPS_API

#include <stdint.h>
#include <memory>
#include <vector>
#include <math.h>
#include <float.h>
#include <limits>
#include <stdexcept>
#include <algorithm>
#include <cstring>


namespace HPSI
{
	class Impl;
	class KeyImpl;
	class TicketImpl;
	class EventDispatcherImpl;
	class AbstractImage;
	class String;
};

namespace HPS
{

	// unimplemented


//Begin Info
/*! The Info class is a concept class for information, warning, and error codes. */
class HPS_API Info
{
public:

	/*! \enum Code
	*	Enumerates the types of information, warning, and error messages. */
	enum class Code : uint32_t
	{
		Unknown,			//!< Info type and source unknown.
		Exchange,			//!< Info from Exchange.
		Publish,			//!< Info from Publish.
		Data,				//!< Problem with provided data.
		Key,				//!< Problem with provided key.	
		Geometry,			//!< Problem with provided geometry.
		Database,			//!< Problem with scene.
		Driver,				//!< Problem with driver.
		Internal,			//!< Problem with internal system.
		Memory,				//!< Problem with memory.
		System,				//!< Problem operating environment.
		Unsupported,		//!< Use is unsupported.
		DWG,				//!< Info from DWG.
		Parasolid,			//!< Info from Parasolid.
	};

private:
	Info() {}
};


//Begin Info
/*! The Emergency class is a concept class for Emergency codes. */
class HPS_API Emergency
{
public:

	/*! \enum Code
	*	This describe the types of conditions that can trigger an EmergencyHandler. */
	enum class Code : uint32_t
	{
		Unknown,			//!< Emergencies type unknown.
		Fatal,				//!< Fatal fault has occurred. Saving the Database is not possible and the EmergencyHandler must abort. After a fatal error, no Visualize functions may be called - to do so will result in a crash or deadlock.    
		SoftMemoryLimit,	//!< Soft memory limit breached. This limit is considered to be breached when Visualize has allocated the amount of memory specified by a previous call to HPS::Database::SetSoftMemoryLimit.
		HardMemoryLimit,	//!< Hard memory limit breached. This limit is considered to be breached when an operating system memory allocation has failed, and indicates that Visualize is not able to allocate memory required for proceeding with normal operation.
	};

private:
	Emergency() {}
};


//Begin Window
/*! The Window class is a concept class for window-related enum classes. */
class HPS_API Window
{
public:

	/*! \enum Driver 
	 *	Enumerates the types of supported display drivers. We recommend that you use the Default3D driver type,
	 *	and provide end-users with the ability to manually select from a range of 3d drivers in a driver-pulldown list.
	 *	This will allow them to potentially work around graphics-card-specific problems that occur with a specific driver type.*/
	enum class Driver : uint32_t
	{
		Default3D,			//!< Visualize will perform runtime query of the 3D capabilities of the Operating System and graphics card and automatically choose a display driver.  Under Windows, preference will be given to DirectX API, followed by OpenGL. Under all other platforms, only the OpenGL API is supported. 
		OpenGL,				//!< This is an alias for OpenGL2
		OpenGL2,			//!< Shader-based driver which supports OpenGL 2.X+   Available on Windows, Linux, Mac OS X, iOS and Android.
		DirectX11,			//!< Shader-based driver which supports DirectX 10.X+   Available on Windows. 
		OpenGL1Deprecated,	//!< \deprecated (OpenGL1 has been deprecated and will be removed from a future version; please use the OpenGL2 driver instead.) Fixed-function driver which supports OpenGL 1.X+   Any functionality that requires shaders will not be supported when using this driver. Available on Windows, Linux and Mac OS X.
		Vulkan,
		OpenGL2Mesa,
	};

	/*! \enum UpdateStatus 
	 *	Enumerates the status that can be returned when performing an update. */
	enum class UpdateStatus : uint32_t
	{
		InProgress,			//!< Update is not done yet.
		Completed,			//!< Update was successfully completed.
		TimedOut,			//!< Update timed out before it could be completed.
		Interrupted,		//!< Update was interrupted.
		Failed				//!< Update failed.
	};

	/*! \enum UpdateType
	Controls the type of update that Visualize will attempt to perform. For information regarding static model regeneration for each specific UpdateType, 
	please see <a href="../../prog_guide/0703_performance_considerations.html">Performance Considerations</a> in the %Rendering section of the programming guide. */
	enum class UpdateType : uint32_t
	{
		//! Makes sure that the screen is up-to-date with respect to the internal scene graph. Allows Visualize to automatically perform optimizations.
		Default,

		/*! Redraws the entire scene regardless of whether any changes occurred in the scene-graph which may have triggered (required) an update.
		It should only be used in specific situations where an update is required due to factors external to the scene-graph.
		An example would be the situation where GUI event-handling logic encounters a 'GUI window expose' event which Visualize is not aware of,
		but the scene needs to be forcefully redrawn to repair (via a complete redraw) the exposed portion of the window.  */
		Complete,

		//! Pulls the back buffer onto the screen. This is a useful way to update the screen after an expose event like when a window that was occluding your scene is moved away.
		Refresh,
		
		//! Only compiles static trees and display lists.
		CompileOnly,

		/*! Will perform a complete update and also rebuild static trees and display lists that are enabled in the scene-graph.
		This should typically only be performed for the first update following a file load, or the effective equivalent, such as loading/creating another model
		inside an existing scene-graph that has the static setting.  */
		Exhaustive,
	};

	/*! \enum Mobility
	 *	Enumerates the mobility modes (i.e., resizing and positioning behaviors) for stand-alone windows. */
	enum class Mobility : uint32_t
	{
		Locked,				//!< The stand-alone window cannot be moved or resized.
		Floating,			//!< The stand-alone window can be moved, but cannot be resized.
		FixedRatio,			//!< The stand-alone window can be moved and resized, but the aspect ratio cannot be changed.
		Free				//!< The stand-alone window can be moved and resized, and the aspect ratio can be changed.
	};

	/*! \enum FrameSize
	Dimensions of the Window Frame */
	enum class FrameSize : uint32_t
	{
		Single,				//!< Window Frame Size
		Double				//!< Window Frame Size
	};

	/*! \enum FrameOptions
	Window Frame Positioning */
	enum class FrameOptions : uint32_t
	{
		Inset,				//!< Window Frame Positioning
		Overlay				//!< Window Frame Positioning
	};

	/*! \enum ImageFormat
	The native image format for off-screen windows */
	enum class ImageFormat : uint32_t
	{
		Default,			//!< Image Format
		RGBA,				//!< Image Format
		RGB,				//!< Image Format
		Jpeg,				//!< Image Format
		Png					//!< Image Format
	};

private:
	Window() {}
};

//Begin Subwindow
/*! This is the Subwindow Class*/
class HPS_API Subwindow
{
public:
	enum class Background : uint32_t
	{
		SolidColor,						//!< Subwindow Background
		Image,							//!< Subwindow Background
		Cubemap,						//!< Subwindow Background
		Blend,							//!< Subwindow Background
		Transparent,					//!< Subwindow Background
		Interactive,					//!< Subwindow Background

		GradientTopToBottom,			//!< Subwindow Background
		GradientBottomToTop,			//!< Subwindow Background
		GradientLeftToRight,			//!< Subwindow Background
		GradientRightToLeft,			//!< Subwindow Background
		GradientTopLeftToBottomRight,	//!< Subwindow Background
		GradientTopRightToBottomLeft,	//!< Subwindow Background
		GradientBottomLeftToTopRight,	//!< Subwindow Background
		GradientBottomRightToTopLeft,	//!< Subwindow Background
	};

	enum class Type : uint32_t
	{
		Standard,			//!< Subwindow Type
		Lightweight			//!< Subwindow Type
	};

	enum class Border : uint32_t
	{
		None,				//!< Subwindow Border
		Inset,				//!< Subwindow Border
		InsetBold,			//!< Subwindow Border
		Overlay,			//!< Subwindow Border
		OverlayBold			//!< Subwindow Border
	};


    /*! \enum RenderingAlgorithm  Specifies the Rendering Algorithm to use for drawing the scene. */
	enum class RenderingAlgorithm : uint32_t
	{
		/*! Instructs the system to use a z-buffering algorithm which is of O(n) complexity.
		 *	A hardware z-buffer will be used if the active display driver supports it, otherwise a software-buffer will be used. */
		ZBuffer,			

		/*! Instructs the system to display visible (i.e. unobscured) lines, edges, markers and text. Recommended when rendering an HLR result to any 2D driver device such as hardcopy.
		 *  Faces which are set to be visible are used to obscure the lines, edges, markers and text. It is O(n log n) complexity, and therefore computationally intensive when dealing with a
		 *  large amount of geometry in the scene.  
		 *  This rendering algorithm is not interruptible, and Visualize will perform a full update regardless of the amount of time required.  
		 *  Therefore it is not compatible with time-bound updates which are also used by Visualize to provide fixed-framerate support. */
		HiddenLine,			

		/*! Instructs the system to display visible (i.e. unobscured) lines, edges, markers and text. Recommended when you wish to display accurate HLR result on the screen.
		 *  Faces which are set to be visible are used to obscure the lines, edges, markers and text. It is O(n) complexity and uses a multi-pass, z-buffer rendering approach that takes
		 *  advantage of underlying 3D graphics hardware.  
		 *  This rendering algorithm is not interruptible, and Visualize will perform a full update regardless of the amount of time required.
		 *  Therefore it is not compatible with time-bound updates which are also used by Visualize to provide fixed-framerate support. */
		FastHiddenLine,		

		/*! 
         *  <p>Instructs the system to use the priority value specified by SegmentKey::SetPriority to ultimately determine the drawing order of objects. Objects with the highest priority are drawn on top, regardless of Z order. This algorithm is primarily intended to control layering within 2D scenes and will cause undesired results when rendering non-planar objects that have some parts overlapping others within the same primitive. The shader-based DirectX and OpenGL2 drivers have the ability to convert priority values into final Z positions, thereby enabling hardware-accelerated z-buffer rendering, and thus fast performance. Other drivers will produce the correct result, but rendering will be slower since all geometry will be sorted during scene-graph traversal. Priority can be set at a number of different levels:</p>
         *  
		 *	<p><b>Segment-level priority:</b> Priority values only control the traversal order of sibling segments. It does not directly control drawing order of geometry, however, segment-level priority will influence the draw order of two geometries in sibling segments which have the same priority value.</p>
         *  
		 *  <p><b>Geometry-level priority:</b> Priority values applied to primitives are global and are honored irrespective of the priority values of their parent segments. Use this to control draw order.</p>
         *  
		 *  <p><b>Include links:</b> All primitives behind an include link are put into the global list according to the priority set on the include link
		 *  and then sorted relative to each other using their respective priorities.</p>
		 *  
         *  <p><b>Limitations:</b></p>
         *  
         *  <p>This algorithm does NOT work with anti-aliasing. Anti-aliasing will not be applied to scenes rendered with priority. If it is attempted, geometry will be drawn, but it will NOT be anti-aliased.</p>
         *  
         *  <p>Working with priority on a mobile platform? You should be aware that when two geometries are inserted with the same priority, and one of those geometries is transparent, the transparent geometry will draw on top of the opaque one. This only apples when depth peeling is used as the transparency method.</p>
         */
		Priority			
	};

private:
	Subwindow() {}
};
//End Subwindow

/*! This is the Style Class */
class HPS_API Style
{
public:

	/*! \enum Type
	The type of style	*/
	enum class Type : uint32_t
	{
		Segment,		//!< Style Type
		Named			//!< Style Type
	};

	/*! \enum AppendMode
	The behavior when appending multiple conditional styles that refer to the same source segment.	*/
	enum class AppendMode : uint32_t
	{
		None,		//!< Style Append Mode
		And,		//!< Style Append Mode
		Or			//!< Style Append Mode
	};

private:
	Style() {}
};


/*! The Shell class is a concept class for shell-related enum classes. */
class HPS_API Shell
{
public:

	/*! \enum Component
	 *	Enumerates the shell components that vertex colors can be applied to. */
	enum class Component : uint32_t
	{
		Faces,		//!< The vertex colors applied to faces.
		Edges,		//!< The vertex colors applied to edges.
		Vertices	//!< The vertex colors applied to vertices.
	};

	/* \enum ToleranceUnits
	 * Enumerates the Tolerance Units used to determine if points can be merged during shell optimization. */
	enum class ToleranceUnits : uint32_t
	{
		ObjectSpace,			//!< Base tolerance on absolute distance in object space.
		FeatureSizePercentage	//!< Base tolerance on percentage of the smallest non-zero distance between adjacent vertices or faces.
	};

	/* \enum HandednessOptimization
	 * Enumerates the shell optimization options with regards to handedness. */
	enum class HandednessOptimization : uint32_t
	{
		None,					//!< Do nothing with handedness.
		Fix,					//!< Converts the handedness of the minority of the face to the handedness of the majority.
		Reverse					//!< Reverses the handedness of the shell's faces
	};

	/* \enum RelationResults
	 * Enumerates the results of a shell relation computation. */
	enum class Relation : uint32_t
	{
		On,						//!< The point is on this shell, within the specified tolerance.
		Off,					//!< The point is not on this shell, within the specified tolerance.
		In,						//!< The point is inside this shell.
		Out						//!< The point is outside this shell.
	};

	/* \enum RelationTest
	 * Enumerates the test options for a shell relation computation. */
	enum class RelationTest : uint32_t
	{
		Simple,					//!< The points will only be tested for whether they lie on this shell or not.
		Enclosure,				//!< The points will be tested for whether they lie on this shell, are enclosed within, or are outside it.
		Distance				//!< The shortest distance from each point to this shell will be computed.
	};

private:
	Shell() {}
};


/*! The Mesh class is a concept class for mesh-related enum classes. */
class HPS_API Mesh
{
public:

	/*! \enum Component
	 *	Enumerates the mesh components that vertex colors can be applied to. */
	enum class Component : uint32_t
	{
		Faces,		//!< The vertex colors applied to faces.
		Edges,		//!< The vertex colors applied to edges.
		Vertices	//!< The vertex colors applied to vertices.
	};

private:
	Mesh() {}
};


/*! The InfiniteLine class is a concept class for infinite-line-related enum classes. */
class HPS_API InfiniteLine
{
public:

	/*! \enum Type
	 *	Enumerates the types of infinite line objects. */
	enum class Type : uint32_t
	{
		Line,		//!< Infinite line which  extends infinitely in both directions along a vector.
		Ray			//!< Infinite ray which extends infinitely in one direction along a vector.
	};

private:
	InfiniteLine() {}
};


/*! The Trim class is a concept class for trim-related enum classes. */
class HPS_API Trim
{
public:

	/*! \enum Type
	 *	Enumerates the types of curves that can be used to define a trim region for a NURBS surface. */
	enum class Type : uint32_t
	{
		Line,			//!< A line will act as the trim.
		Curve			//!< A NURBS curve will act as the trim.
	};

	/*! \enum Operation
	 *	Enumerates the operation the trim region will perform.  This indicates whether the NURBS surface interior to a trim region is kept or removed, and hence, whether the surface
	 *	exterior to a region is removed or kept. */
	enum class Operation : uint32_t
	{
		Keep,			//!< Keep the surface interior to the trim region and remove the surface exterior to the trim region.
		Remove			//!< Remove the surface interior to the trim region and keep the surface exterior to the trim region.
	};

private:
	Trim() {}
};


/*! The Spotlight class is a concept class for spotlight-related enum classes. */
class HPS_API Spotlight
{
public:

	/*! \enum OuterConeUnits
		 *	Enumerates the units used when specifying an outer-cone size for a spotlight. */
	enum class OuterConeUnits : uint32_t
	{
		/*! The number of degrees from one edge of the cone, through the light-direction vector, to the opposite edge of the cone.  The corresponding size should be in the range
			*	<span class='code'>(0, 360]</span>.  It is possible to make a spotlight shine "behind" itself by specifying an angle larger than 180 degrees, and it is possible to
			*	have a spotlight which shines in all directions by specifying an angle of 360 degrees. */
		Degrees,
		/*! The radius (in object space units) of the circular intersection of the cone with the plane passing through the target point with a normal parallel to the light-direction vector.
			*	The corresponding size should be greater than or equal to 0.  Using this unit, it is not possible to specify a cone that shines "behind" the spotlight,
			*	since an infinitely large radius would correspond to an angular size of 180 degrees. */
		FieldRadius
	};

	/*! \enum InnerConeUnits
	*	Enumerates the units used when specifying an inner-cone size for a spotlight. */
	enum class InnerConeUnits : uint32_t
	{
		/*! The number of degrees from one edge of the cone, through the light-direction vector, to the opposite edge of the cone.  The corresponding size should be in the range
			*	<span class='code'>(0, 360]</span>.  It is possible to make a spotlight shine "behind" itself by specifying an angle larger than 180 degrees, and it is possible to
			*	have a spotlight which shines in all directions by specifying an angle of 360 degrees. */
		Degrees,
		/*! The radius (in object space units) of the circular intersection of the cone with the plane passing through the target point with a normal parallel to the light-direction vector.
			*	The corresponding size should be greater than or equal to 0.  Using this unit, it is not possible to specify a cone that shines "behind" the spotlight,
			*	since an infinitely large radius would correspond to an angular size of 180 degrees. */
		FieldRadius,
		/*! The percentage of the containing outer-cone size.  The corresponding size should be in the range <span class='code'>[0, 100]</span>.  A value of 0 results in a cone size equal to
			*	the light-direction vector itself, a value of 100 results in a cone size identical to the containing outer-cone size. */
		Percent
	};

private:
	Spotlight() {}
};


/*! The Cylinder class is a concept class for cylinder-related enum classes. */
class HPS_API Cylinder
{
public:

	/*! \enum Component
	 *	Enumerates the cylinder components vertex colors can be applied to. */
	enum class Component : uint32_t
	{
		Faces,				//!< The vertex colors applied to faces.
		Edges,				//!< The vertex colors applied to edges.
	};

	/*! \enum Capping
	 *	Enumerates the type of capping geometry to use for cylinders. */
	enum class Capping : uint32_t
	{
		None,				//!< Neither cylinder end will be capped.
		First,				//!< Only the first cylinder end will be capped.
		Last,				//!< Only the second cylinder end will be capped.
		Both				//!< Both cylinder ends will be capped.
	};

	/*! \enum Orientation
	Allows reversing of cylinder colors, radii, or both */
	enum class Orientation : uint32_t
	{
		Default,			//!< Cylinder Orientation
		DefaultRadii,		//!< Cylinder Orientation
		InvertRadii,		//!< Cylinder Orientation
		InvertRadiiOnly,	//!< Cylinder Orientation
		DefaultColors,		//!< Cylinder Orientation
		InvertColors,		//!< Cylinder Orientation
		InvertColorsOnly,	//!< Cylinder Orientation
		InvertAll			//!< Cylinder Orientation
	};

private:
	Cylinder() {}
};


/*! The HighlightSearch class is a concept class for highlight search related enum classes. */
class HPS_API HighlightSearch
{
public:

	/*! \enum Scope
	*	Enumeration of how to interpret path scope when performing a highlight search. */
	enum class Scope : uint32_t
	{
		AtOrAbovePath,  //!< Only return highlights that apply at or above the specified path.
		AtOrBelowPath,  //!< Only return highlights that apply at or below the specified path.
		ExactPath       //!< Only return highlights that apply at exactly the specified path.
	};

private:
	HighlightSearch() {}
};

/*! The Search class is a concept class for search-related enum classes. */
class HPS_API Search
{
public:

	/*! \enum Space
	 *	Enumeration of which segments to look in when performing a search. */
	enum class Space : uint32_t
	{
		SegmentOnly,				//!< Search the current segment only.
		Subsegments,				//!< Search the current segment and any subsegments.
		SubsegmentsAndIncludes		//!< Search the current segment, any subsegments and any includes.
	};

	/*! \enum Behavior
	 *	Enumeration of the search behaviors. */
	enum class Behavior : uint32_t
	{
		Exhaustive,					//!< Find every instance of the specified types in the specified search space.
		FirstMatch					//!< Find the first instance of any of the specified types in the specified search space.
	};
	
	/*! \enum Type
	 *	Enumeration of the types that can be searched for. */
	enum class Type : uint32_t
	{
		None										= 0x00000000,	//!< No type.
		Everything									= 0x00ffffff,	//!< Search for all attributes, geometry, segments, includes and includers.

		Include										= 0x00000042,	//!< Search for include keys.
		Segment										= 0x00000043,	//!< Search for segments.

		Includer									= 0x00000100,	//!< Search for segments which include the current segment being searched.

		// Geometry
		Geometry									= 0x10000000,	//!< Search for all geometry types.

		CuttingSection								= 0x10000026,	//!< Search for cutting sections.
		Shell										= 0x10000028,	//!< Search for shells.
		Mesh						 				= 0x10000029,	//!< Search for meshes.
		Grid										= 0x1000002a,	//!< Search for grids.
		NURBSSurface								= 0x1000002b,	//!< Search for NURBS surfaces.
		Cylinder									= 0x1000002d,	//!< Search for cylinders.
		Sphere										= 0x1000002e,	//!< Search for spheres.
		Polygon										= 0x1000002f,	//!< Search for polygons.
		Circle										= 0x10000030,	//!< Search for circles.
		//unused									= 0x10000031,
		CircularWedge								= 0x10000032,	//!< Search for circular wedges.
		Ellipse										= 0x10000033,	//!< Search for ellipses.
		Line										= 0x10000034,	//!< Search for lines.
		NURBSCurve									= 0x10000037,	//!< Search for NURBS curves.
		CircularArc									= 0x10000038,	//!< Search for circular arcs.
		EllipticalArc								= 0x10000039,	//!< Search for elliptical arcs.
		InfiniteLine								= 0x1000003a,	//!< Search for infinite lines.
		//unused									= 0x1000003b,
		Marker										= 0x1000003c,	//!< Search for markers.
		Text										= 0x1000003e,	//!< Search for text.
		Reference									= 0x10000041,	//!< Search for geometry references.

		DistantLight								= 0x10000100,	//!< Search for distant lights.
		Spotlight									= 0x10000101,	//!< Search for spotlights.
		InfiniteRay									= 0x10000102,	//!< Search for infinite rays.

		// Attributes
		Attribute									= 0x20000000,	//!< Search for all attributes.
		
		Priority									= 0x20000001,	//!< Search for priority settings.

		// Simple Attributes
		Material									= 0x2000000b,	//!< Search for material settings.
		PBRMaterial									= 0x2000000c,	//!< Search for pbr material settings.
		Camera										= 0x2000000f,	//!< Search for cameras.
		ModellingMatrix								= 0x20000011,	//!< Search for modelling matrices.
		UserData									= 0x20000022,	//!< Search for user data settings.
		TextureMatrix								= 0x20000024,	//!< Search for texture matrices.

		// Complex Attributes
		Culling										= 0x20001000,	//!< Search for any culling attribute settings.
		CullingBackFace								= 0x20001001,	//!< Search for back face culling settings.
		CullingExtent								= 0x20001002,	//!< Search for extent culling settings.
		CullingVector								= 0x20001003,	//!< Search for vector culling settings.
		CullingVectorTolerance						= 0x20001004,	//!< Search for vector tolerance culling settings.
		CullingFrustum								= 0x20001005,	//!< Search for frustum culling settings.
		CullingDeferralExtent						= 0x20001006,	//!< Search for deferral extent culling settings.
		CullingVolume								= 0x20001007,	//!< Search for volume culling settings.
		CullingDistance								= 0x20001008,	//!< Search for distance culling settings.

		CurveAttribute								= 0x20002000,	//!< Search for any curve attribute settings.
		CurveAttributeBudget						= 0x20002001,	//!< Search for curve budget settings.
		CurveAttributeContinuedBudget				= 0x20002002,	//!< Search for curve continued budget settings.
		CurveAttributeViewDependent					= 0x20002003,	//!< Search for curve view dependent settings.
		CurveAttributeMaximumDeviation				= 0x20002004,	//!< Search for curve maximum deviation settings.
		CurveAttributeMaximumAngle					= 0x20002005,	//!< Search for curve maximum angle settings.
		CurveAttributeMaximumLength					= 0x20002006,	//!< Search for curve maximum length settings.

		CylinderAttribute							= 0x20003000,	//!< Search for any cylinder attribute settings.
		CylinderAttributeTessellation				= 0x20003001,	//!< Search for cylinder tessellation settings.
		CylinderAttributeOrientation				= 0x20003002,	//!< Search for cylinder orientation settings.

		EdgeAttribute								= 0x20004000,	//!< Search for any edge attribute settings.
		EdgeAttributePattern						= 0x20004016,	//!< Search for edge pattern settings.
		EdgeAttributeWeight							= 0x20004017,	//!< Search for edge weight settings.
		EdgeAttributeHardAngle						= 0x20004018,	//!< Search for edge weight settings.

		LightingAttribute							= 0x20005000,	//!< Search for any lighting attribute settings.
		LightingAttributeInterpolation				= 0x20005001,	//!< Search for lighting interpolation settings.

		LineAttribute								= 0x20006000,	//!< Search for any line attribute settings.
		LineAttributePattern						= 0x2000601a,	//!< Search for line pattern settings.
		LineAttributeWeight							= 0x2000601b,	//!< Search for line weight settings.

		MarkerAttribute								= 0x20007000,	//!< Search for any marker attribute settings.
		MarkerAttributeGlyphRotation				= 0x2000701a,	//!< Search for marker glyph rotation settings.
		MarkerAttributeSize							= 0x2000701c,	//!< Search for marker size settings.
		MarkerAttributeSymbol						= 0x2000701d,	//!< Search for marker symbol settings.
		MarkerAttributePreference					= 0x2000701e,	//!< Search for marker drawing preference settings.

		SurfaceAttribute							= 0x20008000,	//!< Search for any surface attribute settings.
		SurfaceAttributeBudget						= 0x20008001,	//!< Search for surface budget settings.
		SurfaceAttributeMaximumFacetDeviation		= 0x20008002,	//!< Search for surface maximum facet deviation settings.
		SurfaceAttributeMaximumFacetAngle			= 0x20008003,	//!< Search for surface maximum facet angle settings.
		SurfaceAttributeMaximumFacetWidth			= 0x20008004,	//!< Search for surface maximum facet width settings.
		SurfaceAttributeTrimCurveBudget				= 0x20008005,	//!< Search for surface trim curve budget settings.
		SurfaceAttributeMaximumTrimCurveDeviation	= 0x20008006,	//!< Search for surface maximum trim curve deviation settings.

		Selectability								= 0x20009000,	//!< Search for any selectability settings.
		SelectabilityWindows						= 0x20009001,	//!< Search for window selectability settings.
		SelectabilityEdges							= 0x20009002,	//!< Search for edge selectability settings.
		SelectabilityFaces							= 0x20009003,	//!< Search for face selectability settings.
		SelectabilityLights							= 0x20009004,	//!< Search for light selectability settings.
		SelectabilityLines							= 0x20009005,	//!< Search for line selectability settings.
		SelectabilityMarkers						= 0x20009006,	//!< Search for marker selectability settings.
		SelectabilityVertices						= 0x20009007,	//!< Search for vertex selectability settings.
		SelectabilityText							= 0x20009008,	//!< Search for text selectability settings.

		SphereAttribute								= 0x2000a000,	//!< Search for any sphere attribute settings.
		SphereAttributeTessellation					= 0x2000a001,	//!< Search for sphere tessellation settings.

		Subwindow									= 0x2000b000,	//!< Search for any subwindow settings.
		SubwindowEitherType							= 0x2000b001,	//!< Search for either standard or lightweight subwindow settings.
		SubwindowStandard							= 0x2000b00e,	//!< Search for standard subwindow settings.
		SubwindowLightweight						= 0x2000b002,	//!< Search for lightweight subwindow settings.
		SubwindowBackground							= 0x2000b003,	//!< Search for subwindow background settings.
		SubwindowBorder								= 0x2000b004,	//!< Search for subwindow border settings.
		SubwindowRenderingAlgorithm					= 0x2000b005,   //!< Search for subwindow rendering algorithm.

		TextAttribute								= 0x2000c000,	//!< Search for any text attribute settings.
		TextAttributeAlignment						= 0x2000c01e,	//!< Search for text alignment settings.
		TextAttributeBold							= 0x2000c002,	//!< Search for bold text settings.
		TextAttributeItalic							= 0x2000c003,	//!< Search for italic text settings.
		TextAttributeOverline						= 0x2000c004,	//!< Search for overline text settings.
		TextAttributeStrikethrough					= 0x2000c005,	//!< Search for strikethrough text settings.
		TextAttributeUnderline						= 0x2000c006,	//!< Search for underline text settings.
		TextAttributeSlant							= 0x2000c007,	//!< Search for text slant settings.
		TextAttributeLineSpacing					= 0x2000c008,	//!< Search for text line spacing settings.
		TextAttributeRotation						= 0x2000c00a,	//!< Search for text rotation settings.
		TextAttributeExtraSpace						= 0x2000c00b,	//!< Search for text extra space settings.
		TextAttributeGreeking						= 0x2000c00c,	//!< Search for text greeking settings.
		TextAttributeSizeTolerance					= 0x2000c00d,	//!< Search for text size tolerance settings.
		TextAttributeSize							= 0x2000c00e,	//!< Search for text size settings.
		TextAttributeFont							= 0x2000c00f,	//!< Search for text font settings.
		TextAttributeTransform						= 0x2000c010,	//!< Search for text transform settings.
		TextAttributeRenderer						= 0x2000c011,	//!< Search for text renderer settings.
		TextAttributePreference						= 0x2000c012,	//!< Search for text preference settings.
		TextAttributePath							= 0x2000c020,	//!< Search for text path settings.
		TextAttributeSpacing						= 0x2000c021,	//!< Search for text spacing settings.
		TextAttributeBackground						= 0x2000c022,	//!< Search for text background settings.
		TextAttributeBackgroundMargins				= 0x2000c023,	//!< Search for text background margin settings.
		TextAttributeBackgroundStyle				= 0x2000c024,	//!< Search for text background style settings.
		TextAttributeLeaderLine						= 0x2000c025,	//!< Search for text leader line settings.

		Transparency								= 0x2000d000,	//!< Search for any transparency settings.
		TransparencyMethod							= 0x2000d001,	//!< Search for transparency method settings.
		TransparencyAlgorithm						= 0x2000d002,	//!< Search for transparency algorithm settings.
		TransparencyDepthPeelingLayers				= 0x2000d004,	//!< Search for depth peeling layers settings.
		TransparencyDepthPeelingMinimumArea			= 0x2000d005,	//!< Search for depth peeling minimum area settings.
		TransparencyDepthWriting					= 0x2000d006,	//!< Search for depth writing settings.

		Visibility									= 0x2000e000,	//!< Search for any visibility settings.
		VisibilityCuttingSections					= 0x2000e001,	//!< Search for cutting section visibility settings.
		VisibilityCutEdges							= 0x2000e002,	//!< Search for cut edge visibility settings.
		VisibilityCutFaces							= 0x2000e003,	//!< Search for cut face visibility settings.
		VisibilityWindows							= 0x2000e004,	//!< Search for window visibility settings.
		VisibilityText								= 0x2000e005,	//!< Search for text visibility settings.
		VisibilityLines								= 0x2000e006,	//!< Search for line visibility settings.
		VisibilityEdgeLights						= 0x2000e007,	//!< Search for edge light visibility settings.
		VisibilityMarkerLights						= 0x2000e008,	//!< Search for marker light visibility settings.
		VisibilityFaceLights						= 0x2000e009,	//!< Search for face light visibility settings.
		VisibilityGenericEdges						= 0x2000e00a,	//!< Search for generic edge visibility settings.
		VisibilityHardEdges							= 0x2000e00b,	//!< Search for hard edge visibility settings.
		VisibilityAdjacentEdges						= 0x2000e00c,	//!< Search for adjacent edge visibility settings.
		VisibilityInteriorSilhouetteEdges			= 0x2000e00d,	//!< Search for interior silhouette edge visibility settings.
		VisibilityShadowEmitting					= 0x2000e00e,	//!< Search for shadow emitting visibility settings.
		VisibilityShadowReceiving					= 0x2000e00f,	//!< Search for shadow receiving visibility settings.
		VisibilityShadowCasting						= 0x2000e010,	//!< Search for shadow casting visibility settings.
		VisibilityMarkers							= 0x2000e011,	//!< Search for marker visibility settings.
		VisibilityVertices							= 0x2000e012,	//!< Search for vertex visibility settings.
		VisibilityFaces								= 0x2000e013,	//!< Search for face visibility settings.
		VisibilityPerimeterEdges					= 0x2000e014,	//!< Search for perimeter edge visibility settings.
		VisibilityNonCulledEdges					= 0x2000e015,	//!< Search for non-culled edge visibility settings.
		VisibilityMeshQuadEdges						= 0x2000e016,	//!< Search for mesh quad edge visibility settings.
		VisibilityEdges								= 0x2000e017,	//!< Search for any edge visibility settings.
		VisibilityLeaderLines						= 0x2000e018,	//!< Search for text leader line visibility settings.

		VisualEffects								= 0x2000f000,	//!< Search for any visual effects settings.
		VisualEffectsPostProcessEffectsEnabled		= 0x2000f001,	//!< Search for visual effects post-process effects enabled settings.
		VisualEffectsAntiAliasing					= 0x2000f002,	//!< Search for visual effects anti-aliasing settings.
		VisualEffectsShadowMaps						= 0x2000f003,	//!< Search for visual effects shadow maps settings.
		VisualEffectsSimpleShadow					= 0x2000f004,	//!< Search for visual effects simple shadow settings.
		VisualEffectsSimpleShadowPlane				= 0x2000f005,	//!< Search for visual effects simple shadow plane settings.
		VisualEffectsSimpleShadowLightDirection		= 0x2000f006,	//!< Search for visual effects simple shadow light direction settings.
		VisualEffectsSimpleShadowColor				= 0x2000f007,	//!< Search for visual effects simple shadow color settings.
		VisualEffectsSimpleReflection				= 0x2000f008,	//!< Search for visual effects simple reflection settings.
		VisualEffectsSimpleReflectionPlane			= 0x2000f009,	//!< Search for visual effects simple reflection plane settings.
		VisualEffectsSimpleReflectionVisibility		= 0x2000f00a,	//!< Search for visual effects simple reflection visibility settings.
		VisualEffectsEyeDomeLightingBackColor		= 0x2000f00b,	//!< Search for visual effects eye dome lighting back color settings.

		Performance									= 0x20010000,	//!< Search for any performance settings.
		PerformanceDisplayLists						= 0x20010001,	//!< Search for performance display lists settings.
		PerformanceStaticModel						= 0x20010002,	//!< Search for performance static model settings.
		StaticModelSegment							= 0x40000043,	//!< Search for static model segments.

		DrawingAttribute							= 0x20011000,	//!< Search for any drawing attribute settings.
		DrawingAttributePolygonHandedness			= 0x20011001,	//!< Search for drawing attribute polygon handedness settings.
		DrawingAttributeDepthRange					= 0x20011002,	//!< Search for drawing attribute depth range settings.
		DrawingAttributeFaceDisplacement			= 0x20011003,	//!< Search for drawing attribute face displacement settings.
		DrawingAttributeGeneralDisplacement			= 0x20011004,	//!< Search for drawing attribute general displacement settings.
		DrawingAttributeVertexDisplacement			= 0x20011005,	//!< Search for drawing attribute vertex displacement settings.
		DrawingAttributeOverlay						= 0x20011006,	//!< Search for drawing attribute overlay settings.
		DrawingAttributeDeferral					= 0x20011007,	//!< Search for drawing attribute deferral settings.
		DrawingAttributeVertexDecimation			= 0x20011008,	//!< Search for drawing attribute vertex decimation settings.
		DrawingAttributeVertexRandomization			= 0x20011009,	//!< Search for drawing attribute vertex randomization settings.
		DrawingAttributeOverrideInternalColor		= 0x2001100a,	//!< Search for drawing attribute override internal color settings.
		DrawingAttributeClipRegion					= 0x20011013,	//!< Search for drawing attribute clip region settings.
		DrawingAttributeWorldHandedness				= 0x20011019,	//!< Search for drawing attribute world handedness settings.

		
		HiddenLineAttribute							= 0x20012000,	//!< Search for any hidden line attribute settings.
		HiddenLineAttributeAlgorithm				= 0x20012001,	//!< Search for hidden line algorithm settings.
		HiddenLineAttributeColor					= 0x20012002,	//!< Search for hidden line color settings.
		HiddenLineAttributeDimFactor				= 0x20012003,	//!< Search for hidden line dim factor settings.
		HiddenLineAttributeFaceDisplacement			= 0x20012004,	//!< Search for hidden line face displacement settings.
		HiddenLineAttributeLinePattern				= 0x20012005,	//!< Search for hidden line pattern settings.
		HiddenLineAttributeLineSort					= 0x20012006,	//!< Search for hidden line sort settings.
		HiddenLineAttributeRenderFaces				= 0x20012007,	//!< Search for hidden line render faces settings.
		HiddenLineAttributeRenderText				= 0x20012008,	//!< Search for hidden line render text settings.
		HiddenLineAttributeSilhouetteCleanup		= 0x20012009, 	//!< Search for hidden line silhouette cleanup settings.
		HiddenLineAttributeTransparencyCutoff		= 0x2001200a,	//!< Search for hidden line transparency cutoff settings.
		HiddenLineAttributeVisibility				= 0x2001200b,	//!< Search for hidden line visibility settings.
		HiddenLineAttributeWeight					= 0x2001200c,	//!< Search for hidden line weight settings.
		

		SegmentStyle								= 0x20013001,	//!< Search for any segment style settings.
		NamedStyle									= 0x20013002,	//!< Search for any named style settings.
		MaterialPalette								= 0x20013003,	//!< Search for any material palette settings.
		Portfolio									= 0x20013004,	//!< Search for any portfolio settings.

		ContourLine									= 0x20014000,	//!< Search for any contour line settings.
		ContourLineVisibility						= 0x20014001,	//!< Search for contour line visibility settings.
		ContourLinePosition							= 0x20014002,	//!< Search for contour line position settings.
		ContourLineColor							= 0x20014003,	//!< Search for contour line color settings.
		ContourLinePattern							= 0x20014004,	//!< Search for contour line pattern settings.
		ContourLineWeight							= 0x20014005,	//!< Search for contour line weight settings.
		ContourLineLighting							= 0x20014006,	//!< Search for contour line lighting settings.

		Condition									= 0x20015000,	//!< Search for any condition settings.

		Bounding									= 0x20016000,	//!< Search for any bounding settings.
		BoundingVolume								= 0x20016001,	//!< Search for bounding volume settings.
		BoundingExclusion							= 0x20016002,	//!< Search for bounding exclusion settings.
		
		AttributeLock								= 0x20017000,	//!< Search for any attribute lock settings.
		AttributeLockSetting						= 0x20017001,	//!< Search for attribute lock setting settings.
		AttributeLockSubsegmentOverride				= 0x20017002,	//!< Search for attribute lock subsegment override settings.

		TransformMask								= 0x20018000,	//!< Search for any transform mask settings.
		TransformMaskCamera							= 0x20018001,	//!< Search for any transform mask camera settings.
		TransformMaskCameraTranslation				= 0x20018002,	//!< Search for transform mask translation settings.
		TransformMaskCameraScale					= 0x20018003,	//!< Search for transform mask scale settings.
		TransformMaskCameraOffset					= 0x20018004,	//!< Search for transform mask offset settings.
		TransformMaskCameraRotation					= 0x20018005,	//!< Search for transform mask rotation settings.
		TransformMaskCameraPerspectiveScale			= 0x20018006,	//!< Search for transform mask perspective scale settings.
		TransformMaskCameraProjection				= 0x20018007,	//!< Search for transform mask projection settings.
		TransformMaskModellingMatrix				= 0x20018008,	//!< Search for any transform mask modelling matrix settings.
		TransformMaskModellingMatrixTranslation		= 0x20018009,	//!< Search for transform mask modelling matrix translation settings.
		TransformMaskModellingMatrixScale			= 0x20018010,	//!< Search for transform mask modelling matrix scale settings.
		TransformMaskModellingMatrixOffset			= 0x20018011,	//!< Search for transform mask modelling matrix offset settings.
		TransformMaskModellingMatrixRotation		= 0x20018012,	//!< Search for transform mask modelling matrix rotation settings.

		ColorInterpolation							= 0x20019000,	//!< Search for any color interpolation settings.
		ColorInterpolationFaceColor					= 0x20019001,	//!< Search for color interpolation face color settings.
		ColorInterpolationEdgeColor					= 0x20019002,	//!< Search for color interpolation edge color settings.
		ColorInterpolationMarkerColor				= 0x20019003,	//!< Search for color interpolation marker color settings.
		ColorInterpolationFaceIndex					= 0x20019004,	//!< Search for color interpolation face index settings.
		ColorInterpolationEdgeIndex					= 0x20019005,	//!< Search for color interpolation edge index settings.
		ColorInterpolationMarkerIndex				= 0x20019006,	//!< Search for color interpolation marker index settings.

		CuttingSectionAttribute						= 0x2001a000,	//!< Search for any cutting section attribute settings.
		CuttingSectionAttributeCuttingLevel			= 0x2001a001,	//!< Search for cutting section cutting level settings.
		CuttingSectionAttributeCappingLevel			= 0x2001a002,	//!< Search for cutting section capping level settings.
		CuttingSectionAttributeMaterialPreference	= 0x2001a003,	//!< Search for cutting section material preference settings.
		CuttingSectionAttributeEdgeWeight			= 0x2001a004,	//!< Search for cutting section edge weight settings.
		CuttingSectionAttributeTolerance			= 0x2001a005,	//!< Search for cutting section tolerance settings.
		CuttingSectionAttributeCappingUsage			= 0x2001a006,	//!< Search for cutting section capping level settings.

	};

private:
	Search() {}
};


/*! The Material class is a concept class for material-related enum classes. */
class HPS_API Material
{
public:

	/*! \enum Type 
	 *	Enumerates the types of materials that can be set on various Visualize entities. */
	enum class Type : uint32_t
	{
		None 					=  0,		//!< No material was set.
		FullMaterial,						//!< A full material was set.  The MaterialKit is valid.
		RGBColor,							//!< An RGB color was set.  The RGBColor is valid.
		RGBAColor,							//!< An RGBA color was set.  The RGBAColor is valid.
		MaterialIndex,						//!< A material index was set.  The material index (float value) is valid.
		TextureName,						//!< An unmodulated texture was set.  The texture name is valid.
		ModulatedTexture,					//!< A modulated texture was set.  Both the RGBColor (or RGBAColor) and texture name are valid.
		CubeMapName,						//!< An unmodulated cube map texture was set.  The cube map texture name is valid.
		ModulatedCubeMap,					//!< A modulated cube map was set.  Both the RGBColor (or RGBAColor) and cube map texture name are valid.
		GlossValue,							//!< A gloss value was set.  The gloss (float value) is valid.
		DiffuseChannelAlpha					//!< An alpha value was set.  The alpha (float value) is valid.		
	};

	/*! \enum Channel 
	Material Channel */
	enum class Channel : uint32_t
	{
		DiffuseColor = 1,		//!< Material Channel
		DiffuseTexture = 2,		//!< Material Channel
		Specular = 3,			//!< Material Channel
		Emission = 4,			//!< Material Channel
		Transmission = 5,		//!< Material Channel
		Mirror = 6,				//!< Material Channel
		Bump = 7,				//!< Material Channel
		EnvironmentTexture = 8,	//!< Material Channel
		EnvironmentCubeMap = 9,	//!< Material Channel
		Gloss = 10,				//!< Material Channel
		Alpha = 11				//!< Material Channel
	};

	/*! The Material Color Class*/
	class HPS_API Color 
	{
	public:	

		/*! \enum Channel 
		Material Color Channel */
		enum class Channel : uint32_t 
		{
			DiffuseColor = 1,				//!< Material Color Channel
			Specular = 3,					//!< Material Color Channel
			Emission = 4,					//!< Material Color Channel
			Mirror	 = 6					//!< Material Color Channel
		};

	private:
		Color() {}
	};
	
	/*! The Material::Texture class is a concept class for texture-related enum classes. */
	class HPS_API Texture 
	{
	public:

		/*! \enum Channel 
		Material Texture Channel */
		enum class Channel : uint32_t 
		{
			DiffuseTexture = 2,			//!< Material Texture Channel
			Specular = 3,				//!< Material Texture Channel
			Emission = 4,				//!< Material Texture Channel
			Transmission = 5,			//!< Material Texture Channel
			Mirror = 6,					//!< Material Texture Channel
			Bump = 7,					//!< Material Texture Channel
			EnvironmentTexture = 8,		//!< Material Texture Channel
			EnvironmentCubeMap = 9		//!< Material Texture Channel
		};

		/*! \enum Parameterization
		 *	Enumeration of the parameterization sources for textures. */
		enum class Parameterization : uint32_t 
		{
			/*! Use a cylindrical mapping for the texture. */
			Cylinder,

			/*! Texture Parameterization. */
			PhysicalReflection,
			
			/*! Use the <span class='code'>(x,y,z)</span> coordinates for the object before transforms have been applied for the texture parameters. */
			Object,
			
			/*! Use the natural mapping for meshes, NURBS surfaces and shells for the texture.
			 * 	For meshes, textures will be stretched in the range <span class='code'>[0,1]</span>.
			 * 	For NURBS surfaces, textures will be mapped in the range <span class='code'>[0,(control point count - degree)]</span>.
			 * 	For shells, textures will be mapped such that <span class='code'>u=x+z</span> and <span class='code'>v=x+y</span>
			 * 	where <span class='code'>(x,y,z)</span> is in object space. */
			NaturalUV,
			
			/*! Texture Parameterization. */
			ReflectionVector,
			
			/*! Texture Parameterization. */
			SurfaceNormal,
			
			/*! Use a spherical mapping for the texture. */
			Sphere,
			
			/*! Use the mapping explicitly defined on the geometry for the texture. */
			UV,
			
			/*! Use the <span class='code'>(x, y, z)</span> coordinates for the object after transforms have been applied for the texture parameters. */
			World
		};

		/*! \enum Tiling
		 *	Enumeration of the tiling modes for textures. */
		enum class Tiling : uint32_t 
		{
			/*! The texture will get mapped normally for parameters in the range <span class='code'>[0,1]</span>, but parameters less than <span class='code'>0</span>
			 *	will be clamped to <span class='code'>0</span> and parameters greater than <span class='code'>1</code> will be clamped to <span class='code'>1</span>. */
			Clamp,
			
			/*! The texture will get mapped repeatedly in a modulo fashion. */
			Repeat,
			
			/*! The texture will get mapped repeatedly in a modulo fashion.  Every other modulo will also be inverted. */
			Reflect,
			
			/*! The texture will get mapped normally for parameters in the range <span class='code'>[0,1]</span>, but parameters outside that range will act as if the
			 *	texture at that location is transparent. */
			Trim
		};

		/*! \enum Interpolation
		 *	Enumeration of the various interpolation filters for textures.  These are used when the texture needs to be magnified. */
		enum class Interpolation : uint32_t 
		{
			/*! The texture coordinate will map to the closest texture samples. */
			None,

			/*! The texture data from the four closest texture samples to a texture coordinate will be blended via a weighted average. */
			Bilinear
		};

		/*! \enum Decimation 
		 *	Enumeration of the various decimation filters for textures.  These are used when the texture needs to minimized. */
		enum class Decimation : uint32_t 
		{
			/*! No down-sampling will be performed.  Data will be retrieved via the specified Texture::Interpolation filter. */
			None,
			
			/*! The texture will be down-sampled to non-square image sizes which will get used for sampling and filtering based on the
			 *	angle between the normal of a textured surface and the view vector. */
			Anisotropic,
			
			/*! The texture will be down-sampled to square, power-of-two-sized images which will get used for sampling and filtering. */
			Mipmap
		};

		/*! \enum ChannelMapping 
		Material Texture ChannelMapping
		*/
		enum class ChannelMapping : uint32_t 
		{
			Red,		//!< Material Texture ChannelMapping
			Green,		//!< Material Texture ChannelMapping
			Blue,		//!< Material Texture ChannelMapping
			Alpha,		//!< Material Texture ChannelMapping
			Zero,		//!< Material Texture ChannelMapping
			One,		//!< Material Texture ChannelMapping
			Luminance	//!< Material Texture ChannelMapping
		};

	private:	
		Texture() {}
	};

private:
	Material() {}
};


class HPS_API PostProcessEffects
{
public:

	class HPS_API AmbientOcclusion
	{
	public:

		/*! \enum Quality 
		Ambient Occlusion Quality */
		enum class Quality : uint32_t
		{
			Fastest,			//!< Fastest ambient occlusion but lower quality
			Nicest				//!< Nicest looking ambient occlusion but slower
		};

	private:
		AmbientOcclusion() {}
	};

	class HPS_API Bloom
	{
	public:
		/*! \enum Shape 
		Bloom Shape
		*/
		enum class Shape : uint32_t
		{
			Star,			//!< Star-shaped bloom
			Radial			//!< Radial bloom
		};

	private:
		Bloom() {}
	};

private:
	PostProcessEffects() {}
};

class HPS_API Performance
{
public:

	/*! \enum DisplayLists 
	 *	Display lists are a GPU hardware caching technology which can greatly improve rendering performance.
	 *	The underlying implementation depends on the 3D driver being used.*/
	enum class DisplayLists : uint32_t
	{
		/*! Display Lists will not be used for rendering the scene. */
		None,

		/*! Display Lists will be created on a per-geometry basis.
		 *	If the geometry is modified, the display list will be regenerated. */
		Geometry,

		/*! Display Lists will be created on a per-segment basis.
		 *	If any geometry in the segment is modified, the display list will be regenerated. */
		Segment
	};

	/*! \enum StaticModel
	 *	StaticModel is a technique used for improving rendering performance.
	 *	This setting tells the system that the segment tree affected by the attribute will remain 'static' or unchanging.
	 *  The system will create an internal, optimized segment tree which is used for rendering in lieu of the normal tree.
	 *	The original segment tree is untouched and can be used normally.
	 *
	 *	If changes are made in a part of the segment tree that is subject to the static model attribute, the internal tree will be regenerated, with a few exceptions:
	 *		If geometry is deleted or edited, the internal tree will not need to be regenerated. */
	enum class StaticModel : uint32_t
	{
		None,				//!< No static model will be used, rendering will be done from the segment tree.
		Attribute,			//!< An optimized segment tree will be used for rendering.   The tree will be sorted by attributes.  
		AttributeSpatial	//!< An optimized segment tree will be used for rendering.   The tree will be sorted based on both attributes and spatial locations of objects.  This is particularly useful for very large, spatially dispersed models.
	};

	/*! \enum StaticConditions
	 *	StaticConditions indicates how conditional expressions will be handled inside a StaticModel. 
	 *  A model segment which has no conditionals expressions, or only has expressions satisfied by conditions
	 *  set within the segment should not be affected by this.
	 */
	enum class StaticConditions : uint32_t
	{
		/*! Conditional expressions will be maintained in the static tree.
		 *  The tree may be referenced from multiple places (such as view) without forcing
		 * regeneration, but the static tree will be sub-optimal */
		Independent,

		/*! Conditional expressions will be evaluated assuming the current condition state available
		 *  when the static tree is generated is the only one of interest.  The static tree will resolve
		 * any use of conditions for better performance, but changes to this state will cause it to regenerate,
		 *  and a static tree used in multiple places (such as different views) may thrash (continuously
		 *  regenerate multiple times every update).
		 */
		Single

		/* placeholder.  Option would generate different optimized trees at the cost of memory. */
		//Multiple		//!< An optimized segment tree will be used for rendering.   The tree will be sorted based on both attributes and spatial locations of objects.  This is particularly useful for very large, spatially dispersed models.
	};

	
private:
	Performance() {}
};


class HPS_API AttributeLock
{
public:

	/*! \enum Type The types of attributes that can be locked */
	enum class Type : uint32_t
	{
		Everything							= 0x01000000,

		Visibility							= 0x02000000,

		VisibilityCuttingSections,
		VisibilityCutEdges,
		VisibilityCutFaces,
		VisibilityWindows,
		VisibilityText,
		VisibilityLines,
		VisibilityEdgeLights,
		VisibilityMarkerLights,
		VisibilityFaceLights,
		VisibilityGenericEdges,
		VisibilityHardEdges,
		VisibilityAdjacentEdges,
		VisibilityInteriorSilhouetteEdges,
		VisibilityShadowEmitting,
		VisibilityShadowReceiving,
 		VisibilityShadowCasting,
		VisibilityMarkers,
		VisibilityVertices,
		VisibilityFaces,
		VisibilityPerimeterEdges,
		VisibilityNonCulledEdges,
		VisibilityMeshQuadEdges,
		VisibilityCutGeometry,
		VisibilityEdges,
		VisibilityGeometry,
		VisibilityLights,
		VisibilityShadows,

		Material							= 0x03000000,

		MaterialGeometry,
		MaterialCutGeometry,

		MaterialAmbientLightUpColor,
		MaterialAmbientLightDownColor,
		MaterialAmbientLightColor,

		MaterialWindowColor,
		MaterialWindowContrastColor,

		MaterialLightColor,
		MaterialLineColor,
		MaterialMarkerColor,
		MaterialTextColor,
		MaterialCutEdgeColor,

		MaterialVertex,
		MaterialVertexDiffuse,
		MaterialVertexDiffuseColor,
		MaterialVertexDiffuseAlpha,
		MaterialVertexDiffuseTexture,
		MaterialVertexSpecular,
		MaterialVertexMirror,
		MaterialVertexTransmission,
		MaterialVertexEmission,
		MaterialVertexEnvironment,
		MaterialVertexBump,
		MaterialVertexGloss,

		MaterialEdge,
		MaterialEdgeDiffuse,
		MaterialEdgeDiffuseColor,
		MaterialEdgeDiffuseAlpha,
		MaterialEdgeDiffuseTexture,
		MaterialEdgeSpecular,
		MaterialEdgeMirror,
		MaterialEdgeTransmission,
		MaterialEdgeEmission,
		MaterialEdgeEnvironment,
		MaterialEdgeBump,
		MaterialEdgeGloss,

		MaterialFace,
		MaterialFaceDiffuse,
		MaterialFaceDiffuseColor,
		MaterialFaceDiffuseAlpha,
		MaterialFaceDiffuseTexture,
		MaterialFaceSpecular,
		MaterialFaceMirror,
		MaterialFaceTransmission,
		MaterialFaceEmission,
		MaterialFaceEnvironment,
		MaterialFaceBump,
		MaterialFaceGloss,

		MaterialBackFace,
		MaterialBackFaceDiffuse,
		MaterialBackFaceDiffuseColor,
		MaterialBackFaceDiffuseAlpha,
		MaterialBackFaceDiffuseTexture,
		MaterialBackFaceSpecular,
		MaterialBackFaceMirror,
		MaterialBackFaceTransmission,
		MaterialBackFaceEmission,
		MaterialBackFaceEnvironment,
		MaterialBackFaceBump,
		MaterialBackFaceGloss,

		MaterialFrontFace,
		MaterialFrontFaceDiffuse,
		MaterialFrontFaceDiffuseColor,
		MaterialFrontFaceDiffuseAlpha,
		MaterialFrontFaceDiffuseTexture,
		MaterialFrontFaceSpecular,
		MaterialFrontFaceMirror,
		MaterialFrontFaceTransmission,
		MaterialFrontFaceEmission,
		MaterialFrontFaceEnvironment,
		MaterialFrontFaceBump,
		MaterialFrontFaceGloss,

		MaterialCutFace,
		MaterialCutFaceDiffuse,
		MaterialCutFaceDiffuseColor,
		MaterialCutFaceDiffuseAlpha,
		MaterialCutFaceDiffuseTexture,
		MaterialCutFaceSpecular,
		MaterialCutFaceMirror,
		MaterialCutFaceTransmission,
		MaterialCutFaceEmission,
		MaterialCutFaceEnvironment,
		MaterialCutFaceBump,
		MaterialCutFaceGloss,

		Camera							= 0x04000000,
	};

private:
	AttributeLock() {}
};

class HPS_API Drawing
{
public:

	/*! \enum Handedness 
	 *	Handedness is used to define the front face of a polygon as well as the orientation of the z-axis relative to the x-y plane. */
	enum class Handedness : uint32_t
	{
		None,					//!< No Handedness
		Left,					//!< Left Handed
		Right					//!< Right Handed
	};

	/*! \enum Overlay
	 *	Enumeration of the various overlay modes. */
	enum class Overlay : uint32_t
	{
		/*! No overlay will be used.  If geometry is moved, edited or highlighted, a full screen redraw will be triggered on the subsequent update. */
		None,
		
		/*! Any geometry in a segment with this mode set will be redrawn on each update and it will appear on top of the scene regardless of whether it should appear behind other geometry.
		 *	This is the most efficient overlay mode. */
		Default,
		
		/*! Any geometry in a segment with this mode set will be drawn on each update and it will be positioned correctly with respect to other geometry within the scene.
		 *	This is the most accurate overlay mode, but is not as efficient as NormalOverlay. */
		WithZValues,

		/*! This setting is useful when you are applying a transparent highlight style to overlay geometry.
		 * This setting suppresses the drawing of the geometry, instead drawing the highlight itself in its place.
		 * If you are not using a transparent highlight style, this setting has no visible effect. This setting is
		 * slightly more computationally expensive than the other overlay settings. */
		InPlace,
	};

	/*! \enum ClipOperation
	 * 	Enumerates the clip region operation types. */
	enum class ClipOperation : uint32_t
	{
		Keep,		//!< The geometry inside the clip region is drawn. Everything outside of it is clipped.
		Remove,		//!< The geometry outside the clip region is drawn. Everything inside of it is clipped.
	};

	/*! \enum ClipSpace
	 * 	Enumerates the coordinate spaces types for clip regions. */
	enum class ClipSpace : uint32_t
	{
		Window,		//!< The clip region is specified in window coordinates.
		World,		//!< The clip region is specified in world coordinated.
		Object,		//!< The clip region is specified in object coordinated.
	};

private:
	Drawing() {}
};


class HPS_API HiddenLine
{
public:

	/*! \enum Algorithm
	Specifies the sorting algorithm that should be used to sort the geometry which has been drawn as a result of setting SetRenderFaces to true. 
	*/
	enum class Algorithm : uint32_t
	{
		None,	//!< No sorting of faces will be performed
		ZBuffer,//!< Utilizes a z-buffering algorithm, defaulting to hardware z-buffer
		ZSort,	//!< Utilizes a z-sorting algorithm which sorts faces based on the z-value of each triangles centroid
	};

private:
	HiddenLine() {}
};


/*! The Selection class is a concept class for selection-related enum classes. */
class HPS_API Selection
{
public:

	/*! \enum Level
	 *	Enumeration of the various selection levels. */
	enum class Level : uint32_t
	{
		Segment,			//!< Return the owning segment of the selected geometry entities in SelectionResults.
		Entity,				//!< Return the selected geometry entities in SelectionResults.
		Subentity,			//!< Return the selected geometry entities and the associated faces, edges and vertices for shells or meshes in SelectionResults.
	};

	/*! \enum Level
	 *	Enumeration of the various selection sorting choices. */
	enum class Sorting: uint32_t
	{
		Off,		//!< Do not sort selection results.

		/*! Sort selection results according to the screen-space proximity to the selection point.
		* Ties (items with equal proximity) will be further z-sorted. Note that Lines (and edges and all line-like geometry such as circular arcs)
		* and Markers are biased to make them more easily selectable. This biasing is part of the proximity calculation, and it is therefore possible
		* that Lines and Markers are sorted ahead of other geometry that is closer to the selection point.
		*
		* Proximity sorting is only relevant for SelectByPoint. */
		Proximity,

		ZSorting,	//!< Sort selection results from front to back.

		Default		//!< Use Proximity sorting for SelectByPoint. Use ZSorting in all other cases.
	};

	/*! \enum Algorithm 
	 *	Enumeration of the various selection algorithms. */
	enum class Algorithm : uint32_t
	{
		/*!	This algorithm will post-process the SelectionResults to remove items which are obscured by other objects in the scene,
		 *	and therefore only items that are visible on the screen will be selected. */
		Visual,

		/*!	This algorithm will perform analytic world space selection testing, and will not post-process the SelectionResults based
		 *	on obscuration. Therefore, items which are not currently visible may still be returned in the SelectionResults. */
		Analytic
	};

	/*! \enum Granularity 
	 *	Enumeration of the various selection granularities. */
	enum class Granularity : uint32_t
	{
		General,			//!< Use the most efficient selection determination for curves, edges and lines.
		Detailed			//!< Use the most accurate selection determination for curves, edges and lines.
	};

private:
	Selection() {}
};


//////////////////////////////////////////////////////////////////////
///////////////////////////// Attributes /////////////////////////////
//////////////////////////////////////////////////////////////////////

/*! This is the Camera Class*/
class HPS_API Camera
{
public:

	/*! \enum Projection 
	Camera Projection */
	enum class Projection : uint32_t
	{
		Default		= 1 ,		//!< Camera Type
		Perspective,			//!< Camera Type
		Orthographic,			//!< Camera Type
		Stretched,				//!< Camera Type
	};

private:
	Camera() {}
};


/*! This is the Selectability Class*/
class HPS_API Selectability
{
public:
	/*! \enum Value
	Selectability Value
	*/
	enum class Value : uint32_t
	{
		Off = 0,	//!< Not selectable.
		On,			//!< Selectable if visible.
		ForcedOn	//!< Selectable even if not visible. 
	};

private:
	Selectability() {}
};


/*! This is the Transparency Class */
class HPS_API Transparency
{
public:

	/*! \enum Method
	Transparency Method */
	enum class Method : uint32_t
	{
		None,			//!< This will disable transparency, overriding all other transparency settings and forcing geometry to be opaque.
		Blended,		//!< The transparent object will be blended with the color of the underlying object.
		ScreenDoor		//!< This is a pseudo-transparency algorithm that sacrifices visual quality to improve performance.
	};

	/*! \enum Algorithm 
	Transparency Algorithm */
	enum class Algorithm : uint32_t
	{
		None,			//!< No sorting will be performed, but transparent objects will be deferred (drawn on top).  If overlapping transparent objects are present the rendering will not be accurate.
		Painters,		//!< Will produce a completely accurate rendering of transparent objects which are overlapping other transparent objects, but tends to be slow.
		ZSortNicest,	//!< Sorts every transparent triangle in a shell by its mid-point.  This algorithm can result in rendering artifacts at locations where transparent objects intersect with one another.
		ZSortFastest,	//!< Sorts transparent tristrips in a shell by the mid-point of the entire tristrip.  This algorithm can result in rendering artifacts at locations where transparent objects intersect with one another.
		DepthPeeling,	//!< Non-sorting technique based on multi-pass drawing, and leverages hardware acceleration to quickly produce an accurate rendering. Will give varying accuracy and performance results based on the number of 'layers' that are specified by the user.
		WeightedBlended //!< Non-sorting technique which blends and approximates transparent objects based on the distance from the camera.
	};

	/*! \enum AreaUnits 
	Transparency Area Units
	*/
	enum class AreaUnits : uint32_t
	{
		Percent,	//!< Transparency Area Units
		Pixels		//!< Transparency Area Units
	};

	/*! \enum Preference
	Transparency Preference
	*/
	enum class Preference
	{
		Nicest, //!< Quality should be favored at the possible cost of performance.
		Fastest, //!< Performance should be favored at the possible cost of some loss in image quality.
	};

private:
	Transparency() {}
};


/*! This is the Marker Class*/
class HPS_API Marker
{
public:
	/*! \enum drawing preference for markers */
	enum class DrawingPreference : uint32_t
	{
		Nicest, // !< Markers should always be drawn at the requested size at the possible cost of performance.
		Fastest, //!< Performance should be favored at the possible cost of drawing markers at a smaller size than requested.
	};

	/*! \enum SizeUnits 
	Marker Size Units */
	enum class SizeUnits : uint32_t
	{
		ScaleFactor,			//!< A unitless linear scaling factor.  A value of 2.0 will cause markers to be rendered twice as large.  A value of 1.0 will result in a visually pleasing device-dependent marker size that is approximately 3% of the height of the outer window.  A value of 0 will result in a single pixel marker for display-devices, or the smallest size supported by any other device.
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels					//!< Number of pixels.
	};

private:
	Marker() {}
};


/*! This is the Lighting Class*/
class HPS_API Lighting 
{
public:

	/*! \enum Interpolation Algorithm 
	Lighting Interpolation Algorithm */
	enum class InterpolationAlgorithm : uint32_t 
	{
		Phong,		//!< Lighting Interpolation Algorithm
		Gouraud,	//!< Lighting Interpolation Algorithm
		Flat		//!< Lighting Interpolation Algorithm
	};

private:
	Lighting() {}
};

/*! The Text class is a concept class for text-related enum classes. */
class HPS_API Text
{
public:

	/*! \enum Alignment
	 *	Enumeration of the alignments used for text string.  These define what the insertion point for a text string is measured with respect to. */
	enum class Alignment : uint32_t
	{
		TopLeft,					//!< Insertion point is the top left corner of the text string.
		CenterLeft,					//!< Insertion point is the center of the left side of the text string.
		BottomLeft,					//!< Insertion point is the bottom left corner of the text string.
		TopCenter,					//!< Insertion point is the center of the top side of the text string.
		Center,						//!< Insertion point is the vertical and horizontal center of the text string.
		BottomCenter,				//!< Insertion point is the center of the bottom side of the text string.
		TopRight,					//!< Insertion point is the top right corner of the text string.
		CenterRight,				//!< Insertion point is the center of the right side of the text string.
		BottomRight					//!< Insertion point is the bottom right corner of the text string.
	};

	/*! \enum ReferenceFrame
	 *	Enumeration of the reference frames for text alignment and justification. */
	enum class ReferenceFrame : uint32_t
	{
		WorldAligned,				//!< Alignment and justification will be defined relative to a screen-facing box around the text.
		PathAligned					//!< Alignment and justification will be defined relative to a text-path-aligned box around the text.
	};
	
	/*! \enum Justification
	 *	Enumerates the justifications used for multiline text strings. */
	enum class Justification : uint32_t
	{
		Left,						//!< Multiline strings will be left justified.
		Right,						//!< Multiline strings will be right justified.
		Center						//!< Multiline strings will be center justified.
	};
	
	/*! \enum Transform
	 *	Enumerates the transform behaviors for text strings.  These define how the entire string will be positioned within 3D space. */
	enum class Transform : uint32_t
	{
		/*! Text will be subject to all modelling and projection matrices, essentially acting as a textured quad.  Text paths will be act as transformations in 3D space. */
		Transformable,
		/*! Only the text insertion point (see also Text::Alignment) will be subject to modelling and projection matrices.  Text will always be drawn in screen space.
		 *	Text paths will act as transformations in screen space. */
		NonTransformable,
		/*! Text will be subject to all modelling and projection matrices, however characters will always be drawn in screen space. */
		CharacterPositionOnly,
		/*! Equivalent to CharacterPositionOnly, but additionally will draw text upright when it would otherwise appear upside down based on the camera.  To get this behavior
		 *	Text::ReferenceFrame::PathAligned and Text::Rotation::FollowPath must be set, otherwise this will be equivalent to CharacterPositionOnly. */
		CharacterPositionAdjusted,
		/*! Text will be subject to all modelling and projection matrices except for size changes, otherwise acting as a textured quad.  Text paths will be act as transformations in 3D space. */
		NonScalingTransformable
	};

	/*! \enum Renderer
	 *	Enumerates the renderers for text strings.  These define the font-handling subsystems Visualize uses to find and render fonts. */ 
	enum class Renderer : uint32_t
	{
		Default,					//!< All font-handling subsystems will be used.
		Driver,						//!< Only driver fonts will be used.  If a non-driver font is requested, the stroked font will be used instead.
		Truetype,					//!< Only TrueType fonts will be used.  If a non-TrueType font is requested, the stroked font will be used instead.
	};

	/*! \enum Preference
	 *	Enumerates the font type preferences for text strings.  These define the types of fonts Visualize will use. */
	enum class Preference : uint32_t
	{
		Default,					//!< Use the default font type for the current driver.
		Vector,						//!< Use vector fonts.
		Raster,						//!< Use raster or bitmap fonts.
		Exterior					//!< Use the font outline (characters will be unfilled).
	};

	/*! \enum Rotatation
	 *	Enumerates the rotation modes for characters within text strings. */
	enum class Rotation : uint32_t
	{
		None,						//!< Characters are not rotated.
		Rotate,						//!< Characters are rotated clockwise by a specified angle.
		FollowPath					//!< Characters are rotated such that they will be perpendicular to the text path.
	};


	/*! \enum SizeUnits
	*	Enumerates the units for font sizes. */ 
	enum class SizeUnits : uint32_t
	{
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels					//!< Number of pixels.
	};

	/*! \enum SizeToleranceUnits
	*	Enumerates the units for size tolerances. */
	enum class SizeToleranceUnits : uint32_t
	{
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels,					//!< Number of pixels.
		Percent					//!< Percentage of the requested font size defining the lower limit on the smallest font size that can be substituted in the requested's place.
	};

	/*! \enum MarginUnits
	*	Enumerates the units for background margins. */
	enum class MarginUnits : uint32_t
	{
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels,					//!< Number of pixels.
		Percent					//!< Percentage of the requested font height.
	};

	/*! \enum GreekingUnits
	*	Enumerates the units for greeking limits. */
	enum class GreekingUnits : uint32_t
	{
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels					//!< Number of pixels.
	};

	/*! \enum GreekingMode
	*	Enumerates the greeking modes.  These define what to draw in place of characters once they fall below the greeking limit. */
	enum class GreekingMode : uint32_t
	{
		Nothing,				//!< Nothing will be drawn for characters below the greeking limit.
		Lines,					//!< A grid of lines will be drawn in place of characters below the greeking limit.
		Box						//!< A filled box will be drawn in place of characters below the greeking limit.
	};

	/*! \enum RegionAlignment
	 *	Enumerates the alignments for text regions.  These define how text strings will be positioned relative to the line defining the text region. */
	enum class RegionAlignment : uint32_t
	{
		Top,					//!< Text will be drawn below the region line.
		Center,					//!< Text will be drawn such that the region line passes through its center.
		Bottom					//!< Text will be drawn above the region line.
	};

	/*! \enum LeaderLineSpace
	 *	Enumerates the spaces in which leader lines can be defined.*/
	enum class LeaderLineSpace : uint32_t
	{
		Object,					//!< The leader line position is supplied in Object Space.
		World,					//!< The leader line position is supplied in World Space.
	};

	/*! \enum RegionFitting
	*	Enumerates how text is arranged within a region.*/
	enum class RegionFitting : uint32_t
	{
		Left,					//!< Text will be left-justified on the region line.
		Center,					//!< Text will be centered-justified on the region line.
		Right,					//!< Text will be right-justified on the region line.
		Spacing,				//!< Text will be stretched or squeezed to fill the region line and character width will not change (characters may overlap).
		Width,					//!< Text will be stretched or squeezed to fill the region line and character width will change (narrowing or widening as necessary).
		Auto,					//!< Text will be stretched or squeezed to fill the region line.  This will behave as Width when the text needs to be squeezed, or as Spacing when the text needs to be stretched.
	};
private:
	Text() {}
};


/*! This is the Line Class */
class HPS_API Line
{
public:

	/*! \enum CoordinateSpace
	The CoordinateSpace enum is a list of all coordinate spaces used in Visualize. These correspond to HPS::Coordinate::Space
	*/
	enum class CoordinateSpace : uint32_t
	{
		Object, //!< \sa HPS::Coordinate::Space::Object
		World, //!< \sa HPS::Coordinate::Space::World
		NormalizedInnerWindow, //!< \sa HPS::Coordinate::Space::NormalizedInnerWindow
		NormalizedInnerPixel //!< \sa HPS::Coordinate::Space::NormalizedInnerPixel
	};

	/*! \enum SizeUnits 
	Line Size Units
	*/
	enum class SizeUnits : uint32_t
	{
		ScaleFactor,			//!< A unitless linear scaling factor.  A value of 2.0 will cause lines to be rendered twice as thick.  A value of 1.0 will result in a visually pleasing device-dependent line weight.  A value of 0 will result in the minimal weight line supported by the device.
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels					//!< Number of pixels.
	};

private:
	Line() {}
};


/*! This is the Edge Class */
class HPS_API Edge
{
public:

	/*! \enum SizeUnits 
	Edge Size Units */
	enum class SizeUnits : uint32_t
	{
		ScaleFactor,			//!< A unitless linear scaling factor.  A value of 2.0 will cause edges to be rendered twice as thick.  A value of 1.0 will result in a visually pleasing device-dependent edge weight.  A value of 0 will result in the minimal weight edge supported by the device.
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels					//!< Number of pixels.
	};

private:
	Edge() {}
};


/*! The CuttingSection class is a concept class for cutting-section-related enum classes. */
class HPS_API CuttingSection
{
public:

	/*! \enum Mode
	 *	Enumerates the modes for cutting sections.  These are the shapes (if any) of the visualization geometry that will be drawn to represent cutting planes within cutting sections. */
	enum class Mode : uint32_t
	{
		None,		//!< No visualization geometry will be drawn for cutting planes in a cutting sections.
		Round,		//!< A circular plane will be drawn for cutting planes in a cutting section.  The size of the planes will be based on the size of the geometry being cut and the visualization scale.
		Square,		//!< A square plane will be drawn for cutting planes in a cutting section.  The size of the planes will be based on the size of the geometry being cut and the visualization scale.
		Plane		//!< An infinitely large plane will be drawn for cutting planes in a cutting section.
	};

	/*! \enum CappingLevel
	 * 	Enumerates the level at which capping geometry should be generated for cutting sections. */
	enum class CappingLevel : uint32_t
	{
		Entity,				//!< Each piece of geometry should be treated as if it encloses a volume.
		Segment,			//!< All geometry in a segment (but not subsegments) should be treated as if it encloses a single volume.
		SegmentTree			//!< All geometry in a segment tree should be treated as if it encloses a single volume.
	};

	/*! \enum CappingUsage
	 * 	Enumerates the choices for whether geometry (faces) are cut and processed for capping geometry. */
	enum class CappingUsage : uint32_t
	{
		Off,				//!< Faces will not be used for capping
		On,					//!< Faces will be used for capping generation
		Visibility			//!< Faces will be used for capping generation if they are visible
	};

	/*! \enum ToleranceUnits
	* 	Enumerates the how tolerance should be interpreted. */
	enum class ToleranceUnits : uint32_t
	{
		Percent,				//!< Tolerance specified is interpreted as a percentage of current view (camera field).
		WorldSpace,				//!< Tolerance specified is interpreted in world space.
	};

	/*! \enum CuttingLevel
	 * 	Enumerates the level at which cutting planes should operate. */
	enum class CuttingLevel : uint32_t
	{
		Global,				//!< Cutting sections will cut all geometry in the scene graph.
		Local,				//!< Cutting sections will only cut geometry contained in the segment and subsegments where the cutting section is inserted.
	};

	/*! \enum MaterialPreference
	 * 	Enumerates which material settings should be used for cut geometry generated for cutting sections. */
	enum class MaterialPreference : uint32_t
	{
		Explicit,			//!< Use the effective materials set for cut faces and cut edges in the segment tree. <br /><br />For example, the following function applies color settings that would be respected when <span class="code">MaterialPreference</span> is set to Explicit: <span class="code">mySegmentKey.GetMaterialMappingControl().SetCutFaceColor(myRGBAColor).SetCutEdgeColor(myRGBAColor)</span>
		Implicit,			//!< Use the effective materials set for (regular) faces and (regular) edges in the segment tree. For <span class="code">Segment</span> or <span class="code">SegmentTree</span> <span class="code">CappingLevel</span>, the implicit capping geometry face color will be the weighted average of the geometry face colors where the cut is applied. <br /><br />For example, the following function applies color settings that would be respected when <span class="code">MaterialPreference</span> is set to Implicit: <span class="code">mySegmentKey.GetMaterialMappingControl().SetFaceColor(myRGBAColor).SetEdgeColor(myRGBAColor)</span>
	};

	/*! \enum GatheringLevel
	 * 	Enumerates the level at which capping geometry should be gathered. */
	enum class GatheringLevel : uint32_t
	{
		Segment,				//!< Capping geometry will be gathered only from a single segment.
		SegmentTree				//!< Capping geometry will be gathered from the segment and all its subsegments and includes.
	};

private:
	CuttingSection() {}
};

/*! This is the ContourLine Class*/
class HPS_API ContourLine
{
public:

	/*! \enum Mode 
	ContourLine Mode
	*/
	enum class Mode : uint32_t
	{
		Repeating,	//!< CuttingSection Mode
		Explicit,	//!< CuttingSection Mode
	};

private:
	ContourLine() {}
};

/*! \enum IOResult
 *	Enumerates the import and export result values. */
enum class IOResult : uint32_t
{
	Success,						//!< File IO Success.
	Failure,						//!< File IO Failure.
	FileNotFound,					//!< File was not found.
	UnableToOpenFile,				//!< Unable to open file.
	InvalidOptions,					//!< Invalid options specified.
	InvalidSegment,					//!< Invalid import/export segment specified.
	InProgress,						//!< File IO currently in progress.
	Canceled,						//!< File IO was canceled.
	UnableToLoadLibraries,			//!< Unable to load or locate the necessary libraries.
	VersionIncompatibility,			//!< Either failed to query the library version, libraries are too old or too new, or failed to initialize the required version.
	InitializationFailed,			//!< Unable to initialize the necessary libraries.
	UnsupportedFormat,				//!< File format cannot be imported.
	InvalidFile,					//!< File is corrupt or missing some necessary data.
};

/*! The LinePattern class is a concept class for line-pattern-related enum classes. */
class HPS_API LinePattern
{
public:

	/*! \enum SizeUnits
	 *	Enumerates the units used when specifying length, weight and offsets for line patterns. */
	enum class SizeUnits : uint32_t
	{
		ObjectSpace,			//!< Object space units ignoring any scaling components in modelling matrices.
		SubscreenRelative,		//!< Fraction of the height of the outermost window.
		WindowRelative,			//!< Fraction of the height of the local window.
		WorldSpace,				//!< Object space units including any scaling components in modelling matrices and cameras.
		Points,					//!< Points units typically used for text size.  1 point corresponds to 1/72 inch.
		Pixels,					//!< Number of pixels.
		ScaleFactor				//!< Fraction of the default line width.  A value of <span class='code'>1</span> corresponds to 0.1 percent of the screen size.
	};

	/*! \enum InsetBehavior
	 *	Enumerates how glyphs interact with other line pattern elements within a line pattern. */
	enum class InsetBehavior : uint32_t
	{
		Overlap,				//!< Glyphs will overlap with surrounding line pattern elements.  Line pattern elements adjacent to glyphs will not be trimmed.
		Trim,					//!< Glyphs will overlap with surrounding line pattern elements.  Line pattern elements adjacent to glyphs will be trimmed.
		Inline					//!< Glyphs will not overlap with surrounding line pattern elements, and adjacent line pattern elements will not be trimmed.
	};

	/*! \enum Join
	 * 	Enumerates the types of join to use for a line pattern.  Joins will always be mitred at the half angle for the smaller angle defined by two line
	 *	segments.  This enumeration defines what the join will look like for the larger angle defined by two line segments. */
	enum class Join : uint32_t
	{
		Mitre,				//!< The join for the larger angle will be mitred, i.e., the segments will meet at a point at the half angle of the larger angle.
		Round,				//!< The join for the larger angle will be rounded, i.e., there will be a circle that subtends the larger angle.
		Bevel				//!< The join for the larger angle will be beveled, i.e., there will be a line that subtends the larger angle.
	};

	/*! \enum Cap
	 *  Enumerates the predefined cap types that can be used at the ends of line segments within a line pattern. */
	enum class Cap : uint32_t
	{
		/*! Line segments will end with a flat cap perpendicular to the line segment vector.  This cap will occur immediately at the end of the line segment
		 * 	and will not extend its length. */
		Butt,
		/*! Line segments will end with half of a filled square cap whose side is perpendicular to the line segment vector.  This cap will extend the length of a
		 * 	line segment, but otherwise will appear the same as the ButtCap. */
		Square,
		/*! Line segments will end with half of a filled circle cap whose diameter is perpendicular to the line segment vector.  This cap will extend the length
		 * 	of a line segment. */
		Round,
		/*! Line segments will end with a filled triangle cap whose base is perpendicular to the line segment vector.  This cap will extend the length of a line segment. */
		Mitre
	};

	/*! \enum Justification
	 *	Enumerates the justfication modes for a line pattern.  These are used to attempt to make the line pattern appear evenly spaced between end points of a line. */
	enum class Justification : uint32_t
	{
		/*! Attempts to ensure that the first element of the line pattern appears at both the beginning and the end of the line.  This will give the best results
		 *	if the first element in a line pattern makes up at least half the total length of the elements for the line pattern body. */
		Center,
		/*! Stretches the pattern and modifies the size of the line pattern elements to ensure even spacing. */
		Stretch
	};

	/*! \enum Modifier
	 * 	Enumerates the types of joins, start caps, and end caps that can be set when a line pattern attribute is set. */
	enum class Modifier : uint32_t
	{
		GlyphName,				//!< A glyph was set for the cap or join.  The glyph name is valid.
		Enumerated				//!< A predefined (enumerated) cap or join was set.  The enumeration type is valid.
	};


	/*! \enum Default
	 * 	<p>Enumerates the predefined line patterns in Visualize.  These can be accessed via the LinePatternKit::GetDefault function and their appearance can be seen
	 * 	<a href="../../prog_guide/default_line_patterns.html">here</a>. Hardware acceleration for line patterns is available when the following conditions are met:</p>
        
        <ul>
            <li>You are using the DirectX11 or OpenGL2 driver</li>
            <li>You are using Visualize 2015 or later</li>
	        <li>Segment-level display lists are active</li>
	        <li>The line weight is 1</li>
	    </ul>
	
		<p>The following line patterns can be hardware accelerated: <span class="code">Dashed, Dotted, DashDot, Dash2Dot, Dash3Dot, LongDash, FineDot</span>. The pattern does not continue along adjacent edges. The pattern is restarted for each edge.</p>
	*/
	enum class Default : uint32_t
	{
		Solid,					//!< A solid unbroked line pattern.
		DashDot,				//!< A repeating pattern of 18 solid pixels, 5 blank pixels, 4 solid pixels, and 5 blank pixels.
		Dashed,					//!< A repeating pattern of 10 solid pixels and 6 blank pixels.
		Dotted,					//!< A repeating pattern of 5 solid pixels and 3 blank pixels.
		Dash2Dot,				//!< A repeating pattern of 15 solid pixels, 4 blank pixels, 3 solid pixels, 3 blank pixels, 3 solid pixels, and 4 blank pixels.
		Dash3Dot,				//!< A repeating pattern of 15 solid pixels, 2 blank pixels, 3 solid pixels, 2 blank pixels, 3 solid pixels, 2 blank pixels, 3 solid pixels, and 2 blank pixels.
		LongDash,				//!< A repeating pattern of 26 solid pixels and 6 blank pixels.
		LongDashShortDash,		//!< A repeating pattern of 100 solid pixels, 10 blank pixels, 20 solid pixels, and 10 blank pixels.
		LongDash2ShortDash,		//!< A repeating pattern of 86 solid pixels, 8 blank pixels, 15 solid pixels, 8 blank pixels, 15 solid pixels, and 8 blank pixels.
		FineDot,				//!< A repeating pattern of 1 solid pixel and 3 blank pixels.
	};

private:
	LinePattern() {}
};


/*! The Shape class is a concept class for shape-related enum classes. */
class HPS_API Shape
{
public:
	enum class Default : uint32_t
	{
		Rectangle,			//!< A rectangle.
		RoundedRectangle,	//!< A rectangle with rounded corners.
		Oval,				//!< An oval.
		Ellipse,			//!< An ellipse.
	};

private:
	Shape() {}
};


//Begin Glyphs
/*! The Glyph class is a concept class for glyph-related enum classes. */
class HPS_API Glyph
{
public:

	/*! \enum Fill
	 * 	Enumerates the fill modes that can apply to glyph elements. */
	enum class Fill : uint32_t
	{
		None,					//!< Closed geometry will not be filled.
		Continuous,				//!< Closed geometry will be filled.  If previous geometry was already filled, the fill will be be continued.
		New,					//!< Closed geometry will be filled.  If previous geometry was already filled, the fill will be restarted.
		NewLoop					//!< Closed geometry will be filled.  If previous geometry was already filled, the fill will be continued as a new loop (such as a hole).
	};

	/*! \enum ColorSource
	 * 	Enumerates the color modes that can apply to glyph elements. */
	enum class ColorSource : uint32_t
	{
		Default,					//!< Glyph element color will be inherited from the color of the owning geometry.
		Explicit,				//!< Glyph element color will be the specified RGBA color.
		Indexed					//!< Glyph element color will be the color at the specified index in the effective material palette.
	};

	/*! \enum Default
	 * 	Enumerates the predefined glyphs in Visualize.  These can be accessed via the GlyphKit::GetDefault function and their appearance can be seen
	 * 	<a href="../../prog_guide/default_glyphs.html">here</a>. */
	enum class Default : uint32_t
	{
		Circle,					//!< An unfilled circle.
		CircleWithDot,			//!< An unfilled circle with a dot in the center.
		CircleWithPlus,			//!< An unfilled circle with a plus sign in the center.
		CircleWithTimes,		//!< An unfilled circle with a times sign (X-shaped) in the center.
		CircleWithCircle,		//!< An unfilled circle with a smaller unfilled circle inside it.
		SolidCircle,			//!< A filled circle.
		Dot,					//!< A single dot.
		Plus,					//!< A plus sign.
		Times,					//!< A times sign (X-shaped).
		Splat,					//!< An asterisk (an X shape with an additional horizonatal line through the intersection point).
		Box,					//!< An unfilled square.
		BoxWithDot,				//!< An unfilled square with a dot in the center.
		BoxWithTimes,			//!< An unfilled square with a times sign (X-shaped) in the center.
		SolidBox,				//!< A filled square.
		Diamond,				//!< An unfilled diamond.
		DiamondWithDot,			//!< An unfilled diamond with a dot in the center.
		DiamondWithPlus,		//!< An unfilled diamond with a plus sign in the center.
		SolidDiamond,			//!< A filled diamond.
		TriangleUp,				//!< An unfilled upward-pointing triangle.
		TriangleUpWithDot,		//!< An unfilled upward-pointing triangle with a dot in the center.
		SolidTriangleUp,		//!< A filled upward-pointing triangle.
		TriangleDown,			//!< An unfilled downward-pointing triangle.
		TriangleDownWithDot,	//!< An unfilled downward-pointing triangle with a dot in the center.
		SolidTriangleDown,		//!< A filled downward-pointing triangle.
		TriangleRight,			//!< An unfilled rightward-pointing triangle.
		TriangleRightWithDot,	//!< An unfilled rightward-pointing triangle with a dot in the center.
		SolidTriangleRight,		//!< A filled rightward-pointing triangle.
		TriangleLeft,			//!< An unfilled leftward-pointing triangle.
		TriangleLeftWithDot,	//!< An unfilled leftward-pointing triangle with a dot in the center.
		SolidTriangleLeft,		//!< A filled leftward-pointing triangle.
		TriangleUpV,			//!< An unfilled upward-pointing triangle with the top vertex at the glyph canvas origin.
		SolidTriangleUpV,		//!< A filled upward-pointing triangle with the top vertex at the glyph canvas origin.
		TriangleDownV,			//!< An unfilled downward-pointing triangle with the bottom vertex at the glyph canvas origin.
		SolidTriangleDownV,		//!< A filled downward-pointing triangle with the bottom vertex at the glyph canvas origin.
		TriangleRightV,			//!< An unfilled rightward-facing triangle with the right vertex at the glyph canvas origin.
		SolidTriangleRightV,	//!< A filled rightward-facing triangle with the right vertex at the glyph canvas origin.
		TriangleLeftV,			//!< An unfilled leftward-facing triangle with the left vertex at the glyph canvas origin.
		SolidTriangleLeftV,		//!< A filled leftward-facing triangle with the left vertex at the glyph canvas origin.
		LetterY,				//!< The letter Y.
		LetterZ,				//!< The letter Z.
		CircleLetterY,			//!< The letter Y circumscribed in an unfilled circle.
		CircleLetterZ,			//!< The letter Z circumscribed in an unfilled circle.
		VerticalBar,			//!< A vertical bar.
		HorizontalBar,			//!< A horizontal bar.
		SlantLeft,				//!< A left-slanting bar.
		SlantRight,				//!< A right-slanting bar.
		WidePlus,				//!< An unfilled plus sign.
		SolidWidePlus,			//!< A filled plus sign.
		WideTimes,				//!< An unfilled times sign (X-shaped).
		SolidWideTimes,			//!< A filled times sign (X-shaped).
		Pound,					//!< Two parallel vertical bars intersecting two parallel horizontal bars.
		Sphere,					//!< A phong-shaded sphere when vertex lighting is enabled on supported drivers. A solid circle in all other cases.
	};
	
private:
	Glyph() {}
};


/*! This is the Bounding Class*/
class HPS_API Bounding
{
public:

	/*! \enum Type
	Bounding Type */
	enum class Type : uint32_t
	{
		None,
		Sphere,		//!< Bounding Type
		Cuboid		//!< Bounding Type
	};
	
private:
	Bounding() {}
};


/*! The Condition class is a concept class for condition-related enum classes. */
class HPS_API Condition
{
public:

	enum class Intrinsic : uint32_t
	{
		Extent,
		DrawPass,
		InnerPixelWidth,
		InnerPixelHeight,
		Selection,
		QuickMovesProbe,
	};

private:
	Condition() {}
};


/*! The Grid class is a concept class for grid-related enum classes. */
class HPS_API Grid
{
public:

	/*! \enum Type
	 * 	Enumerates the grid types. */
	enum class Type : uint32_t
	{
		Quadrilateral,	//!< Grid composed of quadrilaterals.
		Radial			//!< Grid composed of circular wedges.
	};

private:
	Grid() {}
};


class HPS_API SegmentOptimizationOptions
{
public:

	enum class UserData : uint32_t
	{
		None,
		Discard,
		Preserve,
		Merge,
		Localize,
	};

	enum class Scope : uint32_t
	{
		SubSegments,
		SubsegmentsAndIncludes,
		SegmentOnly,
	};

	enum class Expansion : uint32_t
	{
		None,
		Includes,
		References,
		IncludesAndReferences,
	};

	enum class Matrix : uint32_t
	{
		None,
		Localize,
		Collapse,
	};

	enum class Reorganization : uint32_t
	{
		None,
		Attribute,
		Spatial,
		AttributeSpatial,
	};

private:
	SegmentOptimizationOptions() {}
};


/*! The Coordinate class is a concept class that contains information about various coordinate spaces. */
class HPS_API Coordinate
{
public:

	/*! \enum Space
		The Space enum is a list of all coordinate spaces used in Visualize.
	*/
	enum class Space : uint32_t
	{
		Object,					//!< An infinite 3D Cartesian coordinate system local to the object or segment itself.
		World,					//!< An infinite 3D Cartesian coordinate system where objects reside after their modelling transformations have been applied.
		Camera,					//!< A space defined by a camera's view of world space with the origin at the camera position, y-axis along the camera's up vector and z-axis pointing toward the camera target.
		Window,					//!< A rectangle ([-1,1] in x and y directions) with the origin at center of the outer window.
		Pixel,					//!< The pixel position of the outer window counting from the top-left corner
		InnerWindow,			//!< A rectangle ([-1,1] in x and y directions) with the origin at center of the inner window.
		InnerPixel,				//!< The pixel position of the inner window counting from the top-left corner
		NormalizedInnerWindow,	//!< Same as InnerWindow except z is in [0,1] with 0 at the camera limit and 1 at infinity
		NormalizedInnerPixel,	//!< Same as InnerPixel except z is in [0,1] with 0 at the camera limit and 1 at infinity
		NormalizedWindow,		//!< Same as Window except z is in [0,1] with 0 at the camera limit and 1 at infinity
		NormalizedPixel,		//!< Same as Pixel except z is in [0,1] with 0 at the camera limit and 1 at infinity
	};

private:
	Coordinate() {}
};

/*! The Extent class is a concept class that contains information about various extent options. */
class HPS_API Extent
{
public:

	enum class ClipRegion : uint32_t
	{
		Include,
		Ignore
	};

private:
	Extent() {}
};

class HPS_API GPU
{
public:

	/*! \enum Preference
	* 	Used to determine which GPU Visualize should use when there are multiple available GPUs on the system.
	*   Note that that HighPerformance and Integrated enumerations are best-guesses. Use 'Specific' to have
	*	the highest degree of control over which GPU is used. */
	enum class Preference
	{
		HighPerformance,	//!< Automatically detect and use the highest performing GPU available on the system.
		Integrated,			//!< Automatically detect and use the CPU-integrated GPU, if available.
		Specific,			//!< Choose a specific GPU out of the ones available on the system.
		Default,			//!< Choose the first GPU found by the DirectX driver.
	};

private:
	GPU() {}
};

	typedef double			Time;

#ifdef _MSC_VER
#	ifndef HPS_INLINE
#		define	HPS_INLINE		__forceinline
#	endif
#else
#	define HPS_INLINE inline
#endif

#ifndef HPS_UNREFERENCED
#define HPS_UNREFERENCED(param) ((void)(param))
#endif


const double PI = 3.141592653589793238462643383279502884197169399375105820974944592308;

template<typename T>
HPS_INLINE T Degrees_To_Radians(T const & degrees)
{
	return degrees * (T)(PI / 180.0);
}

template<typename T>
HPS_INLINE T Radians_To_Degrees(T const & radians)
{
	return radians * (T)(180.0 / PI);
}

template<typename T>
HPS_INLINE void SinCos(T const & angle, T & sine, T & cosine) {
	T a = Degrees_To_Radians(angle);
	cosine = cos(a);
	sine = sin(a);
}

template<typename T>
HPS_INLINE T Cos(T const & angle) {
	return cos (Degrees_To_Radians(angle));
}

template<typename T>
HPS_INLINE T Sin(T const & angle) {
	return sin (Degrees_To_Radians(angle));
}

template<typename T>
HPS_INLINE T ACos(T const & x) {
	if (x > 1)
		return 0;
	if (x < -1)
		return 180;
	return Radians_To_Degrees(acos(x));
}

template<typename T>
HPS_INLINE T ATan2(T const & y, T const & x) {
	if (x == 0 && y == 0)
		return 0;
	return Radians_To_Degrees(atan2(y, x));
}


template <typename F>	struct Float_Traits {};
template <> struct Float_Traits<float>	{
	typedef double	Alternative;
	static const int Type = 1;
	static float Epsilon () { return 1.0e-30f; }
};
template <> struct Float_Traits<double>	{
	typedef float	Alternative;
	static const int Type = 2;
	static double Epsilon () { return 1.0e-300; }
};



/*! The Float class is a concept class that exposes a number of useful utilities for working with floating point numbers.	*/
class HPS_API Float {
private:
	enum Parts {
#		if HOOPS_BIGENDIAN
			High, Low
#		else
			Low, High
#		endif
	};

	// & functions for a float represented in an int, * version for a double in an array of 2 ints
	static HPS_INLINE bool is_infinite(int32_t const & v)	{ return (v & 0x7FFFFFFF) == 0x7F800000; }
	static HPS_INLINE bool is_infinite(uint32_t const & v)	{ return (v & 0x7FFFFFFF) == 0x7F800000; }
	static HPS_INLINE bool is_infinite(int32_t const * v)	{ return (v[High] & 0x7FFFFFFF) == 0x7FF00000 && v[Low] == 0; }
	static HPS_INLINE bool is_infinite(uint32_t const * v)	{ return (v[High] & 0x7FFFFFFF) == 0x7FF00000 && v[Low] == 0; }

	static HPS_INLINE bool is_nan(int32_t const & v) {
		uint32_t	exp = v & 0x7F800000, mantissa = v & 0x007FFFFF;
		return exp == 0x7F800000 && mantissa != 0;
	}
	static HPS_INLINE bool is_nan(uint32_t const & v) {
		uint32_t	exp = v & 0x7F800000, mantissa = v & 0x007FFFFF;
		return exp == 0x7F800000 && mantissa != 0;
	}
	static HPS_INLINE bool is_nan(int32_t const * v) {
		uint32_t	exp = v[High] & 0x7FF00000, mantissa_high = v[High] & 0x000FFFFF;
		return exp == 0x7FF00000 && (mantissa_high | v[Low]) != 0;
	}
	static HPS_INLINE bool is_nan(uint32_t const * v) {
		uint32_t	exp = v[High] & 0x7FF00000, mantissa_high = v[High] & 0x000FFFFF;
		return exp == 0x7FF00000 && (mantissa_high | v[Low]) != 0;
	}

	static HPS_INLINE bool is_special(int32_t const & v)	{ return (v & 0x7F800000) == 0x7F800000; }
	static HPS_INLINE bool is_special(uint32_t const & v)	{ return (v & 0x7F800000) == 0x7F800000; }
	static HPS_INLINE bool is_special(int32_t const * v)	{ return (v[High] & 0x7FF00000) == 0x7FF00000; }
	static HPS_INLINE bool is_special(uint32_t const * v)	{ return (v[High] & 0x7FF00000) == 0x7FF00000; }
public:

	/*! The 32-bit float representation of infinity.  */
	static const float Infinity;
	/*! The 32-bit float representation of negative infinity.  */
	static const float NegativeInfinity;

	/*! See if the value is either infinity */
	static HPS_INLINE bool IsInfinite(float const & a) { return is_infinite (extract_uint32_t(a)); }
	static HPS_INLINE bool IsInfinite(double const & a) {
		uint32_t	v[2];
		memcpy (v, &a, sizeof(double));
		return is_infinite (v);
	}

	/*! See if the value is Not-A-Number */
	static HPS_INLINE bool IsNAN(float const & a) { return is_nan (extract_uint32_t(a)); }
	static HPS_INLINE bool IsNAN(double const & a) {
		uint32_t	v[2];
		memcpy (v, &a, sizeof(double));
		return is_nan (v);
	}

	/*! See if the value is not "normal" (infinite or NaN) */
	static HPS_INLINE bool IsAbnormal(float const & a) { return is_special (extract_uint32_t(a)); }
	static HPS_INLINE bool IsAbnormal(double const & a) {
		uint32_t	v[2];
		memcpy (v, &a, sizeof(double));
		return is_special (v);
	}

	/*! Checks two floats for equality within a specified tolerance.
	The tolerance is specified in float increments that scale with the floats themselves. */
	static HPS_INLINE bool Equals(float const & a, float const & b, int tolerance = 32);
	static HPS_INLINE bool Equals(double const & a, double const & b, int tolerance = 32);

#ifndef HOOPS_DEFINED
	template <typename Alloc>
	static HPS_INLINE bool Equals(std::vector<float, Alloc> const & a, std::vector<float, Alloc> const & b, int tolerance = 32)
	{
		if (a.size() != b.size())
			return false; 

		auto it1 = a.begin(); 
		auto it2 = b.begin();
		auto const end = a.end(); 
		for ( ; it1 != end; ++it1, ++it2)
		{
			if (!Equals(*it1, *it2, tolerance))
				return false; 
		}
		return true; 
	}
#endif

	static HPS_INLINE uint32_t extract_sign_bit(float const & a) {
		return extract_uint32_t(a) & 0x80000000;
	}
	static HPS_INLINE uint32_t extract_sign_bit(double const & a) {
		uint32_t	v[2];
		memcpy (v, &a, sizeof(double));
		return v[High] & 0x80000000;
	}

	static HPS_INLINE void apply_sign_bit(float & a, uint32_t const & sign_bit) {
		uint32_t	v = extract_uint32_t(a);
		v &= 0x7FFFFFFF;
		v |= sign_bit;
		inject_uint32_t(a, v);
	}
	static HPS_INLINE void apply_sign_bit(double & a, uint32_t const & sign_bit) {
		uint32_t	v[2];
		memcpy (v, &a, sizeof(double));
		v[High] &= 0x7FFFFFFF;
		v[High] |= sign_bit;
		memcpy (&a, v, sizeof(double));
	}


	static HPS_INLINE unsigned char unit_to_byte(float const & a) {
		uint32_t	v = extract_uint32_t(a);

		v &= 0x7FFFFFFF;
		if (v < 0x3B800000)
			return 0;

		v--;

		uint32_t	exp = v >> 23;
		uint32_t	man = (v & 0x007FFFFF) | 0x00800000;

		return (unsigned char) (man >> (16 + 126 - exp));
	}

	static HPS_INLINE unsigned char unit_to_byte_scaled(float const & a, unsigned char mix) {
		uint32_t	v = extract_uint32_t(a);

		v &= 0x7FFFFFFF;
		if (v < 0x3B800000)
			return 0;

		v--;

		uint32_t	exp = v >> 23;
		uint32_t	man = (v & 0x007FFFFF) | 0x00800000;

		uint32_t	x = (man >> (16 + 126 - exp));

		return (unsigned char) ((x * (mix+1)) >> 8);
	}


	static HPS_INLINE bool match(float const & a, float const & b) {
		uint32_t va = extract_uint32_t(a);
		uint32_t vb = extract_uint32_t(b);

		if (((va | vb) & 0x7FFFFFFF) == 0)
			return true;

		return va == vb;
	}
	static HPS_INLINE bool match(double const & a, double const & b) {
		return a == b;
	}


	static HPS_INLINE void replace_if_smaller(float & a, float const & b) {
		if (b < a)
			a = b;
	}
	static HPS_INLINE void replace_if_smaller(double & a, double const & b) {
		if (b < a)
			a = b;
	}

	static HPS_INLINE void replace_if_larger(float & a, float const & b) {
		if (b > a)
			a = b;
	}
	static HPS_INLINE void replace_if_larger(double & a, double const & b) {
		if (b > a)
			a = b;
	}


	static HPS_INLINE uint32_t extract_uint32_t(float const & a) {
		uint32_t i;
		memcpy(&i, &a, sizeof(float));
		return i;
	}

	static HPS_INLINE void inject_uint32_t(float & a, uint32_t const & i) {
		memcpy(&a, &i, sizeof(float));
	}

	static HPS_INLINE float C2F(unsigned char x) {
		//return (float)x * (1.0f/255.0f);
		return char_to_float[x];
	}


	// SSE convenience functions
	static HPS_INLINE void pack_4(float const & f, float * m) {
		memcpy(&m[0], &f, sizeof(float));
		memcpy(&m[1], &f, sizeof(float));
		memcpy(&m[2], &f, sizeof(float));
		memcpy(&m[3], &f, sizeof(float));
	}

	static HPS_INLINE void pack_4(float const & f0, float const & f1, float const & f2, float const & f3, float * m) {
		memcpy(&m[0], &f0, sizeof(float));
		memcpy(&m[1], &f1, sizeof(float));
		memcpy(&m[2], &f2, sizeof(float));
		memcpy(&m[3], &f3, sizeof(float));
	}

	static HPS_INLINE void unpack_4(float * f0, float const * const m) {
		memcpy(f0, m, sizeof(float)*4);
	}

	static HPS_INLINE void unpack_4(float & f0, float & f1, float & f2, float & f3, float const * const m) {
		memcpy(&f0, &m[0], sizeof(float));
		memcpy(&f1, &m[1], sizeof(float));
		memcpy(&f2, &m[2], sizeof(float));
		memcpy(&f3, &m[3], sizeof(float));
	}

private:
	static const float char_to_float[256];

	Float();
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <typename T>	HPS_INLINE	T *	Alter (T const * a)	{ return const_cast<T *>(a); }
template <typename T>	HPS_INLINE	T &	Alter (T const & a)	{ return const_cast<T &>(a); }

template <typename T>	HPS_INLINE	T		Abs (T const & a)					{ return  a < 0 ? -a : a; }
template <typename T>	HPS_INLINE	int		Compare (T const & a, T const & b)	{ return a == b ? 0 : a < b ? -1 : 1;  }
template <typename T>	HPS_INLINE	int		Sign (T const & a)					{ return Compare(a,(T)0); }
template <typename T>	HPS_INLINE	void	Swap (T & a, T & b)	{ T temp = a; a = b; b = temp; }
template <typename T>	HPS_INLINE	int		Floor(T const & a) { return ((a > 0 || (T)(int)a == a) ? (int)a : ((int)a - 1)); }
template <typename T>	HPS_INLINE	int		Ceiling(T const & a) { return ((a < 0 || (T)(int)a == a) ? (int)a : ((int)a + 1)); }

template <typename T>	HPS_INLINE	T const &	Min (T const & a, T const & b)	{ return  a < b ? a : b; }
template <typename T>	HPS_INLINE	T const &	Min (T const & a, T const & b, T const & c)	{ return  Min(Min(a,b),c); }
template <typename T>	HPS_INLINE	T const &	Min (T const & a, T const & b, T const & c, T const & d) { return Min(Min(a, b, c),d); }
template <typename T>	HPS_INLINE	T const &	Min (T const & a, T const & b, T const & c, T const & d, T const & e) { return Min(Min(a,b,c,d),e); }
template <typename T>	HPS_INLINE	T const &	Min (T const & a, T const & b, T const & c, T const & d, T const & e, T const & f) { return Min(Min(a,b,c,d,e),f); }

template <typename T>	HPS_INLINE	T const &	Max (T const & a, T const & b)	{ return  a > b ? a : b; }
template <typename T>	HPS_INLINE	T const &	Max (T const & a, T const & b, T const & c)	{ return  Max(Max(a,b),c); }
template <typename T>	HPS_INLINE	T const &	Max (T const & a, T const & b, T const & c, T const & d) { return Max(Max(a, b, c),d); }
template <typename T>	HPS_INLINE	T const &	Max (T const & a, T const & b, T const & c, T const & d, T const & e) { return Max(Max(a,b,c,d),e); }
template <typename T>	HPS_INLINE	T const &	Max (T const & a, T const & b, T const & c, T const & d, T const & e, T const & f) { return Max(Max(a,b,c,d,e),f); }

template <typename T>	HPS_INLINE	T const &	Clamp(T const & x, T const & min, T const & max) { return x < min ? min : x > max ? max : x; }


template <> HPS_INLINE float	Abs<float> (float const & a) {
	uint32_t	v = Float::extract_uint32_t(a);
	v &= 0x7FFFFFFF;
	float f;
	Float::inject_uint32_t(f,v);
	return f;
}

template <> HPS_INLINE int	Sign<float> (float const & a) {
	uint32_t	v = Float::extract_uint32_t(a);

	if ((v & 0x7FFFFFFF) == 0)
		return 0;

	return ((int32_t)(v & 0x80000000)>>31) | 0x01;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HPS_INLINE bool Float::Equals(float const & a, float const & b, int tolerance) {
	int32_t		va = Float::extract_uint32_t(a);
	int32_t		vb = Float::extract_uint32_t(b);

	if (is_special(va) || is_special(vb)) {
		if (is_infinite(va) || is_infinite(vb))
			return va == vb;				// final check is for sign bits same
		if (is_nan(va) || is_nan(vb))
			return false;
	}

	int const	close_to_zero = 0x36A00000;	// (approx) 5.0e-6f;
	if ((va & 0x7FFFFFFF) == 0)
		return (vb & 0x7FFFFFFF) < close_to_zero;
	else if ((vb & 0x7FFFFFFF) == 0)
		return (va & 0x7FFFFFFF) < close_to_zero;

	uint32_t	sign_mask = va ^ vb;
	(int32_t &)sign_mask >>= 31;

	int32_t		diff = ((va + sign_mask) ^ (sign_mask & 0x7FFFFFFF)) -vb; 
	int32_t		v1 = tolerance + diff;
	int32_t		v2 = tolerance - diff;
	return (v1|v2) >= 0;
}

HPS_INLINE bool Float::Equals(double const & a, double const & b, int tolerance) {
	int32_t		va[2], vb[2];
	memcpy (va, &a, sizeof(double));
	memcpy (vb, &b, sizeof(double));

	if (is_special(va) || is_special(vb)) {
		if (is_infinite(va) || is_infinite(vb))
			return va[High] == vb[High] && va[Low] == vb[Low];	// final check is for sign bits same
		if (is_nan(va) || is_nan(vb))
			return false;
	}

	if ((va[High] == 0 && va[Low] == 0) || (vb[High] == 0 && vb[Low] == 0))
		return Abs(a - b) < 0.000000000000005;

	if (extract_sign_bit(a) != extract_sign_bit(b))
		return a == b; //-V550

	if (va[High] != vb[High])
		return false;

	return Abs(va[Low] - vb[Low]) <= tolerance;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


HPS_INLINE bool Is_Abnormal (float const & f)	{ return Float::IsAbnormal (f); }
HPS_INLINE bool Is_Abnormal (double const & d)	{ return Float::IsAbnormal (d); }

template <typename T>
HPS_INLINE bool Is_Abnormal (size_t count, T const * t) {
	while (count-- > 0)
		if (Is_Abnormal (*t++))
			return true;
	return false;
}

template <typename T>
HPS_INLINE bool Is_Abnormal (int count, T const * t) {
	return count >= 0 && Is_Abnormal((size_t)count, t);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <typename F> class HPS_TEMPLATE_API Vector_3D;
template <typename F> class HPS_TEMPLATE_API Plane_3D;
template <typename F> class HPS_TEMPLATE_API Vector_2D;
template <typename F> class HPS_TEMPLATE_API Point_2D;


template <typename F>
class HPS_TEMPLATE_API Point_3D {
	public:
		F	x;
		F	y;
		F	z;

		Point_3D () {}
		Point_3D (F v1, F v2, F v3) : x (v1), y (v2), z (v3) {}

		template <typename D>
		explicit Point_3D (Point_3D<D> const & that) : x ((F)that.x), y ((F)that.y), z ((F)that.z) {}

		explicit Point_3D (Vector_3D<F> const & v);
		explicit Point_3D (Vector_2D<F> const & v);
		explicit Point_3D (Point_2D<F> const & that);

		Point_3D const	operator- () const	{ return Point_3D (-x, -y, -z); }

		bool				operator== (Point_3D const & p) const	{ return  x == p.x && y == p.y && z == p.z; }
		bool				operator!= (Point_3D const & p) const	{ return  !(*this == p); }

		bool				Equals(Point_3D const & p, int in_tolerance = 32) const {
								return	Float::Equals(x, p.x, in_tolerance) &&
										Float::Equals(y, p.y, in_tolerance) &&
										Float::Equals(z, p.z, in_tolerance);
							}


		Point_3D &			operator*= (F s)		{ x *= s; y *= s; z *= s;  return *this; }
		Point_3D &			operator/= (F s)		{ return operator*= ((F)1 / s); }
		Point_3D const		operator* (F s) const	{ return Point_3D (x * s, y * s, z * s); }
		Point_3D const		operator/ (F s) const	{ return operator* ((F)1 / s); }

		F &					operator[] (size_t i)		{ return (&x)[i]; }
		F const &			operator[] (size_t i) const	{ return (&x)[i]; }

		Point_3D &			operator+= (Vector_3D<F> const & v);
		Point_3D &			operator-= (Vector_3D<F> const & v);
		Point_3D &			operator*= (Vector_3D<F> const & v);
		Point_3D &			operator/= (Vector_3D<F> const & v);
		Point_3D const		operator* (Vector_3D<F> const & v) const;
		Point_3D const		operator/ (Vector_3D<F> const & v) const;

		Point_3D &			operator+= (Vector_2D<F> const & v);
		Point_3D &			operator-= (Vector_2D<F> const & v);
		Point_3D &			operator*= (Vector_2D<F> const & v);
		Point_3D &			operator/= (Vector_2D<F> const & v);
		Point_3D const		operator* (Vector_2D<F> const & v) const;
		Point_3D const		operator/ (Vector_2D<F> const & v) const;

		Vector_3D<F> const	operator- (Point_3D const & p) const;

		Point_3D const		operator+ (Vector_3D<F> const & v) const;
		Point_3D const		operator- (Vector_3D<F> const & v) const;

		Point_3D const		operator+ (Vector_2D<F> const & v) const;
		Point_3D const		operator- (Vector_2D<F> const & v) const;

		static HPS_INLINE Point_3D	Origin() {return Point_3D (0, 0, 0);};
		static HPS_INLINE Point_3D	Zero() {return Point_3D (0, 0, 0);}; //-V524
};

typedef	Point_3D<float>		Point;
typedef	Point_3D<double>	DPoint;



template <typename F, typename S>
HPS_INLINE Point_3D<F>	operator* (S s, Point_3D<F> const & a) { return Point_3D<F> (F(s * a.x), F(s * a.y), F(s * a.z)); }

template <typename F>
HPS_INLINE Point_3D<F> Midpoint (Point_3D<F> const & a, Point_3D<F> const & b) {
	return Point_3D<F> (a.x + b.x, a.y + b.y, a.z + b.z) * 0.5f;
}

template <typename F>
HPS_INLINE Point_3D<F> Midpoint (Point_3D<F> const & a, Point_3D<F> const & b, Point_3D<F> const & c) {
	return Point_3D<F> (a.x + b.x + c.x, a.y + b.y + c.y, a.z + b.z + c.z) * (F)(1.0/3.0);
}

template <typename F>
HPS_INLINE bool Is_Abnormal (Point_3D<F> const & p) {
	return Is_Abnormal (p.x) || Is_Abnormal (p.y) || Is_Abnormal (p.z);
}


template <typename F>
class HPS_TEMPLATE_API Point_2D {
public:
	F	x;
	F	y;

	Point_2D () {}
	Point_2D (F v1, F v2) : x (v1), y (v2) {}

	template <typename D>
	explicit Point_2D (Point_2D<D> const & that) : x ((F)that.x), y ((F)that.y) {}

	explicit Point_2D (Point_3D<F> const & that) : x ((F)that.x), y ((F)that.y) {}
	explicit Point_2D (Vector_2D<F> const & v);

	Point_2D const	operator- () const	{ return Point_2D (-x, -y); }

	bool				operator== (Point_2D const & p) const	{ return  x == p.x && y == p.y; }
	bool				operator!= (Point_2D const & p) const	{ return  !(*this == p); }

	bool				Equals(Point_2D const & p, int in_tolerance = 32) const {
		return Float::Equals(x, p.x, in_tolerance) && Float::Equals(y, p.y, in_tolerance);
	}


	Point_2D &			operator*= (F s)		{ x *= s; y *= s; return *this; }
	Point_2D &			operator/= (F s)		{ return operator*= ((F)1 / s); }
	Point_2D const		operator* (F s) const	{ return Point_2D (x * s, y * s); }
	Point_2D const		operator/ (F s) const	{ return operator* ((F)1 / s); }

	F &					operator[] (size_t i)		{ return (&x)[i]; }
	F const &			operator[] (size_t i) const	{ return (&x)[i]; }

	Point_2D &			operator+= (Vector_2D<F> const & v);
	Point_2D &			operator-= (Vector_2D<F> const & v);
	Point_2D &			operator*= (Vector_2D<F> const & v);
	Point_2D &			operator/= (Vector_2D<F> const & v);
	Point_2D const		operator* (Vector_2D<F> const & v) const;
	Point_2D const		operator/ (Vector_2D<F> const & v) const;

	Vector_2D<F> const	operator- (Point_2D const & p) const;

	Point_2D const		operator+ (Vector_2D<F> const & v) const;
	Point_2D const		operator- (Vector_2D<F> const & v) const;

	static HPS_INLINE Point_2D	Origin() {return Point_2D (0, 0);};
	static HPS_INLINE Point_2D	Zero() {return Point_2D (0, 0);}; //-V524
};

typedef	Point_2D<float>		Point2D;
typedef	Point_2D<double>	DPoint2D;

template <typename F>
HPS_INLINE Point_3D<F>::Point_3D (Point_2D<F> const & that) : x (that.x), y (that.y), z (0) {}

template <typename F, typename S>
HPS_INLINE Point_2D<F>	operator* (S s, Point_2D<F> const & a) { return Point_2D<F> (F(s * a.x), F(s * a.y)); }

template <typename F>
HPS_INLINE Point_2D<F> Midpoint (Point_2D<F> const & a, Point_2D<F> const & b) {
	return Point_2D<F> (a.x + b.x, a.y + b.y) * 0.5f;
}

template <typename F>
HPS_INLINE Point_2D<F> Midpoint (Point_2D<F> const & a, Point_2D<F> const & b, Point_2D<F> const & c) {
	return Point_2D<F> (a.x + b.x + c.x, a.y + b.y + c.y, a.z + b.z + c.z) * (F)(1.0/3.0);
}

template <typename F>
HPS_INLINE bool Is_Abnormal (Point_2D<F> const & p) {
	return Is_Abnormal (p.x) || Is_Abnormal (p.y);
}


template <typename F>
class HPS_TEMPLATE_API Vector_3D {
	public:
		F	x;
		F	y;
		F	z;

		Vector_3D () {}
		Vector_3D (F v1, F v2, F v3) : x (v1), y (v2), z (v3) {}
		template <typename D>
			explicit Vector_3D (Vector_3D<D> const & that) : x ((F)that.x), y ((F)that.y), z ((F)that.z) {}
		explicit Vector_3D(Point_3D<F> const & p) : x(p.x), y(p.y), z(p.z) {}
		explicit Vector_3D(Plane_3D<F> const & p);

		explicit Vector_3D (Vector_2D<F> const & that);

		Vector_3D const	operator- () const	{ return Vector_3D (-x, -y, -z); }

		bool				operator== (Vector_3D const & v) const		{
								return  Float::match(x, v.x) && Float::match(y, v.y) && Float::match(z, v.z);
							}
		bool				operator!= (Vector_3D const & v) const		{ return  !(*this == v); }

		bool				Equals(Vector_3D const & v, int in_tolerance = 32) const {
								return	Float::Equals(x, v.x, in_tolerance) &&
										Float::Equals(y, v.y, in_tolerance) &&
										Float::Equals(z, v.z, in_tolerance);
							}

		Vector_3D &			operator+= (Vector_3D const & v)		{ x += v.x; y += v.y; z += v.z;  return *this; }
		Vector_3D &			operator-= (Vector_3D const & v)		{ x -= v.x; y -= v.y; z -= v.z;  return *this; }
		Vector_3D const		operator+ (Vector_3D const & v) const	{ return Vector_3D (x + v.x, y + v.y, z + v.z); }
		Vector_3D const		operator- (Vector_3D const & v) const	{ return Vector_3D (x - v.x, y - v.y, z - v.z); }

		Vector_3D &			operator*= (F s)				{ x *= s; y *= s; z *= s;  return *this; }
		Vector_3D &			operator/= (F s)				{ return operator*= (1.0f / s); }
		Vector_3D const		operator* (F s) const			{ return Vector_3D (x * s, y * s, z * s); }
		Vector_3D const		operator/ (F s) const			{ return operator* (1.0f / s); }

		F &					operator[] (size_t i)		{ return (&x)[i]; }
		F const &			operator[] (size_t i) const	{ return (&x)[i]; }

		HPS_INLINE double	Length () const { return sqrt (LengthSquared()); }

		HPS_INLINE double	LengthSquared () const { return (double)x*(double)x + (double)y*(double)y + (double)z*(double)z; }

		HPS_INLINE double	Length2D () const { return sqrt (LengthSquared2D()); }

		HPS_INLINE double	LengthSquared2D () const { return (double)x*(double)x + (double)y*(double)y;}

		HPS_INLINE Vector_3D &	Normalize (bool check_range = false, F epsilon = Float_Traits<F>::Epsilon()) {// not const &; allow V.normalize() *= S;
			if (check_range) {
				F	range = Max (Abs (x), Abs (y), Abs (z));
				if (range > F(1.0e10))
					operator/= (range);
			}

			F	len = (F)Length();
			if (len > epsilon)
				operator/= (len);
			else
				*this = Zero();
			return *this;
		}
		HPS_INLINE Vector_3D &	Normalize (F epsilon) { return Normalize (false, epsilon); }

		HPS_INLINE Vector_3D &	Clean_Zeroes (F epsilon = F(1.0e-4)) {
			if (Abs(x) < epsilon)
				x = 0;
			if (Abs(y) < epsilon)
				y = 0;
			if (Abs(z) < epsilon)
				z = 0;
			return *this;
		}

		HPS_INLINE F		Magnitude () const { return Max (Abs(x), Abs(y), Abs(z)); }
		HPS_INLINE F		Manhattan () const { return Abs(x)+Abs(y)+Abs(z); }

		HPS_INLINE F		Dot (Vector_3D const & v) const { return x * v.x  +  y * v.y  +  z * v.z; }

		HPS_INLINE Vector_3D	Cross (Vector_3D const & v) const {
									return Vector_3D (y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);
								}


		HPS_INLINE Vector_3D	Scale (Vector_3D const & v) const {
									return Vector_3D (x * v.x, y * v.y, z * v.z);
								}

		Vector_3D<F> different_vector () const {
			if (Abs (x) < Abs (y))
				return Vector_3D<F>::XAxis();
			else
				return Vector_3D<F>::YAxis();
		}


		static HPS_INLINE Vector_3D	XAxis()	{return Vector_3D (1, 0, 0);};
		static HPS_INLINE Vector_3D	YAxis()	{return Vector_3D (0, 1, 0);};
		static HPS_INLINE Vector_3D	ZAxis()	{return Vector_3D (0, 0, 1);};
		static HPS_INLINE Vector_3D	Zero()	{return Vector_3D (0, 0, 0);};
		static HPS_INLINE Vector_3D	Unit()	{return Vector_3D (1, 1, 1);};
};

typedef Vector_3D<float>	Vector;
typedef Vector_3D<double>	DVector;


template <typename F, typename S>
HPS_INLINE	Vector_3D<F>	operator* (S s, Vector_3D<F> const & v) {return Vector_3D<F> (F(s * v.x), F(s * v.y), F(s * v.z)); }

template <typename F>
HPS_INLINE bool Is_Abnormal (Vector_3D<F> const & v) {
	return Is_Abnormal (v.x) || Is_Abnormal (v.y) || Is_Abnormal (v.z);
}


template <typename F>
HPS_INLINE	Point_3D<F>::Point_3D(Vector_3D<F> const & v) : x(v.x), y(v.y), z(v.z) {}

template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator+= (Vector_3D<F> const & v)	{ x += v.x; y += v.y; z += v.z;  return *this; }
template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator-= (Vector_3D<F> const & v)	{ x -= v.x; y -= v.y; z -= v.z;  return *this; }

template <typename F>
HPS_INLINE	Vector_3D<F> const	Point_3D<F>::operator- (Point_3D<F> const & p) const	{ return Vector_3D<F> (x - p.x, y - p.y, z - p.z); }

template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator+ (Vector_3D<F> const & v) const	{ return Point_3D<F>  (x + v.x, y + v.y, z + v.z); }
template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator- (Vector_3D<F> const & v) const	{ return Point_3D<F>  (x - v.x, y - v.y, z - v.z); }

template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator*= (Vector_3D<F> const & v) { x *= v.x; y *= v.y; z *= v.z;  return *this; }
template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator/= (Vector_3D<F> const & v) { x /= v.x; y /= v.y; z /= v.z;  return *this; }
template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator* (Vector_3D<F> const & v) const { return Point_3D<F> (x * v.x, y * v.y, z * v.z); }
template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator/ (Vector_3D<F> const & v) const { return Point_3D<F> (x / v.x, y / v.y, z / v.z); }



template <typename F>
HPS_INLINE Point_3D<F> Interpolate(Point_3D<F> const & a, Point_3D<F> const & b, float t) {
	return a + (b - a) * t;
}

template <typename F>
HPS_INLINE Vector_3D<F> Interpolate(Vector_3D<F> const & a, Vector_3D<F> const & b, float t) {
	return Vector_3D<F>(a + (b - a) * t).Normalize();
}



template <typename F>
HPS_INLINE	double PointToPointDistance(Point_3D<F> const & p1, Point_3D<F> const & p2) {
	return (p2 - p1).Length();
}

template <typename F>
HPS_INLINE	double PointToPointDistanceSquared(Point_3D<F> const & p1, Point_3D<F> const & p2) {
	return (p2 - p1).LengthSquared();
}

template <typename F>
HPS_INLINE Point_3D<F> Circumcenter(Point_3D<F> const & a, Point_3D<F> const & b, Point_3D<F> const & c) {
	F	p = static_cast<F>((c - b).LengthSquared());
	F	q = static_cast<F>((c - a).LengthSquared());
	F	r = static_cast<F>((b - a).LengthSquared());

	return Point_3D<F>(
		(a * (p*(q+r-p)) + (Vector_3D<F>)b * (q*(r+p-q)) + (Vector_3D<F>)c * (r*(p+q-r)))
			/ (2 * (p*q + p*r + q*r) - (p*p + q*q + r*r)) );
}



template <typename F>
HPS_INLINE bool Normalize(size_t count, Vector_3D<F> * vectors) {
	bool success = true;
	for (size_t i = 0; i < count; ++i) {
		if (vectors->Normalize() == Vector_3D<F>::Zero())
			success = false;
		vectors++;
	}
	return success;
}


template <typename F> class HPS_TEMPLATE_API Plane_2D;

template <typename F>
class HPS_TEMPLATE_API Vector_2D {
public:
	F	x;
	F	y;

	Vector_2D () {}
	Vector_2D (F v1, F v2) : x (v1), y (v2) {}
	template <typename D>
	explicit Vector_2D (Vector_2D<D> const & that) : x ((F)that.x), y ((F)that.y) {}

	explicit Vector_2D (Vector_3D<F> const & that) : x (that.x), y (that.y) {}
	explicit Vector_2D (Point_2D<F> const & p) : x(p.x), y(p.y) {}
	explicit Vector_2D (Plane_2D<F> const & p);

	Vector_2D const	operator- () const	{ return Vector_2D (-x, -y); }

	bool				operator== (Vector_2D const & v) const		{
		return  Float::match(x, v.x) && Float::match(y, v.y);
	}
	bool				operator!= (Vector_2D const & v) const		{ return  !(*this == v); }

	bool				Equals(Vector_2D const & v, int in_tolerance = 32) const {
		return	Float::Equals(x, v.x, in_tolerance) && Float::Equals(y, v.y, in_tolerance);
	}

	Vector_2D &			operator+= (Vector_2D const & v)		{ x += v.x; y += v.y; return *this; }
	Vector_2D &			operator-= (Vector_2D const & v)		{ x -= v.x; y -= v.y; return *this; }
	Vector_2D const		operator+ (Vector_2D const & v) const	{ return Vector_2D (x + v.x, y + v.y); }
	Vector_2D const		operator- (Vector_2D const & v) const	{ return Vector_2D (x - v.x, y - v.y); }

	Vector_2D &			operator*= (F s)				{ x *= s; y *= s; return *this; }
	Vector_2D &			operator/= (F s)				{ return operator*= (1.0f / s); }
	Vector_2D const		operator* (F s) const			{ return Vector_2D (x * s, y * s); }
	Vector_2D const		operator/ (F s) const			{ return operator* (1.0f / s); }

	F &					operator[] (size_t i)		{ return (&x)[i]; }
	F const &			operator[] (size_t i) const	{ return (&x)[i]; }

	HPS_INLINE double	Length () const { return sqrt (LengthSquared()); }

	HPS_INLINE double	LengthSquared () const { return (double)x*(double)x + (double)y*(double)y; }

	HPS_INLINE Vector_2D &	Normalize (bool check_range = false, F epsilon = Float_Traits<F>::Epsilon()) {// not const &; allow V.normalize() *= S;
		if (check_range) {
			F	range = Max (Abs (x), Abs (y));
			if (range > F(1.0e10))
				operator/= (range);
		}

		F	len = (F)Length();
		if (len > epsilon)
			operator/= (len);
		else
			*this = Zero();
		return *this;
	}
	HPS_INLINE Vector_2D &	Normalize (F epsilon) { return Normalize (false, epsilon); }

	HPS_INLINE F		Magnitude () const { return Max (Abs(x), Abs(y)); }
	HPS_INLINE F		Manhattan () const { return Abs(x)+Abs(y); }

	HPS_INLINE F		Dot (Vector_2D const & v) const { return x * v.x  +  y * v.y; }


	HPS_INLINE F		Cross (Vector_2D const & v) const {
		return x * v.y - y * v.x;
	}

	HPS_INLINE Vector_2D	Scale (Vector_2D const & v) const {
		return Vector_2D (x * v.x, y * v.y);
	}

	static HPS_INLINE Vector_2D	XAxis()	{return Vector_2D (1, 0);};
	static HPS_INLINE Vector_2D	YAxis()	{return Vector_2D (0, 1);};

	static HPS_INLINE Vector_2D	Zero()	{return Vector_2D (0, 0);};
	static HPS_INLINE Vector_2D	Unit()	{return Vector_2D (1, 1);};
};

typedef Vector_2D<float>	Vector2D;
typedef Vector_2D<double>	DVector2D;

template <typename F, typename S>
HPS_INLINE	Vector_2D<F>	operator* (S s, Vector_2D<F> const & v) {return Vector_2D<F> (F(s * v.x), F(s * v.y)); }

template <typename F>
HPS_INLINE bool Is_Abnormal (Vector_2D<F> const & v) {		
	return Is_Abnormal (v.x) || Is_Abnormal (v.y);
}


template <typename F>
HPS_INLINE	Vector_3D<F>::Vector_3D (Vector_2D<F> const & that) : x (that.x), y (that.y), z(0) {}

template <typename F>
HPS_INLINE	Point_3D<F>::Point_3D(Vector_2D<F> const & v) : x(v.x), y(v.y), z(0) {}

template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator+= (Vector_2D<F> const & v)	{ x += v.x; y += v.y; return *this; }
template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator-= (Vector_2D<F> const & v)	{ x -= v.x; y -= v.y; return *this; }

template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator+ (Vector_2D<F> const & v) const	{ return Point_3D<F>  (x + v.x, y + v.y, z); }
template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator- (Vector_2D<F> const & v) const	{ return Point_3D<F>  (x - v.x, y - v.y, z); }

template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator*= (Vector_2D<F> const & v) { x *= v.x; y *= v.y; return *this; }
template <typename F>
HPS_INLINE	Point_3D<F> &		Point_3D<F>::operator/= (Vector_2D<F> const & v) { x /= v.x; y /= v.y; return *this; }

template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator* (Vector_2D<F> const & v) const { return Point_3D<F> (x * v.x, y * v.y, z); }
template <typename F>
HPS_INLINE	Point_3D<F> const	Point_3D<F>::operator/ (Vector_2D<F> const & v) const { return Point_3D<F> (x / v.x, y / v.y, z); }


template <typename F>
HPS_INLINE	Point_2D<F> &		Point_2D<F>::operator+= (Vector_2D<F> const & v)	{ x += v.x; y += v.y; return *this; }
template <typename F>
HPS_INLINE	Point_2D<F> &		Point_2D<F>::operator-= (Vector_2D<F> const & v)	{ x -= v.x; y -= v.y; return *this; }

template <typename F>
HPS_INLINE	Vector_2D<F> const	Point_2D<F>::operator- (Point_2D<F> const & p) const	{ return Vector_2D<F> (x - p.x, y - p.y); }

template <typename F>
HPS_INLINE	Point_2D<F> const	Point_2D<F>::operator+ (Vector_2D<F> const & v) const	{ return Point_2D<F>  (x + v.x, y + v.y); }
template <typename F>
HPS_INLINE	Point_2D<F> const	Point_2D<F>::operator- (Vector_2D<F> const & v) const	{ return Point_2D<F>  (x - v.x, y - v.y); }

template <typename F>
HPS_INLINE	Point_2D<F> &		Point_2D<F>::operator*= (Vector_2D<F> const & v) { x *= v.x; y *= v.y; return *this; }
template <typename F>
HPS_INLINE	Point_2D<F> &		Point_2D<F>::operator/= (Vector_2D<F> const & v) { x /= v.x; y /= v.y; return *this; }
template <typename F>
HPS_INLINE	Point_2D<F> const	Point_2D<F>::operator* (Vector_2D<F> const & v) const { return Point_2D<F> (x * v.x, y * v.y); }
template <typename F>
HPS_INLINE	Point_2D<F> const	Point_2D<F>::operator/ (Vector_2D<F> const & v) const { return Point_2D<F> (x / v.x, y / v.y); }





template <typename F>
class HPS_TEMPLATE_API Plane_3D {
	public:
		F	a;
		F	b;
		F	c;
		F	d;

		Plane_3D () {}
		Plane_3D (F v1, F v2, F v3, F v4) : a (v1), b (v2), c (v3), d (v4) {}
		Plane_3D (Vector_3D<F> const & v, F f = 0) : a (v.x), b (v.y), c (v.z), d (f) {}
		Plane_3D (Vector_3D<F> const & v, Point_3D<F> const & p) : a (v.x), b (v.y), c (v.z), d (-(p.x * v.x + p.y * v.y + p.z * v.z)) {}
		Plane_3D (Point_3D<F> const & p, Vector_3D<F> const & v) : a (v.x), b (v.y), c (v.z), d (-(p.x * v.x + p.y * v.y + p.z * v.z)) {}
		template <typename D>
			explicit Plane_3D (Plane_3D<D> const & that) : a ((F)that.a), b ((F)that.b), c ((F)that.c), d ((F)that.d) {}

		Plane_3D (size_t count, Point_3D<F> const * points) {
			if (count >= 3) {
				// The 3 coefficients A, B, and C are proportional to the areas of the
				// projections of the polygon onto the yz, zx, and xy planes, respectively.

				// run around the polygon, collecting trapezoidal areas
				// a "center" point is also collected, to make the plane 'd' slightly more "valid" when the polygon is non-planar.

				// take care of the swing point first
				Point_3D<F> const * p0 = &points[count-1];

				Point_3D<double>	ctr = Point_3D<double>::Origin();
				Vector_3D<F>		normal = Vector_3D<F>::Zero();

				for (size_t i=0; i<count; ++i) {
					Point_3D<F> const * p1 = &points[i];

					normal.x += (p0->y + p1->y) * (p1->z - p0->z);
					normal.y += (p0->z + p1->z) * (p1->x - p0->x);
					normal.z += (p0->x + p1->x) * (p1->y - p0->y);

					ctr += Vector_3D<double>(Vector_3D<F>(points[i]));

					p0 = p1;
				}

				// ("should" always be != 0)
				if (normal.Normalize() != Vector_3D<F>::Zero()) {
					/* finish finding the average */
					double	inv_count = 1.0 / (double)count;
					ctr *= inv_count;

					*this = Plane_3D(normal, Point_3D<F>(ctr));
					return;
				}
			}

			*this = Plane_3D::Zero();
		}


		Plane_3D const		operator- () const							{ return Plane_3D (-a, -b, -c, -d); }

		bool				operator== (Plane_3D const & p) const		{ return  a == p.a && b == p.b && c == p.c && d == p.d; }
		bool				operator!= (Plane_3D const & p) const		{ return  !(*this == p); }

		F &					operator[] (size_t i)		{ return (&a)[i]; }
		F const &			operator[] (size_t i) const	{ return (&a)[i]; }

		HPS_INLINE bool	Equals(Plane_3D const & p, int in_tolerance = 32) const { 
			return  Float::Equals(a, p.a, in_tolerance) && Float::Equals(b, p.b, in_tolerance) && 
					Float::Equals(c, p.c, in_tolerance) && Float::Equals(d, p.d, in_tolerance);
		}

		Plane_3D &		Normalize (F epsilon = Float_Traits<F>::Epsilon()) {	// not const &; allow V.normalize() *= S;
			F len = (F)Vector_3D<F>(*this).Length();
			if (len > epsilon)
				operator/= (len);
			else
				*this = Zero();
			return *this;
		}

		Point_3D<F>		IntersectLineSegment(Point_3D<F> const & p1, Point_3D<F> const & p2, float eps = 1e-5f) const {
			F	val1 = Abs (a * p1.x + b * p1.y + c * p1.z + d);
			F	val2 = Abs (a * p2.x + b * p2.y + c * p2.z + d);

			if (val1 >= eps) {
				return Point_3D<F> (((val1 * p2.x) + (val2 * p1.x)) / (val1 + val2),
									((val1 * p2.y) + (val2 * p1.y)) / (val1 + val2),
									((val1 * p2.z) + (val2 * p1.z)) / (val1 + val2));
			}
			else
				return p1;
		}

		Point_3D<F>		IntersectLineSegment2(Point_3D<F> const & p1, Point_3D<F> const & p2) const {
			F		 u = (a * p1.x + b * p1.y + c * p1.z + d) /
						(a * (p1.x - p2.x) + b * (p1.y - p2.y) + c * (p1.z - p2.z));

			return Point_3D<F>(p1.x + u * (p2.x - p1.x), p1.y + u * (p2.y - p1.y), p1.z + u * (p2.z - p1.z));
		}


		bool parallel (Plane_3D const & p) const {
			return  equivalent (a, p.a) &&
					equivalent (b, p.b) &&
					equivalent (c, p.c);
		}

		bool equivalent (Plane_3D const & p) const {
			return  parallel (p) &&
					equivalent (d, p.d, (F)1.0e-6);
		}


		static HPS_INLINE Plane_3D Zero() {return Plane_3D (0.0f, 0.0f, 0.0f, 0.0f);};


	private:
		Plane_3D &		operator*= (F s)				{ a *= s; b *= s; c *= s; d *= s; return *this; }
		Plane_3D &		operator/= (F s)				{ return operator*= ((F)1.0 / s); }
		Plane_3D const	operator* (F s) const			{ return Plane_3D (a * s, b * s, c * s, d * s); }
		Plane_3D const	operator/ (F s) const			{ return operator* ((F)1.0 / s); }

		static bool equivalent (float a, float b) {					// for vector components
			if (Abs(a) < 1.0e-4f && Abs(b) < 1.0e-4f)
				return true;
			return Float::Equals (a, b);
		}

		static bool equivalent (float a, float b, float cutoff) {	// for distance
			if (Abs(a) < cutoff && Abs(b) < cutoff)
				return a == b;
			return Float::Equals (a, b);
		}
};

typedef Plane_3D<float>		Plane;
typedef Plane_3D<double>	DPlane;


template <typename F>
HPS_INLINE bool Is_Abnormal (Plane_3D<F> const & p) {
	return Is_Abnormal (p.a) || Is_Abnormal (p.b) || Is_Abnormal (p.c) || Is_Abnormal (p.d);
}


template <typename F>
HPS_INLINE	F operator* (Plane_3D<F> const & plane, Point_3D<F> const & point) {
	return plane.a * point.x  +  plane.b * point.y  +  plane.c * point.z  +  plane.d;
}
template <typename F>
HPS_INLINE	F operator* (Point_3D<F> const & point, Plane_3D<F> const & plane) {
	return plane * point;
}

template <typename F>
HPS_INLINE Plane_3D<F> Interpolate(Plane_3D<F> const & a, Plane_3D<F> const & b, float t) {
	return Plane_3D<F>(a.a + (b.a - a.a) * t, a.b + (b.b - a.b) * t, a.c + (b.c - a.c) * t, a.d + (b.d - a.d) * t);
}

template <typename F>
Vector_3D<F>::Vector_3D(Plane_3D<F> const & p) : x(p.a), y(p.b), z(p.c) {}






template <typename F>
class HPS_TEMPLATE_API Plane_2D {
public:
	F	a;
	F	b;
	F	c;

	Plane_2D () {}
	Plane_2D (F v1, F v2, F v3) : a (v1), b (v2), c (v3) {}
	Plane_2D (Vector_2D<F> const & v, F f = 0) : a (v.x), b (v.y), c (f) {}
	Plane_2D (Vector_2D<F> const & v, Point_2D<F> const & p) : a (v.x), b (v.y), c (-(p.x * v.x + p.y * v.y)) {}
	Plane_2D (Point_2D<F> const & p, Vector_2D<F> const & v) : a (v.x), b (v.y), c (-(p.x * v.x + p.y * v.y)) {}
	template <typename D>
	explicit Plane_2D (Plane_2D<D> const & that) : a ((F)that.a), b ((F)that.b), c ((F)that.c) {}

	Plane_2D const		operator- () const							{ return Plane_2D (-a, -b, -c); }

	bool				operator== (Plane_2D const & p) const		{ return  a == p.a && b == p.b && c == p.c; }
	bool				operator!= (Plane_2D const & p) const		{ return  !(*this == p); }

	F &					operator[] (size_t i)		{ return (&a)[i]; }
	F const &			operator[] (size_t i) const	{ return (&a)[i]; }

	HPS_INLINE bool	Equals(Plane_2D const & p, int in_tolerance = 32) const { 
		return  Float::Equals(a, p.a, in_tolerance) && Float::Equals(b, p.b, in_tolerance) && Float::Equals(c, p.c, in_tolerance); 
	}

	Plane_2D &		Normalize (F epsilon = Float_Traits<F>::Epsilon()) {	// not const &; allow V.Normalize() *= S;
		F len = (F)Vector_2D<F>(*this).Length();
		if (len > epsilon)
			operator/= (len);
		else
			*this = Zero();
		return *this;
	}

	static HPS_INLINE Plane_2D Zero() {return Plane_2D (0.0f, 0.0f, 0.0f);};


private:
	Plane_2D &		operator*= (F s)				{ a *= s; b *= s; c *= s; return *this; }
	Plane_2D &		operator/= (F s)				{ return operator*= ((F)1.0 / s); }
	Plane_2D const	operator* (F s) const			{ return Plane_2D (a * s, b * s, c * s); }
	Plane_2D const	operator/ (F s) const			{ return operator* ((F)1.0 / s); }
};

typedef Plane_2D<float>		Plane2D;
typedef Plane_2D<double>	DPlane2D;


template <typename F>
HPS_INLINE bool Is_Abnormal (Plane_2D<F> const & p) {
	return Is_Abnormal (p.a) || Is_Abnormal (p.b) || Is_Abnormal (p.c);
}


template <typename F>
HPS_INLINE	F operator* (Plane_2D<F> const & plane, Point_2D<F> const & point) { 
	return plane.a * point.x + plane.b * point.y + plane.c;
}
template <typename F>
HPS_INLINE	F operator* (Point_3D<F> const & point, Plane_2D<F> const & plane) {
	return plane * point;
}

template <typename F>
HPS_INLINE Plane_2D<F> Interpolate(Plane_2D<F> const & a, Plane_2D<F> const & b, float t) {
	return Plane_2D<F>(a.a + (b.a - a.a) * t, a.b + (b.b - a.b) * t, a.c + (b.c - a.c) * t);
}

template <typename F>
Vector_2D<F>::Vector_2D(Plane_2D<F> const & p) : x(p.a), y(p.b) {}




struct Rectangle;

struct HPS_API IntRectangle {
	int	left;
	int	right;
	int	bottom;
	int	top;

	IntRectangle()
		: left(std::numeric_limits<int>::max()), right(std::numeric_limits<int>::min()),
		  bottom(std::numeric_limits<int>::max()), top(std::numeric_limits<int>::min()) {}

	IntRectangle(int in_left, int in_right, int in_bottom, int in_top)
		: left(in_left), right(in_right), bottom(in_bottom), top(in_top) {}

	IntRectangle(IntRectangle const & that)
		: left(that.left), right(that.right), bottom(that.bottom), top(that.top) {}

	explicit IntRectangle(Rectangle const & that);

	bool operator==(IntRectangle const & rect) const {
		return  (left == rect.left && right == rect.right && bottom == rect.bottom && top == rect.top);
	}

	bool operator!=(IntRectangle const & rect) const {
		return  !(*this == rect);
	}

	HPS_INLINE int PixelWidth() const {
		return right - left + 1;
	}

	HPS_INLINE int PixelHeight() const {
		return top - bottom + 1;
	}

	HPS_INLINE int Width() const {
		return right - left;
	}

	HPS_INLINE int Height() const {
		return top - bottom;
	}

	HPS_INLINE int Area() const {
		return Width() * Height();
	}

	HPS_INLINE float Aspect() const {
		return  (float)Height() / (float)Width();
	}

	HPS_INLINE Point2D Center() const {
		return Point2D((float)(left + right) * 0.5f, (float)(bottom + top) * 0.5f);
	}

	HPS_INLINE bool Intersecting(IntRectangle const & rect) const {
		return	right >= rect.left && left <= rect.right && top >= rect.bottom && bottom <= rect.top;
	}

	HPS_INLINE bool Contains(IntRectangle const & rect) const {
		return (left <= rect.left && right >= rect.right && bottom <= rect.bottom && top >= rect.top);
	}

	HPS_INLINE IntRectangle & Expand(int border) {
		left -= border;
		right += border;
		bottom -= border;
		top += border;
		return *this;
	}

	HPS_INLINE IntRectangle & Expand(IntRectangle const & rect) {
		left -= rect.left;
		right += rect.right;
		bottom -= rect.bottom;
		top += rect.top;
		return *this;
	}

	HPS_INLINE IntRectangle & Contract(int border) {
		left += border;
		right -= border;
		bottom += border;
		top -= border;
		return *this;
	}

	HPS_INLINE IntRectangle & Contract(IntRectangle const & rect) {
		left += rect.left;
		right -= rect.right;
		bottom += rect.bottom;
		top -= rect.top;
		return *this;
	}

	HPS_INLINE IntRectangle & Intersect(IntRectangle const & rect) {
		left = Max(left, rect.left);
		right = Min(right, rect.right);
		bottom = Max(bottom, rect.bottom);
		top = Min(top, rect.top);
		return *this;
	}

	HPS_INLINE IntRectangle & Union(IntRectangle const & rect) {
		left = Min(left, rect.left);
		right = Max(right, rect.right);
		bottom = Min(bottom, rect.bottom);
		top = Max(top, rect.top);
		return *this;
	}


	static HPS_INLINE IntRectangle Invalid() {
		return IntRectangle();
	}

	static HPS_INLINE IntRectangle Zero() {
		return IntRectangle(0, 0, 0, 0);
	}

};

HPS_INLINE IntRectangle Expand(IntRectangle const & a, IntRectangle const & border) {
	IntRectangle temp = a;
	return temp.Expand(border);
}

HPS_INLINE IntRectangle Expand(IntRectangle const & a, int border) {
	IntRectangle temp = a;
	return temp.Expand(border);
}

HPS_INLINE IntRectangle Contract(IntRectangle const & a, int border) {
	IntRectangle temp = a;
	return temp.Contract(border);
}

HPS_INLINE IntRectangle Contract(IntRectangle const & a, IntRectangle const & border) {
	IntRectangle temp = a;
	return temp.Contract(border);
}

HPS_INLINE IntRectangle Intersect(IntRectangle const & a, IntRectangle const & b) {
	IntRectangle temp = a;
	return temp.Intersect(b);
}

HPS_INLINE IntRectangle Union(IntRectangle const & a, IntRectangle const & b) {
	IntRectangle temp = a;
	return temp.Union(b);
}

struct HPS_API Rectangle {
	float	left;
	float	right;
	float	bottom;
	float	top;

	Rectangle()
		: left(std::numeric_limits<float>::max()), right(-std::numeric_limits<float>::max()),
		  bottom(std::numeric_limits<float>::max()), top(-std::numeric_limits<float>::max()) {}

	Rectangle(float in_left, float in_right, float in_bottom, float in_top)
		: left(in_left), right(in_right), bottom(in_bottom), top(in_top) {}

	Rectangle(Rectangle const & that) 
		: left(that.left), right(that.right), bottom(that.bottom), top(that.top) {}

	explicit Rectangle(IntRectangle const & that)
		: left((float)that.left), right((float)that.right), bottom((float)that.bottom), top((float)that.top) {}

	HPS_INLINE	Rectangle(size_t count, Point const * points) {
		left = points->x;
		right = points->x;
		top = points->y;
		bottom = points->y;
		--count;
		if (count > 0) {
			++points;
			Merge(count, points);
		}
	}

	HPS_INLINE	Rectangle(size_t count, Point2D const * points) {
		left = points->x;
		right = points->x;
		top = points->y;
		bottom = points->y;
		--count;
		if (count > 0) {
			++points;
			Merge(count, points);
		}
	}

	HPS_INLINE float Width() const {
		return right - left;
	}

	HPS_INLINE float Height() const {
		return top - bottom;
	}

	HPS_INLINE float Area() const {
		return Width() * Height();
	}

	HPS_INLINE float Aspect() const {
		return  Height() / Width();
	}

	HPS_INLINE Point2D Center() const {
		return Point2D((left + right) * 0.5f, (bottom + top) * 0.5f);
	}

	HPS_INLINE void Merge(size_t count, Point const * points) {

		while (count > 1) {
			if (points[0].x > points[1].x) {
				Float::replace_if_smaller(left, points[1].x);
				Float::replace_if_larger(right, points[0].x);
			}
			else {
				Float::replace_if_smaller(left, points[0].x);
				Float::replace_if_larger(right, points[1].x);
			}

			if (points[0].y > points[1].y) {
				Float::replace_if_smaller(bottom, points[1].y);
				Float::replace_if_larger(top, points[0].y);
			}
			else {
				Float::replace_if_smaller(bottom, points[0].y);
				Float::replace_if_larger(top, points[1].y);
			}

			points += 2;
			count -= 2;
		}

		if (count > 0)
			Merge(*points);
	}

	HPS_INLINE void Merge(Point const & point) 	{
		Float::replace_if_smaller(left, point.x);
		Float::replace_if_smaller(bottom, point.y);
		Float::replace_if_larger(right, point.x);
		Float::replace_if_larger(top, point.y);
	}

	HPS_INLINE void Merge(size_t count, Point2D const * points) {

		while (count > 1) {
			if (points[0].x > points[1].x) {
				Float::replace_if_smaller(left, points[1].x);
				Float::replace_if_larger(right, points[0].x);
			}
			else {
				Float::replace_if_smaller(left, points[0].x);
				Float::replace_if_larger(right, points[1].x);
			}

			if (points[0].y > points[1].y) {
				Float::replace_if_smaller(bottom, points[1].y);
				Float::replace_if_larger(top, points[0].y);
			}
			else {
				Float::replace_if_smaller(bottom, points[0].y);
				Float::replace_if_larger(top, points[1].y);
			}

			points += 2;
			count -= 2;
		}

		if (count > 0)
			Merge(*points);
	}

	HPS_INLINE void Merge(Point2D const & point) 	{
		Float::replace_if_smaller(left, point.x);
		Float::replace_if_smaller(bottom, point.y);
		Float::replace_if_larger(right, point.x);
		Float::replace_if_larger(top, point.y);
	}

	HPS_INLINE bool operator==(Rectangle const & rect) const {
		return (left == rect.left && right == rect.right && bottom == rect.bottom && top == rect.top);
	}

	HPS_INLINE bool operator!=(Rectangle const & rect) const {
		return  !(*this == rect);
	}

	HPS_INLINE bool Equals(Rectangle const & rect, int in_tolerance = 32) const {
		return Float::Equals(left, rect.left, in_tolerance) &&
			Float::Equals(right, rect.right, in_tolerance) &&
			Float::Equals(top, rect.top, in_tolerance) &&
			Float::Equals(bottom, rect.bottom, in_tolerance);
	}

	HPS_INLINE bool Intersecting(Rectangle const & rect) const {
		return	right >= rect.left && left <= rect.right && top >= rect.bottom && bottom <= rect.top;
	}

	HPS_INLINE bool Contains(Point const & contained) const {
		return !(contained.x < left || contained.x > right || contained.y < bottom || contained.y > top);
	}

	HPS_INLINE bool Contains(Point2D const & contained) const {
		return !(contained.x < left || contained.x > right || contained.y < bottom || contained.y > top);
	}

	HPS_INLINE bool Contains(Rectangle const & rect) {
		return (left <= rect.left && right >= rect.right && bottom <= rect.bottom && top >= rect.top);
	}

	HPS_INLINE bool Contains(Rectangle const & rect, float epsilon) {
		return (left <= rect.left + epsilon && right >= rect.right - epsilon && 
				bottom <= rect.bottom + epsilon && top >= rect.top	- epsilon);
	}

	HPS_INLINE Rectangle & Expand(float border) {
		left -= border;
		right += border;
		bottom -= border;
		top += border;
		return *this;
	}

	HPS_INLINE Rectangle & Expand(int border) {
		Expand((float)border);
		return *this;
	}

	HPS_INLINE Rectangle & Expand(Rectangle const & rect) {
		left -= rect.left;
		right += rect.right;
		bottom -= rect.bottom;
		top += rect.top;
		return *this;
	}

	HPS_INLINE Rectangle & Contract(int border) {
		left += border;
		right -= border;
		bottom += border;
		top -= border;
		return *this;
	}

	HPS_INLINE Rectangle & Contract(Rectangle const & rect) {
		left += rect.left;
		right -= rect.right;
		bottom += rect.bottom;
		top -= rect.top;
		return *this;
	}

	HPS_INLINE Rectangle & Intersect(Rectangle const & rect) {
		left = Max(left, rect.left);
		right = Min(right, rect.right);
		bottom = Max(bottom, rect.bottom);
		top = Min(top, rect.top);
		return *this;
	}

	HPS_INLINE Rectangle & Union(Rectangle const & rect) {
		left = Min(left, rect.left);
		right = Max(right, rect.right);
		bottom = Min(bottom, rect.bottom);
		top = Max(top, rect.top);
		return *this;
	}

	HPS_INLINE Rectangle & Inscribe_Scope(Rectangle const & scope) {
		float scale = (scope.right - scope.left) * 0.5f;
		float trans = (scope.right + scope.left) * 0.5f;

		left = left * scale + trans;
		right = right * scale + trans;

		scale = (scope.top - scope.bottom) * 0.5f;
		trans = (scope.top + scope.bottom) * 0.5f;

		bottom = bottom * scale + trans;
		top = top * scale + trans;
		return *this;
	}

	HPS_INLINE Rectangle & Circumscribe_Scope(Rectangle const & scope) {
		float tmp = 2.0f/(scope.right - scope.left);
		right = (right - scope.left) * tmp - 1.0f;
		left = (left - scope.left) * tmp - 1.0f;

		tmp = 2.0f/(scope.top - scope.bottom);
		top = (top - scope.bottom) * tmp - 1.0f;
		bottom = (bottom - scope.bottom) * tmp - 1.0f;
		return *this;
	}

	static HPS_INLINE Rectangle FullScope() {
		return Rectangle(-1.0f, 1.0f, -1.0f, 1.0f);
	}

	static HPS_INLINE Rectangle InvalidScope() {
		return Rectangle(1.0f, -1.0f, 1.0f, -1.0f);
	}

	static HPS_INLINE Rectangle Zero() {
		return Rectangle(0, 0, 0, 0);
	}

};


HPS_INLINE IntRectangle Floor(Rectangle const & a) {
	IntRectangle temp;
	temp.left = Floor (a.left);
	temp.right = Floor (a.right);
	temp.bottom = Floor (a.bottom);
	temp.top = Floor (a.top);
	return temp;
}

HPS_INLINE Rectangle Expand(Rectangle const & a, Rectangle const & border) {
	Rectangle temp = a;
	return temp.Expand(border);
}

HPS_INLINE Rectangle Expand(Rectangle const & a, float border) {
	Rectangle temp = a;
	return temp.Expand(border);
}

HPS_INLINE Rectangle Contract(Rectangle const & a, int border) {
	Rectangle temp = a;
	return temp.Contract(border);
}

HPS_INLINE Rectangle Contract(Rectangle const & a, Rectangle const & border) {
	Rectangle temp = a;
	return temp.Contract(border);
}

HPS_INLINE Rectangle Intersect(Rectangle const & a, Rectangle const & b) {
	Rectangle temp = a;
	return temp.Intersect(b);
}

HPS_INLINE Rectangle Union(Rectangle const & a, Rectangle const & b) {
	Rectangle temp = a;
	return temp.Union(b);
}

HPS_INLINE Rectangle Inscribe_Scope(Rectangle const & a, Rectangle const & scope) {
	Rectangle temp = a;
	return temp.Inscribe_Scope(scope);
}

HPS_INLINE Rectangle Circumscribe_Scope(Rectangle const & a, Rectangle const & scope) {
	Rectangle temp = a;
	return temp.Circumscribe_Scope(scope);
}

HPS_INLINE	IntRectangle::IntRectangle(Rectangle const & that)
	: left ((int)that.left), right ((int)that.right), bottom ((int)that.bottom), top ((int)that.top) {}




template <typename F>
struct Sphere_3D;

template <typename F>
struct HPS_TEMPLATE_API Cuboid_3D {
	/*! The minimum point of this cuboid */
	Point_3D<F>		min;
	/*! The maximum point of this cuboid */
	Point_3D<F>		max;


	/*!
		Creates an invalid cuboid. 
	*/
	Cuboid_3D () : min (Limit_Point()), max (-Limit_Point()) {}

	
	/*!
		Creates a cuboid equal to another cuboid. 
		\param that The other cuboid
	*/
	template <typename D>
	explicit Cuboid_3D (Cuboid_3D<D> const & that) : min (Point_3D<F>(that.min)), max (Point_3D<F>(that.max)) {}


	/*!
		Creates a cuboid that will fit tightly around a sphere. 
		\param that The sphere to fit
	*/
	Cuboid_3D (Sphere_3D<F> const & that);

	/*!
		Creates a cuboid based on two points, which become opposite corners of the cuboid. 
		\param in_min The first point of the cuboid
		\param in_max The second point of the cuboid
	*/
	Cuboid_3D (Point_3D<F> const & in_min, Point_3D<F> const & in_max) : min (in_min), max (in_max) {}

	/*!
		Creates a cuboid based on an array of points. Only the minimum and maximum points are used, which become opposite corners of the cuboid. If count is 0, then an invalid cuboid is returned.
		\param count The size of points
		\param points An array of points
	*/
	Cuboid_3D (size_t count, Point_3D<F> const * points) {
		if (count == 0) {
			min = Limit_Point();
			max = -Limit_Point();
			return;
		}
		min = max = *points++;
		if (--count > 0)
			Merge(count, points);
	}

	/*!
		Creates a cuboid based on an array of points. Only the minimum and maximum points are used, which become opposite corners of the cuboid. If count is 0, then an invalid cuboid is returned.
		\param count The number of index values in indices
		\param indices the index values used to select points
		\param points An array of points
	*/
	template <typename T>
	Cuboid_3D (size_t count, T const * indices, Point_3D<F> const * points) {
		if (count == 0) {
			min = Limit_Point();
			max = -Limit_Point();
			return;
		}
		min = max = points[*indices++];
		if (--count > 0)
			Merge(count, indices, points);
	}

	/*!
		Creates a cuboid with the same dimensions as a rectangle.
		\param that The rectangle to create the cuboid from
	*/
	Cuboid_3D (Rectangle const & that) : min (Point_3D<F>(that.left, that.bottom, 0)), max (Point_3D<F>(that.right, that.top, 0)) {}

	/*!
		Tests whether this cuboid is valid. The cuboid is considered valid if the minimum point is less than or equal to the maximum point.
	*/
	HPS_INLINE bool		IsValid() const {
		return min.x <= max.x && min.y <= max.y && min.z <= max.z;
	}

	/*!
		Creates an invalid cuboid.
	*/
	static HPS_INLINE Cuboid_3D Invalid() {return Cuboid_3D ();};

	/*!
		Invalidates this cuboid.
	*/
	void Invalidate() {min = Limit_Point(); max = -Limit_Point();}

	/*!
		Determines if the maximum and minimum points of this cuboid are equal to the maximum and minimum points of another cuboid.
		\param cuboid The other cuboid
	*/
	HPS_INLINE bool		operator== (Cuboid_3D const & cuboid) const	{ return  (min == cuboid.min && max == cuboid.max); }
	
	/*!
		Determines if the maximum and minimum points of this cuboid are not equal to the maximum and minimum points of another cuboid.
		\param cuboid The other cuboid
	*/
	HPS_INLINE bool		operator!= (Cuboid_3D const & cuboid) const	{ return  !(*this == cuboid); }

	/*!
		Assigns the eight corners of the cuboid based on the points in the parameter array. The array must contain at least eight points.
		\param points The array which contains points
	*/
	HPS_INLINE void Generate_Cuboid_Points (Point_3D<F> * points) const {
		points[0] = Point_3D<F> (min.x, min.y, min.z);
		points[1] = Point_3D<F> (min.x, min.y, max.z);
		points[2] = Point_3D<F> (min.x, max.y, min.z);
		points[3] = Point_3D<F> (min.x, max.y, max.z);
		points[4] = Point_3D<F> (max.x, min.y, min.z);
		points[5] = Point_3D<F> (max.x, min.y, max.z);
		points[6] = Point_3D<F> (max.x, max.y, min.z);
		points[7] = Point_3D<F> (max.x, max.y, max.z);
	}

	/*!
		Returns the diagonal vector of the cuboid.
	*/
	HPS_INLINE Vector_3D<F> Diagonal() const { return max - min; }

	/*!
		Returns the volume of this cuboid.
	*/
	HPS_INLINE F Volume () const { return (max.x - min.x) * (max.y - min.y) * (max.z - min.z); }

	/*! 
		Determines whether this cuboid intersects with another cuboid.
	
		\param cuboid The other cuboid
	*/
	HPS_INLINE bool Intersecting (Cuboid_3D const & cuboid) const {
		return	max.x >= cuboid.min.x && min.x <= cuboid.max.x &&
				max.y >= cuboid.min.y && min.y <= cuboid.max.y &&
				max.z >= cuboid.min.z && min.z <= cuboid.max.z;
	}

	/*! 
		Determines whether this cuboid intersects with another cuboid. Allows for a tolerance value to be considered.
	
		\param cuboid The other cuboid
	*/
	HPS_INLINE bool Intersecting (Cuboid_3D const & cuboid, F const allowance) const {
		return	max.x + allowance >= cuboid.min.x && min.x - allowance <= cuboid.max.x &&
				max.y + allowance >= cuboid.min.y && min.y - allowance <= cuboid.max.y &&
				max.z + allowance >= cuboid.min.z && min.z - allowance <= cuboid.max.z;
	}

	/*!
		Returns true if this cuboid intersects with the parameter cuboid along a certain axis.
	
		\param dimension Must be either 0, 1, or 2. Corresponds to the X, Y, and Z axes.
		\param cuboid The cuboid to test against
	*/
	HPS_INLINE bool Intersecting (int dimension, Cuboid_3D const & cuboid) const {
		//ASSERT (0 <= dimension && dimension <= 2);
		return	max[dimension] >= cuboid.min[dimension] && min[dimension] <= cuboid.max[dimension];
	}

	/*!
		Returns true if this cuboid intersects with the parameter cuboid along a certain axis, and considers a tolerance value.
	
		\param dimension Must be 0, 1, or 2. Corresponds to the X, Y, and Z axes.
		\param cuboid The cuboid to test against
		\param allowance The tolerance value
	*/
	HPS_INLINE bool Intersecting (int dimension, Cuboid_3D const & cuboid, F const allowance) const {
		//ASSERT (0 <= dimension && dimension <= 2);
		return	max[dimension] + allowance >= cuboid.min[dimension] && min[dimension] - allowance <= cuboid.max[dimension];
	}

	/*!
		Determines whether this cuboid intersects with a ray.
	
		\param start The start point of the ray.
		\param direction The direction of the ray.
	*/
	HPS_INLINE bool Intersecting (Point_3D<F> const & start, Vector_3D<F> const & direction) const {
		return LineIntersecting(start, direction, true);
	}

	/*!
		Determines whether this cuboid intersects with an infinite line.
	
		\param point1 A point on the line.
		\param point2 A different point on the line.
	*/
	HPS_INLINE bool Intersecting (Point_3D<F> const & point1, Point_3D<F> const & point2) const {
		Vector_3D<F> const direction = point2 - point1;
		return LineIntersecting(point1, direction, false);
	}

	/*!
		Merges this cuboid with another cuboid. Only the smallest and largest values of the cuboids are retained.
	
		\param cuboid The other cuboid
	*/
	HPS_INLINE void Merge(Cuboid_3D const & cuboid) 	{
		Float::replace_if_smaller(min.x, cuboid.min.x);
		Float::replace_if_smaller(min.y, cuboid.min.y);
		Float::replace_if_smaller(min.z, cuboid.min.z);
		Float::replace_if_larger(max.x, cuboid.max.x);
		Float::replace_if_larger(max.y, cuboid.max.y);
		Float::replace_if_larger(max.z, cuboid.max.z);
	}

	/*!
		Merges this cuboid with another cuboid created from a sphere. Only the smallest and largest values of the cuboids are retained.
	
		\param cuboid The other cuboid
	*/
	HPS_INLINE void Merge(Sphere_3D<F> const & sphere) { Merge (Cuboid_3D (sphere)); }

	/*!
		Expands the cuboid to include a point.
	
		\param point The point to include
	*/
	HPS_INLINE void Merge(Point_3D<F> const & point) 	{
		Float::replace_if_smaller(min.x, point.x);
		Float::replace_if_smaller(min.y, point.y);
		Float::replace_if_smaller(min.z, point.z);
		Float::replace_if_larger(max.x, point.x);
		Float::replace_if_larger(max.y, point.y);
		Float::replace_if_larger(max.z, point.z);
	}

	/*!
		Expands this cuboid to include a set of points.
	
		\param count The number of points in points
		\param points The array of points
	*/
	void Merge(size_t count, Point_3D<F> const * points) 	{
		while (count > 1) {
			merge2(points[0], points[1]);
			points += 2;
			count -= 2;
		}

		if (count > 0)
			Merge(*points);
	}

	/*!
		Expands this cuboid to include a set of indexed points.
	
		\param count The number of index values in indices
		\param indices the index values used to select points
		\param points The array of points
	*/
	template <typename T>
	void Merge(size_t count, T const * indices, Point_3D<F> const * points) 	{
		while (count > 1) {
			T		i1 = *indices++;
			T		i2 = *indices++;
			merge2(points[i1], points[i2]);
			count -= 2;
		}

		if (count > 0)
			Merge(points[*indices]);
	}

	/*!
		Returns true if the cuboid completely contains the parameter cuboid.
	
		\param contained The other cuboid
	*/
	HPS_INLINE bool Contains(Cuboid_3D const & contained) const {
		return (contained.min.x >= min.x &&
				contained.min.y >= min.y &&
				contained.min.z >= min.z &&
				contained.max.x <= max.x &&
				contained.max.y <= max.y &&
				contained.max.z <= max.z);
	}

	/*!
		Returns true if the cuboid completely contains a cuboid based on the  parameter points.
	
		\param contained The points to compare against
	*/
	HPS_INLINE bool Contains(Point_3D<F> const & contained) const {
		return (contained.x >= min.x &&
				contained.y >= min.y &&
				contained.z >= min.z &&
				contained.x <= max.x &&
				contained.y <= max.y &&
				contained.z <= max.z);
	}

	/*!
		Returns true if the cuboid completely contains a cuboid based on the  parameter points, with a tolerance value.
	
		\param contained The points to compare against
		\param epsilon The tolerance value
	*/
	HPS_INLINE bool Contains(Point_3D<F> const & contained, F epsilon) const {
		return (contained.x >= min.x - epsilon &&
				contained.y >= min.y - epsilon &&
				contained.z >= min.z - epsilon &&
				contained.x <= max.x + epsilon &&
				contained.y <= max.y + epsilon &&
				contained.z <= max.z + epsilon);
	}

	/*!
		Replaces this cuboid with the intersection of this cuboid and the parameter cuboid.
	
		\param cuboid The cuboid to compute intersection against
	*/
	HPS_INLINE Cuboid_3D & Intersect(Cuboid_3D const & cuboid)  {
		Float::replace_if_larger(min.x, cuboid.min.x);
		Float::replace_if_larger(min.y, cuboid.min.y);
		Float::replace_if_larger(min.z, cuboid.min.z);
		Float::replace_if_smaller(max.x, cuboid.max.x);
		Float::replace_if_smaller(max.y, cuboid.max.y);
		Float::replace_if_smaller(max.z, cuboid.max.z);
		return *this;
	}

	/*!
		Replaces this cuboid with the union of this cuboid and the parameter cuboid.
	
		\param cuboid The cuboid to compute union against
	*/
	HPS_INLINE Cuboid_3D & Union(Cuboid_3D const & cuboid)  {
		Float::replace_if_smaller(min.x, cuboid.min.x);
		Float::replace_if_smaller(min.y, cuboid.min.y);
		Float::replace_if_smaller(min.z, cuboid.min.z);
		Float::replace_if_larger(max.x, cuboid.max.x);
		Float::replace_if_larger(max.y, cuboid.max.y);
		Float::replace_if_larger(max.z, cuboid.max.z);
		return *this;
	}

	/*!
		Expands both corners of this cuboid.
	
		\param border Amount to expand
	*/
	HPS_INLINE Cuboid_3D & Expand(F border)  {
		Vector_3D<F>		delta (border, border, border);
		min -= delta;
		max += delta;
		return *this;
	}

	/*!
		Contracts both corners of this cuboid.
	
		\param border Amount to contract
	*/
	HPS_INLINE Cuboid_3D & Contract(F border)  {
		Vector_3D<F>		delta (border, border, border);
		min += delta;
		max -= delta;
		return *this;
	}

private:
	void merge2(Point_3D<F> const & p1, Point_3D<F> const & p2) 	{
		if (p1.x > p2.x) {
			Float::replace_if_smaller(min.x, p2.x);
			Float::replace_if_larger(max.x, p1.x);
		}
		else {
			Float::replace_if_smaller(min.x, p1.x);
			Float::replace_if_larger(max.x, p2.x);
		}

		if (p1.y > p2.y) {
			Float::replace_if_smaller(min.y, p2.y);
			Float::replace_if_larger(max.y, p1.y);
		}
		else {
			Float::replace_if_smaller(min.y, p1.y);
			Float::replace_if_larger(max.y, p2.y);
		}

		if (p1.z > p2.z) {
			Float::replace_if_smaller(min.z, p2.z);
			Float::replace_if_larger(max.z, p1.z);
		}
		else {
			Float::replace_if_smaller(min.z, p1.z);
			Float::replace_if_larger(max.z, p2.z);
		}
	}

	HPS_INLINE static Point_3D<F> Limit_Point () {
		F const		x = std::numeric_limits<F>::max();
		return Point_3D<F> (x, x, x);
	}

	bool LineIntersecting (Point_3D<F> const & start, Vector_3D<F> const & direction, bool is_ray) const;
};

typedef	Cuboid_3D<float>	SimpleCuboid;
typedef	Cuboid_3D<double>	DSimpleCuboid;


template <typename F>
HPS_INLINE Cuboid_3D<F> Intersect(Cuboid_3D<F> const & a, Cuboid_3D<F> const & b) {
	Cuboid_3D<F> temp = a;
	return temp.Intersect(b);
}

template <typename F>
HPS_INLINE Cuboid_3D<F> Union(Cuboid_3D<F> const & a, Cuboid_3D<F> const & b) {
	Cuboid_3D<F> temp = a;
	return temp.Union(b);
}

template <typename F>
HPS_INLINE Cuboid_3D<F> Expand(Cuboid_3D<F> const & a, F border) {
	Cuboid_3D<F> temp = a;
	return temp.Expand(border);
}

template <typename F>
HPS_INLINE Cuboid_3D<F> Contract(Cuboid_3D<F> const & a, F border) {
	Cuboid_3D<F> temp = a;
	return temp.Contract(border);
}



template <typename F>
struct HPS_TEMPLATE_API Sphere_3D {
	Point_3D<F>			center;
	F					radius;

	Sphere_3D () : center(Point_3D<F>(0, 0, 0)), radius(-1) {}

	template <typename D>
		explicit Sphere_3D (Sphere_3D<D> const & that) : center(Point_3D<F>(that.center)), radius(F(that.radius)) {}

	Sphere_3D (Cuboid_3D<F> const & cuboid) {
		if (cuboid.max.x < cuboid.min.x || cuboid.max.y < cuboid.min.y || cuboid.max.z < cuboid.min.z)
			*this = Invalid();
		else {
			center = Midpoint(cuboid.min, cuboid.max);
			radius = F(0.5 * cuboid.Diagonal().Length());
		}
	}

	Sphere_3D (Point_3D<F> const & starting_center, F in_radius = 0) : center(starting_center), radius(in_radius) {}

	Sphere_3D (size_t count, Point_3D<F> const * points) : radius(0.0f) {
		Cuboid_3D<F>	cuboid(count, points);
		center = Midpoint(cuboid.min, cuboid.max);
		Engulf (count, points);
	}

	template <typename T>
	Sphere_3D (size_t count, T const * indices, Point_3D<F> const * points) : radius(0.0f) {
		Cuboid_3D<F>	cuboid(count, indices, points);
		center = Midpoint(cuboid.min, cuboid.max);
		Engulf (count, indices, points);
	}

	Sphere_3D (size_t count, Point_3D<F> const * points, Point_3D<F> const & starting_center)
		: center(starting_center), radius(0) {
		Engulf (count, points);
	}

	template <typename T>
	Sphere_3D (size_t count, T const * indices, Point_3D<F> const * points, Point_3D<F> const & starting_center)
		: center(starting_center), radius(0) {
		Engulf (count, indices, points);
	}

	HPS_INLINE bool		IsValid() const {
		return radius >= 0;
	}

	static HPS_INLINE Sphere_3D Invalid() {return Sphere_3D(Point_3D<F>(0,0,0), -1);};

	void Invalidate() {radius = -1;}

	HPS_INLINE bool	operator== (Sphere_3D const & sphere) const	{ return  (center == sphere.center && radius == sphere.radius); }
	HPS_INLINE bool	operator!= (Sphere_3D const & sphere) const	{ return  !(*this == sphere); }

	HPS_INLINE F	Volume () const { return F((4.0 / 3.0 * PI) * radius * radius * radius); }

	HPS_INLINE void Merge(Point_3D<F> const & point) {
		Vector_3D<F>	dir = point - center;
		F				distance = (F)dir.Length();

		if (distance > radius) {
			F	t = F(0.5) * (distance - radius);
			center += t * dir.Normalize();
			radius += t;
		}
	}

	HPS_INLINE void Merge(size_t count, Point_3D<F> const * points) {
		F radius_squared = radius * radius;
		for (size_t i = 0; i < count; ++i) {
			Vector_3D<F>	dir = *points - center;
			F				distance_squared = (F)dir.LengthSquared();

			if (distance_squared > radius_squared) {
				F	distance = sqrt(distance_squared);
				F	t = F(0.5) * ( distance - radius);
				center += t * (distance > Float_Traits<F>::Epsilon() ? dir / distance : Vector_3D<F>::Zero());
				radius += t;
				radius_squared = radius * radius;
			}

			++points;
		}
	}

	HPS_INLINE void	Merge (Sphere_3D const & sphere) {
		Vector_3D<F>	dir = sphere.center - center;
		F				distance = (F)dir.Length();

		if (distance + sphere.radius > radius) {
			if (distance + radius > sphere.radius) {
				F		t = F(0.5 * (sphere.radius + distance - radius));
				center += t * dir.Normalize();
				radius += t;
			}
			else {
				center = sphere.center;
				radius = sphere.radius;
			}
		}
	}

	HPS_INLINE void	Merge (Cuboid_3D<F> const & cuboid)	{ Merge (Sphere_3D (cuboid)); }

private:
	// Engulf expands the sphere to include the points, but does not change the center as Merge does
	HPS_INLINE void Engulf (size_t count, Point_3D<F> const * points) {
		double		rsq = radius * radius;
		for (size_t i = 0; i < count; ++i) {
			double	dsq = (*points++ - center).LengthSquared();
			if (dsq > rsq)
				rsq = dsq;
		}
		radius = (F)sqrt(rsq);
	}

	template <typename T>
	HPS_INLINE void Engulf (size_t count, T const * indices, Point_3D<F> const * points) {
		double		rsq = radius * radius;
		for (size_t i = 0; i < count; ++i) {
			double	dsq = (points[*indices++] - center).LengthSquared();
			if (dsq > rsq)
				rsq = dsq;
		}
		radius = (F)sqrt(rsq);
	}
};

typedef	Sphere_3D<float>	SimpleSphere;
typedef	Sphere_3D<double>	DSimpleSphere;


template <typename F>
HPS_INLINE	Cuboid_3D<F>::Cuboid_3D(Sphere_3D<F> const & sphere) {
	if (sphere.radius < 0)
		*this = Invalid();
	else {
		min = Point_3D<F>(sphere.center.x - sphere.radius, sphere.center.y - sphere.radius, sphere.center.z - sphere.radius);
		max = Point_3D<F>(sphere.center.x + sphere.radius, sphere.center.y + sphere.radius, sphere.center.z + sphere.radius);
	}
}




class RGB24Color;
class RGBA32Color;
class RGBAS32Color;
class RGBAColor;

class HPS_API RGBColor {
public:
	float	red;
	float	green;
	float	blue;

	HPS_INLINE RGBColor () {}
	HPS_INLINE RGBColor (float r, float g, float b) : red (r), green (g), blue (b) {}
	explicit HPS_INLINE RGBColor (RGB24Color const & c24);
	explicit HPS_INLINE RGBColor (float gray) : red (gray), green (gray), blue (gray) {}
	explicit HPS_INLINE RGBColor (RGBAS32Color const & c32);
	explicit HPS_INLINE RGBColor (RGBA32Color const & c32);
	explicit HPS_INLINE RGBColor (RGBAColor const & c);

	HPS_INLINE bool		IsGray() const {return (red == green && green == blue);}
	HPS_INLINE float	Gray() const { return  0.3125f * red  +  0.5000f * green  +  0.1875f * blue; }
	float Distance(RGBColor const & other_color) const;
	HPS_INLINE bool		IsValid() const {
		return (Float::extract_sign_bit(red) | Float::extract_sign_bit(green) | Float::extract_sign_bit(blue)) == 0;
	}

	HPS_INLINE bool	operator== (RGBColor const & c) const	{ return  red == c.red && green == c.green && blue == c.blue; }
	HPS_INLINE bool	operator!= (RGBColor const & c) const	{ return  !(*this == c); }

	HPS_INLINE bool	Equals(RGBColor const & c, int in_tolerance = 32) const
		{ return  Float::Equals(red, c.red, in_tolerance) && Float::Equals(green, c.green, in_tolerance) && Float::Equals(blue, c.blue, in_tolerance); }

	HPS_INLINE RGBColor &		operator*= (RGBColor const & c)	{ red *= c.red; green *= c.green; blue *= c.blue;  return *this; }
	HPS_INLINE RGBColor &		operator+= (RGBColor const & c)	{ red += c.red; green += c.green; blue += c.blue;  return *this; }
	HPS_INLINE RGBColor &		operator-= (RGBColor const & c)	{ red -= c.red; green -= c.green; blue -= c.blue;  return *this; }
	HPS_INLINE RGBColor const	operator* (RGBColor const & c) const { return RGBColor (red * c.red, green * c.green, blue * c.blue); }
	HPS_INLINE RGBColor const	operator+ (RGBColor const & c) const { return RGBColor (red + c.red, green + c.green, blue + c.blue); }
	HPS_INLINE RGBColor const	operator- (RGBColor const & c) const { return RGBColor (red - c.red, green - c.green, blue - c.blue); }

	HPS_INLINE RGBColor &		operator*= (float s) { red *= s; green *= s; blue *= s;  return *this; }
	HPS_INLINE RGBColor &		operator/= (float s) { return operator*= (1.0f / s); }
	HPS_INLINE RGBColor &		operator+= (float s) { red += s; green += s; blue += s;  return *this; }
	HPS_INLINE RGBColor &		operator-= (float s) { red -= s; green -= s; blue -= s;  return *this; }
	HPS_INLINE RGBColor const	operator* (float s) const { return RGBColor (red * s, green * s, blue * s); }
	HPS_INLINE RGBColor const	operator/ (float s) const { return operator* (1.0f / s); }
	HPS_INLINE RGBColor const	operator+ (float s) const { return RGBColor (red + s, green + s, blue + s); }
	HPS_INLINE RGBColor const	operator- (float s) const { return RGBColor (red - s, green - s, blue - s); }

	static HPS_INLINE RGBColor Black() {return RGBColor (0, 0, 0);};
	static HPS_INLINE RGBColor White() {return RGBColor (1, 1, 1);};
	static HPS_INLINE RGBColor Invalid() {return RGBColor (-1, -1, -1);};

	void ShowHLS(float & out_hue, float & out_lightness, float & out_saturation) const;
	void ShowHSV(float & out_hue, float & out_saturation, float & out_value) const;
	void ShowHIC(float & out_hue, float & out_intensity, float & out_chromaticity) const;

	static RGBColor HLS(float in_hue, float in_lightness, float in_saturation);
	static RGBColor HSV(float in_hue, float in_saturation, float in_value);
	static RGBColor HIC(float in_hue, float in_intensity, float in_chromaticity);
};

HPS_INLINE	RGBColor const	operator* (float s, RGBColor const & v) { return RGBColor (s * v.red, s * v.green, s * v.blue); }
HPS_INLINE	RGBColor const	operator+ (float s, RGBColor const & v) { return RGBColor (s + v.red, s + v.green, s + v.blue); }
HPS_INLINE	RGBColor const	operator- (float s, RGBColor const & v) { return RGBColor (s - v.red, s - v.green, s - v.blue); }


class HPS_API RGBAColor {
public:
	
	float	red; /*!< Red component of this color object, from 0.0 to 1.0 */
	float	green; /*!< Green component of this color object, from 0.0 to 1.0 */
	float	blue; /*!< Blue component of this color object, from 0.0 to 1.0 */
	float	alpha; /*!< Alpha component of this color object, from 0.0 to 1.0 */

	HPS_INLINE RGBAColor () {}
	explicit HPS_INLINE RGBAColor (float gray, float a = 1) : red (gray), green (gray), blue (gray), alpha (a) {}
	HPS_INLINE RGBAColor (float r, float g, float b, float a = 1) : red (r), green (g), blue (b), alpha (a) {}

	HPS_INLINE RGBAColor (RGBColor const & c) {
		memcpy(this, &c, sizeof(RGBColor)); //-V512
		alpha = 1.0f;
		Float::apply_sign_bit(alpha, Float::extract_sign_bit(c.red) | Float::extract_sign_bit(c.green) | Float::extract_sign_bit(c.blue));
	}
	HPS_INLINE RGBAColor (RGBColor const & c, float a) {
		memcpy(this, &c, sizeof(RGBColor));
		memcpy(&alpha, &a, sizeof(float));
		Float::apply_sign_bit(alpha, Float::extract_sign_bit(c.red) | Float::extract_sign_bit(c.green) | Float::extract_sign_bit(c.blue));
	}
	explicit HPS_INLINE RGBAColor (RGBA32Color const & c32);
	explicit HPS_INLINE RGBAColor (RGBAS32Color const & c32);

	HPS_INLINE bool		IsGray() const {return (red == green && green == blue);}
	HPS_INLINE float	Gray() const { return  0.3125f * red  +  0.5000f * green  +  0.1875f * blue; }
	HPS_INLINE bool		IsValid() const {
		return (Float::extract_sign_bit(red) | Float::extract_sign_bit(green) | Float::extract_sign_bit(blue) | Float::extract_sign_bit(alpha)) == 0;
	}

	/*!
		Determines RGBA equivalency between this object and argument.

		\param c The color object to test against
		\return true if the objects are equivalent, false otherwise
	*/
	HPS_INLINE bool	operator== (RGBAColor const & c) const		{ return  red == c.red && green == c.green && blue == c.blue && alpha == c.alpha; }

	/*!
	Determines RGBA non-equivalency between this object and argument.

	\param c The color object to test against
	\return true if the objects are not equivalent, false otherwise
	*/
	HPS_INLINE bool	operator!= (RGBAColor const & c) const		{ return  !(*this == c); }

	HPS_INLINE bool	Equals(RGBAColor const & c, int in_tolerance = 32) const {
		return Float::Equals(red, c.red, in_tolerance) && Float::Equals(green, c.green, in_tolerance) &&
				Float::Equals(blue, c.blue, in_tolerance) && Float::Equals(alpha, c.alpha, in_tolerance);
	}

	HPS_INLINE RGBAColor &		operator*= (RGBAColor const & c)	{ red *= c.red; green *= c.green; blue *= c.blue; alpha *= c.alpha; return *this; }
	HPS_INLINE RGBAColor &		operator+= (RGBAColor const & c)	{ red += c.red; green += c.green; blue += c.blue; alpha += c.alpha; return *this; }
	HPS_INLINE RGBAColor &		operator-= (RGBAColor const & c)	{ red -= c.red; green -= c.green; blue -= c.blue; alpha -= c.alpha; return *this; }
	HPS_INLINE RGBAColor const	operator* (RGBAColor const & c) const { return RGBAColor (red * c.red, green * c.green, blue * c.blue, alpha * c.alpha); }
	HPS_INLINE RGBAColor const	operator+ (RGBAColor const & c) const { return RGBAColor (red + c.red, green + c.green, blue + c.blue, alpha + c.alpha); }
	HPS_INLINE RGBAColor const	operator- (RGBAColor const & c) const { return RGBAColor (red - c.red, green - c.green, blue - c.blue, alpha - c.alpha); }

	HPS_INLINE RGBAColor &		operator*= (float s) { red *= s; green *= s; blue *= s; alpha *= s; return *this; }
	HPS_INLINE RGBAColor &		operator/= (float s) { return operator*= (1.0f / s); }
	HPS_INLINE RGBAColor &		operator+= (float s) { red += s; green += s; blue += s; alpha += s; return *this; }
	HPS_INLINE RGBAColor &		operator-= (float s) { red -= s; green -= s; blue -= s; alpha -= s; return *this; }
	HPS_INLINE RGBAColor const	operator* (float s) const { return RGBAColor (red * s, green * s, blue * s, alpha * s); }
	HPS_INLINE RGBAColor const	operator/ (float s) const { return operator* (1.0f / s); }
	HPS_INLINE RGBAColor const	operator+ (float s) const { return RGBAColor (red + s, green + s, blue + s, alpha + s); }
	HPS_INLINE RGBAColor const	operator- (float s) const { return RGBAColor (red - s, green - s, blue - s, alpha - s); }

	HPS_INLINE RGBAColor &		operator*= (RGBColor const & c)	{ red *= c.red; green *= c.green; blue *= c.blue; return *this; }
	HPS_INLINE RGBAColor &		operator+= (RGBColor const & c)	{ red += c.red; green += c.green; blue += c.blue; return *this; }
	HPS_INLINE RGBAColor &		operator-= (RGBColor const & c)	{ red -= c.red; green -= c.green; blue -= c.blue; return *this; }
	HPS_INLINE RGBAColor const	operator* (RGBColor const & c) const { return RGBAColor (red * c.red, green * c.green, blue * c.blue, alpha); }
	HPS_INLINE RGBAColor const	operator+ (RGBColor const & c) const { return RGBAColor (red + c.red, green + c.green, blue + c.blue, alpha); }
	HPS_INLINE RGBAColor const	operator- (RGBColor const & c) const { return RGBAColor (red - c.red, green - c.green, blue - c.blue, alpha); }

	static HPS_INLINE RGBAColor Black() {return RGBAColor (0, 0, 0, 1);};
	static HPS_INLINE RGBAColor White() {return RGBAColor (1, 1, 1, 1);};
	static HPS_INLINE RGBAColor Nothing() {return RGBAColor (0, 0, 0, 0);};
	static HPS_INLINE RGBAColor Invalid() {return RGBAColor (-1, -1, -1, -1);};
};

HPS_INLINE	RGBAColor const	operator* (float s, RGBAColor const & v) { return RGBAColor (s * v.red, s * v.green, s * v.blue, s * v.alpha); }
HPS_INLINE	RGBAColor const	operator+ (float s, RGBAColor const & v) { return RGBAColor (s + v.red, s + v.green, s + v.blue, s + v.alpha); }
HPS_INLINE	RGBAColor const	operator- (float s, RGBAColor const & v) { return RGBAColor (s - v.red, s - v.green, s - v.blue, s - v.alpha); }



struct DirectRGBColor {
public:
	enum Order {
		Order_ABGR,
		Order_RGBA,
		Order_BGRA
	};

#ifdef _MSC_VER
	HPS_INLINE static Order Preferred_Order () {return Order_BGRA;}
	unsigned char	b, g, r, a;
#endif

#ifdef __linux__
	HPS_INLINE static Order Preferred_Order () {return Order_RGBA;}
	unsigned char	r, g, b, a;
#endif

#ifdef __APPLE_CC__
	HPS_INLINE static Order Preferred_Order () {return Order_RGBA;}
	unsigned char	r, g, b, a;
#endif
};



class RGBAS32Color : public DirectRGBColor {
public:

	HPS_INLINE RGBAS32Color () /* : DirectRGBColor() */ {}
	explicit HPS_INLINE RGBAS32Color (unsigned char gray, unsigned char aa = 255) {
		r = gray;
		g = gray;
		b = gray;
		a = aa;
	}
	HPS_INLINE RGBAS32Color (unsigned char rr, unsigned char gg, unsigned char bb, unsigned char aa = 255) {
		r = rr;
		g = gg;
		b = bb;
		a = aa;
	}
	HPS_INLINE RGBAS32Color (DirectRGBColor const & c) : DirectRGBColor(c) {};

	explicit HPS_INLINE RGBAS32Color (RGBColor const & c)
	{
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = 255;
	}

	HPS_INLINE RGBAS32Color (RGB24Color const & c);

	HPS_INLINE RGBAS32Color (RGBA32Color const & c);

	HPS_INLINE RGBAS32Color (RGBColor const & c, float alpha)
	{
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = Float::unit_to_byte(alpha);
	}
	HPS_INLINE RGBAS32Color (RGBColor const & c, unsigned char aa)
	{
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = aa;
	}
	explicit HPS_INLINE RGBAS32Color (RGBAColor const & c)
	{
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = Float::unit_to_byte(c.alpha);
	}
	HPS_INLINE RGBAS32Color (RGBAColor const & c, unsigned char mix)
	{
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = Float::unit_to_byte_scaled(c.alpha, mix);
	}

	HPS_INLINE bool				IsGray() const {return (r == g && g == b);}
	HPS_INLINE unsigned char	Gray() const { return (unsigned char)(0.3125f * (float)r  +  0.5000f * (float)g  +  0.1875f * (float)b); }
	HPS_INLINE bool				IsValid() const { return ((r | g | b | a) != 0); }

	HPS_INLINE bool	operator== (RGBAS32Color const & c) const	{ return (r == c.r && g == c.g && b == c.b && a == c.a); }
	HPS_INLINE bool	operator!= (RGBAS32Color const & c) const	{ return !(*this == c); }

	static HPS_INLINE RGBAS32Color Black() {return RGBAS32Color (0, 0, 0, 255);};
	static HPS_INLINE RGBAS32Color White() {return RGBAS32Color (255, 255, 255, 255);};
	static HPS_INLINE RGBAS32Color Invalid() {return RGBAS32Color (0, 0, 0, 0);};

	static	HPS_INLINE unsigned char Opaque_Alpha () {return 0xFF;}
};

class RGBA32Color {
public:
	unsigned char	r;
	unsigned char	g;
	unsigned char	b;
	unsigned char	a;

	HPS_INLINE RGBA32Color () {}
	explicit HPS_INLINE RGBA32Color (unsigned char gray, unsigned char aa = 255)
		: r (gray), g (gray), b (gray), a (aa) {}
	HPS_INLINE RGBA32Color (unsigned char rr, unsigned char gg, unsigned char bb, unsigned char aa = 255)
		: r (rr), g (gg), b (bb), a (aa) {}
	HPS_INLINE RGBA32Color (RGBAS32Color const & c32)
		: r (c32.r), g (c32.g), b (c32.b), a (c32.a) {}
	explicit HPS_INLINE	RGBA32Color (RGBColor const & c) {
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = 255;
	}
	HPS_INLINE RGBA32Color (RGBColor const & c, float alpha) {
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = Float::unit_to_byte(alpha);
	}
	HPS_INLINE RGBA32Color (RGBColor const & c, unsigned char aa) {
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = aa;
	}
	explicit HPS_INLINE RGBA32Color (RGBAColor const & c) {
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = Float::unit_to_byte(c.alpha);
	}
	HPS_INLINE RGBA32Color (RGBAColor const & c, unsigned char mix) {
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
		a = Float::unit_to_byte_scaled(c.alpha, mix);
	}

	HPS_INLINE bool				IsGray() const {return (r == g && g == b);}
	HPS_INLINE unsigned char	Gray() const { return (unsigned char)(0.3125f * (float)r  +  0.5000f * (float)g  +  0.1875f * (float)b); }

	HPS_INLINE bool	operator== (RGBA32Color const & c) const { return (r == c.r && g == c.g && b == c.b && a == c.a); }
	HPS_INLINE bool	operator!= (RGBA32Color const & c) const { return  !(*this == c); }

	static HPS_INLINE RGBA32Color Black() {return RGBA32Color (0, 0, 0, 255);};
	static HPS_INLINE RGBA32Color White() {return RGBA32Color (255, 255, 255, 255);};

	static	HPS_INLINE unsigned char Opaque_Alpha () {return 0xFF;}
};


class RGB24Color
{
public:
	unsigned char r;
	unsigned char g;
	unsigned char b;

	HPS_INLINE RGB24Color () {}
	explicit HPS_INLINE RGB24Color (unsigned char gray)
		: r (gray), g (gray), b (gray) {}
	HPS_INLINE RGB24Color (unsigned char rr, unsigned char gg, unsigned char bb)
		: r (rr), g (gg), b (bb) {}
	explicit HPS_INLINE RGB24Color (RGBColor const & c) {
		r = Float::unit_to_byte(c.red);
		g = Float::unit_to_byte(c.green);
		b = Float::unit_to_byte(c.blue);
	}

	HPS_INLINE bool				IsGray() const {return (r == g && g == b);}
	HPS_INLINE unsigned char	Gray() const { return (unsigned char)(0.3125f * (float)r  +  0.5000f * (float)g  +  0.1875f * (float)b); }

	HPS_INLINE bool	operator== (RGB24Color const & c) const { return (r == c.r && g == c.g && b == c.b); }
	HPS_INLINE bool	operator!= (RGB24Color const & c) const { return  !(*this == c); }
};

HPS_INLINE RGBColor::RGBColor (RGBAS32Color const & c32) {
	red = Float::C2F(c32.r);
	green = Float::C2F(c32.g);
	blue = Float::C2F(c32.b);
}

HPS_INLINE RGBColor::RGBColor (RGBA32Color const & c32) {
	red = Float::C2F(c32.r);
	green = Float::C2F(c32.g);
	blue = Float::C2F(c32.b);
}

HPS_INLINE RGBColor::RGBColor (RGBAColor const & c) {
	red = c.red;
	green = c.green;
	blue = c.blue;
}

HPS_INLINE RGBColor::RGBColor (RGB24Color const & c24) {
	red = Float::C2F(c24.r);
	green = Float::C2F(c24.g);
	blue = Float::C2F(c24.b);
}

HPS_INLINE RGBAS32Color::RGBAS32Color (RGB24Color const & c)
{
	r = c.r;
	g = c.g;
	b = c.b;
	a = 255;
}

HPS_INLINE RGBAS32Color::RGBAS32Color (RGBA32Color const & c)
{
	r = c.r;
	g = c.g;
	b = c.b;
	a = c.a;
}

HPS_INLINE RGBAColor::RGBAColor (RGBAS32Color const & c32) {
	red = Float::C2F(c32.r);
	green = Float::C2F(c32.g);
	blue = Float::C2F(c32.b);
	alpha = Float::C2F(c32.a);
}

HPS_INLINE RGBAColor::RGBAColor (RGBA32Color const & c32) {
	red = Float::C2F(c32.r);
	green = Float::C2F(c32.g);
	blue = Float::C2F(c32.b);
	alpha = Float::C2F(c32.a);
}

HPS_INLINE RGBColor Modulate(RGBColor const & a, RGBColor const & b) {
	return RGBColor(a.red * b.red, a.green * b.green, a.blue * b.blue);
}



HPS_INLINE RGBColor Interpolate(RGBColor const & a, RGBColor const & b, float t) {
	return RGBColor(a.red + (b.red - a.red) * t, a.green + (b.green - a.green) * t, a.blue + (b.blue - a.blue) * t);
}

HPS_INLINE RGBAColor Interpolate(RGBAColor const & a, RGBAColor const & b, float t) {
	return RGBAColor(a.red + (b.red - a.red) * t, a.green + (b.green - a.green) * t, a.blue + (b.blue - a.blue) * t, a.alpha + (b.alpha - a.alpha) * t);
}

HPS_INLINE RGBAS32Color Interpolate(RGBAS32Color const & a, RGBAS32Color const & b, float t) {
	return RGBAS32Color(
		(unsigned char)(a.r + ((float)b.r - (float)a.r) * t),
		(unsigned char)(a.g + ((float)b.g - (float)a.g) * t),
		(unsigned char)(a.b + ((float)b.b - (float)a.b) * t),
		(unsigned char)(a.a + ((float)b.a - (float)a.a) * t));
}

HPS_INLINE RGBA32Color Interpolate(RGBA32Color const & a, RGBA32Color const & b, float t) {
	return RGBA32Color(
		(unsigned char)(a.r + ((float)b.r - (float)a.r) * t),
		(unsigned char)(a.g + ((float)b.g - (float)a.g) * t),
		(unsigned char)(a.b + ((float)b.b - (float)a.b) * t),
		(unsigned char)(a.a + ((float)b.a - (float)a.a) * t));
}

HPS_INLINE RGB24Color Interpolate(RGB24Color const & a, RGB24Color const & b, float t) {
	return RGB24Color(
		(unsigned char)(a.r + ((float)b.r - (float)a.r) * t),
		(unsigned char)(a.g + ((float)b.g - (float)a.g) * t),
		(unsigned char)(a.b + ((float)b.b - (float)a.b) * t));
}



class HPS_API Quaternion {
public:
	float		w;
	float		x;
	float		y;
	float		z;

	Quaternion() : w(0.0f), x(0.0f), y(0.0f), z(0.0f) { }

	Quaternion(float in_w, float in_x, float in_y, float in_z) : w(in_w), x(in_x), y(in_y), z(in_z) { }

	Quaternion(Quaternion const & that) : w(that.w), x(that.x), y(that.y), z(that.z) { }

	Quaternion const & Normalize() {
		float mag = Norm();

		if (mag > 0) {
			w /= mag;
			x /= mag;
			y /= mag;
			z /= mag;
		}
		return *this;
	}


	Quaternion operator* (Quaternion const & in_right) const {
		return Quaternion(w*in_right.w - x*in_right.x - y*in_right.y - z*in_right.z,
						y*in_right.z - z*in_right.y + w*in_right.x + x*in_right.w,
						z*in_right.x - x*in_right.z + w*in_right.y + y*in_right.w,
						x*in_right.y - y*in_right.x + w*in_right.z + z*in_right.w);
	}

	Quaternion operator* (float in_right) const {
		return Quaternion(w*in_right, x*in_right, y*in_right, z*in_right);
	}

	friend Quaternion operator* (float in_left, Quaternion const & in_right) {
		return Quaternion(in_left*in_right.w, in_left*in_right.x, in_left*in_right.y, in_left*in_right.z);
	}

	Quaternion operator/ (float in_right) const {
		return Quaternion(w/in_right, x/in_right, y/in_right, z/in_right);
	}

	Quaternion operator- (Quaternion const & in_right) const {
		return Quaternion(w-in_right.w, x-in_right.x, y-in_right.y, z-in_right.z);
	}

	Quaternion operator+ (Quaternion const & in_right) const {
		return Quaternion(w+in_right.w, x+in_right.x, y+in_right.y, z+in_right.z);
	}

	inline float Norm() const {
		return static_cast<float>(sqrt(w*w + x*x + y*y + z*z));
	}


	Quaternion Log() const {
		Quaternion	ret;
		float		mag_q = Norm();
		float		mag_V = static_cast<float>(sqrt(x*x + y*y + z*z));

		ret.w = static_cast<float>(log(mag_q));

		if (mag_V > 0) {
			float scale = static_cast<float>(acos(w / mag_q) / mag_V);

			ret.x = x * scale;
			ret.y = y * scale;
			ret.z = z * scale;
		}
		else
			ret.x = ret.y = ret.z = 0;

		return ret;
	}

	Quaternion Exp() const {
		Quaternion	ret;
		float		ea = static_cast<float>(exp(w));
		float		mag_V = static_cast<float>(sqrt(x*x + y*y + z*z));
		float		scale = ea * sin(mag_V) / mag_V;

		ret.w = ea * cos(mag_V);
		ret.x = scale * x;
		ret.y = scale * y;
		ret.z = scale * z;

		return ret;
	}

	Quaternion Lerp(Quaternion const & in_right, float in_fraction) const {
		Quaternion	ret = *this + in_fraction * (in_right - *this);
		return ret.Normalize();
	}


	Quaternion Slerp(Quaternion const & in_right, float in_fraction, bool in_shortest_path_only = true) const {
		Quaternion	q3;
		float		dot = x*in_right.x + y*in_right.y + z*in_right.z + w*in_right.w;

		if (in_shortest_path_only && dot < 0) {
			dot = -dot;
			q3 = -1 * in_right;
		}
		else
			q3 = in_right;

		if (dot > -0.95f && dot < 0.95f) {
			float	 angle = static_cast<float>(acos(dot));
			float	 sina = static_cast<float>(sin(angle));
			float	 sinat = static_cast<float>(sin(angle*in_fraction));
			float	 sinaomt = static_cast<float>(sin(angle*(1-in_fraction)));

			return (*this * sinaomt + q3 * sinat) / sina;
		}
		else	//if the angle is small, we use linear interpolation
			return Lerp(q3, in_fraction);
	}


	/*
	Spherical cubic interpolation between two Quaternions
	\param in_right The Quaternion for interpolation.
	\param in_control1 The first control point.
	\param in_control2 The second control point.
	\param in_fraction Interpolation distance (0 - 1).
	\return Result of interpolation.
	*/
	Quaternion Squad(Quaternion const & in_right, Quaternion const & in_control1, Quaternion const & in_control2, float in_fraction) const {
		Quaternion	q1 = Slerp(in_right , in_fraction, false);
		Quaternion	q2 = in_control1.Slerp(in_control2, in_fraction, false);

		return q1.Slerp(q2, 2*in_fraction*(1-in_fraction), false);
	}

	/*!
	Calculate a control point to be used in spline interpolation
	\param in_previous The control point before this
	\param in_next The control point after this
	\return Resultant spline control point
	*/
	Quaternion Spline(Quaternion const & in_previous, Quaternion const & in_next) const {
		Quaternion qni(w, -x, -y, -z);

		return *this * Quaternion(((qni*in_previous).Log() + (qni*in_next).Log()) / -4).Exp();
	}

};

struct UpdateInfo
{
	Time update_time;							//!< Time taken by the last update
	Time static_time;							//!< Time taken to create the static model(s) during the last update
	size_t dot_dc_count;						//!< Number of DC dots drawn during the last update
	size_t dot_3d_count;						//!< Number of 3D dots drawn during the last update
	size_t line_dc_count;						//!< Number of DC lines drawn during the last update
	size_t line_3d_count;						//!< Number of 3D lines drawn during the last update
	size_t triangle_dc_count;					//!< Number of DC triangles drawn during the last update
	size_t triangle_3d_count;					//!< Number of 3D triangles drawn during the last update
	size_t polygon_dc_count;					//!< Number of DC polygons drawn during the last update
	size_t polygon_3d_count;					//!< Number of 3D polygons drawn during the last update
	size_t polyhedron_count;					//!< Number of polyhedra drawn during the last update
	size_t deleted_display_list_count;			//!< Number of deleted display lists during the last update
	size_t display_list_line_3d_count;			//!< Number of lines drawn from display lists during the last update
	size_t display_list_triangle_3d_count;		//!< Number of triangles drawn from display lists during the last update
	size_t display_list_vertex_3d_count;		//!< Number of vertices drawn from display lists during the last update
	size_t display_list_tristrip_count;			//!< Number of tristrips drawn from display lists during the last update
	size_t non_display_list_tristrip_count;		//!< Number of tristrips drawn during the last update
	size_t culled_display_list_tristrip_count;	//!< Number of tristrips from display lists culled during the last update
	size_t raster_count;						//!< Number of rasters drawn during the last update
	size_t segment_count;						//!< Number of segments traversed during the last update
	size_t frustum_culled_segment_count;		//!< Number of segments culled because of frustum culling during the last update
	size_t extent_culled_segment_count;			//!< Number of segments culled because of extent culling during the last update
	size_t vector_culled_segment_count;			//!< Number of segments culled because of vector culling during the last update
	size_t save_region_count;					//!< Number of framebuffer regions saved during the last update
	size_t restore_region_count;				//!< Number of framebuffer regions restored during the last update
	size_t statics_created_count;				//!< Number of static models that were created during the last update
	size_t deferred_3d_items_created;			//!< Number of deferred items created during the last update
	size_t deferred_3d_items_deleted;			//!< Number of deferred items deleted during the last update
	size_t deferred_inplace_items;				//!< Number of InPlace items deferred
	size_t deferred_sprite_items;				//!< Number of Spriting items deferred
	size_t deferred_sprite_transparent_items;	//!< Number of transparent Spriting items deferred
	size_t static_segments;						//!< Number of segments created while generating static models
	float static_density;						//!< The average number of geometry per segment in the static models
	size_t static_not_drawing;					//!< Number of segments that are part of the static model, that do not contribute towards drawing
	size_t static_not_flattened_invisible;		//!< Number of segments that were not flattened as part of static model generation, because they were invisible
	size_t static_not_flattened_big;			//!< Number of segments that were not flattened as part of static model generation, because they were considered too big
};

typedef unsigned char	byte;
typedef signed char		sbyte;
typedef intptr_t		WindowHandle;
typedef int64_t			TouchID;
typedef intptr_t		PlatformData;
typedef intptr_t		OpaqueHandle;

/*
HPS Lexicon:

Concept Class -- A class that contains only enums and possibly static functions.  The
		constructor is usually private because they are not intended to be instantiated.

Database -- (1) The internal space that stores and manages all HOOPS objects.  Access to
		database objects is subject to locking to prevent threading deadlocks.  (2) The class
		of the same name, offering static functions to initiate operations that take place
		within the database.

Key -- A reference counted smart pointer to an object in the database.  The

Kit -- A user space object that carries a complete specification for a geometry, attribute,
		option group, or other type.  Modifying a kit has no effect on the database unless
		and until it is applied.  Kits should generally be passed by reference because they
		are potentially very large and copying them can be arduous.

Smart Pointer -- An encapsulated, reference counted pointer to an internal object.  Smart
		pointers should generally be passed by value to ensure the reference count is
		correct.

User Space -- The external space occupied by all user code.  User space objects are not
		in the database and are not subject to locking.

*/

//////////////////////////////////////////////////////////////////////
/////////////////////// Forward Declarations /////////////////////////
//////////////////////////////////////////////////////////////////////
class SegmentKey;
class AttributesControl;
class LineKit;
class LineKey;
class TextKey;
class TextKit;
class Key;
class VisibilityControl;
class CameraControl;
class SelectabilityControl;
class TransparencyKit;
class TransparencyControl;
class CullingKit;
class CullingControl;
class GlyphKit;
class ShapeKit;
class MarkerAttributeControl;
class GlyphDefinition;
class ShapeDefinition;
class GeometryInsertControl;
class GlyphElement;
class ShapeElement;
class TextAttributeControl;
class TextAttributeKit;
class LineAttributeKit;
class LineAttributeControl;
class EdgeAttributeKit;
class EdgeAttributeControl;
class CurveAttributeKit;
class CurveAttributeControl;
class GlyphPoint;
class MatrixKit;
class ModellingMatrixControl;
class TextureMatrixControl;
class TextureDefinition;
class MaterialMappingKit;
class PBRMaterialKit;
class MaterialMappingControl;
class MaterialKit;
class MarkerKit;
class MarkerKey;
class DistantLightKit;
class DistantLightKey;
class CuttingSectionKit;
class CuttingSectionKey;
class CuttingSectionAttributeKit;
class CuttingSectionAttributeControl;
class CylinderAttributeKit;
class CylinderAttributeControl;
class Cylinder;
class CylinderKey;
class CylinderKit;
class SphereKey;
class SphereKit;
class SphereAttributeKit;
class SphereAttributeControl;
class PolygonKit;
class PolygonKey;
class CircleKey;
class CircleKit;
class CircularArcKey;
class CircularArcKit;
class CircularWedgeKey;
class CircularWedgeKit;
class IncludeKey;
class InfiniteLineKey;
class InfiniteLineKit;
class SpotlightKey;
class SpotlightKit;
class NURBSCurveKey;
class NURBSCurveKit;
class NURBSSurfaceKey;
class NURBSSurfaceKit;
class TrimKit;
class TrimElement;
class EllipseKey;
class EllipseKit;
class EllipticalArcKey;
class EllipticalArcKit;
class ShellKit;
class ShellKey;
class Shell;
class MeshKit;
class MeshKey;
class WindowKey;
class Database;
class NURBSSurfaceAttributeKit;
class NURBSSurfaceAttributeControl;
class Driver;
class Search;
class PerformanceKit;
class PerformanceControl;
class HiddenLineAttributeKit;
class HiddenLineAttributeControl;
class DrawingAttributeKit;
class DrawingAttributeControl;
class PortfolioKey;
class Selection;
class SelectionOptionsKit;
class SelectionResults;
class SelectionItem;
class SelectionControl;
class HighlightControl;
class HighlightOptionsKit;
class ImageDefinition;
class ImageKit;
class TextureDefinition;
class TextureOptionsKit;
class NamedStyleDefinition;
class MaterialPaletteDefinition;
class GlyphDefinition;
class LinePatternOptionsKit;
class LinePatternDefinition;
class LinePatternKit;
class LinePatternElement;
class LinePatternParallelKit;
class CubeMapDefinition;
class ShaderKit;
class ShaderDefinition;
class EmergencyHandler;
class EventDispatcher;
class EventHandler;
class Event;
#if TARGET_OS_ANDROID == 0 && !defined(__APPLE__)
class StandAloneWindowKey;
class StandAloneWindowOptionsKit;
#endif
class ApplicationWindowKey;
class ApplicationWindowOptionsKit;
class OffScreenWindowKey;
class OffScreenWindowOptionsKit;
class LightingAttributeControl;
class VisualEffectsControl;
class PostProcessEffectsControl;
class SelectionOptionsControl;
class ObjectPoint;
class WorldPoint;
class CameraPoint;
class InnerWindowPoint;
class InnerPixelPoint;
class WindowPoint;
class PixelPoint;
class VisibilityKit;
class CameraKit;
class SelectabilityKit;
class MarkerAttributeKit;
class LightingAttributeKit;
class VisualEffectsKit;
class PostProcessEffectsKit;
class Portfolio;
class SubwindowControl;
class SubwindowKit;
class World;
class DebuggingControl;
class DebuggingKit;
class KeyPath;
class ContourLineKit;
class ContourLineControl;
class UTF8;
class StyleControl;
class PortfolioControl;
class ConditionalExpression;
class ConditionControl;
class WindowInfoKit;
class WindowInfoControl;
class FontInfoState;
class FontInfoControl;
class SearchOptionsKit;
class AttributeLockControl;
class AttributeLockKit;
class ReferenceKey;
class StyleKey;
class BoundingKit;
class BoundingControl;
class TransformMaskKit;
class TransformMaskControl;
class ColorInterpolationKit;
class ColorInterpolationControl;
class UpdateOptionsKit;
class UpdateOptionsControl;
class GeometryKey;
class TreeContext;
class ShellRelationOptionsKit;
class ShellRelationResultsKit;
class GridKit;
class GridKey;
class CutGeometryGatheringOptionsKit;
class SegmentOptimizationOptionsKit;
class HighlightSearchOptionsKit;
class HighlightState;
class HighlightSearchResultsIterator;
class HighlightSearchResults;
class OptimizeMappingResults;
class OptimizeMappingResultsIterator;

//////////////////////////////////////////////////////////////////////
////////////////////////////// Utility ///////////////////////////////
//////////////////////////////////////////////////////////////////////


/*! The GlyphPoint class is a point that is used in the definition of glyphs.
	It is a 2d point with x, y restricted to [-128, 127].  */
class HPS_API GlyphPoint
{
public:

	//! Default constructor
	GlyphPoint();

	/*! Construct a new GlyphPoint from an (x, y) pair.
	\param in_x The x location of the point.
	\param in_y The y location of the point.
	*/
	GlyphPoint(sbyte in_x, sbyte in_y);

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise.
	*/
	bool Equals(GlyphPoint const & in_that) const { return (x==in_that.x && y==in_that.y); }

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise.
	*/
	bool operator==(GlyphPoint const & in_that) const { return Equals(in_that); }

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise.
	*/
	bool operator!=(GlyphPoint const & in_that) const { return !Equals(in_that); }

	sbyte x;
	sbyte y;
};

/*! The Type class is a concept class that contains type information for all classes.  */

enum class Type : uint32_t
{
	None									= 0x00000000,
	GenericMask								= 0xffffff00,

	World									= 0x00000001,
	UTF8									= 0x00000002,
	EventDispatcher							= 0x00000003,
	EventHandler							= 0x00000004,
	EventNotifier							= 0x00000005,
	UpdateNotifier							= 0x00000006,
	SearchResults							= 0x00000008,
	FontSearchResults						= 0x00000009,
	SelectionResults						= 0x0000000a,
	SelectionItem							= 0x0000000b,
	TreeContext								= 0x0000000c,
	StreamToolkit							= 0x0000000d,
	DriverEventHandler						= 0x0000000e,
	HighlightSearchResults					= 0x0000000f,
	OptimizeMappingResults					= 0x00000010,

	IONotifier								= 0x04000100,
	StreamImportNotifier					= 0x04000101,
	STLImportNotifier						= 0x04000102,
	OBJImportNotifier						= 0x04000103,
	ExchangeImportNotifier					= 0x04000104,
	SketchupImportNotifier					= 0x04000105,
	ParasolidImportNotifier					= 0x04000106,
	ExchangeTranslationNotifier				= 0x04000107,
	ExchangeExportNotifier					= 0x04000108,
	StreamExportNotifier					= 0x04000109,
	ExchangeReloadNotifier					= 0x0400010a,
	DWGImportNotifier						= 0x0400010b,
	ExchangeParasolidImportNotifier			= 0x0400010c,
	PointCloudImportNotifier				= 0x0400010d,
	OOCImportNotifier						= 0x0400010e,
	OBJExportNotifier						= 0x0400010f,
	HCAImportNotifier						= 0x04000110,

	SearchResultsIterator					= 0x01000001,
	FontSearchResultsIterator				= 0x01000002,
	SelectionResultsIterator				= 0x01000003,
	HighlightSearchResultsIterator			= 0x01000004,
	OptimizeMappingResultsIterator			= 0x01000005,

	Kit										= 0x01000000,
	MarkerKit								= 0x01000010,
	SphereAttributeKit						= 0x01000011,
	TextAttributeKit						= 0x01000012,
	TransparencyKit							= 0x01000013,
	VisibilityKit							= 0x01000014,
	VisualEffectsKit						= 0x01000015,
	CuttingSectionAttributeKit				= 0x01000016,
	CircleKit								= 0x01000017,
	CircularArcKit							= 0x01000018,
	CircularWedgeKit						= 0x01000019,
	CuttingSectionKit						= 0x0100001a,
	CylinderKit								= 0x0100001b,
	DistantLightKit							= 0x0100001c,
	EllipseKit								= 0x0100001d,
	EllipticalArcKit						= 0x0100001e,
	InfiniteLineKit							= 0x0100001f,
	LineKit									= 0x01000020,
	NURBSCurveKit							= 0x01000021,
	MeshKit									= 0x01000022,
	NURBSSurfaceKit							= 0x01000023,
	PolygonKit								= 0x01000024,
	SphereKit								= 0x01000025,
	SpotlightKit							= 0x01000026,
	ShellKit								= 0x01000027,
	TextKit									= 0x01000028,
	MaterialKit								= 0x01000029,
	TrimKit									= 0x0100002a,
	TextureOptionsKit						= 0x0100002c,
	LinePatternKit							= 0x0100002d,
	GlyphKit								= 0x0100002e,
	ImageKit								= 0x0100002f,
	LinePatternOptionsKit					= 0x01000030,
	CameraKit								= 0x01000031,
	BoundingKit								= 0x01000032,
	CullingKit								= 0x01000033,
	CurveAttributeKit						= 0x01000034,
	CylinderAttributeKit					= 0x01000035,
	EdgeAttributeKit						= 0x01000036,
	LightingAttributeKit					= 0x01000037,
	LineAttributeKit						= 0x01000038,
	MarkerAttributeKit						= 0x01000039,
	MaterialMappingKit						= 0x0100003a,
	//MatrixKit								= 0x0100003b,
	NURBSSurfaceAttributeKit				= 0x0100003c,
	PostProcessEffectsKit					= 0x0100003d,
	SelectabilityKit						= 0x0100003e,
	SelectionOptionsKit						= 0x0100003f,
	StandAloneWindowOptionsKit				= 0x01000040,
	OffScreenWindowOptionsKit				= 0x01000041,
	ApplicationWindowOptionsKit				= 0x01000042,
	HighlightOptionsKit						= 0x01000043,
	LinePatternParallelKit					= 0x01000044,
	SubwindowKit							= 0x01000045,
	PerformanceKit							= 0x01000046,
	HiddenLineAttributeKit					= 0x01000047,
	DrawingAttributeKit						= 0x01000048,
	ShaderKit								= 0x01000049,
	DebuggingKit							= 0x0100004a,
	ContourLineKit							= 0x0100004b,
	StreamImportOptionsKit					= 0x0100004c,
	StreamImportResultsKit					= 0x0100004d,
	StreamExportOptionsKit					= 0x0100004e,
	StreamExportResultsKit					= 0x0100004f,
	WindowInfoKit							= 0x01000050,
	ImageImportOptionsKit					= 0x01000051,
	SearchOptionsKit						= 0x01000052,
	ShaderImportOptionsKit					= 0x01000053,
	HardcopyExportOptionsKit				= 0x01000055, // These two use the same Impl, so
	HardcopyGDIExportOptionsKit				= 0x01001055, // we make sure their bits are compatible here
	AttributeLockKit						= 0x01000056,
	TransformMaskKit						= 0x01000057,
	ColorInterpolationKit					= 0x01000058,
	UpdateOptionsKit						= 0x01000059,
	ImageExportOptionsKit					= 0x0100005a,
	OBJImportOptionsKit						= 0x0100005b,
	OBJImportResultsKit						= 0x0100005c,
	STLImportOptionsKit						= 0x0100005d,
	STLImportResultsKit						= 0x0100005e,
	ShellOptimizationOptionsKit				= 0x0100005f,
	ShellRelationOptionsKit					= 0x01000060,
	ShellRelationResultsKit					= 0x01000061,
	GridKit									= 0x01000062,
	CutGeometryGatheringOptionsKit			= 0x01000063,
	SegmentOptimizationOptionsKit			= 0x01000064,
	PointCloudImportOptionsKit				= 0x01000065,
	PointCloudImportResultsKit				= 0x01000066,
	ShapeKit								= 0x01000067,
	HighlightSearchOptionsKit				= 0x01000068,
	PBRMaterialKit							= 0x01000069,

	LinePatternElement						= 0x03000000,
	SolidLinePatternElement					= 0x03000001,
	BlankLinePatternElement					= 0x03000002,
	GlyphLinePatternElement					= 0x03000003,

	GlyphElement							= 0x05000000,
	DotGlyphElement							= 0x05000001,
	LineGlyphElement						= 0x05000002,
	EllipseGlyphElement						= 0x05000003,
	CircularArcGlyphElement					= 0x05000004,
	InfiniteLineGlyphElement				= 0x05000005,
	SphereGlyphElement						= 0x05000006,
	ImageGlyphElement						= 0x05000007,

	TrimElement								= 0x07000000,

	ConditionalExpression					= 0x09000000,
	NOTCondition							= 0x09000001,
	ANDCondition							= 0x09000002,
	ORCondition								= 0x09000003,
	XORCondition							= 0x09000004,
	EQCondition								= 0x09000005,
	NEQCondition							= 0x09000006,
	GTCondition								= 0x09000007,
	LTCondition								= 0x09000008,
	GTEQCondition							= 0x09000009,
	LTEQCondition							= 0x0900000A,

	ShapeElement							= 0x0B000000,
	PolygonShapeElement						= 0x0B000001,
	EllipseShapeElement						= 0x0B000002,
	CircleShapeElement						= 0x0B000003,
	EllipticalArcShapeElement				= 0x0B000004,
	AnchorShapeElement						= 0x0B000005,
	LineShapeElement						= 0x0B000006,
	CircularArcShapeElement					= 0x0B000007,
	LeaderLineClippingElement				= 0x0B000008,

	MouseState								= 0x01001001,
	TouchState								= 0x01001002,
	KeyboardState							= 0x01001003,
	FontInfoState							= 0x01001004,
	HighlightState							= 0x01001005,

	KeyPath									= 0x01000F01,

	Key										= 0x10000000,
	IncludeKey								= 0x10000001,
	PortfolioKey							= 0x10000002,
	StyleKey								= 0x10000003,

	SegmentKey								= 0x10200000,
	WindowKey								= 0x10600000,
	StandAloneWindowKey						= 0x10600001,
	OffScreenWindowKey						= 0x10600002,
	ApplicationWindowKey					= 0x10600003,

	GeometryKey								= 0x10100000,
	ReferenceKey							= 0x10100001,
	CircleKey								= 0x10100002,
	CircularArcKey							= 0x10100003,
	CircularWedgeKey						= 0x10100004,
	CuttingSectionKey						= 0x10100005,
	CylinderKey								= 0x10100006,
	EllipseKey								= 0x10100007,
	EllipticalArcKey						= 0x10100008,
	InfiniteLineKey							= 0x10100009,
	LineKey									= 0x1010000a,
	DistantLightKey							= 0x1010000b,
	SpotlightKey							= 0x1010000c,
	MarkerKey								= 0x1010000d,
	MeshKey									= 0x1010000e,
	NURBSCurveKey							= 0x1010000f,
	NURBSSurfaceKey							= 0x10100010,
	PolygonKey								= 0x10100011,
	ShellKey								= 0x10100012,
	SphereKey								= 0x10100013,
	TextKey									= 0x10100014,
	GridKey									= 0x10100015,

	Definition								= 0x20000000,
	NamedStyleDefinition					= 0x20000001,
	TextureDefinition						= 0x20000002,
	LinePatternDefinition					= 0x20000003,
	GlyphDefinition							= 0x20000004,
	CubeMapDefinition						= 0x20000005,
	ImageDefinition							= 0x20000006,
	MaterialPaletteDefinition				= 0x20000007,
	ShaderDefinition						= 0x20000008,
	ShapeDefinition							= 0x20000009,

	Control									= 0x50000000,
	CameraControl							= 0x50000001,
	SelectabilityControl					= 0x50000002,
	MarkerAttributeControl					= 0x50000003,
	SphereAttributeControl					= 0x50000004,
	LightingAttributeControl				= 0x50000005,
	CylinderAttributeControl				= 0x50000006,
	TextAttributeControl					= 0x50000007,
	LineAttributeControl					= 0x50000008,
	EdgeAttributeControl					= 0x50000009,
	CurveAttributeControl					= 0x5000000a,
	ModellingMatrixControl					= 0x5000000b,
	TextureMatrixControl					= 0x5000000c,
	CullingControl							= 0x5000000d,
	TransparencyControl						= 0x5000000e,
	MaterialMappingControl					= 0x5000000f,
	NURBSSurfaceAttributeControl			= 0x50000010,
	PostProcessEffectsControl				= 0x50000011,
	BoundingControl							= 0x50000012,
	VisualEffectsControl					= 0x50000013,
	SelectionOptionsControl					= 0x50000014,
	HighlightOptionsControl					= 0x50000015,
	DefinitionControl						= 0x50000016,
	SelectionControl						= 0x50000017,
	HighlightControl						= 0x50000018,
	StandAloneWindowOptionsControl			= 0x50600019, //Is a Window Key
	OffScreenWindowOptionsControl			= 0x5060001a, //Is a Window Key
	ApplicationWindowOptionsControl			= 0x5060001b, //Is a Window Key
	VisibilityControl						= 0x5000001c,
	SubwindowControl						= 0x5000001d,
	PerformanceControl						= 0x5000001e,
	HiddenLineAttributeControl				= 0x5000001f,
	DrawingAttributeControl					= 0x50000020,
	DebuggingControl						= 0x50000021,
	ContourLineControl						= 0x50000022,
	StyleControl							= 0x50000023,
	ConditionControl						= 0x50000024,
	PortfolioControl						= 0x50000025,
	WindowInfoControl						= 0x50000026,
	AttributeLockControl					= 0x50000027,
	TransformMaskControl					= 0x50000028,
	ColorInterpolationControl				= 0x50000029,
	UpdateOptionsControl					= 0x50600030, //Is a Window Key
	CuttingSectionAttributeControl			= 0x50000031,

	LibraryMask								= 0x80FF0000,

	Sprocket								= 0x80000000,
	Canvas									= 0x80000001,
	Layout									= 0x80000002,
	View									= 0x80000003,
	Model									= 0x80000004,
	Operator								= 0x80000005,
	SprocketPath							= 0x80000007,

	SprocketControl							= 0xD0000000,
	OperatorControl							= 0xD0000008,
	NavigationCubeControl					= 0xD0000009,
	AxisTriadControl						= 0xD000000A,

	SprocketKit								= 0x81000000,

	Metadata								= 0x80001000,
	IntegerMetadata							= 0x80001001,
	UnsignedIntegerMetadata					= 0x80001002,
	DoubleMetadata							= 0x80001003,
	StringMetadata							= 0x80001004,
	TimeMetadata							= 0x80001005,
	BooleanMetadata							= 0x80001006,

	Component								= 0x80000200,
	Filter									= 0x80000600,
	Capture									= 0x80000a00,
	CADModel								= 0x80000300,
	ComponentPath							= 0x81001000,

	ExchangeMask							= 0x80020000,
	ExchangeComponent						= 0x80021200,
	ExchangeSheet							= 0x80021201,
	ExchangeProductOccurrence				= 0x80021202,
	ExchangeFilter							= 0x80020601,
	ExchangeCapture							= 0x80020a01,
	ExchangeCADModel						= 0x80020301,
	ExchangeConfiguration					= 0x81020001,
	ExchangeImportOptionsKit				= 0x81020002,
	ExchangeExportACISOptionsKit			= 0x81020003,
	ExchangeExportIGESOptionsKit			= 0x81020004,
	ExchangeExportJTOptionsKit				= 0x81020005,
	ExchangeExportParasolidOptionsKit		= 0x81020006,
	ExchangeExportPRCOptionsKit				= 0x81020007,
	ExchangeExportSTEPOptionsKit			= 0x81020008,
	ExchangeExportSTLOptionsKit				= 0x81020009,
	ExchangeExportU3DOptionsKit				= 0x8102000a,
	ExchangeExportXMLOptionsKit				= 0x8102000b,
	ExchangeTessellationOptionsKit			= 0x8102000c,
	ExchangeModelFileImportOptionsKit		= 0x8102000d,
	ExchangeTranslationOptionsKit			= 0x8102000e,
	ExchangeNURBSConversionOptionsKit		= 0x8102000f,
	ExchangeExport3MFOptionsKit				= 0x81020010,
	ExchangeExportFBXOptionsKit				= 0x81020011,
	ExchangeExportOBJOptionsKit				= 0x81020012,

	PublishMask								= 0x80040000,
	PublishDocumentKit						= 0x81040001,
	PublishPageKit							= 0x81040002,
	PublishTemplateKit						= 0x81040003,
	PublishAnnotationKit					= 0x81040004,
	PublishArtworkKit						= 0x81040005,
	PublishViewKit							= 0x81040006,
	PublishTextKit							= 0x81040007,
	PublishImageKit							= 0x81040008,
	PublishTableKit							= 0x81040009,
	PublishExportOptionsKit					= 0x8104000a,
	PublishLinkKit							= 0x8104000b,
	PublishButtonKit						= 0x8104000c,
	PublishTextFieldKit						= 0x8104000d,
	PublishSlideTableKit					= 0x8104000e,
	PublishCheckBoxKit						= 0x8104000f,
	PublishRadioButtonKit					= 0x81040010,
	PublishListBoxKit						= 0x81040011,
	PublishDropDownListKit					= 0x81040012,
	PublishSignatureFieldKit				= 0x81040013,

	PublishDocumentKey						= 0x80040001,
	PublishPageControl						= 0x80040002,

	ExchangeParasolidMask					= 0x80080000,

	SceneTree								= 0x80008001,
	SceneTreeItem							= 0x80008002,

	ComponentTree							= 0x80008003,
	ComponentTreeItem						= 0x80008004,

	SketchupMask							= 0x80100000,
	SketchupImportOptionsKit				= 0x81100001,
	SketchupImportResultsKit				= 0x81100002,

	ParasolidMask							= 0x80200000,
	ParasolidComponent						= 0x80201201,
	ParasolidCADModel						= 0x80200302,
	ParasolidImportOptionsKit				= 0x81200003,
	ParasolidFacetTessellationKit			= 0x81200004,
	ParasolidLineTessellationKit			= 0x81200005,
	ParasolidExportOptionsKit				= 0x81200006,

	DWGMask									= 0x80400000,
	DWGComponent							= 0x80401201,
	DWGLayer								= 0x80401202,
	DWGLayout								= 0x80400a03,
	DWGCADModel								= 0x80400304,
	DWGImportOptionsKit						= 0x81400005,

	OOCMask									= 0x80800000,
	OOCImportOptionsKit						= 0x81800001,
	OOCImportResultsKit						= 0x81800002,

	HCAMask									= 0x80110000,
	HCAImportOptionsKit						= 0x81110001,
	HCAImportResultsKit						= 0x81110002,
	HCAModel								= 0x80110003,
	HCAModelTree							= 0x80110004,
	HCAModelTreeItem						= 0x80110005,
	HCANetworkImportOptionsKit				= 0x81110006,

	HTMLMask								= 0x80010000,


	IONotifierData							= 0x84000200,
	StreamImportNotifierData				= 0x84000201,
	STLImportNotifierData					= 0x84000202,
	OBJImportNotifierData					= 0x84000203,
	ExchangeImportNotifierData				= 0x84020204,
	SketchupImportNotifierData				= 0x84100205,
	ParasolidImportNotifierData				= 0x84200206,
	ExchangeTranslationNotifierData			= 0x84020207,
	ExchangeExportNotifierData				= 0x84020208,
	StreamExportNotifierData				= 0x84000209,
	DWGImportNotifierData					= 0x8440020a,
	ExchangeParasolidImportNotifierData		= 0x8408020b,
	PointCloudImportNotifierData			= 0x8400020c,
	OOCImportNotifierData					= 0x8480020d,
	OBJExportNotifierData					= 0x8400020e,
	HCAImportNotifierData					= 0x8411020f,

};

/*! The Memory class contains functions for allocating and freeing memory in the Visualize memory space.  */
class HPS_API Memory
{
public:
	/*! Allocates memory in the Visualize memory space and returns a pointer to the user.
	\param in_bytes The amount of memory requested.
	\param in_clear_memory If this flag is set, the memory will be nulled before being returned.
	\return A pointer to the allocated memory.
	*/
	static void *	Allocate(size_t in_bytes, bool in_clear_memory = true);


	/*! Frees memory that has previously been allocated in the Visualize memory space.  Calling this function
		to free memory allocated in any another way has undefined behavior.
	\param in_pointer A pointer to memory previously allocated in the Visualize memory space.
	*/
	static void		Free(void * in_pointer);

private:
	//! Private default constructor to prevent instantiation.
	Memory();
};


/*! The Allocator class is a memory allocator suitable for STL container classes that uses memory in the Visualize memory space. */
template <typename T>
class NO_HPS_API Allocator
{
public:
	typedef T					value_type;
	typedef value_type *		pointer;
	typedef value_type const *	const_pointer;
	typedef value_type &		reference;
	typedef value_type const &	const_reference;
	typedef size_t				size_type;
	typedef ptrdiff_t			difference_type;


	Allocator() {}
	Allocator(Allocator<T> const & in_that) { HPS_UNREFERENCED(in_that); }
	~Allocator() {}

	template <typename U> Allocator(Allocator<U> const &) {}

	template <typename U>
	struct rebind
	{
		typedef Allocator<U> other;
	};


	pointer address(reference x) const { return &x; }
	const_pointer address(const_reference x) const { return &x; }

	pointer  allocate(size_type n, void * v = 0) { HPS_UNREFERENCED(v); return static_cast<pointer>(Memory::Allocate(n * sizeof(T))); }
	void deallocate(pointer p, size_type n) { HPS_UNREFERENCED(n); Memory::Free(p); }

#if defined(_MSC_VER) || defined (__APPLE__)
	void construct(pointer p, const_reference x) { new(p) T(x); }
	void construct(pointer p, value_type && x) { new(p) T(std::move(x)); }
#else
	template<typename U, typename... Args>
	void construct(U * p, Args&&... args) { new(p) U(std::forward<Args>(args)...); }
#endif
	void destroy(pointer p) { HPS_UNREFERENCED(p); p->~T(); }

	size_type max_size() const { return static_cast<size_type>(-1) / sizeof(T); }
};

template <typename T, typename U>
bool operator==(const Allocator<T> &, const Allocator<U> &) { return true; }

template <typename T, typename U>
bool operator!=(const Allocator<T> &, const Allocator<U> &) { return false; }

//! The base class of all HPS exceptions.
class Exception : public std::runtime_error
{
public:
	Exception(char const * in_info) : std::runtime_error(in_info) { }
};


//! An InvalidObjectException is thrown when a user tries to interact with an object that either is uninitialized or has been deleted.
class InvalidObjectException : public Exception
{
public:
	InvalidObjectException(char const * in_info = "Attempted to use a deleted, uninitialized, or otherwise invalid object.") :
	  Exception(in_info) {}
};


/*! An IndexOutOfRangeException is thrown when a user tries to access an array element beyond the valid range,
	typically when interacting with the points or faces defining geometry.  */
class IndexOutOfRangeException : public Exception
{
public:
	IndexOutOfRangeException(char const * in_info = "Attempted to access an element outside the bounds of the array.") :
	  Exception(in_info) {}
};


//! An InvalidSpecificationException is thrown when a method is called with non-sensical or contradictory arguments.
class InvalidSpecificationException : public Exception
{
public:
	InvalidSpecificationException(char const * in_info = "Missing or invalid specification.") :
	  Exception(in_info) {}
};


//! An InvalidLicenseException is thrown when trying to run Visualize with an invalid license.
class InvalidLicenseException : public Exception
{
public:
	InvalidLicenseException(char const * in_info) :
		Exception(in_info) {}
};


//! An InvalidOperationException is thrown when an operation is not supported on the current platform.
class InvalidOperationException : public Exception
{
public:
	InvalidOperationException(char const * in_info = "Operation not supported on this platform.") :
		Exception(in_info) {}
};

/*! The IOException class is an exception that is thrown if there was a problem during file import or export. */
class IOException : public Exception
{
public:
	/*! The default constructor creates an IOException with an IOResult enumeration and string describing the issue.
	 * 	\param in_info String describing the cause of the exception.
	 * 	\param in_result IOResult enumeration indicating the category of the exception. */
	IOException(char const * in_info, IOResult in_result)
		: Exception(in_info), result(in_result) {}

	IOResult result;	//!< Enumeration indicating the category of the exception.
};


/*! The Object class is the common base class of most Visualize classes.  */
class HPS_API Object
{
public:

	Object();

	Object(Object const & that);

	virtual ~Object();

	Object & operator=(Object const & other_object);

	/*! The move constructor creates an Object by transferring the underlying impl of the rvalue reference to this Object
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an Object to take the impl from.*/
	Object(Object && in_that);


	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Object thereby avoiding a copy.
	* \param in_that An rvalue reference to an Object to take the impl from.
	* \return A reference to this Object. */
	Object & operator=(Object && in_that);

	/*! This function returns the true type of the underlying object. This function is useful
		for finding the type of smart pointer objects that have been cast to more generic types.
		\warning This function must synchronize the database (by waiting for all pending database operations to complete) in order
		to know the type status of this object with certainty. Therefore this function can negatively impact performance. You should vigorously avoid
		using this function in high-traffic or peformance-critical areas of your code.
		\return The true type of the object in question. */
	virtual HPS::Type			Type() const;

	/*! Returned by ObjectType() */
	static const HPS::Type staticType = HPS::Type::None;

    /*! This function returns the type the object, as declared (if the object is derived, this does not give the true type of the derived object).
		\return The declared type of the object in question, which may differ from the true, underlying type. */
	virtual HPS::Type	ObjectType() const { return staticType; }

	/*! Indicates whether this object has any values set on it.
	 *  \note An empty object is not necessarily invalid. For example, all fresh new Kits, or Objects that have been reset, are both valid and empty.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise.
	 *  \sa HPS::Object::Reset() */
	virtual bool		Empty() const {return (impl_ == 0);};

	/*! Resets this object to its initial, uninitialized state. */
	virtual void		Reset();

	/*! This function indicates whether this Object has the given Type mask.
	 	\param in_mask The Type mask to check against this Object.
		\warning This function must synchronize the database (by waiting for all pending database operations to complete) in order
		to know the type status of this object with certainty. Therefore this function can negatively impact performance. You should vigorously avoid
		using this function in high-traffic or peformance-critical areas of your code.
	 	\return <span class='code'>true</span> if this Object has the given Type mask, <span class='code'>false</span> otherwise. */
	bool				HasType(HPS::Type in_mask) const;

	/*! Returns a unique identifier that is shared by all objects of the same class.
		\return A unique value shared by all objects of the same class. */
	intptr_t			GetClassID() const;

	/*! Returns the object's database handle, which can be used to determine which instance of a class the object is. For example, controls
        are simply aliases for segment keys that group related functions. Therefore, a SegmentKey and all of its controls would
        return the same instance id. Different keys and controls will return the same value if they are backed by the same database resource.
		\return A value unique to an instance of an object and all objects that are backed by the same database resource. This means
        it would be 4 bytes on a 32-bit system and 8 bytes on a 64-bit system. */
	intptr_t			GetInstanceID() const;

	/*! Unique identifier for this class.
	 *	Note: this method uses construction of static objects.  If used in a constructor, it should be used in the body not the initializer list. */
	template <typename T>
	static intptr_t ClassID()
	{
		static const intptr_t ret = T().GetClassID();
		return ret;
	}
private:

	friend class HPSI::Impl;
	friend class HPSI::KeyImpl;
	friend class HPSI::TicketImpl;

	HPSI::Impl * impl_;
};


/*! The Control class is the base class for all Visualize controls. */
class HPS_API Control : public Object
{
public:
	virtual HPS::Type Type() const { return ObjectType(); }
	static const HPS::Type staticType = HPS::Type::Control;
	HPS::Type		ObjectType() const { return staticType; }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
	Control(Control const & in_that) = default;
#endif

protected:
	Control() {}

	/*! The move constructor creates a Control by transferring the underlying impl of the rvalue reference to this Control
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a Control to take the impl from.*/
	Control(Control && in_that) : Object(std::move(in_that)) {}

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Control thereby avoiding a copy.
	* \param in_that An rvalue reference to an Control to take the impl from.
	* \return A reference to this Control. */
	Control & operator=(Control && in_that)
	{
		this->Object::operator=(std::move(in_that));
		return *this;
	}
};


/*! The Kit class is the base class for all Visualize kits. */
class HPS_API Kit : public Object
{
public:
	static const HPS::Type staticType = HPS::Type::Kit;
	HPS::Type		ObjectType() const { return staticType; }
	virtual HPS::Type Type() const { return ObjectType(); }

#if !defined(_MSC_VER) || _MSC_VER >= 1900
	Kit(Kit const & in_that) = default;
#endif

protected:
	Kit() {}

	/*! The move constructor creates a Kit by transferring the underlying impl of the rvalue reference to this Kit
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to a Kit to take the impl from.*/
	Kit(Kit && in_that) : Object(std::move(in_that)) {}

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Kit thereby avoiding a copy.
	* \param in_that An rvalue reference to an Kit to take the impl from.
	* \return A reference to this Kit. */
	Kit & operator=(Kit && in_that)
	{
		this->Object::operator=(std::move(in_that));
		return *this;
	}
};


/*! The ObjectPoint class is a basic 3D point that is assumed to represent a location in object space. */
class HPS_API ObjectPoint : public Point
{
public:

	/*! Initializes a new Point. */
	ObjectPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	ObjectPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to object space via in_window. */
	ObjectPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:

	ObjectPoint(WorldPoint const & in_point); // Prevent implicit conversion to other types of points
	ObjectPoint(CameraPoint const & in_point); // Prevent implicit conversion to other types of points
	ObjectPoint(InnerWindowPoint const & in_point); // Prevent implicit conversion to other types of points
	ObjectPoint(InnerPixelPoint const & in_point); // Prevent implicit conversion to other types of points
	ObjectPoint(WindowPoint const & in_point); // Prevent implicit conversion to other types of points
	ObjectPoint(PixelPoint const & in_point); // Prevent implicit conversion to other types of points

};

/*! The WorldPoint class is a basic 3D point that is assumed to represent a location in world space. */
class HPS_API WorldPoint : public Point
{
public:
	/*! Initializes a new Point. */
	WorldPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	WorldPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to world space via in_window. */
	WorldPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:

	WorldPoint(ObjectPoint const & in_point); // Prevents implicit conversion to other points
	WorldPoint(CameraPoint const & in_point); // Prevents implicit conversion to other points
	WorldPoint(InnerWindowPoint const & in_point); // Prevents implicit conversion to other points
	WorldPoint(InnerPixelPoint const & in_point); // Prevents implicit conversion to other points
	WorldPoint(WindowPoint const & in_point); // Prevents implicit conversion to other points
	WorldPoint(PixelPoint const & in_point); // Prevents implicit conversion to other points

};

/*! The CameraPoint class is a basic 3D point that is assumed to represent a location in camera space. */
class HPS_API CameraPoint : public Point
{
public:
	/*! Initializes a new Point. */
	CameraPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	CameraPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to camera space via in_window. */
	CameraPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:
	CameraPoint(ObjectPoint const & in_point); // Prevents implicit conversion to other points
	CameraPoint(WorldPoint const & in_point); // Prevents implicit conversion to other points
	CameraPoint(InnerWindowPoint const & in_point); // Prevents implicit conversion to other points
	CameraPoint(InnerPixelPoint const & in_point); // Prevents implicit conversion to other points
	CameraPoint(WindowPoint const & in_point); // Prevents implicit conversion to other points
	CameraPoint(PixelPoint const & in_point); // Prevents implicit conversion to other points

};

/*! The InnerWindowPoint class is a basic 2D point that is assumed to represent a location in inner window space. */
class HPS_API InnerWindowPoint : public Point
{
public:

	/*! Initializes a new Point. */
	InnerWindowPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	InnerWindowPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to inner window space via in_window. */
	InnerWindowPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:
	InnerWindowPoint(ObjectPoint const & in_point); // Prevents implicit conversion to other points
	InnerWindowPoint(WorldPoint const & in_point); // Prevents implicit conversion to other points
	InnerWindowPoint(CameraPoint const & in_point); // Prevents implicit conversion to other points
	InnerWindowPoint(InnerPixelPoint const & in_point); // Prevents implicit conversion to other points
	InnerWindowPoint(WindowPoint const & in_point); // Prevents implicit conversion to other points
	InnerWindowPoint(PixelPoint const & in_point); // Prevents implicit conversion to other points
};

/*! The InnerPixelPoint class is a basic 2D point that is assumed to represent a location in inner pixel screen space. */
class HPS_API InnerPixelPoint : public Point
{
public:

	/*! Initializes a new Point. */
	InnerPixelPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	InnerPixelPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to inner pixel space via in_window. */
	InnerPixelPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:
	InnerPixelPoint(ObjectPoint const & in_point); // Prevents implicit conversion to other points
	InnerPixelPoint(WorldPoint const & in_point); // Prevents implicit conversion to other points
	InnerPixelPoint(CameraPoint const & in_point); // Prevents implicit conversion to other points
	InnerPixelPoint(InnerWindowPoint const & in_point); // Prevents implicit conversion to other points
	InnerPixelPoint(WindowPoint const & in_point); // Prevents implicit conversion to other points
	InnerPixelPoint(PixelPoint const & in_point); // Prevents implicit conversion to other points

};

/*! The WindowPoint class is a basic 2D point that is assumed to represent a location in normalized window space. */
class HPS_API WindowPoint : public Point
{
public:

	/*! Initializes a new Point. */
	WindowPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	WindowPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to window space via in_window. */
	WindowPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:
	WindowPoint(ObjectPoint const & in_point); // Prevents implicit conversion to other points
	WindowPoint(WorldPoint const & in_point); // Prevents implicit conversion to other points
	WindowPoint(CameraPoint const & in_point); // Prevents implicit conversion to other points
	WindowPoint(InnerWindowPoint const & in_point); // Prevents implicit conversion to other points
	WindowPoint(InnerPixelPoint const & in_point); // Prevents implicit conversion to other points
	WindowPoint(PixelPoint const & in_point); // Prevents implicit conversion to other points
};


/*! The PixelPoint class is a basic 2D point that is assumed to represent a location in pixel space. */
class HPS_API PixelPoint : public Point
{
public:
	/*! Initializes a new Point. */
	PixelPoint(float px = 0.0f, float py = 0.0f, float pz = 0.0f) : Point(px, py, pz) {}

	/*! Copies the existing point in_point. */
	PixelPoint(Point const & in_point):Point(in_point){}

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, ObjectPoint const & in_point);

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, WorldPoint const & in_point);

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, CameraPoint const & in_point);

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, InnerWindowPoint const & in_point);

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, InnerPixelPoint const & in_point);

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, WindowPoint const & in_point);

	/*! Converts the point in_point to pixel space via in_window. */
	PixelPoint(WindowKey const & in_window, PixelPoint const & in_point);

private:
	PixelPoint(ObjectPoint const & in_point); // Prevents implicit conversion to other points
	PixelPoint(WorldPoint const & in_point); // Prevents implicit conversion to other points
	PixelPoint(CameraPoint const & in_point); // Prevents implicit conversion to other points
	PixelPoint(InnerWindowPoint const & in_point); // Prevents implicit conversion to other points
	PixelPoint(InnerPixelPoint const & in_point); // Prevents implicit conversion to other points
	PixelPoint(WindowPoint const & in_point); // Prevents implicit conversion to other points

};

/*! The Event class is the common base class of all events. An event can be an error, input event, or a custom event. Events
	occur asynchronously and are processed in order from an event queue. */
class HPS_API Event
{
public:
	/*! \enum Status
		Event Status - returned from a notifier to give the status of the event.
	*/
	enum class Status : uint32_t
	{
		InProgress,			//!< Event is still in progress
		Completed,			//!< Event has completed
		Failed				//!< Event failed
	};

	/*! A constructor for generating events from built-in or custom event ID's. */
	Event(intptr_t in_channel = 0): channel(in_channel), consumable(true), time_stamp(0) {}

	virtual ~Event();

	/*! Returns a unique identifier that is shared by all objects of the same class. */
	intptr_t			GetClassID() const;

	/*! This function is used to copy custom events classes.  Users that create custom
		event classes must override this function to provide the proper copying behavior.  */
	virtual Event *		Clone() const=0;

	/*! This optional function is used to determine if the current event can be dropped based on the following event in the queue. */
	virtual bool		Drop(Event const * in_that_event) const { HPS_UNREFERENCED(in_that_event); return false; }

	/*! This optional function is used to determine if the current event can be dropped in favor of newer event of the same type if one is available.
	* \return A cookie representing the freshen category. Zero indicates a non-freshening event.*/
	virtual intptr_t	Freshen() const { return 0; }

	/*! Returns the channel ID assigned to an event. */
	intptr_t			GetChannel() const { return channel; }

	/*! Returns the time an event was injected into the event queue. */
	Time				GetTimeStamp() const { return time_stamp; }

	/*! Indicates whether an event will be consumed when it is handled or passed on to the next handler anyway. */
	bool				IsConsumable() const { return consumable; }

	static void *		operator new (size_t in_size) { return Memory::Allocate(in_size); }
	static void			operator delete (void * in_ptr, size_t in_size) throw () { HPS_UNREFERENCED(in_size); Memory::Free(in_ptr); }

protected:
	intptr_t	channel;
	bool		consumable;

private:
	friend class HPSI::EventDispatcherImpl;
	Time		time_stamp;
};


/*! The EventNotifier class is a smart pointer that is associated with an event object.  It is a special type of control that
	is used for synchronizing with an event's completion. */
class HPS_API EventNotifier : public Object
{
public:

	/*! The default constructor creates an EventNotifier object not associated with any event.	*/
	EventNotifier();

	/*! The copy constructor creates a new EventNotifier that is associated with the same event as the source EventNotifier.
		\param in_that The source EventNotifier to copy.  */
	EventNotifier(EventNotifier const & in_that);

	/*! The move constructor creates an EventNotifier by transferring the underlying impl of the rvalue reference to this Key
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an EventNotifier to take the impl from.*/
	EventNotifier(EventNotifier && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Control thereby avoiding a copy.
	* \param in_that An rvalue reference to an Control to take the impl from.
	* \return A reference to this Control. */
	EventNotifier & operator=(EventNotifier && in_that);

	virtual ~EventNotifier();

	static const HPS::Type staticType = HPS::Type::EventNotifier;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the EventNotifier source.
	 *	\param in_that The EventNotifier source of the assignment.
	 *	\return A reference to this EventNotifier. */
	EventNotifier &			operator=(EventNotifier const & in_that);

	/*! Share the underlying smart-pointer of the EventNotifier source.
	 *	\param in_that The EventNotifier source of the assignment.  */
	virtual void			Assign(EventNotifier const & in_that);

	/*! Cause this thread to sleep until the event for this notifier has been handled.
	 *	\return A reference to this EventNotifier. */
	EventNotifier const &	Wait() const;

	/*! Query the status of the event for this notifier.
		\return The current state of the event.  */
	Event::Status			Status() const;
};

/*! The KeyboardCode enum contains codes for each key for use by the KeyboardEvent and KeyboardState classes. */
enum class KeyboardCode : uint32_t
{
	None				= 0,	//!< No key.

	Backspace			= 8,	//!< The Backspace key.
	Tab					= 9,	//!< The Tab key.
	Clear				= 11,	//!< The Clear key.
	Return				= 13,	//!< The Return key.
	Shift				= 16,	//!< The Shift key.
	Control				= 17,	//!< The Control key.
	Alt					= 18,	//!< The Alt key.
	Pause				= 19,	//!< The Pause key.
	Escape				= 27,	//!< The ESC key.

	Space				= 32,	//!< The Spacebar key.
	ExclamationMark,			//!< The Exclamation key.
	DoubleQuote,
	Number,
	Dollar,
	Percent,
	Ampersand,
	SingleQuote,
	OpenParen,
	CloseParen,

	Asterisk, 					//!< The Asterisk key.
	Plus, 						//!< The Plus key.
	Comma, 						//!< The Comma key.
	Hyphen, 					//!< The Hyphen key.
	Period,						//!< The Period key.
	Slash, 						//!< The Slash key.

	D0,			 				//!< The 0 (zero) key.
	D1,				 			//!< The 1 (one) key.
	D2, 						//!< The 2 key.
	D3,				 			//!< The 3 key.
	D4, 						//!< The 4 key.
	D5, 						//!< The 5 key.
	D6, 						//!< The 6 key.
	D7, 						//!< The 7 key.
	D8, 						//!< The 8 key.
	D9, 						//!< The 9 key.

	Colon,						//!< The Colon key.
	Semicolon,					//!< The Semicolon key.
	LessThan,
	Equal,						//!< The Equal key.
	GreaterThan,
	QuestionMark,
	AtSymbol,

	A,							//!< The A key.
	B,							//!< The B key.
	C,							//!< The C key.
	D,							//!< The D key.
	E,							//!< The E key.
	F,							//!< The F key.
	G,							//!< The G key.
	H,							//!< The H key.
	I,							//!< The I key.
	J,							//!< The J key.
	K,							//!< The K key.
	L,							//!< The L key.
	M,							//!< The M key.
	N,							//!< The N key.
	O,							//!< The O key.
	P,							//!< The P key.
	Q,							//!< The Q key.
	R,							//!< The R key.
	S,							//!< The S key.
	T,							//!< The T key.
	U,							//!< The U key.
	V,							//!< The V key.
	W,							//!< The W key.
	X,							//!< The X key.
	Y,							//!< The Y key.
	Z,							//!< The Z key.

	OpenBrackets,
	Backslash,
	CloseBrackets,
	Caret,
	Underscore,
	Backtick,

	a,							//!< The lowercase a key.
	b,							//!< The lowercase b key.
	c,							//!< The lowercase c key.
	d,							//!< The lowercase d key.
	e,							//!< The lowercase e key.
	f,							//!< The lowercase f key.
	g,							//!< The lowercase g key.
	h,							//!< The lowercase h key.
	i,							//!< The lowercase i key.
	j,							//!< The lowercase j key.
	k,							//!< The lowercase k key.
	l,							//!< The lowercase l key.
	m,							//!< The lowercase m key.
	n,							//!< The lowercase n key.
	o,							//!< The lowercase o key.
	p,							//!< The lowercase p key.
	q,							//!< The lowercase q key.
	r,							//!< The lowercase r key.
	s,							//!< The lowercase s key.
	t,							//!< The lowercase t key.
	u,							//!< The lowercase u key.
	v,							//!< The lowercase v key.
	w,							//!< The lowercase w key.
	x,							//!< The lowercase x key.
	y,							//!< The lowercase y key.
	z,							//!< The lowercase z key.

	OpenBrace,
	VerticalBar,
	ClosingBrace,
	Tilde,
	Delete,						//!< The Delete key.

	Insert=1024,				//!< The Insert key.
	Home,						//!< The Home key.
	End,						//!< The End key.
	PageUp,						//!< The Page Up key.
	PageDown,					//!< The Page Down key.

	Help,						//!< The Help key.

	Left,						//!< The Left Arrow key.
	Up,							//!< The Up Arrow key.
	Right,						//!< The Right Arrow key.
	Down,						//!< The Down Arrow key.

	NumPad0, 					//!< The 0 numeric keypad if numlock was off.
	NumPad1, 					//!< The 1 numeric keypad if numlock was off.
	NumPad2, 					//!< The 2 numeric keypad if numlock was off.
	NumPad3, 					//!< The 3 numeric keypad if numlock was off.
	NumPad4, 					//!< The 4 numeric keypad if numlock was off.
	NumPad5, 					//!< The 5 numeric keypad if numlock was off.
	NumPad6, 					//!< The 6 numeric keypad if numlock was off.
	NumPad7, 					//!< The 7 numeric keypad if numlock was off.
	NumPad8, 					//!< The 8 numeric keypad if numlock was off.
	NumPad9, 					//!< The 9 numeric keypad if numlock was off.

	F1,							//!< The F1 key.
	F2,							//!< The F2 key.
	F3,							//!< The F3 key.
	F4,							//!< The F4 key.
	F5,							//!< The F5 key.
	F6,							//!< The F6 key.
	F7,							//!< The F7 key.
	F8,							//!< The F8 key.
	F9,							//!< The F9 key.
	F10,						//!< The F10 key.
	F11,						//!< The F11 key.
	F12,						//!< The F12 key.
	F13,						//!< The F13 key.
	F14,						//!< The F14 key.
	F15,						//!< The F15 key.
	F16,						//!< The F16 key.
	F17,						//!< The F17 key.
	F18,						//!< The F18 key.
	F19,						//!< The F19 key.
	F20,						//!< The F20 key.
	F21,						//!< The F21 key.
	F22,						//!< The F22 key.
	F23,						//!< The F23 key.
	F24,						//!< The F24 key.

	CapsLock,					//!< The Caps Lock key.
	NumLock,					//!< The Num Lock key.
	ScrollLock,					//!< The Scroll Lock key.
	LeftShift,					//!< The left Shift key.
	RightShift,					//!< The right Shift key.
	LeftCtrl,					//!< The left CTRL key.
	RightCtrl,					//!< The right CTRL key.
	LeftAlt,					//!< The left ALT key.
	RightAlt,					//!< The right ALT key.

	Select, 					//!< The Select key.
	Print,						//!< The Print key.
	Execute,		 			//!< The Execute key.
	PrintScreen,	 			//!< The Print Screen key.
};


/*!	The Touch class represents the state of a single touch on a multi-touch device. */
class NO_HPS_API Touch
{
public:

	/*! The default constructor creates a Touch object with a null TouchID, location at the window origin,
	*	and a down state of <span class='code'>false</span>. */
	Touch() : ID(0), Location(Point(0,0,0)), TapCount(0) {}

	/*! This constructor creates a Touch object with a specified TouchID, location and down state.
	 * 	\param in_id TouchID for this Touch.
	 * 	\param in_location Location for this Touch.
	 *  \param in_tap_count Number of taps for this Touch. Defaults to 1 */
	Touch(TouchID in_id, WindowPoint const & in_location, size_t in_tap_count = 1)
		: ID(in_id), Location(in_location), TapCount(in_tap_count) {}

	/*!	Check if the source Touch is equivalent to this Touch.
	 *	\param in_that The source Touch to compare to this Touch.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	inline bool operator==(Touch const & in_that) const
	{
		return (ID == in_that.ID && Location == in_that.Location && TapCount == in_that.TapCount);
	}

	/*!	Check if the source Touch is not equivalent to this Touch.
	 *	\param in_that The source Touch to compare to this Touch.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	inline bool operator!=(Touch const & in_that) const
	{
		return !(*this == in_that);
	}

	TouchID		ID;				//!< TouchID for this Touch.
	WindowPoint Location;		//!< Location in window space for this Touch.
	size_t      TapCount;       //!< Number of taps for this Touch.
};
/**
 * \defgroup hps_custom_typedefs HPS Custom Type Definitions
 */
/** \addtogroup hps_custom_typedefs
 *  @{
 */
typedef std::vector<Point, Allocator<Point> >     											                  PointArray;							          //!< Array of type HPS::Point
typedef std::vector<ObjectPoint, Allocator<ObjectPoint> >								                  ObjectPointArray;			            //!< Array of type HPS::ObjectPoint
typedef std::vector<WorldPoint, Allocator<WorldPoint> >									                  WorldPointArray;                  //!< Array of type HPS::WorldPoint
typedef std::vector<CameraPoint, Allocator<CameraPoint> >								                  CameraPointArray;                 //!< Array of type HPS::CameraPoint
typedef std::vector<InnerWindowPoint, Allocator<InnerWindowPoint> >			                  InnerWindowPointArray;            //!< Array of type HPS::InnerWindowPoint
typedef std::vector<InnerPixelPoint, Allocator<InnerPixelPoint> >				                  InnerPixelPointArray;             //!< Array of type HPS::InnerPixelPoint
typedef std::vector<WindowPoint, Allocator<WindowPoint> >								                  WindowPointArray;                 //!< Array of type HPS::WindowPoint
typedef std::vector<PixelPoint, Allocator<PixelPoint> >									                  PixelPointArray;                  //!< Array of type HPS::PixelPoint
typedef std::vector<Vector, Allocator<Vector> >											                      VectorArray;                      //!< Array of type HPS::Vector
typedef std::vector<DVector, Allocator<DVector> >										                      DVectorArray;                     //!< Array of type HPS::DVector
typedef std::vector<Plane, Allocator<Plane> >											                        PlaneArray;                       //!< Array of type HPS::Plane
typedef std::vector<int, Allocator<int> >												                          IntArray;                         //!< Array of type int
typedef std::vector<RGBColor, Allocator<RGBColor> >										                    RGBColorArray;                    //!< Array of type HPS::RGBColor
typedef std::vector<RGBAColor, Allocator<RGBAColor> >									                    RGBAColorArray;                   //!< Array of type HPS::RGBAColor
typedef std::vector<unsigned int, Allocator<unsigned int> >							                  UnsignedIntArray;                 //!< Array of type unsigned int
typedef std::vector<size_t, Allocator<size_t> >											                      SizeTArray;                       //!< Array of type size_t
typedef std::vector<float, Allocator<float> >											                        FloatArray;                       //!< Array of type float
typedef std::vector<SegmentKey, Allocator<SegmentKey> >								                    SegmentKeyArray;                  //!< Array of type HPS::SegmentKey
typedef std::vector<WindowKey, Allocator<WindowKey> >									                    WindowKeyArray;                   //!< Array of type HPS::WindowKey
typedef std::vector<EventHandler, Allocator<EventHandler> >							                  EventHandlerArray;                //!< Array of type HPS::EventHandler
typedef std::vector<GlyphElement, Allocator<GlyphElement> >							                  GlyphElementArray;                //!< Array of type HPS::GlyphElement
typedef std::vector<ShapeElement, Allocator<ShapeElement> >							                  ShapeElementArray;                //!< Array of type HPS::ShapeElement
typedef std::vector<GlyphPoint, Allocator<GlyphPoint> >									                  GlyphPointArray;                  //!< Array of type HPS::GlyphPoint
typedef std::vector<UTF8, Allocator<UTF8> >												                        UTF8Array;                        //!< Array of type HPS::UTF8
typedef std::vector<UTF8Array, Allocator<UTF8Array> >									                    UTF8ArrayArray;                   //!< Array of type HPS::UTF8Array
typedef std::vector<bool, Allocator<bool> >												                        BoolArray;                        //!< Array of type bool
typedef std::vector<TrimKit, Allocator<TrimKit> >										                      TrimKitArray;                     //!< Array of type HPS::TrimKit
typedef std::vector<Key, Allocator<Key> >												                          KeyArray;                         //!< Array of type HPS::Key
typedef std::vector<PortfolioKey, Allocator<PortfolioKey> >							                  PortfolioKeyArray;                //!< Array of type HPS::PortfolioKey
typedef std::vector<char, Allocator<char> >												                        CharArray;                        //!< Array of type char
typedef std::vector<wchar_t, Allocator<wchar_t> >										                      WCharArray;                       //!< Array of type wchar_t
typedef std::vector<byte, Allocator<byte> >												                        ByteArray;                        //!< Array of type HPS::byte
typedef std::vector<ByteArray, Allocator<ByteArray> >									                    ByteArrayArray;                   //!< Array of type HPS::ByteArray
typedef std::vector<sbyte, Allocator<sbyte> >											                        SByteArray;                       //!< Array of type HPS::sbyte
typedef std::vector<MaterialKit, Allocator<MaterialKit> >								                  MaterialKitArray;                 //!< Array of type HPS::MaterialKit
typedef std::vector<LinePatternElement, Allocator<LinePatternElement> >					          LinePatternElementArray;          //!< Array of type HPS::LinePatternElement
typedef std::vector<LinePatternParallelKit, Allocator<LinePatternParallelKit> >		        LinePatternParallelKitArray;      //!< Array of type HPS::LinePatternParallelKit
typedef std::vector<Material::Type, Allocator<Material::Type> >							              MaterialTypeArray;                //!< Array of type HPS::Material::Type
typedef std::vector<Search::Type, Allocator<Search::Type> >								                SearchTypeArray;                  //!< Array of type HPS::Search::Type
typedef std::vector<Line::SizeUnits, Allocator<Line::SizeUnits> >						              LineSizeUnitsArray;               //!< Array of type HPS::Line::SizeUnits
typedef std::vector<CameraKit, Allocator<CameraKit> >									                    CameraKitArray;                   //!< Array of type HPS::CameraKit
typedef std::vector<ConditionalExpression, Allocator<ConditionalExpression> >			        ConditionalExpressionArray;       //!< Array of type HPS::ConditionalExpression
typedef std::vector<TextureDefinition, Allocator<TextureDefinition> >					            TextureDefinitionArray;           //!< Array of type HPS::TexureDefinition
typedef std::vector<CubeMapDefinition, Allocator<CubeMapDefinition> >					            CubeMapDefinitionArray;           //!< Array of type HPS::CubeMapDefinition
typedef std::vector<ImageDefinition, Allocator<ImageDefinition> >						              ImageDefinitionArray;             //!< Array of type HPS::ImageDefinition
typedef std::vector<NamedStyleDefinition, Allocator<NamedStyleDefinition> >				        NamedStyleDefinitionArray;        //!< Array of type HPS::NamedStyleDefinition
typedef std::vector<MaterialPaletteDefinition, Allocator<MaterialPaletteDefinition>	>	    MaterialPaletteDefinitionArray;   //!< Array of type HPS::MaterialPaletteDefinition
typedef std::vector<GlyphDefinition, Allocator<GlyphDefinition> >						              GlyphDefinitionArray;             //!< Array of type HPS::GlpyhDefinition
typedef std::vector<LinePatternDefinition, Allocator<LinePatternDefinition> >			        LinePatternDefinitionArray;       //!< Array of type HPS::LinePatternDefinition
typedef std::vector<ShaderDefinition, Allocator<ShaderDefinition> >						            ShaderDefinitionArray;            //!< Array of type HPS::ShaderDefinition
typedef std::vector<ShapeDefinition, Allocator<ShapeDefinition> >						              ShapeDefinitionArray;             //!< Array of type HPS::ShapeDefinition
typedef std::vector<IntRectangle, Allocator<IntRectangle> >								                IntRectangleArray;                //!< Array of type HPS::IntRectangle
typedef std::vector<AttributeLock::Type, Allocator<AttributeLock::Type> >				          AttributeLockTypeArray;           //!< Array of type HPS::AttributeLock
typedef std::vector<Style::Type, Allocator<Style::Type> >								                  StyleTypeArray;                   //!< Array of type HPS::Style::Type
typedef std::vector<TrimElement, Allocator<TrimElement> >								                  TrimElementArray;                 //!< Array of type HPS::TrimElement
typedef std::vector<KeyPath, Allocator<KeyPath> >										                      KeyPathArray;                     //!< Array of type HPS::KeyPath
typedef std::vector<IncludeKey, Allocator<IncludeKey> >									                  IncludeKeyArray;                  //!< Array of type HPS::IncludeKey
typedef std::vector<KeyboardCode, Allocator<KeyboardCode> >							                  KeyboardCodeArray;                //!< Array of type HPS::KeyboardCode
typedef std::vector<Touch, Allocator<Touch> >											                        TouchArray;                       //!< Array of type HPS::Touch
typedef std::vector<ReferenceKey, Allocator<ReferenceKey> >							                  ReferenceKeyArray;                //!< Array of type HPS::ReferenceKey
typedef std::vector<intptr_t, Allocator<intptr_t> >										                    IntPtrTArray;                     //!< Array of type intptr_t
typedef std::vector<GeometryKey, Allocator<GeometryKey> >								                  GeometryKeyArray;                 //!< Array of type HPS::GeometryKey
typedef std::vector<Shell::Relation, Allocator<Shell::Relation> >				                  ShellRelationArray;               //!< Array of type HPS::ShelL::Relation
typedef std::vector<StyleKey, Allocator<StyleKey> >										                    StyleKeyArray;                    //!< Array of type HPS::StyleKey
typedef std::vector<PointArray, Allocator<PointArray> >									                  PointArrayArray;                  //!< Array of type HPS::PointArray
typedef std::vector<Text::MarginUnits, Allocator<Text::MarginUnits> >		                  TextMarginUnitsArray;             //!< Array of type HPS::Text::MarginUnits
typedef std::vector<PointArrayArray, Allocator<PointArrayArray> >				                  PointArrayArrayArray;             //!< Array of type HPS::PointArrayArray
typedef std::vector<Drawing::ClipSpace, Allocator<Drawing::ClipSpace> >	                  ClipSpaceArray;                   //!< Array of type HPS::Drawing::ClipSpace
typedef std::vector<Drawing::ClipOperation, Allocator<Drawing::ClipOperation> >			      ClipOperationArray;               //!< Array of type HPS::Drawing::ClipOperation
typedef std::vector<MatrixKit, Allocator<MatrixKit> >									                    MatrixKitArray;                   //!< Array of type HPS::MatrixKit
typedef std::vector<int32_t, Allocator<int32_t>>									                    Int32Array;                       //!< Array of type int32_t
typedef std::vector<int64_t, HPS::Allocator<int64_t>> 													Int64Array;                       //!< Array of type int64_t
typedef std::vector<Line::CoordinateSpace, Allocator<Line::CoordinateSpace>>							LineCoordinateSpaceArray;					//!< Array of type HPS::Line::CoordinateSpace
typedef std::vector<Drawing::Overlay, Allocator<Drawing::Overlay>>												DrawingOverlayArray;							//!< Array of type HPS::Drawing::Overlay
typedef std::vector<HighlightState, Allocator<HighlightState>>														HighlightStateArray;							//!< Array of type HPS::HighlightState
typedef std::vector<ImageKit, Allocator<ImageKit>>											ImageKitArray; //!< Array of type HPS::ImageKit
/** @}*/

/*! The ShapeCoordinate class is a coordinate used in shape definitions.
	Two ShapeCoordinates can be used together to define a ShapePoint
	It is a 2d parametric coordinate. */
class HPS_API ShapeCoordinate
{
public:
	//! Default constructor
	ShapeCoordinate();

	/*! Construct a new ShapeCoordinate from an (x, y) pair.
	\param in_x A normalized distance over the horizontal text bounds.
	\param in_y A normalized distance over the vertical text bounds. */
	ShapeCoordinate(float in_x, float in_y);

	/*! Construct a new ShapeCoordinate from an (x, y) pair and up to four margins values
	\param in_x A normalized distance over the horizontal text bounds.
	\param in_y A normalized distance over the vertical text bounds.
	\param in_margins A series of up to four distances, normalized over the respective text margins. */
	ShapeCoordinate(float in_x, float in_y, FloatArray const & in_margins);

	/*! Construct a new ShapeCoordinate from an (x, y) pair and up to four margins values
	\param in_x A normalized distance over the horizontal text bounds.
	\param in_y A normalized distance over the vertical text bounds.
	\param in_size The size of in_margins.
	\param in_margins A series of up to four distances, normalized over the respective text margins. */
	ShapeCoordinate(float in_x, float in_y, size_t in_count, float const in_margins []);

	/*! Construct a new ShapeCoordinate from an (x, y, radius) tuple.
	\param in_x A normalized distance over the horizontal text bounds.
	\param in_y A normalized distance over the vertical text bounds.
	\param in_radius A normalized distance over the radius of the circle circumscribing the text bounds.*/
	ShapeCoordinate(float in_x, float in_y, float in_radius);

	/*! Construct a new ShapeCoordinate from an (x, y, radius) tuple and up to four margin values.
	\param in_x A normalized distance over the horizontal text bounds.
	\param in_y A normalized distance over the vertical text bounds.
	\param in_radius A normalized distance over the radius of the circle circumscribing the text bounds.
	\param in_margins A series of up to four distances, normalized over the respective text margins. */
	ShapeCoordinate(float in_x, float in_y, float in_radius, FloatArray const & in_margins);

	/*! Construct a new ShapeCoordinate from an (x, y, radius) tuple and up to four margin values.
	\param in_x A normalized distance over the horizontal text bounds.
	\param in_y A normalized distance over the vertical text bounds.
	\param in_radius A normalized distance over the radius of the circle circumscribing the text bounds.
	\param in_count The size of in_margins.
	\param in_margins A series of up to four distances, normalized over the respective text margins. */
	ShapeCoordinate(float in_x, float in_y, float in_radius, size_t in_count, float const in_margins []);

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool Equals(ShapeCoordinate const & in_that) const;

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool operator==(ShapeCoordinate const & in_that) const { return Equals(in_that); }

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool operator!=(ShapeCoordinate const & in_that) const { return !Equals(in_that); }

	/*! Sets the margins for this ShapeCoordinate.
	 *	\param in_margin_one The first margin value.
	 *	\param in_margin_two The second margin value.
	 *	\param in_margin_three The third margin value.
	 *	\param in_margin_four The fourth margin value.
	 *	\return A reference to this ShapeCoordinate. */
	ShapeCoordinate & SetMargins(float in_margin_one, float in_margin_two = 0.0f, float in_margin_three = 0.0f, float in_margin_four = 0.0f);

	/*! Shows the margins for this ShapeCoordinate.
	 *	\param out_margins The margins for this ShapeCoordinate.
	 *	\return <span class='code'>true</span> if margins were set, <span class='code'>false</span> otherwise. */
	bool ShowMargins(FloatArray & out_margins) const;

	/*! Removes the margins for this ShapeCoordinate.
	 *	\return A reference to this ShapeCoordinate. */
	ShapeCoordinate & UnsetMargins();

	float x;
	float y;
	float radius;
	FloatArray margins;
};

/*! The ShapePoint class is a point used in shape definitions.
	It is a 2d point. */
class HPS_API ShapePoint
{
public:
	//! Default constructor
	ShapePoint();

	/*! Construct a new ShapePoint from two ShapeCoordinate objects.
	\param in_x A ShapeCoordinate which will be used in the x direction.
	\param in_y A ShapeCoordinate which will be used in the x direction. */
	ShapePoint(ShapeCoordinate const & in_x, ShapeCoordinate const & in_y);

	/*! Construct a new ShapePoint, with margins computed automatically
	This is equivalent to using a ShapePoint constructed with the following two ShapeCoordinates
	ShapeCoordinate(A, 0, FloatArray(1, A))
	ShapeCoordiante(0, B, FloatArray(1, B))
	\param in_x A normalized distance over the horizontal text bounds and margins
	\param in_y A normalized distance over the vertical text bounds and margins. */
	ShapePoint(float in_x, float in_y);

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool Equals(ShapePoint const & in_that) const { return (x == in_that.x && y == in_that.y); }

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool operator==(ShapePoint const & in_that) const { return Equals(in_that); }

	/*! This function is used to check an object for equivalence to this.
	\param in_that The object to compare to this.
	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool operator!=(ShapePoint const & in_that) const { return !Equals(in_that); }

	ShapeCoordinate x;
	ShapeCoordinate y;
};

typedef std::vector<ShapePoint, Allocator<ShapePoint> >									ShapePointArray;

/*! An iterator used for traversing results from a search on an associated SearchResults object. */
class HPS_API SearchResultsIterator : public Object
{
public:

	/*! The default constructor creates a new SearchResultsIterator object that is not associated with any SearchResults object. */
	SearchResultsIterator();

	/*! The copy constructor initializes a new SearchResultsIterator object that is associated with the same SearchResults
		object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
		\param in_search_results_iterator The source of the copy.  */
	SearchResultsIterator(SearchResultsIterator const & in_search_results_iterator);

	/*! The move constructor creates SearchResultsIterator by transferring the underlying impl of the rvalue reference to this Key
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to SearchResultsIterator to take the impl from.*/
	SearchResultsIterator(SearchResultsIterator && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SearchResultsIterator thereby avoiding a copy.
	* \param in_that An rvalue reference to an SearchResultsIterator to take the impl from.
	* \return A reference to this SearchResultsIterator. */
	SearchResultsIterator & operator=(SearchResultsIterator && in_that);

	~SearchResultsIterator();

	static const HPS::Type staticType = HPS::Type::SearchResultsIterator;
	HPS::Type							ObjectType() const {return staticType;}

	/*! Copies a SearchResultsIterator object, associating this object with the same SearchResults
		object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
		\param in_search_results_iterator The source of the copy.
		\return a reference to this object.  */
	SearchResultsIterator &				operator=(SearchResultsIterator const & in_search_results_iterator);

	/*! Copies a SearchResultsIterator object, associating this object with the same SearchResults
		object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
		This method is functionally equivalent to the overloaded assignment operator except for the return value.
		\param in_search_results_iterator The source of the copy.  */
	void								Set(SearchResultsIterator const & in_search_results_iterator);

	/*! Advances the iterator to the next search result item */
	void								Next();

	/*! Advances the iterator to the next search result item
		\return A reference to this object.  */
	SearchResultsIterator &				operator++();

	/*! Advances the iterator to the next search result item
		\return A reference to this object.  */
	SearchResultsIterator				operator++(int in_val);

	/*! Comparison operator between iterators to compare equality
		\param in_search_results_iterator The iterator to compare to */
	bool								operator==(SearchResultsIterator const & in_search_results_iterator);

	/*! Comparison operator between iterators to compare inequality
		\param in_search_results_iterator The iterator to compare to */
	bool								operator!=(SearchResultsIterator const & in_search_results_iterator);

	/*! Queries the validity of this iterator location.  Invalid locations would include uninitialized
		iterators and iterators that had walked past the last element.
		\return <span class='code'>true</span> if this iterator is pointing to a valid item, false otherwise. */
	bool								IsValid() const;

	/*! Resets iterator to the beginning of the associated search results. */
	void								Reset();

	/*! Returns the item that this iterator is currently pointing at.  Throws exception if iterator is not valid.
		This method is functionally equivalent to the overloaded operator*.
		\return The current item.  */
	Key									GetItem() const;

	/*! Returns the item that this iterator is currently pointing at.  Throws exception if iterator is not valid.
		\return The current item.  */
	Key									operator*() const;

	/*! Retrieves the search criteria that were met for the current search item pointed to by this iterator.
		\return An array of search types for the current item.  */
	SearchTypeArray						GetResultTypes() const;
};

/*! The SearchResults class is a smart-pointer to a database object.  It contains the results of a Find operation. */
class HPS_API SearchResults : public Object
{
public:
	//!  The default constructor creates an empty SearchResults object, not associated with any search
	SearchResults();

	/*!  The copy constructor creates a new SearchResults object that shares the underlying smart-pointer of the source.
		\param in_search_results The source of the copy.  */
	SearchResults(SearchResults const & in_search_results);

	/*! The move constructor creates SearchResults by transferring the underlying impl of the rvalue reference to this Key
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to SearchResults to take the impl from.*/
	SearchResults(SearchResults && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SearchResults thereby avoiding a copy.
	* \param in_that An rvalue reference to an SearchResults to take the impl from.
	* \return A reference to this SearchResults. */
	SearchResults & operator=(SearchResults && in_that);

	/*! Resets this object to its initial, uninitialized state. */
	virtual void				Reset();

	//!  The destructor decrements the number of users of the search results.  If there are no remaining users, the results are released.
	~SearchResults();

	static const HPS::Type staticType = HPS::Type::SearchResults;
	HPS::Type				ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer if the assignment source.  This method is functionally
		equivalent to the overloaded assignment operator except for the return value.
		\param in_search_results The source of the assignment.  */
	void					Assign(SearchResults const & in_search_results);

	/*! Share the underlying smart-pointer of the SearchResults source.
	 *	\param in_that The SearchResults source of the assignment.
	 *	\return A reference to this SearchResults. */
	SearchResults &			operator=(SearchResults const & in_search_results);

	/*! Gets the number of items that were found in the associated search.
		\return The number of unique items found.  */
	size_t					GetCount() const;

	/*! Returns a SearchResultsIterator used to iterate through the found search results.
		\return An iterator pointing to the beginning of the search results list.  */
	SearchResultsIterator	GetIterator() const;
};

/*! An iterator used for traversing results from a search on an associated FontSearchResults object. */
class HPS_API FontSearchResultsIterator : public Object
{
public:

	/*! The default constructor creates a new FontSearchResultsIterator object that is not associated with any FontSearchResults object. */
	FontSearchResultsIterator();

	/*! The copy constructor initializes a new FontSearchResultsIterator object that is associated with the same FontSearchResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	\param in_search_results_iterator The source of the copy.  */
	FontSearchResultsIterator(FontSearchResultsIterator const & in_search_results_iterator);

	/*! The move constructor creates FontSearchResultsIterator by transferring the underlying impl of the rvalue reference to this Key
	*      thereby avoiding a copy and allocation.
	*      \param in_that An rvalue reference to FontSearchResultsIterator to take the impl from.*/
	FontSearchResultsIterator(FontSearchResultsIterator && in_that);

	/*! Copies a FontSearchResultsIterator object, associating this object with the same FontSearchResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	\param in_search_results_iterator The source of the copy.
	\return a reference to this object.  */
	FontSearchResultsIterator & 				operator=(FontSearchResultsIterator const & in_search_results_iterator);


	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this FontSearchResultsIterator thereby avoiding a copy.
	* \param in_that An rvalue reference to an FontSearchResultsIterator to take the impl from.
	* \return A reference to this FontSearchResultsIterator. */
	FontSearchResultsIterator & operator=(FontSearchResultsIterator && in_that);

	~FontSearchResultsIterator();

	static const HPS::Type staticType = HPS::Type::FontSearchResultsIterator;
	HPS::Type									ObjectType() const {return staticType;}


	/*! Copies a FontSearchResultsIterator object, associating this object with the same FontSearchResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	This method is functionally equivalent to the overloaded assignment operator except for the return value.
	\param in_search_results_iterator The source of the copy.  */
	void										Set(FontSearchResultsIterator const & in_search_results_iterator);

	/*! Advances the iterator to the next search result item */
	void										Next();

	/*! Advances the iterator to the next search result item
	\return A reference to this object.  */
	FontSearchResultsIterator &					operator++();

	/*! Advances the iterator to the next search result item
	\return A reference to this object.  */
	FontSearchResultsIterator					operator++(int in_val);

	/*! Comparison operator between iterators to compare equality
	\param in_search_results_iterator The iterator to compare to */
	bool										operator==(FontSearchResultsIterator const & in_search_results_iterator);

	/*! Comparison operator between iterators to compare inequality
	\param in_search_results_iterator The iterator to compare to */
	bool										operator!=(FontSearchResultsIterator const & in_search_results_iterator);

	/*! Queries the validity of this iterator location.  Invalid locations would include uninitialized
	iterators and iterators that had walked past the last element.
	\return <span class='code'>true</span> if this iterator is pointing to a valid item, false otherwise. */
	bool										IsValid() const;

	/*! Resets iterator to the beginning of the associated search results. */
	void										Reset();

	/*! Returns the FontInfoState that this iterator is currently pointing at.  Throws exception if iterator is not valid.
	This method is functionally equivalent to the overloaded operator*.
	\return The current item.  */
	FontInfoState								GetItem() const;

	/*! Returns the FontInfoState that this iterator is currently pointing at.  Throws exception if iterator is not valid.
	\return The current font name.  */
	FontInfoState								operator*() const;

};

/*! The FontSearchResults class is a smart-pointer to a database object.  It contains the results of a Find operation. */
class HPS_API FontSearchResults : public Object
{
public:

	//!  The default constructor creates an empty FontSearchResults object, not associated with any search
	FontSearchResults();

	/*!  The copy constructor creates a new FontSearchResults object that shares the underlying smart-pointer of the source.
	\param in_search_results The source of the copy.  */
	FontSearchResults(FontSearchResults const & in_search_results);

	/*! The move constructor creates FontSearchResults by transferring the underlying impl of the rvalue reference to this Key
	*      thereby avoiding a copy and allocation.
	*      \param in_that An rvalue reference to FontSearchResults to take the impl from.*/
	FontSearchResults(FontSearchResults && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this FontSearchResults thereby avoiding a copy.
	* \param in_that An rvalue reference to an FontSearchResults to take the impl from.
	* \return A reference to this FontSearchResults. */
	FontSearchResults & operator=(FontSearchResults && in_that);

	/*! Resets this object to its initial, uninitialized state. */
	virtual void				Reset();

	//!  The destructor decrements the number of users of the search results.  If there are no remaining users, the results are released.
	~FontSearchResults();

	static const HPS::Type staticType = HPS::Type::FontSearchResults;
	HPS::Type						ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer if the assignment source.  This method is functionally
	equivalent to the overloaded assignment operator except for the return value.
	\param in_search_results The source of the assignment.  */
	void							Assign(FontSearchResults const & in_search_results);


	/*! Share the underlying smart-pointer of the assignment source.
	\param in_search_results The source of the assignment.
	\return a reference to this object.  */
	FontSearchResults &				operator=(FontSearchResults const & in_search_results);

	/*! Gets the number of items that were found in the associated search.
	\return The number of unique items found.  */
	size_t							GetCount() const;

	/*! Returns a FontSearchResultsIterator used to iterate through the found search results.
	\return An iterator pointing to the beginning of the search results list.  */
	FontSearchResultsIterator		GetIterator() const;
};

/*! The UTF8 class encapsulates a utf8 encoded array of characters and allows for easy encoding and decoding. */
class HPS_API UTF8
{
public:

	//! The default constructor creates an empty UTF8 string
	UTF8();

	//! A destructor for a UTF8 string
	~UTF8();

	/*! This constructor can be used to encode a string from any known locale to utf8.  Be careful not
		to re-encode a string that's already utf8 encoded.
		\param in_string The string to be encoded.
		\param in_locale A string identifying the source locale of in_string.  If none is specified, the
		default locale on the local machine will be used.  If in_string is already utf8 encoded, specify
		the locale as "utf8" to prevent re-encoding.  */
	UTF8(char const * in_string, char const * in_locale = 0);

	/*! This constructor can be used to encode a wide character string to utf8.
		\param in_string The string to be encoded.  */
	UTF8(wchar_t const * in_string);

	/*! The copy constructor copies the source utf8 string.
		\param in_that the source to be copied. */
	UTF8(UTF8 const & in_that);

	/*! The move constructor takes control of the underlying data from the source utf8 string.
		\param the source of the move. */
	UTF8(UTF8 && in_that);

	/*! Moves the source UTF8 object to this object.  This method is functionally equivalent to the overloaded assignment operator.
		\param in_utf8 The source of the move.
		\return A reference to this object.  */
	UTF8 & Assign(UTF8 && in_utf8);

	/*! The move assignment operator takes control of the underlying data from the source utf8 string.
		\param the source of the move. */
	inline UTF8 & operator= (UTF8 && in_utf8)
	{
		return Assign(std::move(in_utf8));
	}

	/*! Decode a utf8 encoded string into a wide character buffer
		\param out_wide_string
		\return the number of wide characters (code points) in the wide string.
	*/
	size_t ToWStr(wchar_t * out_wide_string) const;

	/*! Decode a utf8 encoded string into a wide character buffer
		\return The number of wide characters (code points) in the wide string.
	*/
	size_t ToWStr(WCharArray & out_wide_string) const;

	/*!  Indicates whether this utf8 string has been initialized.
		\return <span class='code'>true</span> if the UTF8 string has been initialized, false otherwise. */
	inline bool IsValid() const
	{
		return (_length > 0);
	}

	/*!  Indicates whether this utf8 string is empty.
		\return <span class='code'>true</span> if the UTF8 string is empty, false otherwise. */
	inline bool Empty() const
	{
		return (_length == 0);
	}

	//! Reset all string data
	void Clear();

	/*! Resets this object to its initial, uninitialized state. */
	void Reset() { Clear(); }

	/*! Retrieves the number of bytes in the utf8 encoded string up to but not including the null terminator.  This will return
		0 if the utf8 object is uninitialized.
		\return The number of bytes. */
	inline size_t GetLength() const
	{
		return _length;
	}

	/*! Retrieves the number of wide characters in the wchar_t string up to but not including the null terminator.  This will return
		0 if the utf8 object is uninitialized.
		\return The number of wide characters. */
	inline size_t GetWStrLength() const
	{
		return ToWStr(0);
	}

	/*! Retrieves the raw, utf8 encoded character array.
		\return The utf8 encoded character array.  	*/
	inline char const * GetBytes() const
	{
		return _text;
	}

	/*! Allows typecasting to const char * by retrieves the raw, utf8 encoded character array.
		\return The utf8 encoded character array.  */
	inline operator char const * () const
	{
		return _text;
	}

	/*! Retrieves the utf8 encoded character at the specified index.  This method may split up individual code points.
		\return The utf8 encoded character array.  */
	char At(size_t in_index) const
	{
		if(!IsValid())
			throw InvalidObjectException();
		else if(in_index >= _length)
			throw IndexOutOfRangeException();
		else
			return _text[in_index];
	}

	/*! Copies the source UTF8 object to this object.  This method is functionally equivalent to the overloaded assignment operator.
		\param in_utf8 The source of the copy.
		\return A reference to this object.  */
	UTF8 & Assign(UTF8 const & in_utf8);

	/*! Copies the source UTF8 object to this object.
		\param in_utf8 The source of the copy.
		\return A reference to this object.  */
	inline UTF8 & operator= (UTF8 const & in_utf8)
	{
		return Assign(in_utf8);
	}

	/*! Appends a UTF8 object to the end of this object.
		\param in_utf8 The tail end of the new string.
		\return A reference to this object.  */
	UTF8 & operator+= (UTF8 const & in_utf8);

	/*! Appends a utf8 encoded string to the end of this object.
		\param in_utf8 A string, assumed to be utf8 encoded, used as the tail end of the new string.
		\return A reference to this object.  */
	UTF8 & operator+= (char const * in_utf8);

	/*! Creates a new UTF8 object by appending a UTF8 object to the end of this object.
		\param in_utf8 The tail end of the new string.
		\return A new UTF8 object representing the concatenation of 2 strings.  */
	UTF8 operator+ (UTF8 const & in_utf8) const;

	/*! Creates a new UTF8 object by appending a utf8 encoded string to the end of this object.
		\param in_utf8 A string, assumed to be utf8 encoded, used as the tail end of the new string.
		\return A new UTF8 object representing the concatenation of 2 strings.  */
	UTF8 operator+ (char const * in_utf8) const;

	/*! This function is used to check an object for equivalence to this.
		\param in_utf8 The object to compare to this.
		\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise.  */
	bool operator== (UTF8 const & in_utf8) const;

	/*! This function is used to check an object for equivalence to this.
		\param in_utf8 The object to compare to this.
		\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise.  */
	bool operator!= (UTF8 const & in_utf8) const
	{
		return !(*this == in_utf8);
	}

	/*! This function is used to check a utf8-encoded character string for equivalence to this.
		\param in_utf8 The object to compare to this.
		\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise.  */
	bool operator== (char const * in_utf8) const;

	/*! This function is used to check a utf8-encoded character string for equivalence to this.
		\param in_utf8 The object to compare to this.
		\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise.  */
	bool operator!= (char const * in_utf8) const
	{
		return !(*this == in_utf8);
	}

	/*! This function is used to check a utf8-encoded character string for equivalence to a UTF8 object.
		\param in_left A utf8-encoded character string.
		\param in_right A UTF8 object.
		\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise.  */
	friend inline bool operator==(char const * in_left, UTF8 const & in_right)
	{
		return in_right == in_left;
	}

	/*! This function is used to check a utf8-encoded character string for equivalence to a UTF8 object.
		\param in_left A utf8-encoded character string.
		\param in_right A UTF8 object.
		\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise.  */
	friend inline bool operator!=(char const * in_left, UTF8 const & in_right)
	{
		return in_right != in_left;
	}

	/*! This function is used to check a wide character string for equivalence to a UTF8 object.
		\param in_left A wide character string.
		\param in_right A UTF8 object.
		\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise.  */
	friend inline bool operator==(wchar_t const * in_left, UTF8 const & in_right)
	{
		return in_right == UTF8(in_left);
	}

	/*! This function is used to check a wide character string for equivalence to a UTF8 object.
		\param in_left A wide character string.
		\param in_right A UTF8 object.
		\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise.  */
	friend bool operator!=(wchar_t const * in_left, UTF8 const & in_right)
	{
		return in_right != UTF8(in_left);
	}

	/*! Creates a new UTF8 object by appending a UTF8 object to the end of a utf8-encoded character string.
		\param in_left A string, assumed to be utf8 encoded, used as the head end of the new string.
		\param in_right A UTF8 object used as the tail end of the new string.
		\return A new UTF8 object representing the concatenation of 2 strings.  */
	friend inline UTF8 operator+ (char const * in_left, UTF8 const & in_right)
	{
		return UTF8(in_left, "utf8") + in_right;
	}

	/*! Creates a new UTF8 object by appending a UTF8 object to the end of a wide character string.
		\param in_left A wide character string used as the head end of the new string.
		\param in_right A UTF8 object used as the tail end of the new string.
		\return A new UTF8 object representing the concatenation of 2 strings.  */
	friend inline UTF8 operator+ (wchar_t const * in_left, UTF8 const & in_right)
	{
		return UTF8(in_left) + in_right;
	}


	/*! Returns a hash code for the utf8 encoded characters.
		\return The size_t hash code.  */
	size_t GetHash() const;

	friend class HPSI::String;

private:

	size_t internal_encode(wchar_t const * in_wide_string);
	static size_t internal_decode(size_t in_length, const char* in_utf8_string, wchar_t * out_wide_string);
	size_t internal_decode(wchar_t * out_wide_string) const;

	char *				_text;
	size_t				_length;
	mutable size_t		_hash_key;
	static const size_t _buffer_size = 64 - sizeof(const char *) - 2 * sizeof(size_t);
	char				_buffer[_buffer_size];
};

/*!  A std::hash compatible hasher for HPS::UTF8 */
struct UTF8Hasher {
	inline size_t operator()(const HPS::UTF8 & in_utf8) const
	{
		return in_utf8.GetHash();
	}
};

/*!  A ConditionalExpression is a string or collection of strings separated by logical operators.  In practice, conditional expressions
	form a tree with the leaves being strings (the actual Conditions that must be satisfied) and the interior nodes being logical operators.  */
class HPS_API ConditionalExpression : public Object
{
public:

	//! The default constructor creates an empty condition that is always satisfied.
	ConditionalExpression();

	/*! This constructor is the way to construct a ConditionalExpression object from a string.
	*	\param in_condition The string to use as the condition, assumed to be utf8 encoded.  */
	ConditionalExpression(char const * in_condition);

	/*! This constructor is the way to construct a ConditionalExpression object from a number.
	*	\param in_value The number to use as the condition.  */
	ConditionalExpression(float in_number);

	/*! This constructor is the way to construct a ConditionalExpression object from a special intrinsic type.
	*	\param in_special The intrinsic type to use as the condition.  */
	ConditionalExpression(HPS::Condition::Intrinsic in_special);

	/*! The copy constructor copies the source condition.
	*	\param in_that the source to be copied. */
	ConditionalExpression(ConditionalExpression const & in_that);

	/*! The move constructor creates a ConditionalExpression by transferring the underlying impl of the rvalue reference to this ConditionalExpression
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ConditionalExpression to take the impl from.*/
	ConditionalExpression(ConditionalExpression && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ConditionalExpression thereby avoiding a copy.
	* \param in_that An rvalue reference to a ConditionalExpression to take the impl from.
	* \return A reference to this ConditionalExpression. */
	ConditionalExpression & operator=(ConditionalExpression && in_that);

	static const HPS::Type staticType = HPS::Type::ConditionalExpression;
	HPS::Type			ObjectType() const { return staticType; }

	/*! Shows the condition string that has been set on this object, if any.  A ConditionalExpression object can only have either a number, condition string, intrinsic type, or operands.
	 *	\param out_condition The condition string.
	 *	\return <span class='code'>true</span> if a condition string has been set, <span class='code'>false</span> otherwise. */
	bool				ShowCondition(UTF8 & out_condition) const;

	/*! Shows the number that has been set on this object, if any.  A ConditionalExpression object can only have either a number, condition string, intrinsic type, or operands.
	*	\param out_number The number.
	*	\return <span class='code'>true</span> if a number has been set, <span class='code'>false</span> otherwise. */
	bool				ShowNumber(float & out_number) const;

	/*! Shows the intrinsic type that has been set on this object, if any.  A ConditionalExpression object can only have either a number, condition string, intrinsic type, or operands.
	*	\param out_special The intrinsic type.
	*	\return <span class='code'>true</span> if an intrinsic type has been set, <span class='code'>false</span> otherwise. */
	bool				ShowIntrinsic(Condition::Intrinsic & out_special) const;

	/*! Retrieves the operands, if any, of this condition object.  A ConditionalExpression object can only have either a number, condition string, intrinsic type, or operands.
	*	\param out_operands An array of condition operands.
	*	\return <span class='code'>true</span> if operands are set on this object, <span class='code'>false</span> otherwise. */
	bool				ShowOperands(ConditionalExpressionArray & out_operands) const;

	/*! Copies the source ConditionalExpression object to this object.
	 *	\param in_that The source of the copy.
	 *	\return A reference to this object. */
	ConditionalExpression &			operator=(ConditionalExpression const & in_that);

	/*!	Check if the source object is equivalent to this object.
	 *	\param in_that The source object to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool 				Equals(ConditionalExpression const & in_that) const;

	/*!	Check if the source object is equivalent to this object.
	 *	\param in_that The source object to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool 				operator==(ConditionalExpression const & in_that) const;

	/*!	Check if the source object is equivalent to this object.
	 *	\param in_that The source object to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool 				operator!=(ConditionalExpression const & in_that) const;

	/*! Determines if the source ConditionalExpression object is satisfied by the given conditions.
	*  \param in_conditions The conditions to test against the ConditionalExpression object.
	*  \return <span class='code'>true</span> if the ConditionalExpression object is satisfied, <span class='code'>false</span> otherwise. */
	bool				IsSatisfiedBy(UTF8Array const & in_conditions) const;

	/*! Determines if the source ConditionalExpression object is satisfied by the given condition.
	*  \param in_condition The condition to test against the ConditionalExpression object.
	*  \return <span class='code'>true</span> if the ConditionalExpression object is satisfied, <span class='code'>false</span> otherwise. */
	bool				IsSatisfiedBy(char const * in_condition) const;

	/*! An OR condition is satisfied if either of its operand conditions are satisfied.
	*	\param in_operand2 The condition to OR with this object.
	*	\return a new condition representing the logical OR of the operand condition with this object. */
	ConditionalExpression	OR(ConditionalExpression const & in_operand2) const;

	/*! An XOR condition is satisfied if either operand condition is satisfied, but not both.
	*	\param in_operand2 The condition to XOR with this object.
	*	\return a new condition representing the logical XOR of the operand condition with this object. */
	ConditionalExpression	XOR(ConditionalExpression const & in_operand2) const;

	/*! An AND condition is satisfied if both of its operand conditions are satisfied.
	*	\param in_operand2 The condition to AND with this object.
	*	\return a new condition representing the logical AND of the operand condition with this object. */
	ConditionalExpression	AND(ConditionalExpression const & in_operand2) const;

	/*! An EQ conditional expression is satisfied if its operand expressions are equal.
	*	\param in_operand2 The expression to compare to this object.
	*	\return a new conditional expression representing the equality comparison of the operand expression with this object. */
	ConditionalExpression	EQ(ConditionalExpression const & in_operand2) const;

	/*! An NEQ conditional expression is satisfied if its operand expressions are not equal.
	*	\param in_operand2 The expression to compare to this object.
	*	\return a new conditional expression representing the non-equality comparison of the operand expression with this object. */
	ConditionalExpression	NEQ(ConditionalExpression const & in_operand2) const;

	/*! An GT conditional expression is satisfied if its second operand is greater than the first operand.
	*	\param in_operand2 The expression to compare to this object.
	*	\return a new conditional expression representing the greater than comparison of the operand expression with this object. */
	ConditionalExpression	GT(ConditionalExpression const & in_operand2) const;

	/*! An LT conditional expression is satisfied if its second operand is less than the first operand.
	*	\param in_operand2 The expression to compare to this object.
	*	\return a new conditional expression representing the less than comparison of the operand expression with this object. */
	ConditionalExpression	LT(ConditionalExpression const & in_operand2) const;

	/*! An GTEQ conditional expression is satisfied if its second operand is greater than or equal to the first operand.
	*	\param in_operand2 The expression to compare to this object.
	*	\return a new conditional expression representing the greater than or equal to comparison of the operand expression with this object. */
	ConditionalExpression	GTEQ(ConditionalExpression const & in_operand2) const;

	/*! An LTEQ conditional expression is satisfied if its second operand is less than or equal to the first operand.
	*	\param in_operand2 The expression to compare to this object.
	*	\return a new conditional expression representing the less than or equal to comparison of the operand expression with this object. */
	ConditionalExpression	LTEQ(ConditionalExpression const & in_operand2) const;

	/*! A NOT condition is satisfied if its operand condition is not satisfied.
	*	\return a new condition representing the logical negation of this object.  */
	ConditionalExpression	operator !() const;

	/*! An OR condition is satisfied if either of its operand conditions are satisfied.
	*	\param in_operand2 The condition to OR with this object.
	*	\return a new condition representing the logical OR of the operand condition with this object. */
	ConditionalExpression	operator ||(ConditionalExpression const & in_operand2) const;

	/*! An XOR condition is satisfied if either operand condition is satisfied, but not both.
	*	\param in_operand2 The condition to XOR with this object.
	*	\return a new condition representing the logical XOR of the operand condition with this object. */
	ConditionalExpression	operator ^(ConditionalExpression const & in_operand2) const;

	/*! An AND condition is satisfied if both of its operand conditions are satisfied.
	*	\param in_operand2 The condition to AND with this object.
	*	\return a new condition representing the logical AND of the operand condition with this object. */
	ConditionalExpression	operator &&(ConditionalExpression const & in_operand2) const;


	/*! A NOT condition is satisfied if its operand condition is not satisfied.
	 *	\param in_operand The condition operand.
	 *	\return a new condition representing the logical negation of the operand.  */
	static ConditionalExpression NOT(ConditionalExpression const & in_operand);

	/*! An OR condition is satisfied if either of its operand conditions are satisfied.
	 *	\param in_operand1 The first condition operand.
	 *	\param in_operand2 The second condition operand.
	 *	\return a new condition representing the logical OR of the operand conditions. */
	static ConditionalExpression OR(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);


	/*! An XOR condition is satisfied if either operand condition is satisfied, but not both.
	 *	\param in_operand1 The first condition operand.
	 *	\param in_operand2 The second condition operand.
	 *	\return a new condition representing the logical XOR of the operand conditions. */
	static ConditionalExpression XOR(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An AND condition is satisfied if both of its operand conditions are satisfied.
	 *	\param in_operand1 The first condition operand.
	 *	\param in_operand2 The second condition operand.
	 *	\return a new condition representing the logical AND of the operand conditions. */
	static ConditionalExpression AND(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An EQ conditional expression is satisfied if its operand expressions are equal.
	*	\param in_operand1 The first condition operand.
	*	\param in_operand2 The second condition operand.
	*	\return a new conditional expression representing the equality comparison of the operand expressions. */
	static ConditionalExpression EQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An NEQ conditional expression is satisfied if its operand expressions are not equal.
	*	\param in_operand1 The first condition operand.
	*	\param in_operand2 The second condition operand.
	*	\return a new conditional expression representing the non-equality comparison of the operand expressions. */
	static ConditionalExpression NEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An GT conditional expression is satisfied if its second operand is greater than the first operand.
	*	\param in_operand1 The first condition operand.
	*	\param in_operand2 The second condition operand.
	*	\return a new conditional expression representing the greater than comparison of the operand expressions. */
	static ConditionalExpression GT(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An LT conditional expression is satisfied if its second operand is less than the first operand.
	*	\param in_operand1 The first condition operand.
	*	\param in_operand2 The second condition operand.
	*	\return a new conditional expression representing the less than comparison of the operand expressions. */
	static ConditionalExpression LT(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An GTEQ conditional expression is satisfied if its second operand is greater than or equal to the first operand.
	*	\param in_operand1 The first condition operand.
	*	\param in_operand2 The second condition operand.
	*	\return a new conditional expression representing the greater than or equal to comparison of the operands. */
	static ConditionalExpression GTEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	/*! An LTEQ conditional expression is satisfied if its second operand is less than or equal to the first operand.
	*	\param in_operand1 The first condition operand.
	*	\param in_operand2 The second condition operand.
	*	\return a new conditional expression representing the less than or equal to comparison of the operand expressions. */
	static ConditionalExpression LTEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	friend HPS_API ConditionalExpression NOT(ConditionalExpression const & in_operand);
	friend HPS_API ConditionalExpression OR(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression XOR(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression AND(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

	friend HPS_API ConditionalExpression EQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression NEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression GT(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression LT(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression GTEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
	friend HPS_API ConditionalExpression LTEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);
};


/*! A NOT condition is satisfied if its operand condition is not satisfied.
*	\param in_operand The condition operand.
*	\return a new condition representing the logical negation of the operand.  */
HPS_API ConditionalExpression	NOT(ConditionalExpression const & in_operand);

/*! An OR condition is satisfied if either of its operand conditions are satisfied.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new condition representing the logical OR of the operand conditions. */
HPS_API ConditionalExpression	OR(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An XOR condition is satisfied if either operand condition is satisfied, but not both.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new condition representing the logical XOR of the operand conditions. */
HPS_API ConditionalExpression	XOR(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An AND condition is satisfied if both of its operand conditions are satisfied.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new condition representing the logical AND of the operand conditions. */
HPS_API ConditionalExpression	AND(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An EQ conditional expression is satisfied if its operand expressions are equal.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new conditional expression representing the equality comparison of the operand expressions. */
HPS_API ConditionalExpression	EQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An NEQ conditional expression is satisfied if its operand expressions are not equal.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new conditional expression representing the non-equality comparison of the operand expressions. */
HPS_API ConditionalExpression	NEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An GT conditional expression is satisfied if its second operand is greater than the first operand.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new conditional expression representing the greater than comparison of the operand expressions. */
HPS_API ConditionalExpression	GT(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An LT conditional expression is satisfied if its second operand is less than the first operand.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new conditional expression representing the less than comparison of the operand expressions. */
HPS_API ConditionalExpression	LT(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An GTEQ conditional expression is satisfied if its second operand is greater than or equal to the first operand.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new conditional expression representing the greater than or equal to comparison of the operands. */
HPS_API ConditionalExpression	GTEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);

/*! An LTEQ conditional expression is satisfied if its second operand is less than or equal to the first operand.
*	\param in_operand1 The first condition operand.
*	\param in_operand2 The second condition operand.
*	\return a new conditional expression representing the less than or equal to comparison of the operand expressions. */
HPS_API ConditionalExpression	LTEQ(ConditionalExpression const & in_operand1, ConditionalExpression const & in_operand2);



/*! The Key class is the common base class of all Visualize keys. Keys are handles to database objects and are the primary way of interacting with them
	(you would never modify a database object directly). The underlying mechanism is a smart pointer (assignment operator works like regular pointers).
	Attempting to use a deleted or otherwise invalid key will result in an InvalidObjectException. */
class HPS_API Key : public Object
{
public:

	/*! An uninitialized key refers to no database object and Type() will return Type::None. */
	Key();

	/*! Shares a reference to a database object referred to by in_that. */
	Key(Key const & in_that);

	/*! Initializes a key associated to the Control in_control. */
	explicit Key(Control const & in_control);

	/*! The move constructor creates a Key by transferring the underlying impl of the rvalue reference to this Key
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a Key to take the impl from.*/
	Key(Key && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Key thereby avoiding a copy.
	* \param in_that An rvalue reference to an Key to take the impl from.
	* \return A reference to this Key. */
	Key & operator=(Key && in_that);

	/*! Releases a reference to this key, but it does not remove the key from the database. */
	virtual ~Key();

	static const HPS::Type staticType = HPS::Type::Key;
	HPS::Type	ObjectType() const {return staticType;};

	/*! \return Indicates whether this key has an owner or not. */
	bool				HasOwner() const;

	/*! \return The segment containing this key. */
	SegmentKey			Up() const;

	/*! \return The segment containing this key. */
	SegmentKey			Owner() const;

	/*! Removes the database object referred to by this key. */
	void				Delete();

	/*! Moves the database object referred to by this key into a new containing segment pointed to by in_new_owner. */
	void				MoveTo(SegmentKey const & in_new_owner);

	/*! Performs a deep copy of the database object referred to by this key into a segment pointed to by in_destination. If the copied key includes other keys or has child nodes, they will be recursively copied. Include links will also be copied, however, link targets will not be copied.
	 \return The key of the new copy. */
	Key					CopyTo(SegmentKey const & in_destination) const;

	/*! Share the underlying smart-pointer of the Key source.
	 *	\param in_that The Key source of the assignment.
	 *	\return A reference to this Key. */
	Key &				operator=(Key const & in_that);

	/*! Share the underlying smart-pointer of the Key source.
	 *	\param in_that The Key source of the assignment. */
	virtual void		Assign(Key const & in_that);

	/*! Determines whether the database objects pointed to by this key and in_that are the same. Empty keys (when key.Empty() returns true) are never equal to any key, even when the key is compared against itself (they act analogously to NaN comparisons in this case.) */
	bool				Equals(Key const & in_that) const;

	/*! Determines whether the database objects pointed to by this key and in_that are the same. */
	bool				operator!= (Key const & in_that) const;

	/*! Determines whether the database objects pointed to by this key and in_that are the same. */
	bool				operator== (Key const & in_that) const;

	/*! Returns a hash code for the key.
	\return The size_t hash code.  */
	size_t				GetHash() const;
};

/*!  A std::hash compatible hasher for HPS::Key */
struct KeyHasher {
	inline size_t operator()(const HPS::Key & in_key) const
	{
		return in_key.GetHash();
	}
};


/*! The SegmentKey class is a smart pointer to a database object.  Segments are the nodes in the scene graph.  They can
	contain attributes, geometry, or other segments, among other things. */
class HPS_API SegmentKey : public Key
{
public:
	/*! An uninitialized key refers to no database object and Type() will return Type::None. */
	SegmentKey();

	/*! Shares a reference to a database object referred to by in_that. */
	SegmentKey(SegmentKey const & in_that);

	/*! Copy assignment operator for SegmentKey */
	SegmentKey & operator=(SegmentKey const & other);

	/*! The move constructor creates a SegmentKey by transferring the underlying impl of the rvalue reference to this SegmentKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SegmentKey to take the impl from.*/
	SegmentKey(SegmentKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SegmentKey thereby avoiding a copy.
	* \param in_that An rvalue reference to a SegmentKey to take the impl from.
	* \return A reference to this SegmentKey. */
	SegmentKey & operator=(SegmentKey && in_that);

	/*! Shares a reference to a database object referred to by in_that. If the key assignment is invalid, this key will revert to an uninitialized state.  */
	explicit SegmentKey(Key const & in_that);

	/*! Releases a reference to a database object but does not destroy the database object. */
	~SegmentKey();

	static const HPS::Type staticType = HPS::Type::SegmentKey;
	HPS::Type								ObjectType() const {return staticType;};

	/*! Returns the name given to this segment when it was created. */
	UTF8									Name() const;

	/*! Sets the new name of this segment.
	 * \return A reference to this key */
	SegmentKey &							SetName(char const * in_name);

	/*! Returns the segment contained by this key with name of in_segment_name.  If the segment does not exist and the
		flag in_create_if_not_present is not set, the key returned will be uninitialized. */
	SegmentKey								Down(char const * in_segment_name, bool in_create_if_not_present = false) const;

	/*! Returns the segment contained by this key with name of in_segment_name. The segment will be created automatically
		if it does not exist. To prevent automatic segment creation, pass a value of false for in_create_not_present. */
	SegmentKey								Subsegment(char const * in_segment_name = "", bool in_create_if_not_present = true) const;

	/*! Searches in_search_space for in_type_to_remove and deletes all instances from the segment(s). */
	void									Flush(Search::Type in_type_to_remove = Search::Type::Everything, Search::Space in_search_space = Search::Space::SegmentOnly);

	/*! Searches in_search_space for in_types_to_remove and deletes all instances from the segment(s). */
	void									Flush(SearchTypeArray const & in_types_to_remove, Search::Space in_search_space = Search::Space::SegmentOnly);

	/*! Searches in_search_space for in_types_to_remove and deletes all instances from the segment(s). */
	void									Flush(size_t in_types_count, Search::Type const in_types_to_remove [], Search::Space in_search_space = Search::Space::SegmentOnly);



	/*! Searches in_search_space for in_request and returns a handle to the results. */
	size_t									Find(Search::Type in_request, Search::Space in_search_space, SearchResults & out_results) const;

	/*! Searches in_search_space for in_request and returns a handle to the results. */
	size_t									Find(SearchTypeArray const & in_requests, Search::Space in_search_space, SearchResults & out_results) const;

	/*! Searches in_search_space for in_request and returns a handle to the results. */
	size_t									Find(size_t in_types_count, Search::Type const in_requests [], Search::Space in_search_space, SearchResults & out_results) const;


	/*! Searches starting at this segment using in_options and writes found objects into out_results, returns count. */
	size_t									Find(SearchOptionsKit const & in_options, SearchResults & out_results) const;

	/*! Searches starting at this segment using in_options, returns count. */
	size_t									Find(SearchOptionsKit const & in_options) const;


	/*! Creates a link between this segment and in_seg, returns a handle to the include itself.  Included segments
		are treated like child segments for most operations including drawing.  */
	IncludeKey								IncludeSegment(SegmentKey const & in_seg);

	/*! Creates a link between this segment and in_seg, returns a handle to the include itself.  The link will only be
		applied if the condition is set in the draw path. Included segments are treated like child segments for most operations
		including drawing.  */
	IncludeKey								IncludeSegment(SegmentKey const & in_seg, ConditionalExpression const & in_conditional);


	/*! References either a geometry key or a segment key in this segment.  If the provided key is a geometry key, that geometry will be drawn as though it was in this segment.
	 *	If the provided key is a segment key, all geometry in that segment will be drawn as though they were in this segment, however no attributes, subsegments or geometry
	 *	in subsegments will be brought along (though attributes set directly on geometry within the segment will be preserved).
	 *	\param in_key A key to either a piece of geometry or a segment.
	 *	\return A reference to the newly created geometry reference. This will have a type of Type::None if geometry reference creation failed. */
	ReferenceKey							ReferenceGeometry(Key const & in_key);

	/*! Conditionally references either a geometry key or a segment key in this segment.  If the provided key is a geometry key, that geometry will be drawn as though it was in this segment.
	 *	If the provided key is a segment key, all geometry in that segment will be drawn as though they were in this segment, however no attributes, subsegments or geometry
	 *	in subsegments will be brought along (though attributes set directly on geometry within the segment will be preserved).  The referenced geometry will only get drawn in this segment
	 *	if a condition is set above the geometry reference satisfying the provided condition.
	 *	\param in_key A key to either a piece of geometry or a segment.
	 *	\param in_conditional A conditional expression which will determine whether the referenced geometry gets drawn for this segment.
	 *	\return A reference to the newly created geometry reference. This will have a type of Type::None if geometry reference creation failed. */
	ReferenceKey							ReferenceGeometry(Key const & in_key, ConditionalExpression const & in_conditional);


	/*! \return A count of all child segments of this segment */
	size_t									ShowSubsegments() const;

	/*! \return A count of all child segments of this segment and populates out_children with keys to them. */
	size_t									ShowSubsegments(SegmentKeyArray & out_children) const;

	/*! Shows the all the segments which contain references to this key.  Note that while a segment may only appear once in the returned array, that segment could have multiple references to this key.
	 *	\param out_segments The list of segments which contains references to this key.
	 *	\return The number of segments which contain references to this key. */
	size_t									ShowReferrers(SegmentKeyArray & out_segments) const;

	/*! Shows the all the references to this key.
	 *	\param out_references The list of all references to this key.
	 *	\return The number of references to this key. */
	size_t									ShowReferrers(ReferenceKeyArray & out_references) const;

	/*! Shows the all the segments which are styled by this key.  Note that while a segment may only appear once in the returned array, that segment could have multiple styles which refer to this key.
	 *	\param out_segments The list of segments which are styled by this key.
	 *	\return The number of segments which are styled by this key. */
	size_t									ShowStylers(SegmentKeyArray & out_segments) const;

	/*! Shows the all the styles which refer to this key.
	 *	\param out_styles The list of all styles which refer to this key.
	 *	\return The number of styles which refer to this key. */
	size_t									ShowStylers(StyleKeyArray & out_styles) const;

	/*! Shows the all the segments which contain includes of this key.
	 *	\param out_segments The list of segments which contains includes of this key.
	 *	\return The number of segments which contain includes of this key. */
	size_t									ShowIncluders(SegmentKeyArray & out_segments) const;

	/*! Shows the all the includes of this key.
	 *	\param out_includes The list of all includes of this key.
	 *	\return The number of includes of this key. */
	size_t									ShowIncluders(IncludeKeyArray & out_includes) const;



	/*! \return A control that allows the user to manipulate and query details of styles on this segment. */
	StyleControl							GetStyleControl();

	/*! \return A control that allows the user to manipulate and query details of styles on this segment. */
	StyleControl const						GetStyleControl() const;


	/*! \return A control that allows the user to manipulate and query portfolios in use on this segment. */
	PortfolioControl						GetPortfolioControl();

	/*! \return A control that allows the user to manipulate and query portfolios in use on this segment. */
	PortfolioControl const					GetPortfolioControl() const;


	/*! Sets in_condition as the only condition on this segment, replacing any existing conditions. */
	SegmentKey &							SetCondition(char const * in_condition);

	/*! Sets in_conditions as the only conditions on this segment, replacing any existing conditions. */
	SegmentKey &							SetConditions(UTF8Array const & in_conditions);

	/*! Sets in_conditions as the only conditions on this segment, replacing any existing conditions. */
	SegmentKey &							SetConditions(size_t in_count, UTF8 const in_conditions []);

	/*! Unsets all conditions on this segment. */
	SegmentKey &							UnsetConditions();

	/*! Shows all conditions on this segment. */
	bool									ShowConditions(UTF8Array & out_conditions) const;

	/*! \return A control that allows the user to manipulate and query details of conditions on this segment. */
	ConditionControl						GetConditionControl();

	/*! \return A control that allows the user to manipulate and query details of conditions on this segment. */
	ConditionControl const					GetConditionControl() const;


	/*! Applies the material palette associated with in_name to this segment, replacing any existing material palette. */
	SegmentKey &							SetMaterialPalette(char const * in_name);

	/*! Removes the existing material palette, if any, that is active on this segment. */
	SegmentKey &							UnsetMaterialPalette();

	/*! Shows the existing material palette, if any, that is active on this segment. */
	bool									ShowMaterialPalette(UTF8 & out_name) const;


	/*!	Assigns a specific drawing priority value to this segment.  It affects the order in which the segment is visited
	 *	if and only if the rendering algorithm is set to Priority.
	 *  Segments have a default drawing priority assigned, based on the order that they were created.
	 *	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	 *	\return A reference to this object.
	 *	\sa SubwindowKit::SetRenderingAlgorithm() */
	SegmentKey &							SetPriority(int in_priority);

	/*!	Removes the drawing priority setting.
	 *	\return A reference to this object. */
	SegmentKey &							UnsetPriority();

	/*! Shows the drawing priority.
	 *	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	 *	\return <span class='code'>true</span> if a priority was specified, <span class='code'>false</span> otherwise. */
	bool									ShowPriority(int & out_priority) const;

	/*! Sets user data on this key.
	  *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this key. */
	SegmentKey &							SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Sets user data on this key.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this key. */
	SegmentKey &							SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this key.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this key. */
	SegmentKey &							SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Removes the user data at the given index from this key.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this key. */
	SegmentKey &							UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this key.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this key. */
	SegmentKey &							UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this key.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this key. */
	SegmentKey &							UnsetUserData(HPS::IntPtrTArray const & in_indices);

	/*! Removes all user data from this key.
	 *	\return A reference to this key. */
	SegmentKey &							UnsetAllUserData();

	/*! Get the number of user data indices set on this key. */
	size_t									ShowUserDataCount() const;

	/*! Shows all user data for this key.
	 *	\param out_indices An array of all user data indices set on this key.
	 *	\param out_data An array of all user data set on this key.
	 *	\return <span class='code'>true</span> if there is user data on this key, <span class='code'>false</span> otherwise. */
	bool									ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;

	/*! Shows the indices of all user data set on this key.
	 *	\param out_indices The user data indices set on this key.
	 *	\return The number of user data indices set on this key. */
	bool									ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this key.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool									ShowUserData(intptr_t in_index, ByteArray & out_data) const;


	/*! Creates a new line geometry in this segment and returns a key to it. */
	LineKey									InsertLine(LineKit const & in_kit);

	/*! Creates a new line geometry in this segment and returns a key to it. */
	LineKey									InsertLine(size_t in_count, Point const in_pts[]);

	/*! Creates a new line geometry in this segment and returns a key to it. */
	LineKey									InsertLine(PointArray const & in_pts);

	/*! Creates a new line geometry in this segment and returns a key to it. */
	LineKey									InsertLine(Point const & pt1, Point const & pt2);


	/*! Creates a new cylinder geometry in this segment and returns a key to it. */
	CylinderKey								InsertCylinder(CylinderKit const & in_kit);

	/*! Creates a new cylinder geometry in this segment and returns a key to it. */
	CylinderKey								InsertCylinder(size_t in_pcount, Point const in_points[], size_t in_rcount, float const in_radii [], Cylinder::Capping in_caps = Cylinder::Capping::Both);

	/*! Creates a new cylinder geometry in this segment and returns a key to it. */
	CylinderKey								InsertCylinder(PointArray const & in_points, FloatArray const & in_radii, Cylinder::Capping in_caps = Cylinder::Capping::Both);

	/*! Creates a new cylinder geometry in this segment and returns a key to it. */
	CylinderKey								InsertCylinder(Point const & in_point1, Point const & in_point2, float in_radius, Cylinder::Capping in_caps = Cylinder::Capping::Both);


	/*! Creates a new sphere geometry in this segment and returns a key to it.
		\param in_kit The SphereKit that will define the sphere
		\return The reference to the newly created sphere. Will have a type of Type::None if sphere insertion failed
	*/
	SphereKey								InsertSphere(SphereKit const & in_kit);

	/*! Creates a new sphere geometry in this segment and returns a key to it.
		\param in_center The Point that will define the center of the sphere
		\param in_radius The radius of the sphere
		\param in_axis The Vector that will define the axis of the sphere
		\param in_prime_meridian The Vector that will define the orientation of the sphere (as rotated on its axis)
		\return The reference to the newly created sphere. Will have a type of Type::None if sphere insertion failed
	*/
	SphereKey								InsertSphere(Point const & in_center, float in_radius, Vector const & in_axis = Vector(0, 1, 0), Vector const & in_prime_meridian = Vector(1, 0, 0));

	/*! Creates a new circle geometry in this segment and returns a key to it. */
	CircleKey								InsertCircle(CircleKit const & in_kit);

	/*! Creates a new circle geometry in this segment and returns a key to it. */
	CircleKey								InsertCircle(Point const & in_start, Point const & in_middle, Point const & in_end);

	/*! Creates a new circle geometry in this segment and returns a key to it. */
	CircleKey								InsertCircle(Point const & in_center, float in_radius, Vector const & in_normal);


	/*! Creates a new circular arc geometry in this segment and returns a key to it. */
	CircularArcKey							InsertCircularArc(CircularArcKit const & in_kit);

	/*! Creates a new circular arc geometry in this segment and returns a key to it. */
	CircularArcKey							InsertCircularArc(Point const & in_start, Point const & in_middle, Point const & in_end);


	/*! Creates a new circular wedge geometry in this segment and returns a key to it. */
	CircularWedgeKey						InsertCircularWedge(CircularWedgeKit const & in_kit);

	/*! Creates a new circular wedge geometry in this segment and returns a key to it. */
	CircularWedgeKey						InsertCircularWedge(Point const & in_start, Point const & in_middle, Point const & in_end);


	/*! Creates a new ellipse geometry in this segment and returns a key to it. */
	EllipseKey								InsertEllipse(EllipseKit const & in_kit);

	/*! Creates a new ellipse geometry in this segment and returns a key to it. */
	EllipseKey								InsertEllipse(Point const & in_center, Point const & in_major, Point const & in_minor);


	/*! Creates a new elliptical arc geometry in this segment and returns a key to it. */
	EllipticalArcKey						InsertEllipticalArc(EllipticalArcKit const & in_kit);

	/*! Creates a new elliptical arc geometry in this segment and returns a key to it. */
	EllipticalArcKey						InsertEllipticalArc(Point const & in_center, Point const & in_major, Point const & in_minor, float in_start, float in_end);


	/*! Creates a new polygon geometry in this segment and returns a key to it. */
	PolygonKey								InsertPolygon(PolygonKit const & in_kit);

	/*! Creates a new polygon geometry in this segment and returns a key to it. */
	PolygonKey								InsertPolygon(PointArray const & in_points);

	/*! Creates a new polygon geometry in this segment and returns a key to it. */
	PolygonKey								InsertPolygon(size_t in_count, Point const in_points []);


	/*! Creates a new shell geometry in this segment and returns a key to it. */
	ShellKey								InsertShell(ShellKit const & in_kit);

	/*! Creates a new shell geometry in this segment and returns a key to it. */
	ShellKey								InsertShell(PointArray const & in_points, IntArray const & in_facelist);

	/*! Creates a new shell geometry in this segment and returns a key to it. */
	ShellKey								InsertShell(size_t in_point_count, Point const in_points [], size_t in_facelist_count, int const in_facelist []);

	/*! Creates a new shell geometry in this segment and then returns a key to it.
	*
	* \param in_points An array of HPS::Point that will serve as vertices in the tri-strip.
	* \param in_tristrips An array of integers that designates the order of the vertices. The first number indicates the number of vertices in a tri-strip. For example, the following declaration specifies two tri-strips, the first with three vertices and the second with five: IntArray triStripIndex = { 3, 0, 1, 2, 5, 3, 4, 5, 6, 7 };
	*
	* \snippet 00700_insert_shell_by_tristrips.cpp shell_by_tristrips
	*/
	ShellKey								InsertShellByTristrips(PointArray const & in_points, IntArray const & in_tristrips);

	/*! Creates a new shell geometry in this segment and returns a key to it. */
	ShellKey								InsertShellByTristrips(size_t in_point_count, Point const in_points [], size_t in_tristrips_count, int const in_tristrips []);

	/*! Creates a new mesh geometry in this segment and returns a key to it. */
	MeshKey									InsertMesh(MeshKit const & in_kit);

	/*! Creates a new mesh geometry in this segment and returns a key to it. */
	MeshKey									InsertMesh(size_t in_rows, size_t in_columns, PointArray const & in_points);

	/*! Creates a new mesh geometry in this segment and returns a key to it. */
	MeshKey									InsertMesh(size_t in_rows, size_t in_columns, size_t in_point_count, Point const in_points []);


	/*! Creates a new marker geometry in this segment and returns a key to it. */
	MarkerKey								InsertMarker(Point const & in_position);

	/*! Creates a new marker geometry in this segment and returns a key to it. */
	MarkerKey								InsertMarker(MarkerKit const & in_kit);


	/*! Creates a new distant light geometry in this segment and returns a key to it. */
	DistantLightKey							InsertDistantLight(Vector const & in_direction);

	/*! Creates a new distant light geometry in this segment and returns a key to it. */
	DistantLightKey							InsertDistantLight(DistantLightKit const & in_kit);


	/*! Creates a new cutting section in this segment and returns a key to it. */
	CuttingSectionKey						InsertCuttingSection(Plane const & in_plane);

	/*! Creates a new cutting section in this segment and returns a key to it. */
	CuttingSectionKey						InsertCuttingSection(CuttingSectionKit const & in_kit);

	/*! Creates a new cutting section in this segment and returns a key to it. */
	CuttingSectionKey						InsertCuttingSection(PlaneArray const & in_planes);

	/*! Creates a new cutting section in this segment and returns a key to it. */
	CuttingSectionKey						InsertCuttingSection(size_t in_planes_count, Plane const in_planes []);


	/*! Creates a new infinite line geometry in this segment and returns a key to it. */
	InfiniteLineKey							InsertInfiniteLine(InfiniteLineKit const & in_kit);

	/*! Creates a new infinite line geometry in this segment and returns a key to it. */
	InfiniteLineKey							InsertInfiniteLine(Point const & in_first, Point const & in_second, InfiniteLine::Type in_type);


	/*! Creates a new spot light geometry in this segment and returns a key to it. */
	SpotlightKey							InsertSpotlight(Point const & in_position, Point const & in_target);

	/*! Creates a new spot light geometry in this segment and returns a key to it. */
	SpotlightKey							InsertSpotlight(SpotlightKit const & in_kit);


	/*! Creates a new NURBS curve geometry in this segment and returns a key to it. */
	NURBSCurveKey							InsertNURBSCurve(NURBSCurveKit const & in_kit);

	/*! Creates a new NURBS curve geometry in this segment and returns a key to it. */
	NURBSCurveKey							InsertNURBSCurve(size_t in_degree, PointArray const & in_points, FloatArray const & in_weights, FloatArray const & in_knots, float in_start_u, float in_end_u);

	/*! Creates a new NURBS curve geometry in this segment and returns a key to it. */
	NURBSCurveKey							InsertNURBSCurve(size_t in_degree, size_t in_pcount, Point const in_points [], float const in_weights[], size_t in_knot_count, float const in_knots[], float in_start_u, float in_end_u);


	/*! Creates a new NURBS surface geometry in this segment and returns a key to it. */
	NURBSSurfaceKey							InsertNURBSSurface(NURBSSurfaceKit const & in_kit);

	/*! Creates a new NURBS surface geometry in this segment and returns a key to it. */
	NURBSSurfaceKey							InsertNURBSSurface(size_t in_udegree, size_t in_vdegree, size_t in_ucount, size_t in_vcount, PointArray const & in_points, FloatArray const & in_weights, FloatArray const & in_uknots, FloatArray const & in_vknots);

	/*! Creates a new NURBS surface geometry in this segment and returns a key to it. */
	NURBSSurfaceKey							InsertNURBSSurface(size_t in_udegree, size_t in_vdegree, size_t in_ucount, size_t in_vcount, size_t in_point_count, Point const in_points[], float const in_weights[], size_t in_uknot_count, float const in_uknots[], size_t in_vknot_count, float const in_vknots[]);

	/*! Creates a new NURBS surface geometry in this segment and returns a key to it. */
	NURBSSurfaceKey							InsertNURBSSurface(size_t in_udegree, size_t in_vdegree, size_t in_ucount, size_t in_vcount, PointArray const & in_points, FloatArray const & in_weights, FloatArray const & in_uknots, FloatArray const & in_vknots, TrimKitArray const & in_trims);

	/*! Creates a new NURBS surface geometry in this segment and returns a key to it. */
	NURBSSurfaceKey							InsertNURBSSurface(size_t in_udegree, size_t in_vdegree, size_t in_ucount, size_t in_vcount, size_t in_point_count, Point const in_points[], float const in_weights[], size_t in_uknot_count, float const in_uknots[], size_t in_vknot_count, float const in_vknots[], size_t in_trim_count, TrimKit const in_trims[]);


	/*! Creates a new text geometry in this segment and returns a key to it. */
	TextKey									InsertText(TextKit const & in_kit);

	/*! Creates a new text geometry in this segment and returns a key to it.
		\param in_position The position, in world coordinates, where the text will be inserted.
		\param in_text The text UTF-8 encoded string to insert.
		\return A reference to the newly created TextKey object.  Will have a type of Type::None if line insertion failed. */
	TextKey									InsertText(Point const & in_position, char const * in_text);



	/*! Creates a new grid in this segment and returns a key to it. */
	GridKey									InsertGrid(GridKit const & in_kit);

	/*! Creates a new grid in this segment and returns a key to it. */
	GridKey									InsertGrid(Point const & in_origin, Point const & in_first_point = Point(1, 0, 0), Point const & in_second_point = Point(0, 1, 0), int in_first_count = 0, int in_second_count = 0, Grid::Type in_type = Grid::Type::Quadrilateral);



	/*! Creates a new line geometry in this segment which approximates the given circle and returns a key to it.
		\param in_circle The CircleKey that will be used to compute the line approximation.
		\param in_deviation The distance in object space from the line approximation to the circle.
							Default value is <span class='code'>-1.0f</span>, which tells Visualize to compute a deviation based on the bounding
							volume of the circle.
		\return The reference to the newly created line. Will have a type of Type::None if line insertion failed. */
	LineKey									InsertLineFromGeometry(CircleKey const & in_circle, float in_deviation = -1.0f);

	/*! Creates a new line geometry in this segment which approximates the given circular arc and returns a key to it.
		\param in_circular_arc The CircularArcKey that will be used to compute the line approximation.
		\param in_deviation The distance in object space from the line approximation to the circular arc.
							Default value is <span class='code'>-1.0f</span>, which tells Visualize to compute a deviation based on the bounding
							volume of the circular arc.
		\return The reference to the newly created line. Will have a type of Type::None if line insertion failed.
	*/
	LineKey									InsertLineFromGeometry(CircularArcKey const & in_circular_arc, float in_deviation = -1.0f);

	/*! Creates a new line geometry in this segment which approximates the given circular wedge and returns a key to it.
		\param in_circular_wedge The CircularWedgeKey that will be used to compute the line approximation.
		\param in_deviation The distance in object space from the line approximation to the circular wedge.
							Default value is <span class='code'>-1.0f</span>, which tells Visualize to compute a deviation based on the bounding
							volume of the circular wedge.
		\return The reference to the newly created line. Will have a type of Type::None if line insertion failed.
	*/
	LineKey									InsertLineFromGeometry(CircularWedgeKey const & in_circular_wedge, float in_deviation = -1.0f);

	/*! Creates a new line geometry in this segment which approximates the given ellipse and returns a key to it.
		\param in_ellipse The EllipseKey that will be used to compute the line approximation.
		\param in_deviation The distance in object space from the line approximation to the ellipse.
							Default value is <span class='code'>-1.0f</span>, which tells Visualize to compute a deviation based on the bounding
							volume of the ellipse.
		\return The reference to the newly created line. Will have a type of Type::None if line insertion failed.
	*/
	LineKey									InsertLineFromGeometry(EllipseKey const & in_ellipse, float in_deviation = -1.0f);

	/*! Creates a new line geometry in this segment which approximates the given elliptical arc and returns a key to it.
		\param in_elliptical_arc The EllipticalArcKey that will be used to compute the line approximation.
		\param in_deviation The distance in object space from the line approximation to the elliptical arc.
							Default value is <span class='code'>-1.0f</span>, which tells Visualize to compute a deviation based on the bounding
							volume of the elliptical arc.
		\return The reference to the newly created line. Will have a type of Type::None if line insertion failed.
	*/
	LineKey									InsertLineFromGeometry(EllipticalArcKey const & in_elliptical_arc, float in_deviation = -1.0f);

	/*! Creates a new line geometry in this segment which approximates the given NURBS curve and returns a key to it.
		\param in_nurbs_curve The NURBSCurveKey that will be used to compute the line approximation.
		\param in_deviation The distance in object space from the line approximation to the NURBS curve.
							Default value is <span class='code'>-1.0f</span>, which tells Visualize to compute a deviation based on the bounding
							volume of the NURBS curve.
		\return The reference to the newly created line. Will have a type of Type::None if line insertion failed.
	*/
	LineKey									InsertLineFromGeometry(NURBSCurveKey const & in_nurbs_curve, float in_deviation = -1.0f);

	/*! Creates a new shell geometry in this segment which approximates the given sphere and returns a key to it.
		\param in_sphere The SphereKey that will be used to compute the shell approximation.
		\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(SphereKey const & in_sphere);

	/*! Creates a new shell geometry in this segment which approximates the given cylinder and returns a key to it.
		\param in_cylinder The CylinderKey that will be used to compute the shell approximation.
		\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(CylinderKey const & in_cylinder);

	/*! Creates a new shell geometry in this segment which approximates the given NURBS surface and returns a key to it.
		\param in_nurbs_surface The NURBSSurfaceKey that will be used to compute the shell approximation.
		\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(NURBSSurfaceKey const & in_nurbs_surface);

	/*! Creates a new shell geometry in this segment which approximates the given mesh and returns a key to it.
		\param in_mesh The MeshKey that will be used to compute the shell approximation.
		\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(MeshKey const & in_mesh);

	/*! Creates a new shell geometry in this segment which approximates the given polygon and returns a key to it.
		\param in_polygon The PolygonKey that will be used to compute the shell approximation.
		\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(PolygonKey const & in_polygon);

	/*! Creates a new shell geometry in this segment which approximates the given ellipse and returns a key to it.
	\param in_ellipse The EllipseKey that will be used to compute the shell approximation.
	\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(EllipseKey const & in_ellipse);

	/*! Creates a new shell geometry in this segment which approximates the given circle and returns a key to it.
	\param in_circle The CircleKey that will be used to compute the shell approximation.
	\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(CircleKey const & in_circle);

	/*! Creates a new shell geometry in this segment which approximates the given circular wedge and returns a key to it.
	\param in_circular_wedge The CircularWedgeKey that will be used to compute the shell approximation.
	\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(CircularWedgeKey const & in_circular_wedge);

	/*! Creates a new shell geometry in this segment which approximates the given text and returns a key to it. The text must be inserted into the window segment in order for this call to succeed.
		\param in_text The TextKey that will be used to compute the shell approximation.
		\return The reference to the newly created shell. Will have a type of Type::None if shell insertion failed.
	*/
	ShellKey								InsertShellFromGeometry(TextKey const & in_text);


	/*! Sets the attribute locks designated by in_kit on this segment. */
	SegmentKey &							SetAttributeLock(AttributeLockKit const & in_kit);

	/*! Removes all attribute locks settings from this segment. */
	SegmentKey &							UnsetAttributeLock();

	/*! Shows the attribute locks settings on this segment.
	\return False if no attribute locks settings exist on this segment.
	*/
	bool									ShowAttributeLock(AttributeLockKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the attribute locks on this segment. */
	AttributeLockControl					GetAttributeLockControl();

	/*! Returns a control that allows the user to manipulate and query details of the attribute locks on this segment. */
	AttributeLockControl const				GetAttributeLockControl() const;


	/*! Sets the bounding designated by in_kit on this segment. */
	SegmentKey &							SetBounding(BoundingKit const & in_kit);

	/*! Removes all bounding settings from this segment. */
	SegmentKey &							UnsetBounding();

	/*! Shows the bounding or bounding settings on this segment.
	\return False if no bounding or bounding settings on this segment.
	*/
	bool									ShowBounding(BoundingKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the bounding control on this segment. */
	BoundingControl							GetBoundingControl();

	/*! Returns a control that allows the user to manipulate and query details of the bounding control on this segment. */
	BoundingControl const					GetBoundingControl() const;


	/*! Sets the camera attribute designated by in_kit on this segment. */
	SegmentKey &							SetCamera(CameraKit const & in_kit);

	/*! Removes any camera set on this segment. */
	SegmentKey &							UnsetCamera();

	/*! Shows the camera attribute settings on this segment.  Returns <span class='code'>false</span> if no camera is set on this segment. */
	bool									ShowCamera(CameraKit & out_kit) const;

	/*! \return A control that allows the user to manipulate and query details of the camera attribute on this segment. */
	CameraControl							GetCameraControl();

	/*! \return A control that allows the user to manipulate and query details of the camera attribute on this segment. */
	CameraControl const						GetCameraControl() const;


	/*! Sets the color interpolation attributes designated by in_kit on this segment. */
	SegmentKey &							SetColorInterpolation(ColorInterpolationKit const & in_kit);

	/*! Removes any color interpolation attributes set on this segment. */
	SegmentKey &							UnsetColorInterpolation();

	/*! Shows the color interpolation attribute settings on this segment.  Returns <span class='code'>false</span> if no color interpolation attribute settings exist on this segment. */
	bool									ShowColorInterpolation(ColorInterpolationKit & out_kit) const;

	/*! \return A control that allows the user to manipulate and query details of the color interpolation attributes on this segment. */
	ColorInterpolationControl				GetColorInterpolationControl();

	/*! \return A control that allows the user to manipulate and query details of the color interpolation attributes on this segment. */
	ColorInterpolationControl const			GetColorInterpolationControl() const;


	/*! Sets the contour line attributes designated by in_kit on this segment. */
	SegmentKey &							SetContourLine(ContourLineKit const & in_kit);

	/*! Removes any contour line attributes set on this segment. */
	SegmentKey &							UnsetContourLine();

	/*! Shows the contour line attribute settings on this segment.  Returns <span class='code'>false</span> if no contour line attribute settings exist on this segment. */
	bool									ShowContourLine(ContourLineKit & out_kit) const;

	/*! \return A control that allows the user to manipulate and query details of the contour line attributes on this segment. */
	ContourLineControl						GetContourLineControl();

	/*! \return A control that allows the user to manipulate and query details of the contour line attributes on this segment. */
	ContourLineControl const				GetContourLineControl() const;


	/*! Sets the culling attributes designated by in_kit on this segment. */
	SegmentKey &							SetCulling(CullingKit const & in_kit);

	/*! Removes all culling attribute settings from this segment. */
	SegmentKey &							UnsetCulling();

	/*! Shows the culling attribute settings on this segment.
	\return False if no culling attribute settings exist on this segment.
	*/
	bool									ShowCulling(CullingKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the culling attribute on this segment. */
	CullingControl							GetCullingControl();

	/*! Returns a control that allows the user to manipulate and query details of the culling attribute on this segment. */
	CullingControl const					GetCullingControl() const;


	/*! Sets the curve attributes designated by in_kit on this segment. */
	SegmentKey &							SetCurveAttribute(CurveAttributeKit const & in_kit);

	/*! Removes all curve attribute settings from this segment. */
	SegmentKey &							UnsetCurveAttribute();

	/*! Shows the curve attribute settings on this segment.  Returns <span class='code'>false</span> if no curve attribute settings exist on this segment. */
	bool									ShowCurveAttribute(CurveAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the curve attribute on this segment. */
	CurveAttributeControl					GetCurveAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the curve attribute on this segment. */
	CurveAttributeControl const				GetCurveAttributeControl() const;


	/*! Sets the cutting section attributes designated by in_kit on this segment. */
	SegmentKey &							SetCuttingSectionAttribute(CuttingSectionAttributeKit const & in_kit);

	/*! Removes all cutting section attribute settings from this segment. */
	SegmentKey &							UnsetCuttingSectionAttribute();

	/*! Shows the cutting section attribute settings on this segment.  Returns <span class='code'>false</span> if no cutting section attribute settings exist on this segment. */
	bool									ShowCuttingSectionAttribute(CuttingSectionAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the cutting section attributes on this segment. */
	CuttingSectionAttributeControl			GetCuttingSectionAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the cutting section attributes on this segment. */
	CuttingSectionAttributeControl const	GetCuttingSectionAttributeControl() const;


	/*! Sets the cylinder attributes designated by in_kit on this segment. */
	SegmentKey &							SetCylinderAttribute(CylinderAttributeKit const & in_kit);

	/*! Removes all cylinder attribute settings from this segment. */
	SegmentKey &							UnsetCylinderAttribute();

	/*! Shows the cylinder attribute settings on this segment.  Returns <span class='code'>false</span> if no cylinder attribute settings exist on this segment. */
	bool									ShowCylinderAttribute(CylinderAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the cylinder attribute on this segment. */
	CylinderAttributeControl				GetCylinderAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the cylinder attribute on this segment. */
	CylinderAttributeControl const			GetCylinderAttributeControl() const;


	/*! Sets the drawing attributes designated by in_kit on this segment. */
	SegmentKey &							SetDrawingAttribute(DrawingAttributeKit const & in_kit);

	/*! Removes all drawing settings from this segment. */
	SegmentKey &							UnsetDrawingAttribute();

	/*! Shows the drawing attribute settings on this segment.  Returns <span class='code'>false</span> if no drawing settings exist on this segment. */
	bool									ShowDrawingAttribute(DrawingAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the drawing attribute on this segment. */
	DrawingAttributeControl					GetDrawingAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the drawing attribute on this segment. */
	DrawingAttributeControl const			GetDrawingAttributeControl() const;


	/*! Sets the edge attributes designated by in_kit on this segment. */
	SegmentKey &							SetEdgeAttribute(EdgeAttributeKit const & in_kit);

	/*! Removes all edge attribute settings from this segment. */
	SegmentKey &							UnsetEdgeAttribute();

	/*! Shows the edge attribute settings on this segment.  Returns <span class='code'>false</span> if no edge attribute settings exist on this segment. */
	bool									ShowEdgeAttribute(EdgeAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the edge attribute on this segment. */
	EdgeAttributeControl					GetEdgeAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the edge attribute on this segment. */
	EdgeAttributeControl const				GetEdgeAttributeControl() const;


	/*! Sets the hidden line attributes designated by in_kit on this segment. */
	SegmentKey &							SetHiddenLineAttribute(HiddenLineAttributeKit const & in_kit);

	/*! Removes all hidden line settings from this segment. */
	SegmentKey &							UnsetHiddenLineAttribute();

	/*! Shows the hidden line attribute settings on this segment.  Returns <span class='code'>false</span> if no hidden line settings exist on this segment. */
	bool									ShowHiddenLineAttribute(HiddenLineAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the hidden line attribute on this segment. */
	HiddenLineAttributeControl				GetHiddenLineAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the hidden line attribute on this segment. */
	HiddenLineAttributeControl const		GetHiddenLineAttributeControl() const;


	/*! Sets the lighting attributes designated by in_kit on this segment. */
	SegmentKey &							SetLightingAttribute(LightingAttributeKit const & in_kit);

	/*! Removes all lighting attribute settings from this segment. */
	SegmentKey &							UnsetLightingAttribute();

	/*! Shows the lighting attribute settings on this segment.  Returns <span class='code'>false</span> if no lighting attribute settings exist on this segment. */
	bool									ShowLightingAttribute(LightingAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the lighting attribute on this segment. */
	LightingAttributeControl				GetLightingAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the lighting attribute on this segment. */
	LightingAttributeControl const			GetLightingAttributeControl() const;


	/*! Sets the line attributes designated by in_kit on this segment. */
	SegmentKey &							SetLineAttribute(LineAttributeKit const & in_kit);

	/*! Removes all line attribute settings from this segment. */
	SegmentKey &							UnsetLineAttribute();

	/*! Shows the line attribute settings on this segment.  Returns <span class='code'>false</span> if no line attribute settings exist on this segment. */
	bool									ShowLineAttribute(LineAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the line attribute on this segment. */
	LineAttributeControl					GetLineAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the line attribute on this segment. */
	LineAttributeControl const				GetLineAttributeControl() const;


	/*! Sets the material mappings designated by in_kit on this segment. */
	SegmentKey &							SetMaterialMapping(MaterialMappingKit const & in_kit);

	/*! Removes all material mapping settings from this segment. */
	SegmentKey &							UnsetMaterialMapping();

	/*! Shows the material mapping settings on this segment.  Returns <span class='code'>false</span> if no material mapping settings exist on this segment. */
	bool									ShowMaterialMapping(MaterialMappingKit & out_kit) const;

	/*! Sets a PBR material designated by in_kit on this segment. */
	SegmentKey &							SetPBRMaterial(PBRMaterialKit const & in_kit);

	/*! Removes all PBR material settings from this segment. */
	SegmentKey &							UnsetPBRMaterial();

	/*! Shows the PBR material settings on this segment.  Returns <span class='code'>false</span> if no PBR material settings exist on this segment. */
	bool									ShowPBRMaterial(PBRMaterialKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the material mapping on this segment. */
	MaterialMappingControl					GetMaterialMappingControl();

	/*! Returns a control that allows the user to manipulate and query details of the material mapping on this segment. */
	MaterialMappingControl const			GetMaterialMappingControl() const;


	/*! Sets the marker attributes designated by in_kit on this segment. */
	SegmentKey &							SetMarkerAttribute(MarkerAttributeKit const & in_kit);

	/*! Removes all marker attribute settings from this segment. */
	SegmentKey &							UnsetMarkerAttribute();

	/*! Shows the marker attribute settings on this segment.  Returns <span class='code'>false</span> if no marker attribute settings exist on this segment. */
	bool									ShowMarkerAttribute(MarkerAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the marker attribute on this segment. */
	MarkerAttributeControl					GetMarkerAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the marker attribute on this segment. */
	MarkerAttributeControl const			GetMarkerAttributeControl() const;


	/*! Sets the modelling matrix attributes designated by in_kit on this segment. */
	SegmentKey &							SetModellingMatrix(MatrixKit const & in_kit);

	/*! Removes any modelling matrix settings from this segment. */
	SegmentKey &							UnsetModellingMatrix();

	/*! Shows the modelling matrix setting on this segment.  Returns <span class='code'>false</span> if no modelling matrix setting exists on this segment. */
	bool									ShowModellingMatrix(MatrixKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the modelling matrix on this segment. */
	ModellingMatrixControl					GetModellingMatrixControl();

	/*! Returns a control that allows the user to manipulate and query details of the modelling matrix on this segment. */
	ModellingMatrixControl const			GetModellingMatrixControl() const;


	/*! Sets the NURBS surface attributes designated by in_kit on this segment. */
	SegmentKey &							SetNURBSSurfaceAttribute(NURBSSurfaceAttributeKit const & in_kit);

	/*! Removes all NURBS surface attribute settings from this segment. */
	SegmentKey &							UnsetNURBSSurfaceAttribute();

	/*! Shows the NURBS surface attribute settings on this segment.  Returns <span class='code'>false</span> if no NURBS surface attribute settings exist on this segment. */
	bool									ShowNURBSSurfaceAttribute(NURBSSurfaceAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the NURBS surface attribute on this segment. */
	NURBSSurfaceAttributeControl			GetNURBSSurfaceAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the NURBS surface attribute on this segment. */
	NURBSSurfaceAttributeControl const		GetNURBSSurfaceAttributeControl() const;


	/*! Sets the performance attributes designated by in_kit on this segment. */
	SegmentKey &							SetPerformance(PerformanceKit const & in_kit);

	/*! Removes all performance settings from this segment. */
	SegmentKey &							UnsetPerformance();

	/*! Shows the performance attribute settings on this segment.  Returns <span class='code'>false</span> if no performance settings exist on this segment. */
	bool									ShowPerformance(PerformanceKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the performance attribute on this segment. */
	PerformanceControl						GetPerformanceControl();

	/*! Returns a control that allows the user to manipulate and query details of the performance attribute on this segment. */
	PerformanceControl const				GetPerformanceControl() const;


	/*! Sets the selectability attributes designated by in_kit on this segment. */
	SegmentKey &							SetSelectability(SelectabilityKit const & in_kit);

	/*! Removes all selectability settings from this segment. */
	SegmentKey &							UnsetSelectability();

	/*! Shows the selectability attribute settings on this segment.
	\return False if no selectability settings exist on this segment.
	*/
	bool									ShowSelectability(SelectabilityKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the selectability attribute on this segment. */
	SelectabilityControl					GetSelectabilityControl();

	/*! Returns a control that allows the user to manipulate and query details of the selectability attribute on this segment. */
	SelectabilityControl const				GetSelectabilityControl() const;


	/*! Sets the sphere attributes designated by in_kit on this segment. */
	SegmentKey &							SetSphereAttribute(SphereAttributeKit const & in_kit);

	/*! Removes all sphere attribute settings from this segment. */
	SegmentKey &							UnsetSphereAttribute();

	/*! Shows the sphere attribute settings on this segment.
	\return False if no sphere attribute settings exist on this segment. */
	bool									ShowSphereAttribute(SphereAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the sphere attribute on this segment. */
	SphereAttributeControl					GetSphereAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the sphere attribute on this segment. */
	SphereAttributeControl const			GetSphereAttributeControl() const;


	/*! Sets the subwindow attributes designated by in_kit on this segment. */
	SegmentKey &							SetSubwindow(SubwindowKit const & in_kit);

	/*! Removes all subwindow attribute settings from this segment. */
	SegmentKey &							UnsetSubwindow();

	/*! Shows the subwindow attribute settings on this segment.
	\return False if no subwindow attribute settings exist on this segment. */
	bool									ShowSubwindow(SubwindowKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the subwindow attribute on this segment. */
	SubwindowControl						GetSubwindowControl();

	/*! Returns a control that allows the user to manipulate and query details of the subwindow attribute on this segment. */
	SubwindowControl const					GetSubwindowControl() const;


	/*! Sets the text attributes designated by in_kit on this segment. */
	SegmentKey &							SetTextAttribute(TextAttributeKit const & in_kit);

	/*! Removes all text attribute settings from this segment. */
	SegmentKey &							UnsetTextAttribute();

	/*! Shows the text attribute settings on this segment.  Returns <span class='code'>false</span> if no text attribute settings exist on this segment. */
	bool									ShowTextAttribute(TextAttributeKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the text attribute on this segment. */
	TextAttributeControl					GetTextAttributeControl();

	/*! Returns a control that allows the user to manipulate and query details of the text attribute on this segment. */
	TextAttributeControl const				GetTextAttributeControl() const;


	/*! Sets the texture matrix attributes designated by in_kit on this segment. */
	SegmentKey &							SetTextureMatrix(MatrixKit const & in_kit);

	/*! Removes any texture matrix settings from this segment. */
	SegmentKey &							UnsetTextureMatrix();

	/*! Shows the texture matrix setting on this segment.
	\return False if no texture matrix setting exists on this segment. */
	bool									ShowTextureMatrix(MatrixKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the texture matrix on this segment. */
	TextureMatrixControl					GetTextureMatrixControl();

	/*! Returns a control that allows the user to manipulate and query details of the texture matrix on this segment. */
	TextureMatrixControl const				GetTextureMatrixControl() const;


	/*! Sets the transform mask designated by in_kit on this segment. */
	SegmentKey &							SetTransformMask(TransformMaskKit const & in_kit);

	/*! Removes all transform mask settings from this segment. */
	SegmentKey &							UnsetTransformMask();

	/*! Shows the transform mask settings on this segment.
	\return False if no bounding settings exist on this segment. */
	bool									ShowTransformMask(TransformMaskKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the transform mask on this segment. */
	TransformMaskControl					GetTransformMaskControl();

	/*! Returns a control that allows the user to manipulate and query details of the transform mask on this segment. */
	TransformMaskControl const				GetTransformMaskControl() const;


	/*! Sets the transparency attributes designated by in_kit on this segment. */
	SegmentKey &							SetTransparency(TransparencyKit const & in_kit);

	/*! Removes all transparency attribute settings from this segment. */
	SegmentKey &							UnsetTransparency();

	/*! Shows the transparency attribute settings on this segment.
	\return False if no transparency attribute settings exist on this segment. */
	bool									ShowTransparency(TransparencyKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the transparency attribute on this segment. */
	TransparencyControl						GetTransparencyControl();

	/*! Returns a control that allows the user to manipulate and query details of the transparency attribute on this segment. */
	TransparencyControl const				GetTransparencyControl() const;


	/*! Sets the visibility attribute designated by in_kit on this segment. */
	SegmentKey &							SetVisibility(VisibilityKit const & in_kit);

	/*! Removes all visibility settings from this segment. */
	SegmentKey &							UnsetVisibility();

	/*! Shows the visibility attribute settings on this segment.
	\return False if no visibility is set on this segment. */
	bool									ShowVisibility(VisibilityKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the visibility attribute on this segment. */
	VisibilityControl						GetVisibilityControl();

	/*! Returns a control that allows the user to manipulate and query details of the visibility attribute on this segment. */
	VisibilityControl const					GetVisibilityControl() const;


	/*! Sets the visual effects attributes designated by in_kit on this segment. */
	SegmentKey &							SetVisualEffects(VisualEffectsKit const & in_kit);

	/*! Removes all visual effects attribute settings from this segment. */
	SegmentKey &							UnsetVisualEffects();

	/*! Shows the visual effects attribute settings on this segment.
	\return False if no visual effects attribute settings exist on this segment.
	*/
	bool									ShowVisualEffects(VisualEffectsKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the visual effects attribute on this segment. */
	VisualEffectsControl					GetVisualEffectsControl();

	/*! Returns a control that allows the user to manipulate and query details of the visual effects attribute on this segment. */
	VisualEffectsControl const				GetVisualEffectsControl() const;

	/*! Optimizes this Segment according to the options specified in the SegmentOptimizationOptionsKit.
	* \param in_kit A SegmentOptimizationOptionsKit that specifies how the Segment should be optimized. */
	void									Optimize(SegmentOptimizationOptionsKit const & in_kit);


	/*! Optimizes this Segment according to the options specified in the SegmentOptimizationOptionsKit.
	* \note If shell merging is specified in the SegmentOptimizationOptionsKit then the original shells will be preserved.
	* Original shells may be flushed after merging information has been retrieved from the returned OptimizeMappingResults.
	* \param in_kit A SegmentOptimizationOptionsKit that specifies how the Segment should be optimized.
	* \return OptimizeMappingResults with information about merged shells.*/
	OptimizeMappingResults					OptimizeWithMapping(SegmentOptimizationOptionsKit const & in_kit);
};


/*! Configuration options kit for controlling \ref HPS::Segment::Optimize behavior. */
class HPS_API SegmentOptimizationOptionsKit : public Kit
{
public:

	/*! The default constructor creates an empty SegmentOptimizationOptionsKit object. */
	SegmentOptimizationOptionsKit();

	/*! The copy constructor creates a new SegmentOptimizationOptionsKit object that contains the same settings as the source SegmentOptimizationOptionsKit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to copy. */
	SegmentOptimizationOptionsKit(SegmentOptimizationOptionsKit const & in_kit);

	/*! The move constructor creates a SegmentOptimizationOptionsKit by transferring the underlying impl of the rvalue reference to this SegmentOptimizationOptionsKit thereby avoiding a copy and allocation.
	 *  \param in_that An rvalue reference to a SegmentOptimizationOptionsKit to take the impl from. */
	SegmentOptimizationOptionsKit(SegmentOptimizationOptionsKit && in_kit);

	virtual ~SegmentOptimizationOptionsKit();

	static const HPS::Type staticType = HPS::Type::SegmentOptimizationOptionsKit;
	HPS::Type ObjectType() const { return staticType; }

	/*! Copies the source SegmentOptimizationOptionsKit into this SegmentOptimizationOptionsKit and resets the source kit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to consume. */
	void Consume(SegmentOptimizationOptionsKit & in_kit);

	/*! Copies the source SegmentOptimizationOptionsKit into this SegmentOptimizationOptionsKit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to copy. */
	void Set(SegmentOptimizationOptionsKit const & in_kit);

	/*! Copies this SegmentOptimizationOptionsKit into the given SegmentOptimizationOptionsKit.
	 *  \param out_kit The SegmentOptimizationOptionsKit to populate with the contents of this SegmentOptimizationOptionsKit. */
	void Show(SegmentOptimizationOptionsKit & out_kit) const;

	/*! Copies the source SegmentOptimizationOptionsKit into this SegmentOptimizationOptionsKit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to copy.
	 *  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & operator=(SegmentOptimizationOptionsKit const & in_kit);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SegmentOptimizationOptionsKit thereby avoiding a copy.
	 *  \param in_that An rvalue reference to a SegmentOptimizationOptionsKit to take the impl from.
	 *  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & operator=(SegmentOptimizationOptionsKit && in_kit);

	/*! Indicates whether this SegmentOptimizationOptionsKit has any values set on it.
	 *  \return <span class='code'>true</span> if no values are set on this SegmentOptimizationOptionsKit, <span class='code'>false</span> otherwise. */
	bool Empty() const;

	/*! Check if the source SegmentOptimizationOptionsKit is equivalent to this SegmentOptimizationOptionsKit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to compare to this SegmentOptimizationOptionsKit.
	 *  \return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool Equals(SegmentOptimizationOptionsKit const & in_kit) const;

	/*! Check if the source SegmentOptimizationOptionsKit is equivalent to this SegmentOptimizationOptionsKit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to compare to this SegmentOptimizationOptionsKit.
	 *  \return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool operator==(SegmentOptimizationOptionsKit const & in_kit) const;

	/*! Check if the source SegmentOptimizationOptionsKit is not equivalent to this SegmentOptimizationOptionsKit.
	 *  \param in_kit The source SegmentOptimizationOptionsKit to compare to this SegmentOptimizationOptionsKit.
	 *  \return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool operator!=(SegmentOptimizationOptionsKit const & in_kit) const;

	/*! Controls whether or not user data is discarded, preserved, merged, localized, or left as is.
	 *  \param in_user_data The enum value describing how to handle user data.
	 *  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetUserData(HPS::SegmentOptimizationOptions::UserData in_user_data);

	/*! Controls whether or not matrices are localized, collapsed, or left as is.
	*  \param in_matrix The enum value describing how to handle matrices.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetMatrix(HPS::SegmentOptimizationOptions::Matrix in_matrix);

	/*! Controls whether or not includes or references are expanded.
	*  \param in_expansion The enum value describing how to handle includes and references.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetExpansion(HPS::SegmentOptimizationOptions::Expansion in_expansion);

	/*! Controls the traversal scope of the optimization operation.
	*  \param in_scope The enum value describing the traversal scope of the optimization.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetScope(HPS::SegmentOptimizationOptions::Scope in_scope);

	/*! Controls how the tree is reorganized.
	*  \param in_reorganization The enum value describing how to reorganize the tree.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetReorganization(HPS::SegmentOptimizationOptions::Reorganization in_reorganization);

	/*! Controls whether or not duplicate shells are instanced.
	*  \param in_shell_instancing Denotes whether or not shells will be instanced.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetShellInstancing(bool in_shell_instancing);

	/*! Controls whether or not distinct shells are merged into consolidated shells.
	*  \param in_shell_merging Denotes whether or not shells will be merged.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetShellMerging(bool in_shell_merging);

	/*! Controls whether or not local attributes will be pulled out of geometry.
	*  \param in_attribute_delocalization Denotes whether or not local attributes will be pulled out of geometry.
	*  \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & SetAttributeDelocalization(bool in_attribute_delocalization);

	/*! Unsets the UserData value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetUserData();

	/*! Unsets the Matrix value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetMatrix();

	/*! Unsets the Expansion value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetExpansion();

	/*! Unsets the Scope value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetScope();

	/*! Unsets the Reorganization value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetReorganization();

	/*! Unsets the ShellInstancing value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetShellInstancing();

	/*! Unsets the ShellMerging value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetShellMerging();

	/*! Unsets the ttributeDelocalization value on this kit.
	* \return A reference to this SegmentOptimizationOptionsKit. */
	SegmentOptimizationOptionsKit & UnsetAttributeDelocalization();

	/*! Removes all settings from this object.
	 *  \return A reference to this object. */
	SegmentOptimizationOptionsKit & UnsetEverything();

	/*! Shows the User Data setting.
	*	\param out_user_data
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowUserData(HPS::SegmentOptimizationOptions::UserData & out_user_data) const;

	/*! Shows the Matrix setting.
	*	\param out_matrix
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowMatrix(HPS::SegmentOptimizationOptions::Matrix & out_matrix) const;

	/*! Shows the Expansion setting.
	*	\param out_expansion
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowExpansion(HPS::SegmentOptimizationOptions::Expansion & out_expansion) const;

	/*! Shows the Scope setting.
	*	\param out_scope
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowScope(HPS::SegmentOptimizationOptions::Scope & out_scope) const;

	/*! Shows the Reorganization setting.
	*	\param out_reorganization
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowReorganization(HPS::SegmentOptimizationOptions::Reorganization & out_reorganization) const;

	/*! Shows the Shell Instancing setting.
	*	\param out_shell_instancing
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowShellInstancing(bool & out_shell_instancing) const;

	/*! Shows the Shell Merging setting.
	*	\param out_shell_merging
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowShellMerging(bool & out_shell_merging) const;

	/*! Shows the Attribute Delocalization setting.
	*	\param out_attribute_delocalization
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool ShowAttributeDelocalization(bool & out_attribute_delocalization) const;
};


/*! The UpdateNotifier class is a smart pointer that is associated with a window update.  It is a special type of control that
	is used for synchronizing with a window update status. */
class HPS_API UpdateNotifier : public Object
{
public:

	UpdateNotifier();

	UpdateNotifier(UpdateNotifier const & in_that);

	/*! The move constructor creates an UpdateNotifier by transferring the underlying impl of the rvalue reference to this UpdateNotifier
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an UpdateNotifier to take the impl from.*/
	UpdateNotifier(UpdateNotifier && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this UpdateNotifier thereby avoiding a copy.
	* \param in_that An rvalue reference to an UpdateNotifier to take the impl from.
	* \return A reference to this UpdateNotifier. */
	UpdateNotifier & operator=(UpdateNotifier && in_that);

	virtual ~UpdateNotifier();

	static const HPS::Type staticType = HPS::Type::UpdateNotifier;
	HPS::Type		ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the UpdateNotifier source.
	 *	\param in_that The UpdateNotifier source of the assignment.
	 *	\return A reference to this UpdateNotifier. */
	UpdateNotifier &		operator=(UpdateNotifier const & in_that);

	/*! Share the underlying smart-pointer of the UpdateNotifier source.
	 *	\param in_that The UpdateNotifier source of the assignment. */
	void					Assign(UpdateNotifier const & in_that);

	/*! Wait for this Notifier to complete its Update.
	 *	\return A reference to this UpdateNotifier. */
	UpdateNotifier const &	Wait() const;

	/*! Requests to cancel this Notifier's Update operation. The cancel operation returns without waiting for the Update to complete.
	 *  To ensure that the Update is complete, you must call \ref Wait().
	 *	\return A reference to this UpdateNotifier. */
	UpdateNotifier const & 	Cancel() const;

	/*! Returns the \ref HPS::Window::UpdateStatus for the Update represented by this UpdateNotifier. */
	Window::UpdateStatus	Status() const;

};

/*! The DriverEvent class is the common base class of all driver events. A driver event represents a specific action the driver
performs during an update. DriverEvents occur on the driver updater thread. */
class HPS_API DriverEvent
{
public:

	virtual ~DriverEvent();

	/*! Returns a unique identifier that is shared by all objects of the same class. */
	intptr_t			GetClassID() const;

	enum class StereoMatrix
	{
		ViewLeft,
		ViewRight,
		ProjectionLeft,
		ProjectionRight,
	};

	void SetStereoMatrix(StereoMatrix id, HPS::MatrixKit const & in_matrix) const;
	OpaqueHandle GetSurface(int index) const;
	OpaqueHandle GetGraphicsContext() const;

protected:

	DriverEvent(OpaqueHandle in_nr) : nr(in_nr)
	{

	}

	OpaqueHandle nr;
};

/*! The FinishPictureEvent class is the event generated when the driver finishes the update and puts the rendered image
	on screen (except for OffscreenWindows). */
class HPS_API FinishPictureEvent : public DriverEvent
{
public:
	FinishPictureEvent(OpaqueHandle in_nr = 0);
	virtual ~FinishPictureEvent();
};

class HPS_API InitPictureEvent : public DriverEvent
{
public:
	InitPictureEvent(OpaqueHandle in_nr = 0);
	virtual ~InitPictureEvent();

	void SetRenderSurface(OpaqueHandle target) const;
};

/*! The DrawWindowEvent class is the event generated when the driver draws the window background for each subwindow. */
class HPS_API DrawWindowEvent : public DriverEvent
{
public:
	DrawWindowEvent(OpaqueHandle in_nr = 0);
	virtual ~DrawWindowEvent();

	//!< The screen extent for the window being drawn.
	IntRectangle Extent;

    /*! \enum BackgroundTextureFormat
     *     Enumerates the various texture formats supported by the DrawTexturedBackground function . */
    enum class BackgroundTextureFormat
    {
        RGBA, //!< Handle to single GL_RGBA format texture.
        BGRA, //!< Same as RGBA but with swapped red and blue channels.
        ImageExternal, //!< Handle to single OES_EGL_image_external texture.
        LumaChromaPair //!< Pointer to array of two GL texture handles for YpCbCr texture pair (GL_LUMINANCE, GL_LUMINANCE_ALPHA formats).
    };

	/*! Function for drawing a platform-specific texture in place of the normal window background.
	* 	\param in_texture The platform-specific texture handle(s)
    *   \param in_format The format of the texture(s) provided through the 'in_texture' parameter.
	* 	\param in_matrix A transformation to apply to the uv coordinates used to draw the texture to the window.
	* 	\param in_extent The screen extent for the window background to be drawn. */
	void DrawTexturedBackground(OpaqueHandle in_texture, BackgroundTextureFormat in_format, MatrixKit const & in_matrix, IntRectangle const & in_extent) const;

private:

	mutable HPS::FloatArray matrix_elements;
};

/*! The DriverEventHandler class is the base class for driver event handlers. Custom driver event handlers should inherit from this. */
class HPS_API DriverEventHandler : public Object
{
public:

	static const HPS::Type staticType = HPS::Type::DriverEventHandler;
	HPS::Type ObjectType() const override { return staticType; };

	DriverEventHandler();

	DriverEventHandler(DriverEventHandler const & that);

	virtual ~DriverEventHandler();

	/*! Function that gets triggered if this DriverEventHandler receives an event it is subscribed to.  This should be overridden by
	* 	subclasses of DriverEventHandler to perform any custom behavior. This will be called on the driver updater thread.
	* 	\param in_event Event which was triggered. */
	virtual void Handle(DriverEvent const * in_event)
	{
		HPS_UNREFERENCED(in_event);
	}
};




/*! The WindowKey class is a smart pointer to a database object.  Windows are special segments that are backed by a driver
	instance and a physical window.  Some operations and attributes can only be performed or set from window keys.  The WindowKey
	class itself is a base class for more specific window types (application windows, off-screen windows, stand-alone windows). */
class HPS_API WindowKey : public SegmentKey
{
public:

	/*! An uninitialized key refers to no database object and Type() will return Type::None. */
	WindowKey();

	/*! Shares a reference to a database object referred to by in_window. */
	WindowKey(WindowKey const & in_window);

	/*! Copy assignment operator for WindowKey */
	WindowKey & operator=(WindowKey const & other);

	/*! The move constructor creates a WindowKey by transferring the underlying impl of the rvalue reference to this WindowKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a WindowKey to take the impl from.*/
	WindowKey(WindowKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this WindowKey thereby avoiding a copy.
	* \param in_that An rvalue reference to a WindowKey to take the impl from.
	* \return A reference to this WindowKey. */
	WindowKey & operator=(WindowKey && in_that);

	/*! Shares a reference to a database object referred to by in_that. If the key assignment is invalid, this key will revert to an uninitialized state.  */
	WindowKey(Key const & in_key);

	/*! Releases a reference to a database object but does not destroy the database object. */
	~WindowKey();

	static const HPS::Type staticType = HPS::Type::WindowKey;
	HPS::Type							ObjectType() const {return staticType;};

	/*! Converts the point in_point from in_space to in_output_space using the transforms associated with this window.  Returns success. */
	bool								ConvertCoordinate(Coordinate::Space in_space, Point const & in_point, Coordinate::Space in_output_space, Point & out_point) const;

	/*! Searches the system for fonts.
		\param out_results Out parameter that contains results of the font search
		\return The number of fonts found
	*/
	size_t								FindFonts(FontSearchResults & out_results) const;

	/*! Searches for any highlights under this WindowKey.
	*	\param in_options Search options constraining what type of highlights to look for.  If this is empty, all highlights will be returned.
	*	\param out_results The key paths under the window that are highlighted with the given search options.
	*	\return The number of highlighted key paths found. */
	size_t								FindHighlights(HighlightSearchOptionsKit const & in_options, HighlightSearchResults & out_results) const;

	/*! Searches for any highlights under this WindowKey.
	*	\param in_key_path The key path to scope this highlight search by.
	*	\param in_scope Determines how the scope is interpreted during a highlight search.
	*	\param in_options Search options constraining what type of highlights to look for.  If this is empty, all highlights will be returned.
	*	\param out_results The key paths under the window that are highlighted with the given search options.
	*	\return The number of highlighted key paths found. */
	size_t								FindHighlights(KeyPath const & in_key_path, HPS::HighlightSearch::Scope in_scope, HighlightSearchOptionsKit const & in_options, HighlightSearchResults & out_results) const;

	/*! Sets the post-process effects attributes designated by in_kit on this segment. */
	WindowKey &							SetPostProcessEffects(PostProcessEffectsKit const & in_kit);

	/*! Shows the post-process effects attribute settings on this segment.  Returns <span class='code'>false</span> if no post-process effects attribute settings exist on this segment. */
	bool								ShowPostProcessEffects(PostProcessEffectsKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the post-process effects attribute on this segment. */
	PostProcessEffectsControl			GetPostProcessEffectsControl();

	/*! Returns a control that allows the user to manipulate and query details of the post-process effects attribute on this segment. */
	PostProcessEffectsControl const		GetPostProcessEffectsControl() const;


	/*! Sets the debugging attributes designated by in_kit on this segment. */
	WindowKey &							SetDebugging(DebuggingKit const & in_kit);

	/*! Sets the specified driver event handler as the handler for the specified driver event type on this window.
	* 	\param in_handler Driver event handler to be set.
	* 	\param in_type Type of driver event to add the handler for. */
	WindowKey &							SetDriverEventHandler(DriverEventHandler const & in_handler, intptr_t in_type);

	/*! Unsets the driver event handler for the specified driver event type on this window.
	* 	\param in_type Type of driver event to remove the handler for */
	WindowKey &							UnsetDriverEventHandler(intptr_t in_type);

	/*! Shows the debugging attribute settings on this segment.
	\return False if no debugging attribute settings exist on this segment.
	*/
	bool								ShowDebugging(DebuggingKit & out_kit) const;

	/*! Returns a control that allows the user to manipulate and query details of the debugging attribute on this segment. */
	DebuggingControl					GetDebuggingControl();

	/*! Returns a control that allows the user to manipulate and query details of the debugging attribute on this segment. */
	DebuggingControl const				GetDebuggingControl() const;

	/*! Returns a control that allows the user to query various window properties, including size, aspect ratio, resolution, etc. */
	WindowInfoControl const				GetWindowInfoControl() const;

	bool								ShowWindowInfo(WindowInfoKit & out_kit) const;

	/*! Sets the options that will be used by default for selections performed from this window.  Note: these options cannot be unset. */
	WindowKey &							SetSelectionOptions(SelectionOptionsKit const & in_kit);

	/*! Shows the options that will be used by default for selections performed from this window. */
	bool								ShowSelectionOptions(SelectionOptionsKit & out_kit) const;

	/*! Sets the options that will be used by default for update options performed from this window.  Note: these options cannot be unset. */
	WindowKey &							SetUpdateOptions(HPS::UpdateOptionsKit const & in_kit);

	/*! Shows the options that will be used by default for update options performed from this window. */
	bool								ShowUpdateOptions(HPS::UpdateOptionsKit & out_kit) const;


	/*! Returns a control that allows the user to manipulate and query details of the selection options on this window. */
	SelectionOptionsControl				GetSelectionOptionsControl();

	/*! Returns a control that allows the user to manipulate and query details of the selection options on this window. */
	SelectionOptionsControl const		GetSelectionOptionsControl() const;


	/*! Returns a control that allows the user to perform selections in this window. */
	SelectionControl					GetSelectionControl();

	/*! Returns a control that allows the user to perform selections in this window. */
	SelectionControl const				GetSelectionControl() const;

	/*! Returns a control that allows the user to highlight segments or geometry in this window. */
	HighlightControl					GetHighlightControl();

	/*! Returns a control that allows the user to highlight segments or geometry in this window. */
	HighlightControl const				GetHighlightControl() const;

	/*! Returns a control that allows the user to change update options in this window. */
	UpdateOptionsControl				GetUpdateOptionsControl();

	/*! Returns a control that allows the user to change update options in this window. */
	UpdateOptionsControl const			GetUpdateOptionsControl() const;

	/*! Performs a default update in this window, redrawing and refreshing the display. */
	void								Update();

	/*! Performs an update in this window, redrawing and refreshing the display using the options
	 *  in the UpdateOptionsKit.
	 *  \param in_kit Allows the user to control how thorough an update should be.
	 */
	void								Update(UpdateOptionsKit const & in_kit);

	/*! Performs an update in this window within the specified amount of time, redrawing and refreshing the display based on the Window::UpdateType value.  Key behavioral notes regarding a timed-update:

	- Geometry deferral/omission
		- View-dependent shadows will not be drawn (view-independent shadows will be drawn.)
		- Transparent geometry will be deferred and processed after the rest of the scene.
		- If static tree + lmv is enabled, text and lines will be deferred and drawn after opaque facetted geometry

	- Non-incremental rendering modes/attributes
		- A timed update requires Visualize to interrupt the rendering process. However, certain types of rendering modes/attributes cannot be interrupted because they are 'non-incremental'. 		- If your application wishes to use such modes/attributes alongside fixed-framerate, it will need to make a decision about whether Fixed-framerate is preferred.   They include:			- HiddenLine and FastHiddenLine rendering algorithms
			- Transparency that is drawn using 'depth peeling'.   (All depth-peeled transparent geometry will be processed once it is started.)

		\param in_control Allows the user to control how thorough this update should be.
		\param in_time_limit Specifies the desired maximum time this update should take.
	*/
	void								Update(Window::UpdateType in_type, Time in_time_limit=-1);

	/*! Performs a default update in this window, redrawing and refreshing the display.
		\return A UpdateNotifier object that can be used to find out information about the update.
	*/
	UpdateNotifier						UpdateWithNotifier();

	/*! Performs a default update in this window, redrawing and refreshing the display.
		\return A UpdateNotifier object that can be used to find out information about the update.
	*/
	UpdateNotifier						UpdateWithNotifier(HPS::UpdateOptionsKit const & in_kit);

	/*! Performs an update in this window, redrawing and refreshing the display.
		\param in_type Allows the user to control how thorough an update should be.
		\param in_time_limit Specifies a maximum time this update should take.
		\return A UpdateNotifier object that can be used to find out information about the update.
	*/
	UpdateNotifier						UpdateWithNotifier(Window::UpdateType in_type, Time in_time_limit=-1);

	/*! Returns a control that allows the user to interact with events in various ways. */
	EventDispatcher &					GetEventDispatcher();

	/*! Returns a control that allows the user to interact with events in various ways. */
	EventDispatcher const &				GetEventDispatcher() const;

	/*! Shows the current display as an image.  Note: this will return false if an Update was never made or if the window key has framebuffer retention disabled.
		\param out_kit An image kit to show the display into.
		\return <span class='code'>true</span> if able to show display into ImageKit, <span class='code'>false</span> otherwise. */
	bool								ShowSnapshot(ImageKit & out_kit) const;

private:

	/*! Unset methods are hidden here because default attributes cannot be unset from the window. */
	SegmentKey &						UnsetAttributeLock();
	SegmentKey &						UnsetCamera();
	SegmentKey &						UnsetColorInterpolation();
	SegmentKey &						UnsetContourLine();
	SegmentKey &						UnsetCulling();
	SegmentKey &						UnsetCurveAttribute();
	SegmentKey &						UnsetCuttingSectionAttribute();
	SegmentKey &						UnsetCylinderAttribute();
	SegmentKey &						UnsetDrawingAttribute();
	SegmentKey &						UnsetEdgeAttribute();
	SegmentKey &						UnsetHiddenLineAttribute();
	SegmentKey &						UnsetLightingAttribute();
	SegmentKey &						UnsetLineAttribute();
	SegmentKey &						UnsetMaterialMapping();
	SegmentKey &						UnsetMarkerAttribute();
	SegmentKey &						UnsetModellingMatrix();
	SegmentKey &						UnsetNURBSSurfaceAttribute();
	SegmentKey &						UnsetPerformance();
	SegmentKey &						UnsetSelectability();
	SegmentKey &						UnsetSphereAttribute();
	SegmentKey &						UnsetSubwindow();
	SegmentKey &						UnsetTextAttribute();
	SegmentKey &						UnsetTextureMatrix();
	SegmentKey &						UnsetTransformMask();
	SegmentKey &						UnsetTransparency();
	SegmentKey &						UnsetVisibility();
	SegmentKey &						UnsetVisualEffects();

	/*! MoveTo is private because windows cannot be moved to a segment. */
	void								MoveTo(SegmentKey const & in_new_owner);

	/*! CopyTo is private because windows cannot be copied to a segment. */
	Key									CopyTo(SegmentKey const & in_destination) const;
};



/*! The KeyPath contains an array of keys, organized from leaf to root.
	It allows the user to perform a number of queries along that path including accumulating net attributes and converting coordinates. */
class HPS_API KeyPath : public Object
{
public:

	/*! Creates an uninitialized key path that refers to no database objects. */
	KeyPath();

	/*! Creates a new KeyPath object based on the supplied path.
	*	\param in_path An array of keys arranged from leaf to root. */
	KeyPath(KeyArray const & in_path);

	/*! Creates a new KeyPath object based on the supplied path.
	*	\param in_path_count The number of keys in the array.
	*	\param in_path An array of keys arranged from leaf to root. */
	KeyPath(size_t in_path_count, Key const in_path []);

	/*! Copies in_that into this key path. */
	KeyPath(KeyPath const & in_that);

	/*! The move constructor creates a KeyPath by transferring the underlying impl of the rvalue reference to this KeyPath
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a KeyPath to take the impl from.*/
	KeyPath(KeyPath && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this KeyPath thereby avoiding a copy.
	* \param in_that An rvalue reference to a KeyPath to take the impl from.
	* \return A reference to this KeyPath. */
	KeyPath & operator=(KeyPath && in_that);

	/*! Releases a reference to the database object this object is tied to. */
	virtual ~KeyPath();

	static const HPS::Type staticType = HPS::Type::KeyPath;
	HPS::Type			ObjectType() const { return staticType; }

	/*! Appends the supplied Key into this object.  Same as Append function.
	*	\param in_key The key to be appended to this.
	*	\return A reference to this object. */
	KeyPath &			operator+=(Key const & in_key);

	/*! Appends the supplied KeyPath into this object.  Same as Append function.
	*	\param in_key_path The KeyPath to be appended to this.
	*	\return A reference to this object. */
	KeyPath &			operator+=(KeyPath const & in_key_path);

	/*! Appends the supplied KeyArray into this object.  Same as Append function.
	*	\param in_key_array The KeyArray to be appended to this.
	*	\return A reference to this object. */
	KeyPath &			operator+=(KeyArray const & in_key_array);

	/*! Appends the supplied Key into this object.  Same as operator+= function.
	*	\param in_key The Key to be appended to this.
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility. Use KeyPath::PushBack instead. */
	KeyPath &			Append(Key const & in_key);

	/*! Appends the supplied key into this object.  Same as operator+= function.
	*	\param in_key_path The KeyPath to be appended to this.
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility. Use KeyPath::PushBack instead. */
	KeyPath &			Append(KeyPath const & in_key_path);

	/*! Appends the supplied key into this object.  Same as operator+= function.
	*	\param in_key_array The KeyArray to be appended to this.
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility. Use KeyPath::PushBack instead. */
	KeyPath &			Append(KeyArray const & in_key_array);

	/*! Copies the supplied path into this object.
	*	\param in_that The source of the copy.
	*	\return A reference to this object. */
	KeyPath &			operator=(KeyPath const & in_that);

	/*! Copies an array of keys into this object.
	*	\param in_path The source array, assumed to be arranged from leaf to root.
	*	\return A reference to this object. */
	KeyPath &			operator=(KeyArray const & in_path);

	/*! Copies the supplied path into this object.
	*	\param in_that The source of the copy. */
	void				Set(KeyPath const & in_that);

	/*! Check if the source KeyPath is equivalent to this object.
	*	\param in_that The source KeyPath to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(KeyPath const & in_that) const;

	/*! Check if the source KeyPath is not equivalent to this object.
	*	\param in_that The source KeyPath to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!= (KeyPath const & in_that) const;

	/*! Check if the source KeyPath is equivalent to this object.
	*	\param in_that The source KeyPath to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator== (KeyPath const & in_that) const;


	/*! Copies an array of keys into this object.
	*	\param in_keys The source array, assumed to be arranged from leaf to root.
	*	\return A reference to this object. */
	KeyPath &			SetKeys(KeyArray const & in_keys);

	/*! Copies an array of keys into this object.
	*	\param in_key_count the number of keys in the array.
	*	\param in_keys The source array, assumed to arranged from leaf to root.
	*	\return A reference to this object. */
	KeyPath &			SetKeys(size_t in_key_count, Key const in_keys []);


	/*! Removes the keys defining this key path.
	*	\return A reference to this object. */
	KeyPath &			UnsetKeys();


	/*! Shows the keys defining this key path.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowKeys(KeyArray & out_keys) const;


	/*! Converts a point from one coordinate space to another using the transforms along this key path.
	*	\param in_space The coordinate space of the input point.
	*	\param in_point The input point to convert.
	*	\param in_output_space The coordinate space to convert the input point into.
	*	\param out_point The output point, after conversion.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ConvertCoordinate(Coordinate::Space in_space, Point const & in_point, Coordinate::Space in_output_space, Point & out_point) const;

	/*! Converts a point from one coordinate space to another using the transforms along this key path.
	*	\param in_space The coordinate space of the input point.
	*	\param in_points The input points to convert.
	*	\param in_output_space The coordinate space to convert the input point into.
	*	\param out_points The output points, after conversion.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ConvertCoordinate(Coordinate::Space in_space, PointArray const & in_points, Coordinate::Space in_output_space, PointArray & out_points) const;

	/*! Computes the extents of the specified text string based on the effective text attributes along this key path.  If the effective
	*	text transform setting is Text::Transform::Transformable, the returned values will be in object space units.  For any other effective
	*	text transform setting, the returned values will be a fraction of the segment window from 0.0 to 1.0 (or more) along this key path.
	*	\param in_text The text to measure along this keypath
	*	\param out_xfrac The width of the text extent
	*	\param out_yfrac The height of the text extent
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ComputeTextExtent(char const * in_text, float & out_xfrac, float & out_yfrac) const;

	/*! Computes a tight 2D extents box around the geometry contained in this key path.
	*	A user can use this information to tightly fit a camera to a specified segment or draw a 2D box around the segment.
	*	The coordinates are returned to the user in screen space.
	*	\param out_extent The screen extent of the geometry under this key path.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ComputeExtent(Rectangle & out_extent) const;

	/*! Computes a tight 2D extents box around the geometry contained in this key path.
	*	A user can use this information to tightly fit a camera to a specified segment or draw a 2D box around the segment.
	*	The coordinates are returned to the user in screen space.
	*	\param in_vis Explicit visibility settings to acknowledge instead of using the visibilities resolved by this key path.
	*	\param out_extent The screen extent of the geometry under this key path.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ComputeExtent(HPS::VisibilityKit const & in_vis, Rectangle & out_extent) const;


	/*! Computes a tight 2D extents box around the geometry contained in this key path.
	*	A user can use this information to tightly fit a camera to a specified segment or draw a 2D box around the segment.
	*	The coordinates are returned to the user in screen space.
	*	\param in_clip The setting which indicates whether clip regions should be ignored or included.
	*	\param out_extent The screen extent of the geometry under this key path.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ComputeExtent(HPS::Extent::ClipRegion in_clip, Rectangle & out_extent) const;


	/*! Computes a tight 2D extents box around the geometry contained in this key path.
	*	A user can use this information to tightly fit a camera to a specified segment or draw a 2D box around the segment.
	*	The coordinates are returned to the user in screen space.
	*	\param in_vis Explicit visibility settings to acknowledge instead of using the visibilities resolved by this key path.
	*	\param in_clip The setting which indicates whether clip regions should be ignored or included.
	*	\param out_extent The screen extent of the geometry under this key path.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ComputeExtent(HPS::VisibilityKit const & in_vis, HPS::Extent::ClipRegion in_clip, Rectangle & out_extent) const;

	/*! Computes the matrix which transforms objects from the input space to the output space along this key path.
	*	\param in_space The starting or input coordinate space.
	*	\param in_output_space The final or output coordinate space.
	*	\param out_matrix The matrix which transforms objects from the input space to the output space.
	*	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool				ComputeTransform(Coordinate::Space in_space, Coordinate::Space in_output_space, HPS::MatrixKit & out_matrix) const;

	/*! Shows the net visibility attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetVisibility(VisibilityKit & out_kit) const;

	/*! Shows the net bounding along this key path without taking into account attributes set through highlights.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise.
	*	\deprecated This function exists for compatibility and ShowNetBounding(bool, BoundingKit &) should be preferred. This function will be removed in HPS 2021.*/
	bool				ShowNetBounding(BoundingKit & out_kit) const;

	/*! Shows the net bounding along this key path. This function also optionally includes the bounding for geometry affected by in-place highlighting. This includes Show, Hide, and Isolate operations which alter visibility.
	*	In order for all highlights to be accounted for, the KeyPath should be complete, extending from the leaf segment or geometry, all the way to the WindowKey or Canvas.
	*	\param in_consider_highlights If true, geometry with attributes set by in-place highlighting (including those attributes affecting visibility) will be included in the boundary calculation.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetBounding(bool in_consider_highlights, BoundingKit & out_kit) const;

	/*! Shows the net camera attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetCamera(CameraKit & out_kit) const;

	/*! Shows the net color interpolation attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetColorInterpolation(ColorInterpolationKit & out_kit) const;

	/*! Shows the net contour line attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetContourLine(ContourLineKit & out_kit) const;

	/*! Shows the net performance attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetPerformance(PerformanceKit & out_kit) const;

	/*! Shows the net hidden line attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetHiddenLineAttribute(HiddenLineAttributeKit & out_kit) const;

	/*! Shows the net drawing attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetDrawingAttribute(DrawingAttributeKit & out_kit) const;

	/*! Shows the net selectability attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetSelectability(SelectabilityKit & out_kit) const;

	/*! Shows the net marker attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetMarkerAttribute(MarkerAttributeKit & out_kit) const;

	/*! Shows the net sphere attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetSphereAttribute(SphereAttributeKit & out_kit) const;

	/*! Shows the net lighting attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetLightingAttribute(LightingAttributeKit & out_kit) const;

	/*! Shows the net cylinder attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetCylinderAttribute(CylinderAttributeKit & out_kit) const;

	/*! Shows the net cutting section attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetCuttingSectionAttribute(CuttingSectionAttributeKit & out_kit) const;

	/*! Shows the net text attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetTextAttribute(TextAttributeKit & out_kit) const;

	/*! Shows the net line attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetLineAttribute(LineAttributeKit & out_kit) const;

	/*! Shows the net edge attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetEdgeAttribute(EdgeAttributeKit & out_kit) const;

	/*! Shows the net curve attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetCurveAttribute(CurveAttributeKit & out_kit) const;

	/*! Shows the net modelling matrix attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetModellingMatrix(MatrixKit & out_kit) const;

	/*! Shows the net texture matrix attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetTextureMatrix(MatrixKit & out_kit) const;

	/*! Shows the net culling attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetCulling(CullingKit & out_kit) const;

	/*! Shows the net transparency attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetTransparency(TransparencyKit & out_kit) const;

	/*! Shows the net transform mask attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetTransformMask(TransformMaskKit & out_kit) const;

	/*! Shows the net material mapping attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetMaterialMapping(MaterialMappingKit & out_kit) const;

	/*! Shows the net pbr material attribute settings along this key path.
*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetPBRMaterial(PBRMaterialKit & out_kit) const;

	/*! Shows the net NURBS surface attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetNURBSSurfaceAttribute(NURBSSurfaceAttributeKit & out_kit) const;

	/*! Shows the net visual effects attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetVisualEffects(VisualEffectsKit & out_kit) const;

	/*! Shows the net subwindow attribute settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetSubwindow(SubwindowKit & out_kit) const;

	/*! Shows the net attribute lock settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetAttributeLock(AttributeLockKit & out_kit) const;

	/*! Shows the net condition settings along this key path.
	*	\return <span class='code'>true</span> if the setting is valid along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetConditions(UTF8Array & out_conditions) const;

	/*! Collects capping geometry generated by cutting planes. Geometry is deposited in the segment you specify.
	 * Note: Capping geometry is generated during an update.  Until an update is completed, no geometry will be present to gather.
	 *	\param in_destination A segment that the capping geometry will be deposited into.
	 *	\param in_options Options for the gathering operation.
	 *	\return The number of individual caps created.  */
	size_t				GatherCutGeometry(SegmentKey const & in_destination, CutGeometryGatheringOptionsKit const & in_options) const;


	/*! Collects all clip regions on key path.
	*	\param out_loops_array An array of arrays of loops describing the clip region.
	*	\param out_spaces An array of the coordinate spaces in which loops are described.
	*	\param out_operations An array of the operations performed by the clip regions.
	*	\param out_matrices An array of the matrices used by the clip regions if they are in ClipSpace::Object else identity matrix.
	*	\return <span class='code'>true</span> if clip regions exist along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetClipRegions(PointArrayArrayArray & out_loops_array, ClipSpaceArray & out_spaces, ClipOperationArray & out_operations, MatrixKitArray & out_matrices) const;

	/*! Shows the material palette name along this key path.
	*	\return <span class='code'>true</span> if a material palette is set along this path, <span class='code'>false</span> otherwise. */
	bool				ShowNetMaterialPalette(UTF8 & out_name) const;

	/*! Shows the effective material palette definition belonging to the input name along this key path.
	*	\param in_name UTF8-encoded name of the material palette to find along this key path.
	*	\param out_def The effective material palette definition, if any, with the specified name along this key path.
	*	\return <span class='code'>true</span> if the material palette definition exists along this path, <span class='code'>false</span> otherwise. */
	bool				ShowEffectiveMaterialPaletteDefinition(char const * in_name, MaterialPaletteDefinition & out_def) const;

	/*! Shows the effective glyph definition belonging to the input name along this key path.
	*	\param in_name UTF8-encoded name of the glyph to find along this key path.
	*	\param out_def The effective glyph definition, if any, with the specified name along this key path.
	*	\return <span class='code'>true</span> if the glyph definition exists along this path, <span class='code'>false</span> otherwise. */
	bool				ShowEffectiveGlyphDefinition(char const * in_name, GlyphDefinition & out_def) const;

	/*! Shows the effective line pattern definition belonging to the input name along this key path.
	*	\param in_name UTF8-encoded name of the line pattern to find along this key path.
	*	\param out_def The effective material line pattern, if any, with the specified name along this key path.
	*	\return <span class='code'>true</span> if the line pattern definition exists along this path, <span class='code'>false</span> otherwise. */
	bool				ShowEffectiveLinePatternDefinition(char const * in_name, LinePatternDefinition & out_def) const;

	/*! Shows the effective shader definition belonging to the input name along this key path.
	*	\param in_name UTF8-encoded name of the shader to find along this key path.
	*	\param out_def The effective shader definition, if any, with the specified name along this key path.
	*	\return <span class='code'>true</span> if the shader definition exists along this path, <span class='code'>false</span> otherwise. */
	bool				ShowEffectiveShaderDefinition(char const * in_name, ShaderDefinition & out_def) const;

	/*! Shows the effective texture definition belonging to the input name along this key path.
	*	\param in_name UTF8-encoded name of the texture to find along this key path.
	*	\param out_def The effective texture definition, if any, with the specified name along this key path.
	*	\return <span class='code'>true</span> if the texture definition exists along this path, <span class='code'>false</span> otherwise. */
	bool				ShowEffectiveTextureDefinition(char const * in_name, TextureDefinition & out_def) const;

	/*! Shows the effective image definition belonging to the input name along this key path.
	*	\param in_name UTF8-encoded name of the image to find along this key path.
	*	\param out_def The effective image definition, if any, with the specified name along this key path.
	*	\return <span class='code'>true</span> if the image definition exists along this path, <span class='code'>false</span> otherwise. */
	bool				ShowEffectiveImageDefinition(char const * in_name, ImageDefinition & out_def) const;

	/*! Returns the number of Keys contained in this KeyPath object.
	*  \return the number of keys in this key path.*/
	size_t				Size() const;

	/*! Returns whether the key path is empty.
	*	\return <span class='code'>true</span> if the key path is empty, <span class='code'>false</span> otherwise. */
	virtual bool		Empty() const;

	/*! Access a Key in this KeyPath object. An HPS::IndexOutOfRangeException exception is thrown if in_index is out of range.
	*  \param in_index The index of the Key to access, zero based.
	*  \return The Key at position in_index in this key path.*/
	Key &				At(size_t in_index);

	/*! Access a Key in this KeyPath object. An HPS::IndexOutOfRangeException exception is thrown if in_index is out of range.
	*  \param in_index The index of the Key to access, zero based.
	*  \return The Key at position in_index in this key path.*/
	Key const &			At(size_t in_index) const;

	/*! Inserts in_item in the key path before the element at position in_index, increasing the size of the key path by one.
	*  An HPS::IndexOutOfRangeException exception is thrown if in_index is out of range.
	*  \param in_index The index where in_item will be inserted
	*  \param in_item The key to insert in this key path. */
	void				Insert(size_t in_index, Key const & in_item);

	/*! Traverses the keys in this key path and removes the first one which matches in_item
	*  NOTE: A useful KeyPath should not contain duplicate keys.
	*  \param in_item The item to remove from the key path. */
	void				Remove(Key const & in_item);

	/*! Removes the the key at position in_index from this key path. An HPS::IndexOutOfRangeException exception is thrown if in_index is out of range.
	*  \param in_index The index of the key to remove, zero based. */
	void				Remove(size_t in_index);

	/*! Creates and returns a new KeyPath object, with the keys organized in the reverse order.
	*  \return A new KeyPath object, containing keys organized in the reverse order. */
	KeyPath				Reverse() const;

	/*! Returns the first key of this key path. An HPS::IndexOutOfRangeException exception is thrown if the key path is empty.
	*  \return The first key of this key path.*/
	Key &				Front();

	/*! Returns the first key of this key path. An HPS::IndexOutOfRangeException exception is thrown if the key path is empty.
	*  \return The first key of this key path.*/
	Key const &			Front() const;

	/*! Returns the last key of this key path. An HPS::IndexOutOfRangeException exception is thrown if the key path is empty.
	*  \return The last key of this key path.*/
	Key &				Back();

	/*! Returns the last key of this key path. An HPS::IndexOutOfRangeException exception is thrown if the key path is empty.
	*  \return The last key of this key path.*/
	Key const &			Back() const;

	/*! Returns the first key of this key path and returns it. An HPS::IndexOutOfRangeException exception is thrown if the key path is empty.
	*  \return The first key of this key path.*/
	Key 				PopFront();

	/*! Returns the last key of this key path and returns it. An HPS::IndexOutOfRangeException exception is thrown if the key path is empty.
	*  \return The last key of this key path.*/
	Key 				PopBack();

	/*! Adds in_key to the front of the key path.
	*  \param in_key The key to add to the front of the key path.
	*  \return A reference to this object.*/
	KeyPath &			PushFront(Key const & in_key);

	/*! Adds in_key to the end of the key path.
	*  \param in_key The key to add to the end of the key path.
	*  \return A reference to this object.*/
	KeyPath &			PushBack(Key const & in_key);

	/*! Appends the keys contained in the supplied key path at the end of this key path
	*	\param in_key_path The KeyPath to be appended to this.
	*	\return A reference to this object. */
	KeyPath &			PushBack(KeyPath const & in_key_path);

	/*! Appends the supplied key into this object.  Same as operator+= function.
	*	\param in_key_array The KeyArray to be appended to this.
	*	\return A reference to this object. */
	KeyPath &			PushBack(KeyArray const & in_key_array);

#ifndef HPS_GULP_CLANG
	using iterator = HPS::KeyArray::iterator;
	using const_iterator = HPS::KeyArray::const_iterator;
	using reverse_iterator = HPS::KeyArray::reverse_iterator;
	using const_reverse_iterator = HPS::KeyArray::const_reverse_iterator;

	/*! Returns an iterator pointing to the first Key contained in this Key Path
	 * \return An iterator pointing to the first Key contained in this Key Path. */
	iterator			begin();

	/*! Returns a constant iterator pointing to the first Key contained in this Key Path
	* \return A constant iterator pointing to the first Key contained in this Key Path. */
	const_iterator		begin() const;

	/*! Returns an iterator pointing to the last Key contained in this Key Path
	* \return An iterator pointing to the last Key contained in this Key Path. */
	iterator			end();

	/*! Returns a constant iterator pointing to the last Key contained in this Key Path
	* \return A constant iterator pointing to the last Key contained in this Key Path. */
	const_iterator		end() const;

	/*! Returns a constant iterator pointing to the first Key contained in this Key Path
	* \return A constant iterator pointing to the first Key contained in this Key Path. */
	const_iterator		cbegin() const;

	/*! Returns a constant iterator pointing to the last Key contained in this Key Path
	* \return A constant iterator pointing to the last Key contained in this Key Path. */
	const_iterator		cend() const;

	/* Returns a reverse iterator pointing to the last Key contained in this Key Path
	* \return A reverse iterator pointing to the last Key contained in this Key Path. */
	reverse_iterator	rbegin();

	/* Returns a reverse iterator pointing to the first Key contained in this Key Path
	* \return A reverse iterator pointing to the first Key contained in this Key Path. */
	reverse_iterator	rend();

	/* Returns a constant reverse iterator pointing to the last Key contained in this Key Path
	* \return A constant reverse iterator pointing to the last Key contained in this Key Path. */
	const_reverse_iterator	rbegin() const;

	/* Returns a constant iterator pointing to the first Key contained in this Key Path
	* \return A constant iterator pointing to the first Key contained in this Key Path. */
	const_reverse_iterator	rend() const;
#endif
};

/*! Creates a new KeyPath object representing the concatenation of two keys.
 *	\param in_lhs The first key in the returned KeyPath.
 *	\param in_rhs The last key in the returned KeyPath.
 *	\return A new KeyPath object representing the concatenation of two keys. */
inline KeyPath operator+(Key const & in_lhs, Key const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of the key and key array.
 *	\param in_lhs The first key in the returned KeyPath.
 *	\param in_rhs The keys to append to the first key in the returned KeyPath.
 *	\return A new KeyPath object representing the concatenation of the key and key array. */
inline KeyPath operator+(Key const & in_lhs, KeyArray const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of a key and key path.
 *	\param in_lhs The first key in the returned KeyPath.
 *	\param in_rhs The KeyPath to append to the first key in the returned KeyPath.  This KeyPath will be unchanged.
 *	\return A new KeyPath object representing the concatenation of a key and key path. */
inline KeyPath operator+(Key const & in_lhs, KeyPath const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of a key array and a key.
 *	\param in_lhs The key array at the beginning of the returned KeyPath.
 *	\param in_rhs The last key in the returned KeyPath.
 *	\return A new KeyPath object representing the concatenation of a key array and a key. */
inline KeyPath operator+(KeyArray const & in_lhs, Key const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of two key arrays.
 *	\param in_lhs The key array at the beginning of the returned KeyPath.
 *	\param in_rhs The key array at the end of the returned KeyPath.
 *	\return A new KeyPath object representing the concatenation of two key arrays. */
inline KeyPath operator+(KeyArray const & in_lhs, KeyArray const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of a key array and a key path.
 *	\param in_lhs The key array at the beginning of the returned KeyPath.
 *	\param in_rhs The KeyPath to append to the key array in the returned KeyPath.  This KeyPath will be unchanged.
 *	\return A new KeyPath object representing the concatenation of a key array and a key path. */
inline KeyPath operator+(KeyArray const & in_lhs, KeyPath const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of a key path and a key.
 *	\param in_lhs The KeyPath to begin the returned KeyPath.  This KeyPath will be unchanged.
 *	\param in_rhs The last key in the returned KeyPath.
 *	\return A new KeyPath object representing the concatenation of a key path and a key. */
inline KeyPath operator+(KeyPath const & in_lhs, Key const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of a key path and key array.
 *	\param in_lhs The KeyPath to begin the returned KeyPath.  This KeyPath will be unchanged.
 *	\param in_rhs The key array at the end of the returned KeyPath.
 *	\return A new KeyPath object representing the concatenation of a key path and key array. */
inline KeyPath operator+(KeyPath const & in_lhs, KeyArray const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}

/*! Creates a new KeyPath object representing the concatenation of two key paths.
 *	\param in_lhs The KeyPath to begin the returned KeyPath.  This KeyPath will be unchanged.
 *	\param in_rhs The KeyPath to end the returned KeyPath.  This KeyPath will be unchanged.
 *	\return A new KeyPath object representing the concatenation of two key paths. */
inline KeyPath operator+(KeyPath const & in_lhs, KeyPath const & in_rhs)
{
	return HPS::KeyPath().PushBack(in_lhs).PushBack(in_rhs);
}


//////////////////////////////////////////////////////////////////////
///////////////////////////// Attributes /////////////////////////////
//////////////////////////////////////////////////////////////////////

/*! The HPS::BoundingKit class is a user space object, useful for carrying a group of attribute settings. Calling HPS::BoundingKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#bounding">this table</a>. */
class HPS_API BoundingKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	BoundingKit();

	/*! The copy constructor creates a new BoundingKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	BoundingKit(BoundingKit const & in_kit);

	/*! The move constructor creates a BoundingKit by transferring the underlying impl of the rvalue reference to this BoundingKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a BoundingKit to take the impl from.*/
	BoundingKit(BoundingKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this BoundingKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a BoundingKit to take the impl from.
	* \return A reference to this BoundingKit. */
	BoundingKit & operator=(BoundingKit && in_that);

	/*! Destroy this kit. */
	virtual ~BoundingKit();

	static const HPS::Type staticType = HPS::Type::BoundingKit;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Creates a BoundingKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A BoundingKit with the default settings. */
	static BoundingKit	GetDefault();

	/*! Copies all settings from the source BoundingKit into this object.
	* 	\param in_kit The source BoundingKit to copy. */
	void				Set(BoundingKit const & in_kit);

	/*! Copies all settings from this BoundingKit into the given BoundingKit.
	 * 	\param out_kit The BoundingKit to populate with the contents of this object. */
	void				Show(BoundingKit & out_kit) const;

	/*! Copies the source BoundingKit into this object.
	* 	\param in_kit The source BoundingKit to copy.
	 * 	\return A reference to this object. */
	BoundingKit &		operator=(BoundingKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source BoundingKit is equivalent to this object.
	*	\param in_kit The source BoundingKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(BoundingKit const & in_kit) const;

	/*!	Check if the source BoundingKit is equivalent to this object.
	*	\param in_kit The source BoundingKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(BoundingKit const & in_kit) const;

	/*!	Check if the source BoundingKit is not equivalent to this object.
	*	\param in_kit The source BoundingKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(BoundingKit const & in_kit) const;


	/*! Explicitly sets the local bounding.
	*	\param in_sphere The SimpleSphere to set the bounding volume to.
	*	\return A reference to this object. */
	BoundingKit &		SetVolume(SimpleSphere const & in_sphere);

	/*! Explicitly sets the local bounding.
	*	\param in_cuboid The SimpleCuboid to set the bounding volume to.
	*	\return A reference to this object. */
	BoundingKit &		SetVolume(SimpleCuboid const & in_cuboid);

	/*! Controls whether this segment should be excluded when computing bounding volumes.
	*	\param in_exclude Whether to exclude this segment when computing bounding volumes.
	*	\return A reference to this object. */
	BoundingKit &		SetExclusion(bool in_exclude);


	/*! Removes an explicitly set bounding, reverting to the automatically generated one.
	*	\return A reference to this object. */
	BoundingKit &		UnsetVolume();

	/*! Removes a bounding exclusion setting.
	*	\return A reference to this object. */
	BoundingKit &		UnsetExclusion();

	/*! Removes all bounding settings from this object.
	*	\return A reference to this object. */
	BoundingKit &		UnsetEverything();


	/*! Shows the bounding volume.
	*	\param out_sphere A sphere to show the volume into.  If the bounding is not a sphere, this argument will be invalidated.
	*	\param out_cuboid A cuboid to show the volume into.  If the bounding is not a cuboid, this argument will be invalidated.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVolume(SimpleSphere & out_sphere, SimpleCuboid & out_cuboid) const;

	/*! Shows the bounding exclusion setting.
	*	\param out_exclusion Whether to exclude this segment when computing bounding volumes.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowExclusion(bool & out_exclusion) const;

};


/*! The HPS::BoundingControl class is a smart pointer that is tied to a database object. This object allows you to manipulate
	settings related to bounding, such as volume and exclusion. <a href="../../prog_guide/appendix_default_attribute_values.html#bounding">This table</a> lists default values for the various segment attributes accessible from HPS::BoundingControl. */
class HPS_API BoundingControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit BoundingControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	BoundingControl(BoundingControl const & in_that);

	/*! The move constructor creates a BoundingControl by transferring the underlying impl of the rvalue reference to this BoundingControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a BoundingControl to take the impl from.*/
	BoundingControl(BoundingControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this BoundingControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a BoundingControl to take the impl from.
	* \return A reference to this BoundingControl. */
	BoundingControl & operator=(BoundingControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~BoundingControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::BoundingControl;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the BoundingControl source.
	 *	\param in_that The BoundingControl source of the assignment.
	 *	\return A reference to this BoundingControl. */
	BoundingControl &		operator=(BoundingControl const & in_that);

	/*! Explicitly sets the local bounding.
	*	\param in_sphere The SimpleSphere to set the bounding volume to.
	*	\param in_cuboid The SimpleCuboid to set the bounding volume to.
	*	\return A reference to this object. */
	BoundingControl &		SetVolume(SimpleSphere const & in_sphere, SimpleCuboid const & in_cuboid);

	/*! Explicitly sets the local bounding.
	*	\param in_sphere The SimpleSphere to set the bounding volume to.
	*	\return A reference to this object. */
	BoundingControl &		SetVolume(SimpleSphere const & in_sphere);

	/*! Explicitly sets the local bounding.
	*	\param in_cuboid The SimpleCuboid to set the bounding volume to.
	*	\return A reference to this object. */
	BoundingControl &		SetVolume(SimpleCuboid const & in_cuboid);

	/*! Controls whether this segment should be excluded when computing bounding volumes.
	*	\param in_exclude Whether to exclude this segment when computing bounding volumes.
	*	\return A reference to this object. */
	BoundingControl &		SetExclusion(bool in_exclusion);


	/*! Removes an explicitly set bounding, reverting to the automatically generated one. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by BoundingKit::GetDefault().
	*	\return A reference to this object. */
	BoundingControl &		UnsetVolume();

	/*! Removes a bounding exclusion setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by BoundingKit::GetDefault().
	*	\return A reference to this object. */
	BoundingControl &		UnsetExclusion();

	/*! Removes all bounding settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by BoundingKit::GetDefault().
	*	\return A reference to this object. */
	BoundingControl &		UnsetEverything();


	/*! Shows the bounding volume.
	*	\param out_sphere A sphere to show the volume into.  If the bounding is not a sphere, this argument will be invalidated.
	*	\param out_cuboid A cuboid to show the volume into.  If the bounding is not a cuboid, this argument will be invalidated.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVolume(SimpleSphere & out_sphere, SimpleCuboid & out_cuboid) const;

	/*! Shows the bounding exclusion setting.
	*	\param out_exclusion Whether to exclude this segment when computing bounding volumes.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowExclusion(bool & out_exclusion) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	BoundingControl();
};


/*! The HPS::VisibilityKit class is a user space object, useful for carrying a group of attribute settings. Calling HPS::VisibilityKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#visibility">this table</a>. */
class HPS_API VisibilityKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	VisibilityKit();

	/*! The copy constructor creates a new VisibilityKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	VisibilityKit(VisibilityKit const & in_kit);

	/*! The move constructor creates a VisibilityKit by transferring the underlying impl of the rvalue reference to this VisibilityKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a VisibilityKit to take the impl from.*/
	VisibilityKit(VisibilityKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this VisibilityKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a VisibilityKit to take the impl from.
	* \return A reference to this VisibilityKit. */
	VisibilityKit & operator=(VisibilityKit && in_that);

	/*! Destroy this kit. */
	virtual ~VisibilityKit();

	static const HPS::Type staticType = HPS::Type::VisibilityKit;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Creates a VisibilityKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A VisibilityKit with the default settings. */
	static VisibilityKit GetDefault();

	/*! Copies all settings from the source VisibilityKit into this object.
	* 	\param in_kit The source VisibilityKit to copy. */
	void				Set(VisibilityKit const & in_kit);

	/*! Copies all settings from this VisibilityKit into the given VisibilityKit.
	 * 	\param out_kit The VisibilityKit to populate with the contents of this object. */
	void				Show(VisibilityKit & out_kit) const;

	/*! Copies the source VisibilityKit into this object.
	* 	\param in_kit The source VisibilityKit to copy.
	 * 	\return A reference to this object. */
	VisibilityKit &		operator=(VisibilityKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source VisibilityKit is equivalent to this object.
	*	\param in_kit The source VisibilityKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(VisibilityKit const & in_kit) const;

	/*!	Check if the source VisibilityKit is equivalent to this object.
	*	\param in_kit The source VisibilityKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(VisibilityKit const & in_kit) const;

	/*!	Check if the source VisibilityKit is not equivalent to this object.
	*	\param in_kit The source VisibilityKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(VisibilityKit const & in_kit) const;


	/*! Sets the visibility of cutting sections.
	*	\param in_state Whether cutting sections are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetCuttingSections(bool in_state);

	/*! Sets the visibility of edges cut by a cutting sections.
	*	\param in_state Whether cut edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetCutEdges(bool in_state);

	/*! Sets the visibility of capping planes for geometry cut by cutting sections.
	*	\param in_state Whether cut faces are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetCutFaces(bool in_state);

	/*! Sets the visibility of windows.
	*	\param in_state Whether windows are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetWindows(bool in_state);

	/*! Sets the visibility of text.
	*	\param in_state Whether text is visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetText(bool in_state);

	/*! Sets the visibility of lines.
	*	\param in_state Whether lines are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetLines(bool in_state);

	/*! Sets the visibility of lighting on edges.
	*	\param in_state Whether edge lights are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetEdgeLights(bool in_state);

	/*! Sets the visibility of lighting on markers.
	*	\param in_state Whether marker lights are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetMarkerLights(bool in_state);

	/*! Sets the visibility of lighting on faces.
	*	\param in_state Whether face lights are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetFaceLights(bool in_state);

	/*! Sets the visibility of generic edges.
	*	\param in_state Whether generic edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetGenericEdges(bool in_state);

	/*! Sets the visibility of interior silhouette edges.
	*	\param in_state Whether interior silhouette edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetInteriorSilhouetteEdges(bool in_state);

	/*! Sets the visibility of adjacent edges. Adjacent edges are defined as edges that
	*   are attached to at least one visible face. If you want to have no edges between
	*   faces that are explicitly invisible, turn off edges in the segment and turn on
	*   adjacent edges.
	*	\param in_state Whether adjacent edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetAdjacentEdges(bool in_state);

	/*! Sets the visibility of hard edges.
	*	\param in_state Whether hard edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetHardEdges(bool in_state);

	/*! Sets the visibility of edges of mesh quads.
	*	\param in_state Whether mesh quad edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetMeshQuadEdges(bool in_state);

	/*! Sets the visibility of non-culled edges.
	*	\param in_state Whether non-culled edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetNonCulledEdges(bool in_state);

	/*! Sets the visibility of perimeter edges.
	*	\param in_state Whether perimeter edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetPerimeterEdges(bool in_state);

	/*! Sets the visibility of all faces, including shells, meshes, cylinders, etc..
	*	\param in_state Whether faces are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetFaces(bool in_state);

	/*! Sets the visibility of vertices.
	*	\param in_state Whether vertices are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetVertices(bool in_state);

	/*! Sets the visibility of markers.
	*	\param in_state Whether markers are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetMarkers(bool in_state);

	/*! Sets the visibility of shadow casting.
	*	\param in_state Whether casting shadows are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetShadowCasting(bool in_state);

	/*! Sets the visibility of shadow receiving.
	*	\param in_state Whether receiving shadows are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetShadowReceiving(bool in_state);

	/*! Sets the visibility of shadow emitting.
	*	\param in_state Whether emitting shadows are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetShadowEmitting(bool in_state);


	/*! Sets the visibility of cut geometry, both cut faces and cut edges.
	*	\param in_state Whether all cut geometry are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetCutGeometry(bool in_state);

	/*! Sets the visibility of all edges.
	*	\param in_state Whether all edges are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetEdges(bool in_state);

	/*! Sets the visibility of all edges, faces, lines, markers, and text.
	*	\param in_state Whether all geometry is visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetGeometry(bool in_state);

	/*! Sets the visibility of all lights, including face, edge, and marker lights.
	*	\param in_state Whether all lights are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetLights(bool in_state);

	/*! Sets the visibility of shadow casting, emitting, and receiving.
	*	\param in_state Whether all shadows are visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetShadows(bool in_state);

	/*! Sets the visibility of text leader lines.
	*	\param in_state Whether text leader lines are visible
	*	\return A reference to this object. */
	VisibilityKit &		SetLeaderLines(bool in_state);

	/*! Sets the visibility of all geometry and subgeometry.
	*	\param in_state Whether everything is visible.
	*	\return A reference to this object. */
	VisibilityKit &		SetEverything(bool in_state);


	/*! Removes the visibility setting for cutting sections.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetCuttingSections();

	/*! Removes the visibility setting for cut edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetCutEdges();

	/*! Removes the visibility setting for cut faces.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetCutFaces();

	/*! Removes the visibility setting for windows.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetWindows();

	/*! Removes the visibility setting for text.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetText();

	/*! Removes the visibility setting for lines.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetLines();

	/*! Removes the visibility setting for lighting of edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetEdgeLights();

	/*! Removes the visibility setting for lighting or markers.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetMarkerLights();

	/*! Removes the visibility setting for lighting of faces.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetFaceLights();

	/*! Removes the visibility setting for generic edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetGenericEdges();

	/*! Removes the visibility setting for interior silhouette edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetInteriorSilhouetteEdges();

	/*! Removes the visibility setting for adjacent edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetAdjacentEdges();

	/*! Removes the visibility setting for hard edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetHardEdges();

	/*! Removes the visibility setting for edges of mesh quads.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetMeshQuadEdges();

	/*! Removes the visibility setting for non-culled edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetNonCulledEdges();

	/*! Removes the visibility setting for perimeter edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetPerimeterEdges();

	/*! Removes the visibility setting for faces.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetFaces();

	/*! Removes the visibility setting for vertices.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetVertices();

	/*! Removes the visibility setting for markers.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetMarkers();

	/*! Removes the visibility setting for shadow casting.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetShadowCasting();

	/*! Removes the visibility setting for shadow receiving.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetShadowReceiving();

	/*! Removes the visibility setting for shadow emitting.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetShadowEmitting();


	/*! Removes the visibility settings for both cut faces and cut edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetCutGeometry();

	/*! Removes the visibility settings for all edges.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetEdges();

	/*! Removes the visibility settings for all edges, faces, lines, markers, and text.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetGeometry();

	/*! Removes the visibility settings for all lights, including face, edge, and marker lights.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetLights();

	/*! Removes the visibility settings for shadow casting, emitting, and receiving.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetShadows();

	/*! Removes the visibility settings for text leader lines.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetLeaderLines();

	/*! Removes all visibility settings.
	*	\return A reference to this object. */
	VisibilityKit &		UnsetEverything();


	/*! Shows the visibility setting for cutting sections.
	*	\param out_state Whether cutting sections are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowCuttingSections(bool & out_state) const;

	/*! Shows the visibility setting for cut edges.
	*	\param out_state Whether cut edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowCutEdges(bool & out_state) const;

	/*! Shows the visibility setting for cut faces.
	*	\param out_state Whether cut faces are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowCutFaces(bool & out_state) const;

	/*! Shows the visibility setting for windows.
	*	\param out_state Whether windows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowWindows(bool & out_state) const;

	/*! Shows the visibility setting for text.
	*	\param out_state Whether text is visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowText(bool & out_state) const;

	/*! Shows the visibility setting for lines.
	*	\param out_state Whether lines are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowLines(bool & out_state) const;

	/*! Shows the visibility setting for lighting of edges.
	*	\param out_state Whether edge lights are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowEdgeLights(bool & out_state) const;

	/*! Shows the visibility setting for lighting of markers.
	*	\param out_state Whether marker lights are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowMarkerLights(bool & out_state) const;

	/*! Shows the visibility setting for lighting of faces.
	*	\param out_state Whether face lights are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowFaceLights(bool & out_state) const;

	/*! Shows the visibility setting for generic edges.
	*	\param out_state Whether generic edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowGenericEdges(bool & out_state) const;

	/*! Shows the visibility setting for silhouette edges.
	*	\param out_state Whether interior silhouette edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowInteriorSilhouetteEdges(bool & out_state) const;

	/*! Shows the visibility setting for adjacent edges.
	*	\param out_state Whether adjacent edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowAdjacentEdges(bool & out_state) const;

	/*! Shows the visibility setting for hard edges.
	*	\param out_state Whether hard edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowHardEdges(bool & out_state) const;

	/*! Shows the visibility setting for edges of mesh quads.
	*	\param out_state Whether mesh quad edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowMeshQuadEdges(bool & out_state) const;

	/*! Shows the visibility setting for non-culled edges.
	*	\param out_state Whether non-culled edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowNonCulledEdges(bool & out_state) const;

	/*! Shows the visibility setting for perimeter edges.
	*	\param out_state Whether perimeter edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPerimeterEdges(bool & out_state) const;

	/*! Shows the visibility setting for faces.
	*	\param out_state Whether faces are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowFaces(bool & out_state) const;

	/*! Shows the visibility setting for vertices.
	*	\param out_state Whether vertices are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVertices(bool & out_state) const;

	/*! Shows the visibility setting for markers.
	*	\param out_state Whether markers are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowMarkers(bool & out_state) const;

	/*! Shows the visibility setting for shadow casting.
	*	\param out_state Whether casting shadows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowShadowCasting(bool & out_state) const;

	/*! Shows the visibility setting for shadow receiving.
	*	\param out_state Whether receiving shadows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowShadowReceiving(bool & out_state) const;

	/*! Shows the visibility setting for shadow emitting.
	*	\param out_state Whether emitting shadows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowShadowEmitting(bool & out_state) const;

	/*! Shows the visibility setting for text leader lines.
	*	\param out_state Whether text leader lines are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowLeaderLines(bool & out_state) const;
};


/*!
<p>The HPS::VisibilityControl class is a smart pointer that is tied to a database object. This control allows you to set and	unset the visibility of any type of geometry or subentity in the scene. The visibility of windows is also controlled here. Additionally, various behaviors such as casting and emitting shadows is also done through this control. </p>

<p>Default values for the various fields of HPS::VisibilityControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#visibility">here</a>.</p>
*/
class HPS_API VisibilityControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit VisibilityControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	VisibilityControl(VisibilityControl const & in_that);

	/*! The move constructor creates a VisibilityControl by transferring the underlying impl of the rvalue reference to this VisibilityControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a VisibilityControl to take the impl from.*/
	VisibilityControl(VisibilityControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this VisibilityControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a VisibilityControl to take the impl from.
	* \return A reference to this VisibilityControl. */
	VisibilityControl & operator=(VisibilityControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~VisibilityControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::VisibilityControl;
	HPS::Type		ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the VisibilityControl source.
	 *	\param in_that The VisibilityControl source of the assignment.
	 *	\return A reference to this VisibilityControl. */
	VisibilityControl &		operator=(VisibilityControl const & in_that);

	/*! Sets the visibility of cutting sections.
	*	\param in_state Whether cutting sections are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetCuttingSections(bool in_state);

	/*! Sets the visibility of edges cut by a cutting sections.
	*	\param in_state Whether cut edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetCutEdges(bool in_state);

	/*! Sets the visibility of capping planes for geometry cut by cutting sections.
	*	\param in_state Whether cut faces are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetCutFaces(bool in_state);

	/*! Sets the visibility of windows.
	*	\param in_state Whether windows are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetWindows(bool in_state);

	/*! Sets the visibility of text.
	*	\param in_state Whether text is visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetText(bool in_state);

	/*! Sets the visibility of lines.
	*	\param in_state Whether lines are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetLines(bool in_state);

	/*! Sets the visibility of lighting on edges.
	*	\param in_state Whether edge lights are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetEdgeLights(bool in_state);

	/*! Sets the visibility of lighting on markers and vertices.
	*	\param in_state Whether marker lights are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetMarkerLights(bool in_state);

	/*! Sets the visibility of lighting on faces.
	*	\param in_state Whether face lights are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetFaceLights(bool in_state);

	/*! Sets the visibility of generic edges.
	*	\param in_state Whether generic edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetGenericEdges(bool in_state);

	/*! Sets the visibility of interior silhouette edges.
	*	\param in_state Whether interior silhouette edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetInteriorSilhouetteEdges(bool in_state);

	/*! Sets the visibility of adjacent edges.
	*	\param in_state Whether adjacent edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetAdjacentEdges(bool in_state);

	/*! Sets the visibility of hard edges.
	*	\param in_state Whether hard edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetHardEdges(bool in_state);

	/*! Sets the visibility of edges of mesh quads.
	*	\param in_state Whether mesh quad edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetMeshQuadEdges(bool in_state);

	/*! Sets the visibility of non-culled edges.
	*	\param in_state Whether non-culled edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetNonCulledEdges(bool in_state);

	/*! Sets the visibility of perimeter edges.
	*	\param in_state Whether perimeter edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetPerimeterEdges(bool in_state);

	/*! Sets the visibility of all faces, including shells, meshes, cylinders, etc..
	*	\param in_state Whether faces are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetFaces(bool in_state);

	/*! Sets the visibility of vertices.
	*	\param in_state Whether vertices are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetVertices(bool in_state);

	/*! Sets the visibility of markers.
	*	\param in_state Whether markers are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetMarkers(bool in_state);

	/*! Sets the visibility of shadow casting.
	*	\param in_state Whether casting shadows are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetShadowCasting(bool in_state);

	/*! Sets the visibility of shadow receiving.
	*	\param in_state Whether receiving shadows are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetShadowReceiving(bool in_state);

	/*! Sets the visibility of shadow emitting.
	*	\param in_state Whether emitting shadows are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetShadowEmitting(bool in_state);


	/*! Sets the visibility of cut geometry, both cut faces and cut edges.
	*	\param in_state Whether all cut geometry are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetCutGeometry(bool in_state);

	/*! Sets the visibility of all edges.
	*	\param in_state Whether all edges are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetEdges(bool in_state);

	/*! Sets the visibility of all edges, faces, lines, markers, and text.
	*	\param in_state Whether all geometry is visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetGeometry(bool in_state);

	/*! Sets the visibility of all lights, including face, edge, and marker lights.
	*	\param in_state Whether all lights are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetLights(bool in_state);

	/*! Sets the visibility of shadow casting, emitting, and receiving.
	*	\param in_state Whether all shadows are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetShadows(bool in_state);

	/*! Sets the visibility of text leader lines.
	*	\param in_state Whether text leader lines are visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetLeaderLines(bool in_state);

	/*! Sets the visibility of all geometry and subgeometry.
	*	\param in_state Whether everything is visible.
	*	\return A reference to this object. */
	VisibilityControl &		SetEverything(bool in_state);


	/*! Removes the visibility setting for cutting sections. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetCuttingSections();

	/*! Removes the visibility setting for cut edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetCutEdges();

	/*! Removes the visibility setting for cut faces. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetCutFaces();

	/*! Removes the visibility setting for windows. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetWindows();

	/*! Removes the visibility setting for text. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetText();

	/*! Removes the visibility setting for lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetLines();

	/*! Removes the visibility setting for lighting of edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetEdgeLights();

	/*! Removes the visibility setting for lighting or markers. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetMarkerLights();

	/*! Removes the visibility setting for lighting of faces. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetFaceLights();

	/*! Removes the visibility setting for generic edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetGenericEdges();

	/*! Removes the visibility setting for interior silhouette edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetInteriorSilhouetteEdges();

	/*! Removes the visibility setting for adjacent edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetAdjacentEdges();

	/*! Removes the visibility setting for hard edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetHardEdges();

	/*! Removes the visibility setting for edges of mesh quads. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetMeshQuadEdges();

	/*! Removes the visibility setting for non-culled edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetNonCulledEdges();

	/*! Removes the visibility setting for perimeter edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetPerimeterEdges();

	/*! Removes the visibility setting for faces. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetFaces();

	/*! Removes the visibility setting for vertices. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetVertices();

	/*! Removes the visibility setting for markers. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetMarkers();

	/*! Removes the visibility setting for shadow casting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetShadowCasting();

	/*! Removes the visibility setting for shadow receiving. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetShadowReceiving();

	/*! Removes the visibility setting for shadow emitting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetShadowEmitting();


	/*! Removes the visibility settings for both cut faces and cut edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetCutGeometry();

	/*! Removes the visibility settings for all edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetEdges();

	/*! Removes the visibility settings for all edges, faces, lines, markers, and text. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetGeometry();

	/*! Removes the visibility settings for all lights, including face, edge, and marker lights. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetLights();

	/*! Removes the visibility settings for shadow casting, emitting, and receiving. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetShadows();

	/*! Removes the visibility settings for text leader lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetLeaderLines();

	/*! Removes all visibility settings. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by VisibilityKit::GetDefault().
	*	\return A reference to this object. */
	VisibilityControl &		UnsetEverything();


	/*! Shows the visibility setting for cutting sections.
	*	\param out_state Whether cutting sections are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCuttingSections(bool & out_state) const;

	/*! Shows the visibility setting for cut edges.
	*	\param out_state Whether cut edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCutEdges(bool & out_state) const;

	/*! Shows the visibility setting for cut faces.
	*	\param out_state Whether cut faces are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCutFaces(bool & out_state) const;

	/*! Shows the visibility setting for windows.
	*	\param out_state Whether windows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindows(bool & out_state) const;

	/*! Shows the visibility setting for text.
	*	\param out_state Whether text is visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowText(bool & out_state) const;

	/*! Shows the visibility setting for lines.
	*	\param out_state Whether lines are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLines(bool & out_state) const;

	/*! Shows the visibility setting for lighting of edges.
	*	\param out_state Whether edge lights are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEdgeLights(bool & out_state) const;

	/*! Shows the visibility setting for lighting of markers.
	*	\param out_state Whether marker lights are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMarkerLights(bool & out_state) const;

	/*! Shows the visibility setting for lighting of faces.
	*	\param out_state Whether face lights are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFaceLights(bool & out_state) const;

	/*! Shows the visibility setting for generic edges.
	*	\param out_state Whether generic edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowGenericEdges(bool & out_state) const;

	/*! Shows the visibility setting for silhouette edges.
	*	\param out_state Whether interior silhouette edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowInteriorSilhouetteEdges(bool & out_state) const;

	/*! Shows the visibility setting for adjacent edges.
	*	\param out_state Whether adjacent edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowAdjacentEdges(bool & out_state) const;

	/*! Shows the visibility setting for hard edges.
	*	\param out_state Whether hard edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowHardEdges(bool & out_state) const;

	/*! Shows the visibility setting for edges of mesh quads.
	*	\param out_state Whether mesh quad edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMeshQuadEdges(bool & out_state) const;

	/*! Shows the visibility setting for non-culled edges.
	*	\param out_state Whether non-culled edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowNonCulledEdges(bool & out_state) const;

	/*! Shows the visibility setting for perimeter edges.
	*	\param out_state Whether perimeter edges are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPerimeterEdges(bool & out_state) const;

	/*! Shows the visibility setting for faces.
	*	\param out_state Whether faces are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFaces(bool & out_state) const;

	/*! Shows the visibility setting for vertices.
	*	\param out_state Whether vertices are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowVertices(bool & out_state) const;

	/*! Shows the visibility setting for markers.
	*	\param out_state Whether markers are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMarkers(bool & out_state) const;

	/*! Shows the visibility setting for shadow casting.
	*	\param out_state Whether casting shadows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowShadowCasting(bool & out_state) const;

	/*! Shows the visibility setting for shadow receiving.
	*	\param out_state Whether receiving shadows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowShadowReceiving(bool & out_state) const;

	/*! Shows the visibility setting for shadow emitting.
	*	\param out_state Whether emitting shadows are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowShadowEmitting(bool & out_state) const;

	/*! Shows the visibility setting for text leader lines.
	*	\param out_state Whether text leader lines are visible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLeaderLines(bool & out_state) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	VisibilityControl();
};



/*! The HPS::CameraKit class is a user space object, useful for carrying a group of attribute settings. Calling HPS::CameraKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#camera-control">this table</a>.
*/
class HPS_API CameraKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	CameraKit();

	/*! The copy constructor creates a new CameraKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	CameraKit(const CameraKit & in_kit);

	/*! The move constructor creates a CameraKit by transferring the underlying impl of the rvalue reference to this CameraKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CameraKit to take the impl from.*/
	CameraKit(CameraKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CameraKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a CameraKit to take the impl from.
	* \return A reference to this CameraKit. */
	CameraKit & operator=(CameraKit && in_that);

	/*! Destroy this kit. */
	virtual ~CameraKit();

	static const HPS::Type staticType = HPS::Type::CameraKit;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Creates a CameraKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A CameraKit with the default settings. */
	static CameraKit	GetDefault();

	/*! Copies all settings from the source CameraKit into this object.
	* 	\param in_kit The source CameraKit to copy. */
	void				Set(CameraKit const & in_kit);

	/*! Copies all settings from this CameraKit into the given CameraKit.
	 * 	\param out_kit The CameraKit to populate with the contents of this object. */
	void				Show(CameraKit & out_kit) const;

	/*! Copies the source CameraKit into this object.
	* 	\param in_kit The source CameraKit to copy.
	 * 	\return A reference to this object. */
	CameraKit &			operator=(CameraKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source CameraKit is equivalent to this object.
	*	\param in_kit The source CameraKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(CameraKit const & in_kit) const;

	/*!	Check if the source CameraKit is equivalent to this object.
	*	\param in_kit The source CameraKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(CameraKit const & in_kit) const;

	/*!	Check if the source CameraKit is not equivalent to this object.
	*	\param in_kit The source CameraKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(CameraKit const & in_kit) const;

	/*! Sets a vector that defines the vertical up direction of the camera.
	*	\param in_up A vector that defines the vertical up direction of the camera.
	*	\return A reference to this object. */
	CameraKit &			SetUpVector(Vector const & in_up);

	/*! Sets the location of the camera.
	*	\param in_position The location of the camera.
	*	\return A reference to this object. */
	CameraKit &			SetPosition(Point const & in_position);

	/*! Sets the location that the camera is pointed at.
	*	\param in_target The location that the camera is pointed at.
	*	\return A reference to this object. */
	CameraKit &			SetTarget(Point const & in_target);

	/*! Sets the camera projection type and the oblique skew, if any.
	*	\param in_type The type of camera projection.
	*	\param in_oblique_x_skew The oblique skew in the horizontal direction.
	*	\param in_oblique_y_skew The oblique skew in the vertical direction.
	*	\return A reference to this object.
	*   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#camera-projection">Default value</a> */
	CameraKit &			SetProjection(Camera::Projection in_type, float in_oblique_y_skew = 0.0f, float in_oblique_x_skew = 0.0f);

	/*! Sets the camera field.
	*	\param in_width The width of the camera field, in object-space units.
	*	\param in_height The height of the camera field, in object-space units.
	*	\return A reference to this object.
	*   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#camera-field-width">Default value</a> */
	CameraKit &			SetField(float in_width, float in_height);

	/*! Sets the near_limit to in_limit that defines the near limit of the camera.
	*   A value approaching 0.0 will place it close to the camera position
	*   (at the cost of poor z-buffer precision), whereas a value approaching 1.0
	*   will place it near the camera target
	*   (at the cost of clipping away anything closer than the target).
	*   A value exactly equal to 0 will let HOOPS choose a wlimit based on
	*   the precision of the zbuffer as reported by the driver.
	*   \param in_limit The value to set the near limit to
	*   \return A reference to this object. */
	CameraKit &			SetNearLimit(float const in_limit);

	/*! Removes the camera up-vector setting.
	*	\return A reference to this object. */
	CameraKit &			UnsetUpVector();

	/*! Removes the camera position setting.
	*	\return A reference to this object. */
	CameraKit &			UnsetPosition();

	/*! Removes the camera target setting.
	*	\return A reference to this object. */
	CameraKit &			UnsetTarget();

	/*! Removes the camera projection setting.
	*	\return A reference to this object. */
	CameraKit &			UnsetProjection();

	/*! Removes the camera field setting.
	*	\return A reference to this object. */
	CameraKit &			UnsetField();

	/*! Removes the camera near limit setting.
	*	\return A reference to this object. */
	CameraKit &			UnsetNearLimit();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	CameraKit &			UnsetEverything();


	/*! Shows the camera up-vector.
	*	\param out_up_vector A vector that defines the vertical up direction of the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowUpVector(Vector & out_up_vector) const;

	/*! Shows the camera position.
	*	\param out_position the location of the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPosition(Point & out_position) const;

	/*! Shows the camera target.
	*	\param out_target the location that the camera is pointed at.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowTarget(Point & out_target) const;

	/*! Shows the camera projection type.
	*	\param out_type The type of camera projection.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowProjection(Camera::Projection & out_type) const;

	/*! Shows the camera projection type and the oblique skew, if any.
	*	\param out_type The type of camera projection.
	*	\param out_oblique_x_skew The oblique skew in the horizontal direction.
	*	\param out_oblique_y_skew The oblique skew in the vertical direction.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowProjection(Camera::Projection & out_type, float & out_oblique_y_skew, float & out_oblique_x_skew) const;

	/*! Shows the width of the camera field.
	*	\param out_width The width of the camera field, in object-space units.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowWidth(float & out_width) const;

	/*! Shows the height of the camera field.
	*	\param out_height The height of the camera field, in object-space units.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowHeight(float & out_height) const;

	/*! Shows the camera field.
	*	\param out_width The width of the camera field, in object-space units.
	*	\param out_height The height of the camera field, in object-space units.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowField(float & out_width, float & out_height) const;

	/*! Shows the near limit field.
	*	\param out_near_limit The near limit of the camera field.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowNearLimit(float & out_near_limit) const;

	/*! Moves the camera position and target the specified amount but maintains the up vector and field.
	*	If a complete camera is not already set up, one will be populated with default values before dollying.
	*	\param in_x_dir The number of world-space units to move the camera in the x-direction.
	*	\param in_up The number of world-space units to move the camera up, or if negative, down.
	*	\param in_forward The number of world-space units to move the camera toward the target, or if negative, away from the target.
	*	\return A reference to this object. */
	CameraKit &			Dolly(float in_x_dir, float in_up, float in_forward);

	/*! Moves the camera around the target <span class='code'>in_theta</span> degrees to the right and <span class='code'>in_phi</span> degrees up.
	*	The target and field are maintained but position and up_vector may change.
	*	If a complete camera is not already set up, one will be populated with default values before orbiting.
	*	\param in_theta The number of degrees to move the the camera position to the right.
	*	\param in_phi The number of degrees to move the the camera position up.
	*	\return A reference to this object. */
	CameraKit &			Orbit(float in_theta, float in_phi);

	/*! Pivots the camera on its location <span class='code'>in_theta</span> degrees to the right and <span class='code'>in_phi</span> degrees up.
	*	The position and field remain unchanged while the target and up vector may change.
	*	If a complete camera is not already set up, one will be populated with default values before panning.
	*	\param in_theta The number of degrees to move the the camera target to the right.
	*	\param in_phi The number of degrees to move the the camera target up.
	*	\return A reference to this object. */
	CameraKit &			Pan(float in_theta, float in_phi);

	/*! Spins the camera around its target <span class='code'>in_theta</span> degrees counter-clockwise (the scene will appear to move clockwise).
	*	The position, field, and target are unchanged while the up-vector may change.  If a complete camera is not already set
	*	up, one will be populated with default values before rolling.
	*	\param in_theta The number of degrees to roll the camera.
	*	\return A reference to this object. */
	CameraKit &			Roll(float in_theta);

	/*! Adjusts the field of view by dividing the width and height by the input value.  Numbers greater than one will have the effect
	*	of making things on screen appear larger.  Numbers between zero and one will have the opposite effect.  Only the field
	*	is affected.  If a complete camera is not already set up, one will be populated with default values before zooming.
	*	\param in_zoom The zoom scale factor.
	*	\return A reference to this object. */
	CameraKit &			Zoom(float in_zoom);
};

/*!
<p>The HPS::CameraControl class is a smart pointer that is tied to a database object. The CameraControl is used to manipulate the viewpoint, or camera, in a scene. Using this control, the view position, orientation, target, and aspect ratio of a segment's camera can be set. A camera with all of its properties is considered a single segment attribute, therefore, cameras inherit down the segment hierarchy along with all their properties as a group. Because all properties of a camera inherit together, it is not possible to modify an individual property of an inherited camera. Attempting to do so will create a new camera initially populated with default values. <a href="../../prog_guide/appendix_default_attribute_values.html#camera-control">This table</a> lists default values for the various segment attributes accessible from HPS::CameraControl.
*/
class HPS_API CameraControl : public Control
{
public:
	/*! Initializes a control tied to the segment in_seg. */
	explicit CameraControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	CameraControl(CameraControl const & in_that);

	/*! The move constructor creates a CameraControl by transferring the underlying impl of the rvalue reference to this CameraControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CameraControl to take the impl from.*/
	CameraControl(CameraControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CameraControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a CameraControl to take the impl from.
	* \return A reference to this CameraControl. */
	CameraControl & operator=(CameraControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~CameraControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::CameraControl;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the CameraControl source.
	 *	\param in_that The CameraControl source of the assignment.
	 *	\return A reference to this CameraControl. */
	CameraControl &		operator=(CameraControl const & in_that);

	/*! Sets a vector that defines the vertical up direction of the camera.
	*	\param in_up A vector that defines the vertical up direction of the camera.
	*	\return A reference to this object.
	*   \sa camera up vector */
	CameraControl &		SetUpVector(Vector const & in_up);

	/*! Sets the location of the camera.
	*	\param in_position The location of the camera.
	*	\return A reference to this object.
	*   \sa camera position */
	CameraControl &		SetPosition(Point const & in_position);

	/*! Sets the location that the camera is pointed at.
	*	\param in_target The location that the camera is pointed at.
	*	\return A reference to this object.
	*	\sa camera position */
	CameraControl &		SetTarget(Point const & in_target);

	/*! Sets the camera projection type and the oblique skew, if any.
	*	\param in_type The type of camera projection.
	*	\param in_oblique_x_skew The oblique skew in the horizontal direction.
	*	\param in_oblique_y_skew The oblique skew in the vertical direction.
	*	\return A reference to this object.
	*   \sa camera target */
	CameraControl &		SetProjection(Camera::Projection in_type, float in_oblique_x_skew = 0.0f, float in_oblique_y_skew = 0.0f);

	/*! Sets the camera field.
	*	\param in_width The width of the camera field, in object-space units.
	*	\param in_height The height of the camera field, in object-space units.
	*	\return A reference to this object.
	*   \sa camera field */
	CameraControl &		SetField(float in_width, float in_height);

	/*! Sets the near_limit to in_double that defines the near limit of the camera.
	*   A value approaching 0.0 will place it close to the camera position
	*   (at the cost of poor z-buffer precision), whereas a value approaching 1.0
	*   will place it near the camera target
	*   (at the cost of clipping away anything closer than the target).
	*   A value exactly equal to 0 will let HOOPS Visualize choose a  limit based on
	*   the precision of the zbuffer as reported by the driver.
	*   \param in_double The value to set the near limit to
	*   \return A reference to this object.
	*   \sa camera near limit*/
	CameraControl &		SetNearLimit(float in_double);

	/*! Removes all settings from this object. Unlike other attributes, it is not possible to unset just a single field of a camera.
	*   If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by CameraKit::GetDefault().
	*	\return A reference to this object. */
	CameraControl &		UnsetEverything();


	/*! Shows the camera up-vector.
	*	\param out_up_vector A vector that defines the vertical up direction of the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowUpVector(Vector & out_up_vector) const;

	/*! Shows the camera position.
	*	\param out_position the location of the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPosition(Point & out_position) const;

	/*! Shows the camera target.
	*	\param out_target the location that the camera is pointed at.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowTarget(Point & out_target) const;

	/*! Shows the camera projection type.
	*	\param out_type The type of camera projection.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowProjection(Camera::Projection & out_type) const;

	/*! Shows the camera projection type and the oblique skew, if any.
	*	\param out_type The type of camera projection.
	*	\param out_oblique_x_skew The oblique skew in the horizontal direction.
	*	\param out_oblique_y_skew The oblique skew in the vertical direction.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowProjection(Camera::Projection & out_type, float & out_oblique_x_skew, float & out_oblique_y_skew) const;

	/*! Shows the width of the camera field.
	*	\param out_width The width of the camera field, in object-space units.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowWidth(float & out_width) const;

	/*! Shows the height of the camera field.
	*	\param out_height The height of the camera field, in object-space units.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowHeight(float & out_height) const;

	/*! Shows the camera field.
	*	\param out_width The width of the camera field, in object-space units.
	*	\param out_height The height of the camera field, in object-space units.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowField(float & out_width, float & out_height) const;

	/*! Shows the camera near limit.
	*	\param out_width The near limit of the camera field.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowNearLimit(float & out_near_limit) const;

	/*! Moves the camera position and target the specified amount but maintains the up vector and field.
	*	If a complete camera is not already set up, one will be populated with default values before dollying.
	*	\param in_x_dir The number of world-space units to move the camera in the x-direction.
	*	\param in_up The number of world-space units to move the camera up, or if negative, down.
	*	\param in_forward The number of world-space units to move the camera toward the target, or if negative, away from the target.
	*	\return A reference to this object. */
	CameraControl &		Dolly(float in_x_dir, float in_up, float in_forward);

	/*! Moves the camera around the target <span class='code'>in_theta</span> degrees to the right and <span class='code'>in_phi</span> degrees up.
	*	The target and field are maintained but position and up_vector may change.
	*	If a complete camera is not already set up, one will be populated with default values before orbiting.
	*	\param in_theta The number of degrees to move the the camera position to the right.
	*	\param in_phi The number of degrees to move the the camera position up.
	*	\return A reference to this object. */
	CameraControl &		Orbit(float in_theta, float in_phi);

	/*! Pivots the camera on its location <span class='code'>in_theta</span> degrees to the right and <span class='code'>in_phi</span> degrees up.
	*	The position and field remain unchanged while the target and up vector may change.
	*	If a complete camera is not already set up, one will be populated with default values before panning.
	*	\param in_theta The number of degrees to move the the camera target to the right.
	*	\param in_phi The number of degrees to move the the camera target up.
	*	\return A reference to this object. */
	CameraControl &		Pan(float in_theta, float in_phi);

	/*! Spins the camera around its target <span class='code'>in_theta</span> degrees counter-clockwise (the scene will appear to move clockwise).
	*	The position, field, and target are unchanged while the up-vector may change.  If a complete camera is not already set
	*	up, one will be populated with default values before rolling.
	*	\param in_theta The number of degrees to roll the camera.
	*	\return A reference to this object. */
	CameraControl &		Roll(float in_theta);

	/*! Adjusts the field of view by dividing the width and height by the input value.  Numbers greater than one will have the effect
	*	of making things on screen appear larger.  Numbers between zero and one will have the opposite effect.  Only the field
	*	is affected.  If a complete camera is not already set up, one will be populated with default values before zooming.
	*	\param in_zoom The zoom scale factor.
	*	\return A reference to this object. */
	CameraControl &		Zoom(float in_zoom);

private:
	//! Private default constructor to prevent instantiation without a segment.
	CameraControl();
};



/*! The HPS::SelectabilityKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::SelectabilityKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#selectability">this table</a>. */
class HPS_API SelectabilityKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	SelectabilityKit();

	/*! The copy constructor creates a new SelectabilityKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	SelectabilityKit(SelectabilityKit const & in_kit);

	/*! The move constructor creates a SelectabilityKit by transferring the underlying impl of the rvalue reference to this SelectabilityKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectabilityKit to take the impl from.*/
	SelectabilityKit(SelectabilityKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectabilityKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a SelectabilityKit to take the impl from.
	* \return A reference to this SelectabilityKit. */
	SelectabilityKit & operator=(SelectabilityKit && in_that);

	/*! Destroy this kit. */
	virtual ~SelectabilityKit();

	static const HPS::Type staticType = HPS::Type::SelectabilityKit;
	HPS::Type		ObjectType() const {return staticType;};

	/*! Creates a SelectabilityKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A SelectabilityKit with the default settings. */
	static SelectabilityKit		GetDefault();

	/*! Copies all settings from the source SelectabilityKit into this object.
	* 	\param in_kit The source SelectabilityKit to copy. */
	void						Set(SelectabilityKit const & in_kit);

	/*! Copies all settings from this SelectabilityKit into the given SelectabilityKit.
	 * 	\param out_kit The SelectabilityKit to populate with the contents of this object. */
	void						Show(SelectabilityKit & out_kit) const;

	/*! Copies the source SelectabilityKit into this object.
	* 	\param in_kit The source SelectabilityKit to copy.
	 * 	\return A reference to this object. */
	SelectabilityKit &			operator=(SelectabilityKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source SelectabilityKit is equivalent to this object.
	*	\param in_kit The source SelectabilityKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(SelectabilityKit const & in_kit) const;

	/*!	Check if the source SelectabilityKit is equivalent to this object.
	*	\param in_kit The source SelectabilityKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(SelectabilityKit const & in_kit) const;

	/*!	Check if the source SelectabilityKit is not equivalent to this object.
	*	\param in_kit The source SelectabilityKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(SelectabilityKit const & in_kit) const;


	/*! Controls whether windows can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetWindows(Selectability::Value in_val);

	/*! Controls whether windows can be selected by selection actions.
	*	\param in_val Whether visible windows should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetWindows(bool in_val);

	/*! Controls whether edges can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetEdges(Selectability::Value in_val);

	/*! Controls whether edges can be selected by selection actions.
	*	\param in_val Whether visible edges should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetEdges(bool in_val);

	/*! Controls whether faces can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetFaces(Selectability::Value in_val);

	/*! Controls whether faces can be selected by selection actions.
	*	\param in_val Whether visible faces should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetFaces(bool in_val);

	/*! Controls whether lights can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetLights(Selectability::Value in_val);

	/*! Controls whether lights can be selected by selection actions.
	*	\param in_val Whether visible lights should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetLights(bool in_val);

	/*! Controls whether lines can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetLines(Selectability::Value in_val);

	/*! Controls whether lines can be selected by selection actions.
	*	\param in_val Whether visible lines should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetLines(bool in_val);

	/*! Controls whether markers can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetMarkers(Selectability::Value in_val);

	/*! Controls whether markers can be selected by selection actions.
	*	\param in_val Whether visible markers should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetMarkers(bool in_val);

	/*! Controls whether vertices can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetVertices(Selectability::Value in_val);

	/*! Controls whether vertices can be selected by selection actions.
	*	\param in_val Whether visible vertices should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetVertices(bool in_val);

	/*! Controls whether text can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetText(Selectability::Value in_val);

	/*! Controls whether text can be selected by selection actions.
	*	\param in_val Whether visible text should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetText(bool in_val);

	/*! Sets the selectability of all edges, faces, lights, lines, markers, vertices, and text.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetGeometry(Selectability::Value in_val);

	/*! Sets the selectability of all edges, faces, lights, lines, markers, vertices, and text.
	*	\param in_val Whether visible geometry should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetGeometry(bool in_val);

	/*! Sets the selectability of all geometry, subgeometry and windows.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityKit &		SetEverything(Selectability::Value in_val);

	/*! Sets the selectability of all geometry, subgeometry and windows.
	*	\param in_val Whether everything visible should be selectable.
	*	\return A reference to this object. */
	SelectabilityKit &		SetEverything(bool in_val);


	/*! Removes the selectability setting from windows.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetWindows();

	/*! Removes the selectability setting from edges.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetEdges();

	/*! Removes the selectability setting from faces.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetFaces();

	/*! Removes the selectability setting from lights.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetLights();

	/*! Removes the selectability setting from lines.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetLines();

	/*! Removes the selectability setting from markers.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetMarkers();

	/*! Removes the selectability setting from vertices.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetVertices();

	/*! Removes the selectability setting from text.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetText();

	/*! Removes the selectability settings from edges, faces, lights, lines, markers, vertices, and text.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetGeometry();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	SelectabilityKit &			UnsetEverything();


	/*! Shows whether windows can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWindows(Selectability::Value & out_val) const;

	/*! Shows whether edges can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEdges(Selectability::Value & out_val) const;

	/*! Shows whether faces can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaces(Selectability::Value & out_val) const;

	/*! Shows whether lights can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLights(Selectability::Value & out_val) const;

	/*! Shows whether lines can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLines(Selectability::Value & out_val) const;

	/*! Shows whether markers can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowMarkers(Selectability::Value & out_val) const;

	/*! Shows whether vertices can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertices(Selectability::Value & out_val) const;

	/*! Shows whether text can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowText(Selectability::Value & out_val) const;
};

/*!
<p>The SelectabilityControl class is a smart pointer that is tied to a database object. This object allows you to set and unset the selectability of the various types of geometry, such as faces, lines, markers, and vertices.</p>

<p>Default values for the various fields of SelectabilityControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#selectability">here</a>.</p>
*/
class HPS_API SelectabilityControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit SelectabilityControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	SelectabilityControl(SelectabilityControl const & in_that);

	/*! The move constructor creates a SelectabilityControl by transferring the underlying impl of the rvalue reference to this SelectabilityControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectabilityControl to take the impl from.*/
	SelectabilityControl(SelectabilityControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectabilityControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a SelectabilityControl to take the impl from.
	* \return A reference to this SelectabilityControl. */
	SelectabilityControl & operator=(SelectabilityControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~SelectabilityControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::SelectabilityControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the SelectabilityControl source.
	 *	\param in_that The SelectabilityControl source of the assignment.
	 *	\return A reference to this SelectabilityControl. */
	SelectabilityControl &		operator=(SelectabilityControl const & in_that);

	/*! Controls whether windows can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetWindows(Selectability::Value in_val);

	/*! Controls whether windows can be selected by selection actions.
	*	\param in_val Whether visible windows should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetWindows(bool in_val);

	/*! Controls whether edges can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetEdges(Selectability::Value in_val);

	/*! Controls whether edges can be selected by selection actions.
	*	\param in_val Whether visible edges should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetEdges(bool in_val);

	/*! Controls whether faces can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetFaces(Selectability::Value in_val);

	/*! Controls whether faces can be selected by selection actions.
	*	\param in_val Whether visible faces should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetFaces(bool in_val);

	/*! Controls whether lights can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetLights(Selectability::Value in_val);

	/*! Controls whether lights can be selected by selection actions.
	*	\param in_val Whether visible lights should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetLights(bool in_val);

	/*! Controls whether lines can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetLines(Selectability::Value in_val);

	/*! Controls whether lines can be selected by selection actions.
	*	\param in_val Whether visible lines should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetLines(bool in_val);

	/*! Controls whether markers can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetMarkers(Selectability::Value in_val);

	/*! Controls whether markers can be selected by selection actions.
	*	\param in_val Whether visible markers should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetMarkers(bool in_val);

	/*! Controls whether vertices can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetVertices(Selectability::Value in_val);

	/*! Controls whether vertices can be selected by selection actions.
	*	\param in_val Whether visible vertices should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetVertices(bool in_val);

	/*! Controls whether text can be selected by selection actions.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetText(Selectability::Value in_val);

	/*! Controls whether text can be selected by selection actions.
	*	\param in_val Whether visible text should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetText(bool in_val);

	/*! Sets the selectability of all edges, faces, lights, lines, markers, vertices, and text.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetGeometry(Selectability::Value in_val);

	/*! Sets the selectability of all edges, faces, lights, lines, markers, vertices, and text.
	*	\param in_val Whether visible geometry should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetGeometry(bool in_val);

	/*! Sets the selectability of all geometry, subgeometry and windows.
	*	\param in_val The level of selectability.
	*	\return A reference to this object. */
	SelectabilityControl &		SetEverything(Selectability::Value in_val);

	/*! Sets the selectability of all geometry, subgeometry and windows.
	*	\param in_val Whether everything visible should be selectable.
	*	\return A reference to this object. */
	SelectabilityControl &		SetEverything(bool in_val);


	/*! Removes the selectability setting from windows. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetWindows();

	/*! Removes the selectability setting from edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetEdges();

	/*! Removes the selectability setting from faces. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetFaces();

	/*! Removes the selectability setting from lights. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetLights();

	/*! Removes the selectability setting from lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetLines();

	/*! Removes the selectability setting from markers. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetMarkers();

	/*! Removes the selectability setting from vertices. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetVertices();

	/*! Removes the selectability setting from text. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetText();

	/*! Removes the selectability settings from edges, faces, lights, lines, markers, vertices, and text. If the control is attached to a WindowKey this function restores the default value of these
	*   settings as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetGeometry();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by SelectabilityKit::GetDefault().
	*	\return A reference to this object. */
	SelectabilityControl &		UnsetEverything();


	/*! Shows whether windows can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWindows(Selectability::Value & out_val) const;

	/*! Shows whether edges can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEdges(Selectability::Value & out_val) const;

	/*! Shows whether faces can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaces(Selectability::Value & out_val) const;

	/*! Shows whether lights can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLights(Selectability::Value & out_val) const;

	/*! Shows whether lines can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLines(Selectability::Value & out_val) const;

	/*! Shows whether markers can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowMarkers(Selectability::Value & out_val) const;

	/*! Shows whether vertices can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertices(Selectability::Value & out_val) const;

	/*! Shows whether text can be selected by selection actions.
	*	\param out_val The level of selectability.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowText(Selectability::Value & out_val) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	SelectabilityControl();
};


/*! The HPS::TransparencyKit class is a user space object, useful for carrying a group of attribute settings related to transparency. Calling HPS::TransparencyKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#transparency">this table</a>. */
class HPS_API TransparencyKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	TransparencyKit();

	/*! The copy constructor creates a new TransparencyKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	TransparencyKit(TransparencyKit const & in_kit);

	/*! The move constructor creates a TransparencyKit by transferring the underlying impl of the rvalue reference to this TransparencyKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TransparencyKit to take the impl from.*/
	TransparencyKit(TransparencyKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TransparencyKit thereby avoiding a copy.
	* \param in_that An rvalue reference to an TransparencyKit to take the impl from.
	* \return A reference to this TransparencyKit. */
	TransparencyKit & operator=(TransparencyKit && in_that);

	/*! Destroy this kit. */
	virtual ~TransparencyKit();

	static const HPS::Type staticType = HPS::Type::TransparencyKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a TransparencyKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A TransparencyKit with the default settings. */
	static TransparencyKit	GetDefault();

	/*! Copies all settings from the source TransparencyKit into this object.
	* 	\param in_kit The source TransparencyKit to copy. */
	void					Set(TransparencyKit const & in_kit);

	/*! Copies all settings from this TransparencyKit into the given TransparencyKit.
	 * 	\param out_kit The TransparencyKit to populate with the contents of this object. */
	void					Show(TransparencyKit & out_kit) const;

	/*! Copies the source TransparencyKit into this object.
	* 	\param in_kit The source TransparencyKit to copy.
	 * 	\return A reference to this object. */
	TransparencyKit &		operator=(TransparencyKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source TransparencyKit is equivalent to this object.
	*	\param in_kit The source TransparencyKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(TransparencyKit const & in_kit) const;

	/*!	Check if the source TransparencyKit is equivalent to this object.
	*	\param in_kit The source TransparencyKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(TransparencyKit const & in_kit) const;

	/*!	Check if the source TransparencyKit is not equivalent to this object.
	*	\param in_kit The source TransparencyKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(TransparencyKit const & in_kit) const;


	/*! Sets the method to use when blending transparent geometry.
	*	\param in_style The method to use when blending transparent geometry.
	*	\return a reference to this object. */
	TransparencyKit &		SetMethod(Transparency::Method in_style);

	/*! Sets the algorithm to use when calculating transparency.
	*	\param in_algorithm The algorithm to use.
	*	\return a reference to this object. */
	TransparencyKit &		SetAlgorithm(Transparency::Algorithm in_algorithm);

	/*! Sets the number of layers to use when performing depth peeling.
	*	Ignored in other transparency methods.
	*	\warning This setting will be limited by the depth peeling layer count set at the containing window / subwindow. If the count is lower than the containing window's count, excess render passes will be omitted.
	*	\param in_layers The number of layers to use when performing depth peeling.
	*	\return a reference to this object. */
	TransparencyKit &		SetDepthPeelingLayers(unsigned int in_layers);

	/*! Specifies whether quality or performance should be favored when performing depth peeling.
	*	Ignored in other transparency methods.
	*	\param in_perference The desired preference setting.
	*	\return a reference to this object. */
	TransparencyKit &		SetDepthPeelingPreference(Transparency::Preference in_preference);

	/*! Sets the amount of the screen a layer needs to occupy in order to process another layer when performing depth peeling.
	*	Ignored in other transparency methods.
	*	\param in_area The amount of the screen a layer needs to occupy in order to process another layer.
	*	\param in_units The units of the minimum area.
	*	\return a reference to this object. */
	TransparencyKit &		SetDepthPeelingMinimumArea(float in_area, Transparency::AreaUnits in_units);

	/*! Controls whether transparent geometry should write into the Z-buffer.
	*	Applies only when the transparency algorithm is NoSorting, ZSortNicest, or ZSortFastest.
	*	\param in_state Whether transparent geometry should write into the Z-buffer.
	*	\return a reference to this object. */
	TransparencyKit &		SetDepthWriting(bool in_state);


	/*! Removes the transparency method setting.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetMethod();

	/*! Removes the transparency algorithm setting.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetAlgorithm();

	/*! Removes the depth peeling layers setting.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetDepthPeelingLayers();

	/*! Removes the depth peeling minimum area setting.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetDepthPeelingMinimumArea();

	/*! Removes the depth writing setting.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetDepthWriting();

	/*! Removes the depth peeling preference setting.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetDepthPeelingPreference();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	TransparencyKit &		UnsetEverything();


	/*! Shows the method to use when blending transparent geometry.
	*	\param out_style The method to use when blending transparent geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMethod(Transparency::Method & out_style) const;

	/*! Shows the algorithm to use when calculating transparency.
	*	\param out_algorithm The algorithm to use.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowAlgorithm(Transparency::Algorithm & out_algorithm) const;

	/*! Shows the number of layers to use when performing depth peeling.
	*	\param out_layers The number of layers to use when performing depth peeling.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingLayers(unsigned int & out_layers) const;

	/*! Shows the amount of the screen a layer needs to occupy in order to process another layer when performing depth peeling.
	*	\param out_area The amount of the screen a layer needs to occupy in order to process another layer.
	*	\param out_units The units of the minimum area.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingMinimumArea(float & out_area, Transparency::AreaUnits & out_units) const;

	/*! Shows whether transparent geometry should write into the Z-buffer.
	*	\param out_state Whether transparent geometry should write into the Z-buffer.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthWriting(bool & out_state) const;

	/*! Shows the depth peeling performance setting.
	*	\param out_preference Whether quality or performance should be favored when performing depth peeling.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingPreference(Transparency::Preference & out_preference) const;
};

/*!
The HPS::TransparencyControl class is a smart pointer that is tied to a database object. This object allows you to set and unset the algorithms used for calculating transparency. Some algorithms, such as depth peeling, have additional attributes, and those are also controlled using this class. </p>

<p>Default values for the various fields of HPS::TransparencyControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#transparency">here</a>.</p>
*/
class HPS_API TransparencyControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit TransparencyControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	TransparencyControl(TransparencyControl const & in_that);

	/*! The move constructor creates a TransparencyControl by transferring the underlying impl of the rvalue reference to this TransparencyControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TransparencyControl to take the impl from.*/
	TransparencyControl(TransparencyControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TransparencyControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a TransparencyControl to take the impl from.
	* \return A reference to this TransparencyControl. */
	TransparencyControl & operator=(TransparencyControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~TransparencyControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::TransparencyControl;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the TransparencyControl source.
	 *	\param in_that The TransparencyControl source of the assignment.
	 *	\return A reference to this TransparencyControl. */
	TransparencyControl &	operator=(TransparencyControl const & in_that);

	/*! Sets the method to use when blending transparent geometry.
	*	\param in_style The method to use when blending transparent geometry.
	*	\return a reference to this object. */
	TransparencyControl &	SetMethod(Transparency::Method in_style);

	/*! Sets the algorithm to use when calculating transparency.
	*	\param in_algorithm The algorithm to use.
	*	\return a reference to this object. */
	TransparencyControl &	SetAlgorithm(Transparency::Algorithm in_algorithm);

	/*! Sets the number of layers to use when performing depth peeling.
	*	Ignored in other transparency methods.
	*	\warning This setting will be limited by the depth peeling layer count set at the containing window / subwindow. If the count is lower than the containing window's count, excess render passes will be omitted.
	*	\param in_layers The number of layers to use when performing depth peeling.
	*	\return a reference to this object. */
	TransparencyControl &	SetDepthPeelingLayers(unsigned int in_layers);

	/*! Sets the amount of the screen a layer needs to occupy in order to process another layer when performing depth peeling.
	*	Ignored in other transparency methods.
	*	\param in_area The amount of the screen a layer needs to occupy in order to process another layer.
	*	\param in_units The units of the minimum area.
	*	\return a reference to this object. */
	TransparencyControl &	SetDepthPeelingMinimumArea(float in_area, Transparency::AreaUnits in_units);

	/*! Controls whether transparent geometry should write into the Z-buffer.
	*	Applies only when the transparency algorithm is NoSorting, ZSortNicest, or ZSortFastest.
	*	\param in_state Whether transparent geometry should write into the Z-buffer.
	*	\return a reference to this object. */
	TransparencyControl &	SetDepthWriting(bool in_state);

	/*! Specifies whether quality or performance should be favored when performing depth peeling.
	*	Ignored in other transparency methods.
	*	\param in_perference The desired preference setting.
	*	\return a reference to this object. */
	TransparencyControl &		SetDepthPeelingPreference(Transparency::Preference in_preference);

	/*! Removes the transparency method setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl &	UnsetMethod();

	/*! Removes the transparency algorithm setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl &	UnsetAlgorithm();

	/*! Removes the depth peeling layers setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl &	UnsetDepthPeelingLayers();

	/*! Removes the depth peeling minimum area setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl & 	UnsetDepthPeelingMinimumArea();

	/*! Removes the depth writing setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl &	UnsetDepthWriting();

	/*! Removes the depth peeling preference setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl &	UnsetDepthPeelingPreference();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by TransparencyKit::GetDefault().
	*	\return A reference to this object. */
	TransparencyControl &	UnsetEverything();

	/*! Shows the method to use when blending transparent geometry.
	*	\param out_style The method to use when blending transparent geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMethod(Transparency::Method & out_style) const;

	/*! Shows the algorithm to use when calculating transparency.
	*	\param out_algorithm The algorithm to use.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowAlgorithm(Transparency::Algorithm & out_algorithm) const;

	/*! Shows the number of layers to use when performing depth peeling.
	*	\param out_layers The number of layers to use when performing depth peeling.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingLayers(unsigned int & out_layers) const;

	/*! Shows the amount of the screen a layer needs to occupy in order to process another layer when performing depth peeling.
	*	\param out_area The amount of the screen a layer needs to occupy in order to process another layer.
	*	\param out_units The units of the minimum area.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingMinimumArea(float & out_area, Transparency::AreaUnits & out_units) const;

	/*! Shows whether transparent geometry should write into the Z-buffer.
	*	\param out_state Whether transparent geometry should write into the Z-buffer.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthWriting(bool & out_state) const;

	/*! Shows the depth peeling preference.
	*	\param out_preference Whether quality of performance should be favored when performing depth peeling.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingPreference(Transparency::Preference & out_preference) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	TransparencyControl();
};

/*! The HPS::ColorInterpolationKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::ColorInterpolationKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#color-interpolation">this table</a>. */
class HPS_API ColorInterpolationKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	ColorInterpolationKit();

	/*! Copies the kit in_kit into this kit. */
	ColorInterpolationKit(ColorInterpolationKit const & in_kit);

	/*! The move constructor creates a ColorInterpolationKit by transferring the underlying impl of the rvalue reference to this ColorInterpolationKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ColorInterpolationKit to take the impl from.*/
	ColorInterpolationKit(ColorInterpolationKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ColorInterpolationKit thereby avoiding a copy.
	* \param in_that An rvalue reference to an ColorInterpolationKit to take the impl from.
	* \return A reference to this ColorInterpolationKit. */
	ColorInterpolationKit &				operator=(ColorInterpolationKit && in_that);

	/*! Destroy this kit. */
	virtual ~ColorInterpolationKit();

	static const HPS::Type staticType = HPS::Type::ColorInterpolationKit;
	HPS::Type		ObjectType() const {return staticType;};

	static ColorInterpolationKit		GetDefault();

	/*! Copies the kit in_kit into this kit. */
	void								Set(ColorInterpolationKit const & in_kit);

	/*! Copies this kit into out_kit. */
	void								Show(ColorInterpolationKit & out_kit) const;

	/*! Copies the kit in_kit into this kit. */
	ColorInterpolationKit &				operator=(ColorInterpolationKit const & in_kit);

	/*! Returns whether this kit has any values currently set on it. */
	bool								Empty() const;

	/*! Compares the contents of in_kit and this kit. */
	bool								Equals(ColorInterpolationKit const & in_kit) const;

	/*! Compares the contents of in_kit and this kit. */
	bool								operator==(ColorInterpolationKit const & in_kit) const;

	/*! Compares the contents of in_kit and this kit. */
	bool								operator!=(ColorInterpolationKit const & in_kit) const;


	/*! Controls whether face colors will be interpolated.
	*	\param in_state Whether face colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationKit &				SetFaceColor(bool in_state);

	/*! Controls whether edge colors will be interpolated.
	*	\param in_state Whether edge colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationKit &				SetEdgeColor(bool in_state);

	/*! Controls whether vertex colors will be interpolated.
	*	\param in_state Whether vertex colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationKit &				SetVertexColor(bool in_state);

	/*! Controls whether face colors index will be interpolated.
	*	\param in_state Whether face index colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationKit &				SetFaceIndex(bool in_state);

	/*! Controls whether edge index colors will be interpolated.
	*	\param in_state Whether edge index colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationKit &				SetEdgeIndex(bool in_state);

	/*! Controls whether vertex index colors will be interpolated.
	*	\param in_state Whether vertex index colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationKit &				SetVertexIndex(bool in_state);


	/*! Removes the face color interpolation setting.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetFaceColor();

	/*! Removes the edge color interpolation setting.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetEdgeColor();

	/*! Removes the vertex color interpolation setting.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetVertexColor();

	/*! Removes the face index color interpolation setting.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetFaceIndex();

	/*! Removes the edge index color interpolation setting.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetEdgeIndex();

	/*! Removes the vertex index color interpolation setting.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetVertexIndex();

	/*! Unsets all settings in this kit.
	*	\return a reference to this object. */
	ColorInterpolationKit &				UnsetEverything();


	/*! Shows whether color interpolation for the face color is set
	*	\param out_state The face setting for the color interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowFaceColor(bool & out_state) const;

	/*! Shows whether color interpolation for the edge color is set
	*	\param out_state The edge setting for the color interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowEdgeColor(bool & out_state) const;

	/*! Shows whether color interpolation for the vertex color is set
	*	\param out_state The vertex setting for the color interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowVertexColor(bool & out_state) const;

	/*! Shows whether color index interpolation for the face index is set
	*	\param out_state The face setting for the color index interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowFaceIndex(bool & out_state) const;

	/*! Shows whether color index interpolation for the edge index is set
	*	\param out_state The edge setting for the color index interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowEdgeIndex(bool & out_state) const;

	/*! Shows whether color index interpolation for the vertex index is set
	*	\param out_state The vertex setting for the color index interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowVertexIndex(bool & out_state) const;
};


/*!
<p>The HPS::ColorInterpolationControl class is a smart pointer that is tied to a database object. This class is the interface that allows you to manipulate whether color is interpolated over faces and edges. <a href="../../prog_guide/appendix_default_attribute_values.html#color-interpolation">This table</a> lists default values for the various segment attributes accessible from HPS::ColorInterpolationControl.</p>
*/
class HPS_API ColorInterpolationControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit ColorInterpolationControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	ColorInterpolationControl(ColorInterpolationControl const & in_that);

	/*! The move constructor creates a ColorInterpolationControl by transferring the underlying impl of the rvalue reference to this ColorInterpolationControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ColorInterpolationControl to take the impl from.*/
	ColorInterpolationControl(ColorInterpolationControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ColorInterpolationControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a ColorInterpolationControl to take the impl from.
	* \return A reference to this ColorInterpolationControl. */
	ColorInterpolationControl & operator=(ColorInterpolationControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~ColorInterpolationControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::ColorInterpolationControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the ColorInterpolationControl source.
	 *	\param in_that The ColorInterpolationControl source of the assignment.
	 *	\return A reference to this ColorInterpolationControl. */
	ColorInterpolationControl &	operator=(ColorInterpolationControl const & in_that);

	/*! Controls whether face colors will be interpolated.
	*	\param in_state Whether face colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationControl &				SetFaceColor(bool in_state);

	/*! Controls whether edge colors will be interpolated.
	*	\param in_state Whether edge colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationControl &				SetEdgeColor(bool in_state);

	/*! Controls whether vertex colors will be interpolated.
	*	\param in_state Whether vertex colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationControl &				SetVertexColor(bool in_state);

	/*! Controls whether face colors index will be interpolated.
	*	\param in_state Whether face index colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationControl &				SetFaceIndex(bool in_state);

	/*! Controls whether edge index colors will be interpolated.
	*	\param in_state Whether edge index colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationControl &				SetEdgeIndex(bool in_state);

	/*! Controls whether vertex index colors will be interpolated.
	*	\param in_state Whether vertex index colors will be interpolated.
	*	\return a reference to this object. */
	ColorInterpolationControl &				SetVertexIndex(bool in_state);


	/*! Removes the face color interpolation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetFaceColor();

	/*! Removes the edge color interpolation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetEdgeColor();

	/*! Removes the vertex color interpolation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetVertexColor();

	/*! Removes the face index color interpolation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetFaceIndex();

	/*! Removes the edge index color interpolation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetEdgeIndex();

	/*! Removes the vertex index color interpolation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetVertexIndex();

	/*! Unsets all settings in this control. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by ColorInterpolationKit::GetDefault().
	*	\return a reference to this object. */
	ColorInterpolationControl &				UnsetEverything();


	/*! Shows whether color interpolation for the face color is set
	*	\param out_state The face setting for the color interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowFaceColor(bool & out_state) const;

	/*! Shows whether color interpolation for the edge color is set
	*	\param out_state The edge setting for the color interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowEdgeColor(bool & out_state) const;

	/*! Shows whether color interpolation for the vertex color is set
	*	\param out_state The vertex setting for the color interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowVertexColor(bool & out_state) const;

	/*! Shows whether color index interpolation for the face index is set
	*	\param out_state The face setting for the color index interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowFaceIndex(bool & out_state) const;

	/*! Shows whether color index interpolation for the edge index is set
	*	\param out_state The edge setting for the color index interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowEdgeIndex(bool & out_state) const;

	/*! Shows whether color index interpolation for the vertex index is set
	*	\param out_state The vertex setting for the color index interpolation
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowVertexIndex(bool & out_state) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	ColorInterpolationControl() {}
};


/*! The HPS::CullingKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::CullingKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#culling">this table</a>. */
class HPS_API CullingKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	CullingKit();

	/*! The copy constructor creates a new CullingKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	CullingKit(CullingKit const & in_kit);

	/*! The move constructor creates a CullingKit by transferring the underlying impl of the rvalue reference to this CullingKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CullingKit to take the impl from.*/
	CullingKit(CullingKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CullingKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a CullingKit to take the impl from.
	* \return A reference to this CullingKit. */
	CullingKit & operator=(CullingKit && in_that);

	/*! Destroy this kit. */
	virtual ~CullingKit();

	static const HPS::Type staticType = HPS::Type::CullingKit;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Creates a CullingKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A CullingKit with the default settings. */
	static CullingKit	GetDefault();

	/*! Copies all settings from the source CullingKit into this object.
	* 	\param in_kit The source CullingKit to copy. */
	void				Set(CullingKit const & in_kit);

	/*! Copies all settings from this CullingKit into the given CullingKit.
	 * 	\param out_kit The CullingKit to populate with the contents of this object. */
	void				Show(CullingKit & out_kit) const;

	/*! Copies the source CullingKit into this object.
	* 	\param in_kit The source CullingKit to copy.
	 * 	\return A reference to this object. */
	CullingKit &		operator=(CullingKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source CullingKit is equivalent to this object.
	*	\param in_kit The source CullingKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(CullingKit const & in_kit) const;

	/*!	Check if the source CullingKit is equivalent to this object.
	*	\param in_kit The source CullingKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(CullingKit const & in_kit) const;

	/*!	Check if the source CullingKit is not equivalent to this object.
	*	\param in_kit The source CullingKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(CullingKit const & in_kit) const;

	/*! Controls whether geometry that falls below a certain size in pixels should be culled with deferral. Deferral culling means the object is given a low-priority draw order, effectively delaying draw time until the end of the frame.
	*	\param in_state Whether deferral culling should be enabled.
	*	\param in_pixels The number of pixels below which geometry should be culled with deferral.
	*	\return A reference to this object. */
	CullingKit &		SetDeferralExtent(bool in_state, unsigned int in_pixels);

	/*! Controls whether geometry that falls below a certain size in pixels should be culled with deferral. Deferral culling means the object is given a low-priority draw order, effectively delaying draw time until the end of the frame.
	*	This function implicitly enables deferral extent culling.
	*	\param in_pixels The number of pixels below which geometry should be culled with deferral.
	*	\return A reference to this object. */
	CullingKit &		SetDeferralExtent(unsigned int in_pixels);

	/*! Controls whether geometry that falls below a certain size in pixels should be culled.
	*	\param in_state Whether extent culling should be enabled.
	*	\param in_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return A reference to this object. */
	CullingKit &		SetExtent(bool in_state, unsigned int in_pixels);

	/*! Controls whether geometry that falls below a certain size in pixels should be culled.
	*	This function implicitly enables extent culling.
	*	\param in_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return A reference to this object. */
	CullingKit &		SetExtent(unsigned int in_pixels);

	/*! Controls whether faces with normals that point away from the camera should be culled.
	*	\param in_state Whether faces with normals that point away from the camera should be culled.
	*	\return A reference to this object. */
	CullingKit &		SetBackFace(bool in_state);

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	\param in_state Whether to use vector culling.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\param in_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return A reference to this object. */
	CullingKit &		SetVector(bool in_state, HPS::Vector const & in_vector, float in_tolerance_degrees);

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	This function implicitly enables extent culling.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\param in_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return A reference to this object. */
	CullingKit &		SetVector(HPS::Vector const & in_vector, float in_tolerance_degrees);

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	This function does not modify the vector tolerance.
	*	\param in_state Whether to use vector culling.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\return A reference to this object. */
	CullingKit &		SetVector(bool in_state, HPS::Vector const & in_vector = Vector(0.0f, 0.0f, 1.0f));

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	This function implicitly enables extent culling and does not modify the vector tolerance.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\return A reference to this object. */
	CullingKit &		SetVector(HPS::Vector const & in_vector);

	/*! Adjusts the tolerance value used in vector culling.  This setting will have no effect is vector culling is not enabled.
	*	\param in_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return A reference to this object. */
	CullingKit &		SetVectorTolerance(float in_tolerance_degrees);

	/*! Controls whether geometry outside the current view frustum should be culled.
	*	\param in_state Whether geometry outside the current view frustum should be culled.
	*	\return A reference to this object. */
	CullingKit &		SetFrustum(bool in_state);

	/*! Controls state of volume culling.
	*   When using volume culling segments whose bounding not inscribed and does not intersect the
	*	volume specified by in_volume will be culled.
	*	The points of the cuboid passed to this function need to be specified in world units.
	*	\param in_state Whether to use volume culling.
	*	\param in_volume A cuboid used to describe a world-space volume.
	*	\return A reference to this object. */
	CullingKit &		SetVolume(bool in_state, HPS::SimpleCuboid const & in_volume = HPS::SimpleCuboid());

	/*! Controls state of volume culling.
	*   When using volume culling segments whose bounding not inscribed and does not intersect the
	*	volume specified by in_volume will be culled.
	*	The points of the cuboid passed to this function need to be specified in world units.
	*	\param in_volume A cuboid used to describe a world-space volume.
	*	\return A reference to this object. */
	CullingKit &		SetVolume(HPS::SimpleCuboid const & in_volume);

	/*! Controls state of distance culling.
	*   When using distance culling geometries that lie farther away from the camera than
	*	specified in in_max_distance will be culled.
	*	in_max_distance is specified in world units.
	*	\param in_state Whether to use distance culling.
	*	\param in_max_distance The maximum distance from the camera after which geometries will be culled.
	*	\return A reference to this object. */
	CullingKit &	SetDistance(bool in_state, float in_max_distance);

	/*! Controls state of distance culling.
	*	This function implicitly enables distance culling.
	*   When using distance culling geometries that lie farther away from the camera than
	*	specified in in_max_distance will be culled.
	*	in_max_distance is specified in world units.
	*	\param in_max_distance The maximum distance from the camera after which geometries will be culled.
	*	\return A reference to this object. */
	CullingKit &	SetDistance(float in_max_distance);

	/*! Removes the extent culling setting.
	*	\return A reference to this object. */
	CullingKit &		UnsetDeferralExtent();

	/*! Removes the extent culling setting.
	*	\return A reference to this object. */
	CullingKit &		UnsetExtent();

	/*! Removes the back face culling setting.
	*	\return A reference to this object. */
	CullingKit &		UnsetBackFace();

	/*! Removes the vector culling setting while leaving the vector tolerance unmodified.
	*	\return A reference to this object. */
	CullingKit &		UnsetVector();

	/*! Removes the vector culling tolerance setting only.
	*	\return A reference to this object. */
	CullingKit &		UnsetVectorTolerance();

	/*! Removes the frustum culling setting.
	*	\return A reference to this object. */
	CullingKit &		UnsetFrustum();

	/*! Removes the volume culling setting.
	*	\return A reference to this object. */
	CullingKit &		UnsetVolume();

	/*! Removes the distance culling setting.
	*	\return A reference to this object. */
	CullingKit &		UnsetDistance();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	CullingKit &		UnsetEverything();

	/*! Shows whether geometry that falls below a certain size should be culled with deferral.
	*	\param out_state Whether deferral culling should be enabled.
	*	\param out_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return A reference to this object. */
	bool				ShowDeferralExtent(bool & out_state, unsigned int & out_pixels) const;

	/*! Shows whether geometry that falls below a certain size should be culled.
	*	\param out_state Whether extent culling should be enabled.
	*	\param out_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowExtent(bool & out_state, unsigned int & out_pixels) const;

	/*! Shows whether faces with normals that point away from the camera should be culled.
	*	\param out_state Whether faces with normals that point away from the camera should be culled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowBackFace(bool & out_state) const;

	/*! Shows the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	\param out_state Whether to use vector culling.
	*	\param out_vector The reference vector to compare the view vector to.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVector(bool & out_state, HPS::Vector & out_vector) const;

	/*! Shows the tolerance value used in vector culling.  This setting will have no effect is vector culling is not enabled.
	*	\param out_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVectorTolerance(float & out_tolerance_degrees) const;

	/*! Shows whether geometry outside the current view frustum should be culled.
	*	\param out_state Whether geometry outside the current view frustum should be culled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowFrustum(bool & out_state) const;

	/*! Shows the state of volume culling.
	*	When volume culling is active, segments whose bounding is not inscribed or intersecting out_volume will be culled.
	*	\param out_state Whether volume culling is being used.
	*	\param out_volume A cuboid defining a world-space volume.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVolume(bool & out_state, HPS::SimpleCuboid & out_volume) const;

	/*! Shows the state of distance culling.
	*	When distance culling is active, geometries that lie farther away from the camera than out_max_distance will be culled.
	*	\param out_state Whether distance culling is being used.
	*	\param out_max_distance The maximum distance away from the camera before geometries are culled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDistance(bool & out_state, float & out_max_distance) const;
};

/*!
<p>The HPS::CullingControl class is a smart pointer that is tied to a database object. Using this object, you are able to control the various options related to culling, such as enabling or disabling back face culling, vector culling, and frustum culling. <a href="../../prog_guide/appendix_default_attribute_values.html#culling">This table</a> lists default values for the various segment attributes accessible from HPS::CullingControl.</p>
*/
class HPS_API CullingControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit CullingControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	CullingControl(CullingControl const & in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~CullingControl();

	/*! The move constructor creates a CullingControl by transferring the underlying impl of the rvalue reference to this CullingControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CullingControl to take the impl from.*/
	CullingControl(CullingControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CullingControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a CullingControl to take the impl from.
	* \return A reference to this CullingControl. */
	CullingControl & operator=(CullingControl && in_that);

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::CullingControl;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the CullingControl source.
	 *	\param in_that The CullingControl source of the assignment.
	 *	\return A reference to this CullingControl. */
	CullingControl &	operator=(CullingControl const & in_that);

	/*! Controls whether geometry that falls below a certain size should be deferred.
	*	This setting only becomes relevant in timed updates (or fixed-framerate) when deferred geometry is given a lower priority.
	*	During non-timed updates no geometry is deferred, regardless of this setting.
	*	\param in_state Whether deferral culling should be enabled.
	*	\param in_pixels The number of pixels below which geometry should be deferred.
	*	\return A reference to this object. */
	CullingControl &	SetDeferralExtent(bool in_state, unsigned int in_pixels);

	/*! Controls whether geometry that falls below a certain size should be deferred.
	*	This setting only becomes relevant in timed updates (or fixed-framerate) when deferred geometry is given a lower priority.
	*	During non-timed updates no geometry is deferred, regardless of this setting.
	*	\param in_state Whether deferral culling should be enabled.
	*	\param in_pixels The number of pixels below which geometry should be deferred.
	*	\return A reference to this object. */
	CullingControl &	SetDeferralExtent(unsigned int in_pixels);

	/*! Controls whether geometry that falls below a certain size should be culled.
	*	\param in_state Whether extent culling should be enabled.
	*	\param in_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return A reference to this object. */
	CullingControl &	SetExtent(bool in_state, unsigned int in_pixels);

	/*! Controls whether geometry that falls below a certain size should be culled.
	*	This function implicitly enables extent culling.
	*	\param in_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return A reference to this object. */
	CullingControl &	SetExtent(unsigned int in_pixels);

	/*! Controls whether faces with normals that point away from the camera should be culled.
	*	This option can only be effective if a polygon handedness is defined.
	*	\param in_state Whether faces with normals that point away from the camera should be culled.
	*	\return A reference to this object. */
	CullingControl &	SetBackFace(bool in_state);

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	\param in_state Whether to use vector culling.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\param in_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return A reference to this object. */
	CullingControl &	SetVector(bool in_state, HPS::Vector const & in_vector, float in_tolerance_degrees);

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	This function implicitly enables extent culling.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\param in_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return A reference to this object. */
	CullingControl &	SetVector(HPS::Vector const & in_vector, float in_tolerance_degrees);

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	This function does not modify the vector tolerance.
	*	\param in_state Whether to use vector culling.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\return A reference to this object. */
	CullingControl &	SetVector(bool in_state, HPS::Vector const & in_vector = Vector(0.0f, 0.0f, 1.0f));

	/*! Controls the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	This function implicitly enables extent culling and does not modify the vector tolerance.
	*	\param in_vector The reference vector to compare the view vector to.
	*	\return A reference to this object. */
	CullingControl &	SetVector(HPS::Vector const & in_vector);

	/*! Adjusts the tolerance value used in vector culling.  This setting will have no effect is vector culling is not enabled.
	*	\param in_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return A reference to this object. */
	CullingControl &	SetVectorTolerance(float in_tolerance_degrees);

	/*! Controls whether geometry outside the current view frustum should be culled.
	*	\param in_state Whether geometry outside the current view frustum should be culled.
	*	\return A reference to this object. */
	CullingControl &	SetFrustum(bool in_state);

	/*! Controls state of volume culling.
	*   When using volume culling segments whose bounding not inscribed and does not intersect the
	*	volume specified by in_volume will be culled.
	*	The points of the cuboid passed to this function need to be specified in world units.
	*	\param in_state Whether to use volume culling.
	*	\param in_volume A cuboid used to describe a world-space volume.
	*	\return A reference to this object. */
	CullingControl &	SetVolume(bool in_state, HPS::SimpleCuboid const & in_volume = HPS::SimpleCuboid());

	/*! Controls state of volume culling.
	*   When using volume culling segments whose bounding not inscribed and does not intersect the
	*	volume specified by in_volume will be culled.
	*	The points of the cuboid passed to this function need to be specified in world units.
	*	\param in_volume A cuboid used to describe a world-space volume.
	*	\return A reference to this object. */
	CullingControl &	SetVolume(HPS::SimpleCuboid const & in_volume);

	/*! Controls state of distance culling.
	*   When using distance culling geometries that lie farther away from the camera than
	*	specified in in_max_distance will be culled.
	*	in_max_distance is specified in world units.
	*	\param in_state Whether to use distance culling.
	*	\param in_max_distance The maximum distance from the camera after which geometries will be culled.
	*	\return A reference to this object. */
	CullingControl &	SetDistance(bool in_state, float in_max_distance);

	/*! Controls state of distance culling.
	*	This function implicitly enables distance culling.
	*   When using distance culling geometries that lie farther away from the camera than
	*	specified in in_max_distance will be culled.
	*	in_max_distance is specified in world units.
	*	\param in_max_distance The maximum distance from the camera after which geometries will be culled.
	*	\return A reference to this object. */
	CullingControl &	SetDistance(float in_max_distance);

	/*! Removes the extent culling setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetDeferralExtent();

	/*! Removes the extent culling setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetExtent();

	/*! Removes the back face culling setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetBackFace();

	/*! Removes the vector culling setting while leaving the vector tolerance unmodified. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetVector();

	/*! Removes the vector culling tolerance setting only. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetVectorTolerance();

	/*! Removes the frustum culling setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetFrustum();

	/*! Removes the volume culling setting. If the control is attached to a WindowKey this function restores the default value of this
	*	setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetVolume();

	/*! Removes the distance culling setting. If the control is attached to a WindowKey this function restores the default value of this
	*	setting as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetDistance();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by CullingKit::GetDefault().
	*	\return A reference to this object. */
	CullingControl &	UnsetEverything();

	/*! Shows whether geometry that falls below a certain size should be deferred.
	*	\param out_state Whether deferral culling should be enabled.
	*	\param out_pixels The number of pixels below which geometry should be deferred.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDeferralExtent(bool & out_state, unsigned int & out_pixels) const;

	/*! Shows whether geometry that falls below a certain size should be culled.
	*	\param out_state Whether extent culling should be enabled.
	*	\param out_pixels The longest dimension of the screen-space projection of the bounding-volume, in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowExtent(bool & out_state, unsigned int & out_pixels) const;

	/*! Shows whether faces with normals that point away from the camera should be culled.
	*	\param out_state Whether faces with normals that point away from the camera should be culled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowBackFace(bool & out_state) const;

	/*! Shows the state of vector culling.  If the angle between the specified vector and the current
	*	view vector is less than the angle defined, then a segment with vector culling enabled will not be drawn.
	*	\param out_state Whether to use vector culling.
	*	\param out_vector The reference vector to compare the view vector to.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVector(bool & out_state, HPS::Vector & out_vector) const;

	/*! Shows the tolerance value used in vector culling.  This setting will have no effect is vector culling is not enabled.
	*	\param out_tolerance_degrees The upper limit, in degrees, between the reference vector and the view vector.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVectorTolerance(float & out_tolerance_degrees) const;

	/*! Shows whether geometry outside the current view frustum should be culled.
	*	\param out_state Whether geometry outside the current view frustum should be culled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowFrustum(bool & out_state) const;

	/*! Shows the state of volume culling.
	*	When volume culling is active, segments whose bounding is not inscribed or intersecting out_volume will be culled.
	*	\param out_state Whether volume culling is being used.
	*	\param out_volume A cuboid defining a world-space volume.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowVolume(bool & out_state, HPS::SimpleCuboid & out_volume) const;

	/*! Shows the state of distance culling.
	*	When distance culling is active, geometries that lie farther away from the camera than out_max_distance will be culled.
	*	\param out_state Whether distance culling is being used.
	*	\param out_max_distance The maximum distance away from the camera before geometries are culled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDistance(bool & out_state, float & out_max_distance) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	CullingControl();
};




/*! The HPS::MarkerAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::MarkerAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#markers">this table</a>. */
class HPS_API MarkerAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	MarkerAttributeKit();

	/*! The copy constructor creates a new MarkerAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	MarkerAttributeKit(MarkerAttributeKit const & in_kit);

	/*! The move constructor creates a MarkerAttributeKit by transferring the underlying impl of the rvalue reference to this MarkerAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MarkerAttributeKit to take the impl from.*/
	MarkerAttributeKit(MarkerAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MarkerAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a MarkerAttributeKit to take the impl from.
	* \return A reference to this MarkerAttributeKit. */
	MarkerAttributeKit & operator=(MarkerAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~MarkerAttributeKit();

	static const HPS::Type staticType = HPS::Type::MarkerAttributeKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a MarkerAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A MarkerAttributeKit with the default settings. */
	static MarkerAttributeKit GetDefault();

	/*! Copies all settings from the source MarkerAttributeKit into this object.
	* 	\param in_kit The source MarkerAttributeKit to copy. */
	void					Set(MarkerAttributeKit const & in_kit);

	/*! Copies all settings from this MarkerAttributeKit into the given MarkerAttributeKit.
	 * 	\param out_kit The MarkerAttributeKit to populate with the contents of this object. */
	void					Show(MarkerAttributeKit & out_kit) const;

	/*! Copies the source MarkerAttributeKit into this object.
	* 	\param in_kit The source MarkerAttributeKit to copy.
	 * 	\return A reference to this object. */
	MarkerAttributeKit &	operator=(MarkerAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source MarkerAttributeKit is equivalent to this object.
	*	\param in_kit The source MarkerAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(MarkerAttributeKit const & in_kit) const;

	/*!	Check if the source MarkerAttributeKit is equivalent to this object.
	*	\param in_kit The source MarkerAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(MarkerAttributeKit const & in_kit) const;

	/*!	Check if the source MarkerAttributeKit is not equivalent to this object.
	*	\param in_kit The source MarkerAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(MarkerAttributeKit const & in_kit) const;


	/*! Sets the glyph used to represent markers.
	*	\param in_glyph_name A UTF8 encoded name of a glyph, defined in an accessible portfolio.
	*	\return A reference to this object. */
	MarkerAttributeKit &	SetSymbol(char const * in_glyph_name);

	/*! Sets the size of markers.
	*	\param in_size The size for markers.
	*	\param in_units The units of the size for markers.
	*	\return A reference to this object. */
	MarkerAttributeKit &	SetSize(float in_size, Marker::SizeUnits in_units = Marker::SizeUnits::ScaleFactor);

	/*! Sets the drawing method for markers. Fastest will draw at requested size, unless that would incur performance cost. Nicest will anyway.
	*	\param in_preference The preferred drawing style.
	*	\return A reference to this object. */
	MarkerAttributeKit &	SetDrawingPreference(Marker::DrawingPreference in_preference);

	/*! Sets the glyph rotation option.
	*	\param in_rotation The rotation for glyphs.
	*	\return A reference to this object. */
	MarkerAttributeKit &	SetGlyphRotation(float in_rotation);

	/*! Removes the marker symbol setting.
	*	\return A reference to this object. */
	MarkerAttributeKit &	UnsetSymbol();

	/*! Removes the marker size setting.
	*	\return A reference to this object. */
	MarkerAttributeKit &	UnsetSize();

	/*! Removes the drawing preference setting
	*	\return A reference to this object. */
	MarkerAttributeKit &	UnsetDrawingPreference();

	/*! Removes the glyph rotation setting
		*	\return A reference to this object. */
	MarkerAttributeKit &	UnsetGlyphRotation();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	MarkerAttributeKit &	UnsetEverything();

	/*! Shows the glyph that should be used to draw markers.
	*	\param out_glyph_name A UTF8 encoded name of a glyph, defined in an accessible portfolio.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSymbol(UTF8 & out_glyph_name) const;

	/*! Shows the size of markers.
	*	\param out_size The size for markers.
	*	\param out_units The units of the size for markers.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSize(float & out_size, Marker::SizeUnits & out_units) const;

	/*! Shows the drawing method for markers.
	*	\param out_preference The preferred drawing style.
	*	return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDrawingPreference(Marker::DrawingPreference & out_preference) const;

	/*! Shows the glyph rotation option.
	*	\param out_rotation The glyph rotation option in degrees.
	*	return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowGlyphRotation(float & out_rotation) const;
};

/*!
<p>The HPS::MarkerAttributeControl class is a smart pointer that is tied to a database object. This control allows you to manipulate the marker size and symbol at the segment level. </p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#markers">This table</a> lists default values for the various segment attributes accessible from HPS::MarkerAttributeControl.</p>
*/
class HPS_API MarkerAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit MarkerAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	MarkerAttributeControl(MarkerAttributeControl const & in_that);

	/*! The move constructor creates a MarkerAttributeControl by transferring the underlying impl of the rvalue reference to this MarkerAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MarkerAttributeControl to take the impl from.*/
	MarkerAttributeControl(MarkerAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MarkerAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a MarkerAttributeControl to take the impl from.
	* \return A reference to this MarkerAttributeControl. */
	MarkerAttributeControl & operator=(MarkerAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~MarkerAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::MarkerAttributeControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the MarkerAttributeControl source.
	 *	\param in_that The MarkerAttributeControl source of the assignment.
	 *	\return A reference to this MarkerAttributeControl. */
	MarkerAttributeControl &	operator=(MarkerAttributeControl const & in_that);

	/*! Sets the glyph that should be used to draw markers.
	*	\param in_glyph_name A UTF8 encoded name of a glyph, defined in an accessible portfolio.
	*	\return A reference to this object. */
	MarkerAttributeControl &	SetSymbol(char const * in_glyph_name);

	/*! Sets the size of markers.
	*	\param in_size The size for markers.
	*	\param in_units The units of the size for markers.
	*	\return A reference to this object. */
	MarkerAttributeControl &	SetSize(float in_size, Marker::SizeUnits in_units = Marker::SizeUnits::ScaleFactor);

	/*! Sets the drawing method for markers. Fastest will draw at requested size, unless that would incur performance cost. Nicest will anyway.
	*	\param in_preference The preferred drawing style.
	*	\return A reference to this object. */
	MarkerAttributeControl &	SetDrawingPreference(Marker::DrawingPreference in_preference);

	/*! Sets the glyph rotation option.
	*	\param in_rotation The rotation for glyphs.
	*	\return A reference to this object. */
	MarkerAttributeControl &	SetGlyphRotation(float in_rotation);

	/*! Removes the marker symbol setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MarkerAttributeKit::GetDefault().
	*	\return A reference to this object. */
	MarkerAttributeControl &	UnsetSymbol();

	/*! Removes the marker size setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MarkerAttributeKit::GetDefault().
	*	\return A reference to this object. */
	MarkerAttributeControl &	UnsetSize();

	/*! Removes the drawing preference setting
	*	\return A reference to this object. */
	MarkerAttributeControl &	UnsetDrawingPreference();

	/*! Removes the glyph rotation setting
	*	\return A reference to this object. */
	MarkerAttributeControl &	UnsetGlyphRotation();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by MarkerAttributeKit::GetDefault().
	*	\return A reference to this object. */
	MarkerAttributeControl &	UnsetEverything();


	/*! Shows the glyph that should be used to draw markers.
	*	\param out_glyph_name A UTF8 encoded name of a glyph, defined in an accessible portfolio.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSymbol(UTF8 & out_glyph_name) const;

	/*! Shows the size of markers.
	*	\param out_size The size for markers.
	*	\param out_units The units of the size for markers.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSize(float & out_size, Marker::SizeUnits & out_units) const;

	/*! Shows the drawing method for markers.
	*	\param out_preference The preferred drawing style.
	*	return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDrawingPreference(Marker::DrawingPreference & out_preference) const;

	/*! Shows the glyph rotation.
	*	\param out_rotation The rotation value.
	*	return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowGlyphRotation(float & out_rotation) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	MarkerAttributeControl();
};


/*! The HPS::SphereAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::SphereAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#spheres">this table</a>. */
class HPS_API SphereAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	SphereAttributeKit();

	/*! The copy constructor creates a new SphereAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	SphereAttributeKit(SphereAttributeKit const & in_kit);

	/*! The move constructor creates a SphereAttributeKit by transferring the underlying impl of the rvalue reference to this SphereAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SphereAttributeKit to take the impl from.*/
	SphereAttributeKit(SphereAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SphereAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a SphereAttributeKit to take the impl from.
	* \return A reference to this SphereAttributeKit. */
	SphereAttributeKit & operator=(SphereAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~SphereAttributeKit();

	static const HPS::Type staticType = HPS::Type::SphereAttributeKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a SphereAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A SphereAttributeKit with the default settings. */
	static SphereAttributeKit GetDefault();

	/*! Copies all settings from the source SphereAttributeKit into this object.
	* 	\param in_kit The source SphereAttributeKit to copy. */
	void					Set(SphereAttributeKit const & in_kit);

	/*! Copies all settings from this SphereAttributeKit into the given SphereAttributeKit.
	 * 	\param out_kit The SphereAttributeKit to populate with the contents of this object. */
	void					Show(SphereAttributeKit & out_kit) const;

	/*! Copies the source SphereAttributeKit into this object.
	* 	\param in_kit The source SphereAttributeKit to copy.
	 * 	\return A reference to this object. */
	SphereAttributeKit &	operator=(SphereAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source SphereAttributeKit is equivalent to this object.
	*	\param in_kit The source SphereAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(SphereAttributeKit const & in_kit) const;

	/*!	Check if the source SphereAttributeKit is equivalent to this object.
	*	\param in_kit The source SphereAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(SphereAttributeKit const & in_kit) const;

	/*!	Check if the source SphereAttributeKit is not equivalent to this object.
	*	\param in_kit The source SphereAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(SphereAttributeKit const & in_kit) const;


	/*! Sets the number of faces that should be generated around the equator of spheres.
	*	\param in_facets the number of faces that should be generated around the equator of spheres.
	*	\return A reference to this object. */
	SphereAttributeKit &	SetTessellation(size_t in_facets);


	/*! Removes the sphere tessellation setting.
	*	\return A reference to this object. */
	SphereAttributeKit &	UnsetTessellation();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	SphereAttributeKit &	UnsetEverything();


	/*! Shows the number of faces that should be generated around the equator of spheres.
	*	\param out_facets The number of faces that should be generated around the equator of spheres.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowTessellation(size_t & out_facets) const;
};


/*! The HPS::SphereAttributeControl class is a smart pointer that is tied to a database object. This control gives you access to
	the tessellation value for spheres. <a href="../../prog_guide/appendix_default_attribute_values.html#spheres">This table</a> lists default values for the various segment attributes accessible from HPS::SphereAttributeControl. */
class HPS_API SphereAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit SphereAttributeControl(SegmentKey const & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	SphereAttributeControl(SphereAttributeControl const & in_that);

	/*! The move constructor creates a SphereAttributeControl by transferring the underlying impl of the rvalue reference to this SphereAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SphereAttributeControl to take the impl from.*/
	SphereAttributeControl(SphereAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SphereAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a SphereAttributeControl to take the impl from.
	* \return A reference to this SphereAttributeControl. */
	SphereAttributeControl & operator=(SphereAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~SphereAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::SphereAttributeControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the SphereAttributeControl source.
	 *	\param in_that The SphereAttributeControl source of the assignment.
	 *	\return A reference to this SphereAttributeControl. */
	SphereAttributeControl &	operator=(SphereAttributeControl const & in_that);

	/*! Sets the number of faces that should be generated around the equator of spheres.
	*	\param in_facets the number of faces that should be generated around the equator of spheres.
	*	\return A reference to this object.
	*	\sa Sphere tessellation <a href="../../prog_guide/appendix_default_attribute_values.html#sphere-tessellation">default value</a> */
	SphereAttributeControl &	SetTessellation(size_t in_facets);


	/*! Removes the sphere tessellation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SphereAttributeKit::GetDefault().
	*	\return A reference to this object. */
	SphereAttributeControl &	UnsetTessellation();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by SphereAttributeKit::GetDefault().
	*	\return A reference to this object. */
	SphereAttributeControl &	UnsetEverything();


	/*! Shows the number of faces that should be generated around the equator of spheres.
	*	\param out_facets The number of faces that should be generated around the equator of spheres.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTessellation(size_t & out_facets) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	SphereAttributeControl();
};


/*! The HPS::LightingAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::LightingAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#lighting">this table</a>. */
class HPS_API LightingAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	LightingAttributeKit();

	/*! The copy constructor creates a new LightingAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	LightingAttributeKit(LightingAttributeKit const & in_kit);

	/*! The move constructor creates a LightingAttributeKit by transferring the underlying impl of the rvalue reference to this LightingAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LightingAttributeKit to take the impl from.*/
	LightingAttributeKit(LightingAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LightingAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a LightingAttributeKit to take the impl from.
	* \return A reference to this LightingAttributeKit. */
	LightingAttributeKit & operator=(LightingAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~LightingAttributeKit();

	static const HPS::Type staticType = HPS::Type::LightingAttributeKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a LightingAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A LightingAttributeKit with the default settings. */
	static LightingAttributeKit GetDefault();

	/*! Copies all settings from the source LightingAttributeKit into this object.
	* 	\param in_kit The source LightingAttributeKit to copy. */
	void					Set(LightingAttributeKit const & in_kit);

	/*! Copies all settings from this LightingAttributeKit into the given LightingAttributeKit.
	 * 	\param out_kit The LightingAttributeKit to populate with the contents of this object. */
	void					Show(LightingAttributeKit & out_kit) const;

	/*! Copies the source LightingAttributeKit into this object.
	* 	\param in_kit The source LightingAttributeKit to copy.
	 * 	\return A reference to this object. */
	LightingAttributeKit &	operator=(LightingAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source LightingAttributeKit is equivalent to this object.
	*	\param in_kit The source LightingAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(LightingAttributeKit const & in_kit) const;

	/*!	Check if the source LightingAttributeKit is equivalent to this object.
	*	\param in_kit The source LightingAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(LightingAttributeKit const & in_kit) const;

	/*!	Check if the source LightingAttributeKit is not equivalent to this object.
	*	\param in_kit The source LightingAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(LightingAttributeKit const & in_kit) const;


	/*! Sets the interpolation algorithm that will be used for rendering lit faces.
	*	\param in_interpolation The algorithm that will be used for rendering lit faces.
	*	\return A reference to this object. */
	LightingAttributeKit &	SetInterpolationAlgorithm(Lighting::InterpolationAlgorithm in_interpolation);


	/*! Removes the interpolation algorithm setting.
	*	\return A reference to this object. */
	LightingAttributeKit &	UnsetInterpolationAlgorithm();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	LightingAttributeKit &	UnsetEverything();


	/*! Shows the interpolation algorithm that will be used for rendering lit faces.
	*	\param out_interpolation The algorithm that will be used for rendering lit faces.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowInterpolationAlgorithm(Lighting::InterpolationAlgorithm & out_interpolation) const;
};



/*!
<p>The HPS::LightingAttributeControl class is a smart pointer that is tied to a database object. This control is used to set the lighting interpolation algorithm. </p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#lighting">This table</a> lists default values for the various segment attributes accessible from HPS::LightingAttributeControl.</p>
*/
class HPS_API LightingAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit LightingAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	LightingAttributeControl(LightingAttributeControl const & in_that);

	/*! The move constructor creates a LightingAttributeControl by transferring the underlying impl of the rvalue reference to this LightingAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LightingAttributeControl to take the impl from.*/
	LightingAttributeControl(LightingAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LightingAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a LightingAttributeControl to take the impl from.
	* \return A reference to this LightingAttributeControl. */
	LightingAttributeControl & operator=(LightingAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~LightingAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::LightingAttributeControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the LightingAttributeControl source.
	 *	\param in_that The LightingAttributeControl source of the assignment.
	 *	\return A reference to this LightingAttributeControl. */
	LightingAttributeControl &	operator=(LightingAttributeControl const & in_that);

	/*! Sets the interpolation algorithm that will be used for rendering lit faces.
	*	\param in_interpolation The algorithm that will be used for rendering lit faces.
	*	\return A reference to this object. */
	LightingAttributeControl &	SetInterpolationAlgorithm(Lighting::InterpolationAlgorithm in_interpolation);


	/*! Removes the interpolation algorithm setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by LightingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	LightingAttributeControl &	UnsetInterpolationAlgorithm();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by LightingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	LightingAttributeControl &	UnsetEverything();


	/*! Shows the interpolation algorithm that will be used for rendering lit faces.
	*	\param out_interpolation The algorithm that will be used for rendering lit faces.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowInterpolationAlgorithm(Lighting::InterpolationAlgorithm & out_interpolation) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	LightingAttributeControl();
};



/*! The HPS::CylinderAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::CylinderAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#cylinders">this table</a>. */
class HPS_API CylinderAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	CylinderAttributeKit();

	/*! The copy constructor creates a new CylinderAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	CylinderAttributeKit(CylinderAttributeKit const & in_kit);

	/*! The move constructor creates a CylinderAttributeKit by transferring the underlying impl of the rvalue reference to this CylinderAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CylinderAttributeKit to take the impl from.*/
	CylinderAttributeKit(CylinderAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CylinderAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a CylinderAttributeKit to take the impl from.
	* \return A reference to this CylinderAttributeKit. */
	CylinderAttributeKit & operator=(CylinderAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~CylinderAttributeKit();

	static const HPS::Type staticType = HPS::Type::CylinderAttributeKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a CylinderAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A CylinderAttributeKit with the default settings. */
	static CylinderAttributeKit GetDefault();

	/*! Copies all settings from the source CylinderAttributeKit into this object.
	* 	\param in_kit The source CylinderAttributeKit to copy. */
	void						Set(CylinderAttributeKit const & in_kit);

	/*! Copies all settings from this CylinderAttributeKit into the given CylinderAttributeKit.
	 * 	\param out_kit The CylinderAttributeKit to populate with the contents of this object. */
	void						Show(CylinderAttributeKit & out_kit) const;

	/*! Copies the source CylinderAttributeKit into this object.
	* 	\param in_kit The source CylinderAttributeKit to copy.
	 * 	\return A reference to this object. */
	CylinderAttributeKit &		operator=(CylinderAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source CylinderAttributeKit is equivalent to this object.
	*	\param in_kit The source CylinderAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(CylinderAttributeKit const & in_kit) const;

	/*!	Check if the source CylinderAttributeKit is equivalent to this object.
	*	\param in_kit The source CylinderAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(CylinderAttributeKit const & in_kit) const;

	/*!	Check if the source CylinderAttributeKit is not equivalent to this object.
	*	\param in_kit The source CylinderAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(CylinderAttributeKit const & in_kit) const;


	/*! Sets the number of faces that should be generated around cylinders.
	*	\param in_facets the number of faces that should be generated around cylinders.
	*	\return A reference to this object. */
	CylinderAttributeKit &		SetTessellation(size_t in_facets);

	/*! Sets the orientation of colors and radii of cylinders.
	*	This can be used to invert the order of the radii and/or colors of all cylinders in a segment without editing each one.
	*	\param in_orientation The orientation of colors and radii of cylinders.
	*	\return A reference to this object. */
	CylinderAttributeKit &		SetOrientation(Cylinder::Orientation in_adjust);


	/*! Removes the cylinder tessellation setting.
	*	\return A reference to this object. */
	CylinderAttributeKit &		UnsetTessellation();

	/*! Removes the cylinder orientation setting.
	*	\return A reference to this object. */
	CylinderAttributeKit &		UnsetOrientation();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	CylinderAttributeKit &		UnsetEverything();


	/*! Shows the number of faces that should be generated around cylinders.
	*	\param out_facets The number of faces that should be generated around cylinders
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTessellation(size_t & out_facets) const;

	/*! Shows the orientation of colors and radii of cylinders.
	*	\param out_orientation The orientation of colors and radii of cylinders.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOrientation(Cylinder::Orientation & out_orientation) const;
};



/*!
The HPS::CylinderAttributeControl class is a smart pointer that is tied to a database object. This object is used to manipulate the various cylinder attributes, such as orientation and tessellation. <a href="../../prog_guide/appendix_default_attribute_values.html#cylinders">This table</a> lists default values for the various segment attributes accessible from HPS::CylinderAttributeControl.</p>
*/
class HPS_API CylinderAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit CylinderAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	CylinderAttributeControl(CylinderAttributeControl const & in_that);

	/*! The move constructor creates a CylinderAttributeControl by transferring the underlying impl of the rvalue reference to this CylinderAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CylinderAttributeControl to take the impl from.*/
	CylinderAttributeControl(CylinderAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CylinderAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a CylinderAttributeControl to take the impl from.
	* \return A reference to this CylinderAttributeControl. */
	CylinderAttributeControl & operator=(CylinderAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~CylinderAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::CylinderAttributeControl;
	HPS::Type						ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the CylinderAttributeControl source.
	 *	\param in_that The CylinderAttributeControl source of the assignment.
	 *	\return A reference to this CylinderAttributeControl. */
	CylinderAttributeControl &		operator=(CylinderAttributeControl const & in_that);

	/*! Sets the number of faces that should be generated around cylinders.
	*	\param in_facets the number of faces that should be generated around cylinders.
	*	\return A reference to this object. */
	CylinderAttributeControl &		SetTessellation(size_t in_facets);

	/*! Sets the orientation of colors and radii of cylinders.
	*	This can be used to invert the order of the radii and/or colors of all cylinders in a segment without editing each one.
	*	\param in_orientation The orientation of colors and radii of cylinders.
	*	\return A reference to this object. */
	CylinderAttributeControl &		SetOrientation(Cylinder::Orientation in_orientation);


	/*! Removes the cylinder tessellation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CylinderAttributeKit::GetDefault().
	*	\return A reference to this object. */
	CylinderAttributeControl &		UnsetTessellation();

	/*! Removes the cylinder orientation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CylinderAttributeKit::GetDefault().
	*	\return A reference to this object. */
	CylinderAttributeControl &		UnsetOrientation();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by CylinderAttributeKit::GetDefault().
	*	\return A reference to this object. */
	CylinderAttributeControl &		UnsetEverything();


	/*! Shows the number of faces that should be generated around cylinders.
	*	\param out_facets Whether text should be bold.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowTessellation(size_t & out_facets) const;

	/*! Shows the orientation of colors and radii of cylinders.
	*	\param out_orientation The orientation of colors and radii of cylinders.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowOrientation(Cylinder::Orientation & out_adjust) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	CylinderAttributeControl();
};



/*! The HPS::CuttingSectionAttributeKit class is a user space object which encapsulates a set of attributes pertaining to cutting sections. Calling HPS::CuttingSectionAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#cutting-sections">this table</a>. */
class HPS_API CuttingSectionAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	CuttingSectionAttributeKit();

	/*! The copy constructor creates a new CuttingSectionAttributeKit object that contains the same settings as the source object.
	 *	\param in_kit The source object to copy. */
	CuttingSectionAttributeKit(CuttingSectionAttributeKit const & in_kit);

	/*! The move constructor creates a CuttingSectionAttributeKit by transferring the underlying impl of the rvalue reference to this CuttingSectionAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CuttingSectionAttributeKit to take the impl from.*/
	CuttingSectionAttributeKit(CuttingSectionAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CuttingSectionAttributeKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CuttingSectionAttributeKit to take the impl from.
	 *	\return A reference to this CuttingSectionAttributeKit. */
	CuttingSectionAttributeKit & operator=(CuttingSectionAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~CuttingSectionAttributeKit();

	static const HPS::Type staticType = HPS::Type::CuttingSectionAttributeKit;
	HPS::Type							ObjectType() const {return staticType;};

	/*! Creates a CuttingSectionAttributeKit which contains the default settings.  The returned object will not necessarily have values
	 *	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 *	\return A CuttingSectionAttributeKit with the default settings. */
	static CuttingSectionAttributeKit	GetDefault();

	/*! Copies all settings from the source CuttingSectionAttributeKit into this object.
	 * 	\param in_kit The source CuttingSectionAttributeKit to copy. */
	void								Set(CuttingSectionAttributeKit const & in_kit);

	/*! Copies all settings from this CuttingSectionAttributeKit into the given CuttingSectionAttributeKit.
	 * 	\param out_kit The CuttingSectionAttributeKit to populate with the contents of this object. */
	void								Show(CuttingSectionAttributeKit & out_kit) const;

	/*! Copies the source CuttingSectionAttributeKit into this object.
	 * 	\param in_kit The source CuttingSectionAttributeKit to copy.
	 * 	\return A reference to this object. */
	CuttingSectionAttributeKit &		operator=(CuttingSectionAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool								Empty() const;

	/*!	Check if the source CuttingSectionAttributeKit is equivalent to this object.
	 *	\param in_kit The source CuttingSectionAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								Equals(CuttingSectionAttributeKit const & in_kit) const;

	/*!	Check if the source CuttingSectionAttributeKit is equivalent to this object.
	 *	\param in_kit The source CuttingSectionAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								operator==(CuttingSectionAttributeKit const & in_kit) const;

	/*!	Check if the source CuttingSectionAttributeKit is not equivalent to this object.
	 *	\param in_kit The source CuttingSectionAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool								operator!=(CuttingSectionAttributeKit const & in_kit) const;

	/*! Sets the cut edge weight.
	*	\param in_weight The edge weight to apply for cut edges.
	*	\param in_units The units of the weight given.
	*	\return A reference to this object. */
	CuttingSectionAttributeKit &		SetEdgeWeight(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);

	/*! Sets the tolerance for closing loops when processing capping faces.
	*	\param in_tolerance The tolerance to use.
	*	\param in_units How to interpret the given tolerance.
	*	\return A reference to this object. */
	CuttingSectionAttributeKit &		SetTolerance(float in_tolerance, CuttingSection::ToleranceUnits in_units);

	/*! Sets the cutting section cutting level.
	 *	\param in_level The cutting section cutting level.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		SetCuttingLevel(CuttingSection::CuttingLevel in_level);

	/*! Sets the cutting section capping level.
	 *	\param in_level The cutting section capping level.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		SetCappingLevel(CuttingSection::CappingLevel in_level);

	/*! Sets the cutting section capping usage.
	 *	\param in_usage The cutting section capping usage.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		SetCappingUsage(CuttingSection::CappingUsage in_usage);

	/*! Sets the material preference for cut geometry.
	 *	\param in_preference The material preference for cut geometry.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		SetMaterialPreference(CuttingSection::MaterialPreference in_preference);

	/*! Removes the cutting section cut edge weight setting.
	*	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetEdgeWeight();

	/*! Removes the cutting section capping tolerance setting.
	*	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetTolerance();

	/*! Removes the cutting section cutting level setting.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetCuttingLevel();

	/*! Removes the cutting section capping level setting.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetCappingLevel();

	/*! Removes the cutting section capping usage setting.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetCappingUsage();

	/*! Removes the material preference for cut geometry setting.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetMaterialPreference();

	/*! Removes all settings from this object.
	 *	\return A reference to this object. */
	CuttingSectionAttributeKit &		UnsetEverything();


	/*! Shows the cutting section cutting level setting.
	 *	\param out_level The cutting section cutting level.
	 *	\return <span class='code'>true</span> if a cutting section cutting level setting was specified, <span class='code'>false</span> otherwise. */
	bool								ShowCuttingLevel(CuttingSection::CuttingLevel & out_level) const;

	/*! Shows the cutting section capping level setting.
	 *	\param out_level The cutting section capping level.
	 *	\return <span class='code'>true</span> if a cutting section capping level setting was specified, <span class='code'>false</span> otherwise. */
	bool								ShowCappingLevel(CuttingSection::CappingLevel & out_level) const;

	/*! Shows the cutting section capping usage setting.
	 *	\param out_level The cutting section capping usage.
	 *	\return <span class='code'>true</span> if a cutting section capping usage setting was specified, <span class='code'>false</span> otherwise. */
	bool								ShowCappingUsage(CuttingSection::CappingUsage & out_usage) const;

	/*! Shows the orientation of colors and radii of cylinders.
	 *	\param out_preference The material preference for cut geometry.
	 *	\return <span class='code'>true</span> if a material preference for cut geometry was specified, <span class='code'>false</span> otherwise. */
	bool								ShowMaterialPreference(CuttingSection::MaterialPreference & out_preference) const;

	/*! Shows the weight of cut edges.
	*	\param out_weight The weight value for cut edges.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowEdgeWeight(float & out_weight, Line::SizeUnits & out_units) const;

	/*! Shows the tolerance for closing loops when processing capping faces.
	*	\param out_tolerance The tolerance to use.
	*	\param out_units The units for the tolerance.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowTolerance(float & out_tolerance, CuttingSection::ToleranceUnits & out_units) const;
};



/*!
The HPS::CuttingSectionAttributeControl class is a smart pointer that is tied to a database object. This object is used to manipulate the various cutting section attributes. <a href="../../prog_guide/appendix_default_attribute_values.html#cutting-sections">This table</a> lists default values for the various segment attributes accessible from HPS::CuttingSectionAttributeControl.</p>
*/
class HPS_API CuttingSectionAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit CuttingSectionAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	CuttingSectionAttributeControl(CuttingSectionAttributeControl const & in_that);

	/*! The move constructor creates a CuttingSectionAttributeControl by transferring the underlying impl of the rvalue reference to this CuttingSectionAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CuttingSectionAttributeControl to take the impl from.*/
	CuttingSectionAttributeControl(CuttingSectionAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CuttingSectionAttributeControl thereby avoiding a copy.
	 * \param in_that An rvalue reference to a CuttingSectionAttributeControl to take the impl from.
	 * \return A reference to this CuttingSectionAttributeControl. */
	CuttingSectionAttributeControl & operator=(CuttingSectionAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~CuttingSectionAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::CuttingSectionAttributeControl;
	HPS::Type								ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the CuttingSectionAttributeControl source.
	 *	\param in_that The CuttingSectionAttributeControl source of the assignment.
	 *	\return A reference to this CuttingSectionAttributeControl. */
	CuttingSectionAttributeControl &		operator=(CuttingSectionAttributeControl const & in_that);

	/*! Sets the cut edge weight.
	*	\param in_weight The edge weight to apply for cut edges.
	*	\param in_units The units of the weight given.
	*	\return A reference to this object. */
	CuttingSectionAttributeControl &		SetEdgeWeight(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);

	/*! Sets the tolerance for closing loops when processing capping faces.
	*	\param in_tolerance The tolerance to use.
	*	\param in_units How to interpret the given tolerance.
	*	\return A reference to this object. */
	CuttingSectionAttributeControl &		SetTolerance(float in_tolerance, CuttingSection::ToleranceUnits in_units);

	/*! Sets the cutting section cutting level.
	 *	\param in_level The cutting section cutting level.
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		SetCuttingLevel(CuttingSection::CuttingLevel in_level);

	/*! Sets the cutting section capping level.
	 *	\param in_level The cutting section capping level.
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		SetCappingLevel(CuttingSection::CappingLevel in_level);

	/*! Sets the cutting section capping usage.
	 *	\param in_usage The cutting section capping usage.
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		SetCappingUsage(CuttingSection::CappingUsage in_usage);

	/*! Sets the material preference for cut geometry.
	 *	\param in_preference The material preference for cut geometry.
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		SetMaterialPreference(CuttingSection::MaterialPreference in_preference);

	/*! Removes the cutting section cut edge weight setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CuttingSectionAttributeKit::GetDefault().
	*	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetEdgeWeight();

	/*! Removes the cutting section capping tolerance setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CuttingSectionAttributeKit::GetDefault().
	*	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetTolerance();


	/*! Removes the cutting section cutting level setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CuttingSectionAttributeKit::GetDefault().
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetCuttingLevel();

	/*! Removes the cutting section capping level setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CuttingSectionAttributeKit::GetDefault().
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetCappingLevel();

	/*! Removes the cutting section capping usage setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CuttingSectionAttributeKit::GetDefault().
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetCappingUsage();

	/*! Removes the material preference for cut geometry setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CuttingSectionAttributeKit::GetDefault().
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetMaterialPreference();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by CuttingSectionAttributeKit::GetDefault().
	 *	\return A reference to this object. */
	CuttingSectionAttributeControl &		UnsetEverything();


	/*! Shows the cutting section cutting level setting.
	 *	\param out_level The cutting section cutting level.
	 *	\return <span class='code'>true</span> if a cutting section cutting level setting was specified, <span class='code'>false</span> otherwise. */
	bool									ShowCuttingLevel(CuttingSection::CuttingLevel & out_level) const;

	/*! Shows the cutting section capping level setting.
	 *	\param out_level The cutting section capping level.
	 *	\return <span class='code'>true</span> if a cutting section capping level setting was specified, <span class='code'>false</span> otherwise. */
	bool									ShowCappingLevel(CuttingSection::CappingLevel & out_level) const;

	/*! Shows the cutting section capping usage setting.
	 *	\param out_level The cutting section capping usage.
	 *	\return <span class='code'>true</span> if a cutting section capping usage setting was specified, <span class='code'>false</span> otherwise. */
	bool									ShowCappingUsage(CuttingSection::CappingUsage & out_usage) const;

	/*! Shows the orientation of colors and radii of cylinders.
	 *	\param out_preference The material preference for cut geometry.
	 *	\return <span class='code'>true</span> if a material preference for cut geometry was specified, <span class='code'>false</span> otherwise. */
	bool									ShowMaterialPreference(CuttingSection::MaterialPreference & out_preference) const;

	/*! Shows the weight of cut edges.
	*	\param out_weight The weight value for cut edges.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowEdgeWeight(float & out_weight, Line::SizeUnits & out_units) const;

	/*! Shows the tolerance for closing loops when processing capping faces.
	*	\param out_tolerance The tolerance to use.
	*	\param out_units The units for the tolerance.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool									ShowTolerance(float & out_tolerance, CuttingSection::ToleranceUnits & out_units) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	CuttingSectionAttributeControl();
};



/*! The HPS::TextAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::TextAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#text">this table</a>. */
class HPS_API TextAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	TextAttributeKit();

	/*! The copy constructor creates a new TextAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	TextAttributeKit(TextAttributeKit const & in_kit);

	/*! The move constructor creates a TextAttributeKit by transferring the underlying impl of the rvalue reference to this TextAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextAttributeKit to take the impl from.*/
	TextAttributeKit(TextAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a TextAttributeKit to take the impl from.
	* \return A reference to this TextAttributeKit. */
	TextAttributeKit & operator=(TextAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~TextAttributeKit();

	static const HPS::Type staticType = HPS::Type::TextAttributeKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a TextAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A TextAttributeKit with the default settings. */
	static TextAttributeKit GetDefault();

	/*! Copies all settings from the source TextAttributeKit into this object.
	* 	\param in_kit The source TextAttributeKit to copy. */
	void					Set(TextAttributeKit const & in_kit);

	/*! Copies all settings from this TextAttributeKit into the given TextAttributeKit.
	 * 	\param out_kit The TextAttributeKit to populate with the contents of this object. */
	void					Show(TextAttributeKit & out_kit) const;

	/*! Copies the source TextAttributeKit into this object.
	* 	\param in_kit The source TextAttributeKit to copy.
	 * 	\return A reference to this object. */
	TextAttributeKit &		operator=(TextAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source TextAttributeKit is equivalent to this object.
	*	\param in_kit The source TextAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(TextAttributeKit const & in_kit) const;

	/*!	Check if the source TextAttributeKit is equivalent to this object.
	*	\param in_kit The source TextAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(TextAttributeKit const & in_kit) const;

	/*!	Check if the source TextAttributeKit is not equivalent to this object.
	*	\param in_kit The source TextAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(TextAttributeKit const & in_kit) const;


	/*! Sets the alignment for text.
	*	\param in_alignment The alignment for text.
	*	\param in_reference_frame The reference frame for text.
	*	\param in_justification The justification for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetAlignment(Text::Alignment in_align, Text::ReferenceFrame in_ref = Text::ReferenceFrame::WorldAligned, Text::Justification in_justify = Text::Justification::Left);

	/*! Sets whether text should be bold.
	*	For fonts which do not have a bold variant, this setting will be ignored.
	*	\param in_state Whether text should be bold.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBold(bool in_state);

	/*! Sets whether text should be italic.
	*	For fonts which do not have an italic variant, this setting will be ignored.
	*	\param in_state Whether text should be italic.
	*	\return A reference to this object. */
	TextAttributeKit &		SetItalic(bool in_state);

	/*! Sets whether an overline should be drawn over text.
	*	\param in_state Whether an overline should be drawn over text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetOverline(bool in_state);

	/*! Sets whether a strikethrough should be drawn through text.
	 *	\param in_state Whether a strikethrough should be drawn through text.
	 *	\return A reference to this object. */
	TextAttributeKit &		SetStrikethrough(bool in_state);

	/*! Sets whether an underline should be drawn under text.
	*	\param in_state Whether an underline should be drawn under text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetUnderline(bool in_state);

	/*! Sets the slant angle for text.
	*	This determines how far the characters in the string are sheared to the left (negative angle) or right (positive angle) relative
	*	to the perpendicular.
	*	\param in_angle The angle in degrees to slant text.  This value must be in the range <span class='code'>[-75.0f,+75.0f]</span>.
	*	\return A reference to this object. */
	TextAttributeKit &		SetSlant(float in_angle);

	/*! Sets the line spacing multiplier for text.
	*	This is a multiple of the font size that will be used to determine spacing between lines in multi-line text string.
	*	\param in_multiplier The line spacing multiplier for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetLineSpacing(float in_multiplier);

	/*! Sets the angle characters should be rotated within text strings. To rotate the text as a block (instead of each individual
    *   character) use SetPath with SetRotation(HPS::Text::Rotation::FollowPath), or use a modelling matrix rotation.
	*	\param in_state Whether and how to rotate the characters within text string.
	*	\param in_angle The angle in degrees to rotate each character within text strings.  This is only relevant if <span class='code'>in_state</span> is Text::Rotation::Rotate.
	*	\return A reference to this object. */
	TextAttributeKit &		SetRotation(Text::Rotation in_state, float in_angle = 0.0f);

	/*! Sets the angle characters should be rotated within text strings. To rotate the text as a block (instead of each individual
    *   character) use SetPath with SetRotation(HPS::Text::Rotation::FollowPath), or use a modelling matrix rotation.
	*	This function implicitly sets a rotation state of Text::Rotation::Rotate.
	*	\param in_angle The angle in degrees to rotate each character within text strings.
	*	\return A reference to this object. */
	TextAttributeKit &		SetRotation(float in_angle);

	/*! Sets the amount of additional space to add between characters in a text string.
	*	\param in_state Whether to add additional space between characters in a text string.
	*	\param in_size The size of the additional space to add between characters.
	*	\param in_units The units of the size of the additional space to add between characters.
	*	\return A reference to this object. */
	TextAttributeKit &		SetExtraSpace(bool in_state, float in_size = 0.0f, Text::SizeUnits in_units = Text::SizeUnits::ObjectSpace);

	/*! Sets the amount of additional space to add between characters in a text string.
	*	This function implicitly enables the addition of extra space.
	*	\param in_size The size of the additional space to add between characters.
	*	\param in_units The units of the size of the additional space to add between characters.
	*	\return A reference to this object. */
	TextAttributeKit &		SetExtraSpace(float in_size, Text::SizeUnits in_units);

	/*! Sets the greeking settings to use for text.
	*	\param in_state Whether greeking is enabled for text.
	*	\param in_size The size below which to draw a simple symbol in place of a character.
	*	\param in_units The units of the size below which to draw a simple glyph in place of a character.
	*	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.
	*	\return A reference to this object. */
	TextAttributeKit &		SetGreeking(bool in_state, float in_size = 0.0f, Text::GreekingUnits in_units = Text::GreekingUnits::ObjectSpace, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the greeking settings to use for text.  This function implicitly enables text greeking.
	*	\param in_size The size below which to draw a simple symbol in place of a character.
	*	\param in_units The units of the size below which to draw a simple glyph in place of a character.
	*	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.
	*	\return A reference to this object. */
	TextAttributeKit &		SetGreeking(float in_size, Text::GreekingUnits in_units = Text::GreekingUnits::ObjectSpace, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the size tolerance settings to use for text.
	*	These settings control how to render text strings which request a size not available for a bitmap font.
	*	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	*	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.
	*	This setting has no effect for True Type or Open Type fonts.
	*	\param in_state Whether a size tolerance is enabled for text.
	*	\param in_size The size for the tolerance.
	*	\param in_units The units of the size for the tolerance.
	*	\return A reference to this object. */
	TextAttributeKit &		SetSizeTolerance(bool in_state, float in_size = 50.0f, Text::SizeToleranceUnits in_units = Text::SizeToleranceUnits::Percent);

	/*! Sets the size tolerance settings to use for text.
	*	These settings control how to render text strings which request a size not available for a bitmap font.
	*	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	*	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.
	*	This setting has no effect for True Type or Open Type fonts.
	*	This function implicitly enables a size tolerance.
	*	\param in_size The size for the tolerance.
	*	\param in_units The units of the size for the tolerance.
	*	\return A reference to this object. */
	TextAttributeKit &		SetSizeTolerance(float in_size, Text::SizeToleranceUnits in_units);

	/*! Sets the font size to use for text.
	*	\param in_size The size for text.
	*	\param in_units The units of the size for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetSize(float in_size, Text::SizeUnits in_units);

	/*! Sets the font to use for text.
	*	This must either be a builtin font or a font Visualize can locate in the directories specified by World::SetFontDirectories.
	*	If the requested font cannot be found, the stroked font will be used.
	*	\param in_name UTF8-encoded font name to use for text.
	*	\return A reference to this TextKey.
	*	\sa World::SetFontDirectories */
	TextAttributeKit &		SetFont(char const * in_name);

	/*! Sets the transform behavior for text.
	*	\param in_transform The transform behavior for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetTransform(Text::Transform in_trans);

	/*! Sets the renderer for text.
	*	\param in_renderer The renderer for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetRenderer(Text::Renderer in_rend);

	/*! Sets the font type preference for text.
	*	This function implicitly sets the same font type for all text sizes.
	*	\param in_preference The font type preference for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetPreference(Text::Preference in_pref);

	/*! Sets the preference for text.
	*	This setting controls which font type is used for text for "large" and "small" sizes and the cutoff at which this distinction is made.
	*	\param in_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	*	\param in_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	*	\param in_smaller The font type preference for strings below the cutoff size.
	*	\param in_larger The font type preference for strings above the cutoff size.
	*	\return A reference to this object. */
	TextAttributeKit &		SetPreference(float in_cutoff, Text::SizeUnits in_units, Text::Preference in_smaller, Text::Preference in_larger);

	/*! Sets the path for text.
	*	This setting controls the vector along which text strings will be displayed.
	*	\param in_path The path for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetPath(Vector const & in_path);

	/*! Sets the spacing multiplier for text.
	*	This setting controls the spacing between adjacent characters within a string.
	*	A value of <span class='code'>0.0f</span> would result in all characters being drawn on top of each other,
	*	a value of <span class='code'>1.0f</span> would be the standard spacing between characters,
	*	a value of <span class='code'>2.0f</span> would insert twice as much space as would normally be between two characters, and so on.
	*	\param in_multiplier The spacing multiplier for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetSpacing(float in_multiplier);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackground(bool in_state, char const * in_name);

	/*! Sets the background to be used with text.
	*	The state is implicitly on.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackground(char const * in_name);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackground(bool in_state);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	\param in_size The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackgroundMargins(float in_size, Text::MarginUnits in_units = Text::MarginUnits::Percent);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackgroundMargins(FloatArray const & in_sizes, TextMarginUnitsArray const & in_units);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_count The number of elements in each array.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackgroundMargins(size_t in_count, float const in_sizes [], HPS::Text::MarginUnits const in_units []);

	/*! Allows specifying a named style to be used in the drawing of text backgrounds.
	*	If no style is specified, backgrounds inherit the face and edge attributes from the containing segment.
	*	\param in_name The name of a style, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	TextAttributeKit &		SetBackgroundStyle(char const * in_name);


	/*! Removes the alignment setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetAlignment();

	/*! Removes the bold setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetBold();

	/*! Removes the italic setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetItalic();

	/*! Removes the overline setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetOverline();

	/*! Removes the strikethrough setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetStrikethrough();

	/*! Removes the underline setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetUnderline();

	/*! Removes the slant setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetSlant();

	/*! Removes the line spacing setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetLineSpacing();

	/*! Removes the rotation setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetRotation();

	/*! Removes the extra space setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetExtraSpace();

	/*! Removes the greeking setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetGreeking();

	/*! Removes the size tolerance setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetSizeTolerance();

	/*! Removes the size setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetSize();

	/*! Removes the font setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetFont();

	/*! Removes the transform setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetTransform();

	/*! Removes the renderer setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetRenderer();

	/*! Removes the preference setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetPreference();

	/*! Removes the path setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetPath();

	/*! Removes the spacing setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetSpacing();

	/*! Removes the background setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetBackground();

	/*! Removes the background margin setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetBackgroundMargins();

	/*! Removes the background style setting.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetBackgroundStyle();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	TextAttributeKit &		UnsetEverything();


	/*! Shows the alignment for text.
	*	\param out_alignment The alignment for text.
	*	\param out_reference_frame The reference frame for text.
	*	\param out_justification The justification for text.
	*	\return <span class='code'>true</span> if an alignment was set, <span class='code'>false</span> otherwise. */
	bool					ShowAlignment(Text::Alignment & out_align, Text::ReferenceFrame & out_ref, Text::Justification & out_justify) const;

	/*! Shows whether text should be bold.
	*	\param out_state Whether text should be bold.
	*	\return <span class='code'>true</span> if a bold setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowBold(bool & out_state) const;

	/*! Shows whether text should be italic.
	*	\param out_state Whether text should be italic.
	*	\return <span class='code'>true</span> if an italic setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowItalic(bool & out_state) const;

	/*! Shows whether an overline should be drawn over text.
	*	\param out_state Whether an overline should be drawn over text.
	*	\return <span class='code'>true</span> if an overline setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowOverline(bool & out_state) const;

	/*! Shows whether a strikethrough should be drawn through text.
	*	\param out_state Whether a strikethrough should be drawn through text.
	*	\return <span class='code'>true</span> if a strikethrough setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowStrikethrough(bool & out_state) const;

	/*! Shows whether an underline should be drawn under text.
	*	\param out_state Whether an underline should be drawn under text.
	*	\return <span class='code'>true</span> if an underline setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowUnderline(bool & out_state) const;

	/*! Shows the slant angle for text.
	*	\param out_angle The angle in degrees to slant text.
	*	\return <span class='code'>true</span> if a slang angle was set, <span class='code'>false</span> otherwise. */
	bool					ShowSlant(float & out_angle) const;

	/*! Shows the line spacing multiplier for text.
	*	\param out_multiplier The line spacing multiplier for text.
	*	\return <span class='code'>true</span> if a line space multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowLineSpacing(float & out_multiplier) const;

	/*! Shows the angle characters should be rotated within text strings.
	*	\param out_rot Whether to rotate the characters within text strings, and if so, what the angle should be measured with repect to.
	*	\param out_angle The angle in degrees to rotate each character within text strings.
	*	\return <span class='code'>true</span> if a rotation setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowRotation(Text::Rotation & out_rot, float & out_angle) const;

	/*! Shows the amount of additional space to add between characters in a text string.
	*	\param out_state Whether to add additional space between characters in a text string.
	*	\param out_size The size of the additional space to add between characters.
	*	\param out_units The units of the size of the additional space to add between characters.
	*	\return <span class='code'>true</span> if an extra space setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowExtraSpace(bool & out_state, float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the greeking settings to use for text.
	*	\param out_state Whether greeking is enabled for text.
	*	\param out_size The size below which to draw a simple symbol in place of a character.
	*	\param out_units The units of the size below which to draw a simple glyph in place of a character.
	*	\param out_mode The type of symbol to draw for characters which are smaller than the greeking size.
	*	\return <span class='code'>true</span> if greeking settings were set, <span class='code'>false</span> otherwise. */
	bool					ShowGreeking(bool & out_state, float & out_size, Text::GreekingUnits & out_units, Text::GreekingMode & out_mode) const;

	/*! Shows the size tolerance settings to use for text.
	*	\param out_state Whether a size tolerance is enabled for text.
	*	\param out_size The size for the tolerance.
	*	\param out_units The units of the size for the tolerance.
	*	\return <span class='code'>true</span> if a size tolerance was set, <span class='code'>false</span> otherwise. */
	bool					ShowSizeTolerance(bool & out_state, float & out_size, Text::SizeToleranceUnits & out_units) const;

	/*! Shows the font size to use for text.
	*	\param out_size The size for text.
	*	\param out_units The units of the size for text.
	*	\return <span class='code'>true</span> if a size was set, <span class='code'>false</span> otherwise. */
	bool					ShowSize(float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the font to use for text.
	*	\param out_name UTF8-encoded font name to use for text.
	*	\return <span class='code'>true</span> if a font was set, <span class='code'>false</span> otherwise. */
	bool					ShowFont(UTF8 & out_name) const;

	/*! Shows the transform state for text.
	*	\param out_transform The transform state for text.
	*	\return <span class='code'>true</span> if a transform state was set, <span class='code'>false</span> otherwise. */
	bool					ShowTransform(Text::Transform & out_trans) const;

	/*! Shows the renderer for text.
	*	\param in_renderer The renderer for text.
	*	\return <span class='code'>true</span> if a renderer was set, <span class='code'>false</span> otherwise. */
	bool					ShowRenderer(Text::Renderer & out_rend) const;

	/*! Shows the preference for text.
	*	\param out_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	*	\param out_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	*	\param out_smaller The font type preference for strings below the cutoff size.
	*	\param out_larger The font type preference for strings above the cutoff size.
	*	\return <span class='code'>true</span> if a preference was set, <span class='code'>false</span> otherwise. */
	bool					ShowPreference(float & out_cutoff, Text::SizeUnits & out_units, Text::Preference & out_smaller, Text::Preference & out_larger) const;

	/*! Shows the path for text.
	*	\param out_path The path for text.
	*	\return <span class='code'>true</span> if a path was set, <span class='code'>false</span> otherwise. */
	bool					ShowPath(Vector & out_path) const;

	/*! Shows the spacing multiplier for text.
	*	\param out_multiplier The spacing multiplier for text.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowSpacing(float & out_multiplier) const;

	/*! Shows the background to be used with text.
	*	\param out_state Whether a background is drawn for text.
	*	\param out_name The name of a shape definition.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowBackground(bool & out_state, UTF8 & out_name) const;

	/*! Shows the amount of additional padding around text strings when backgrounds are used.
	*	\param out_size The size of the margins.
	*	\param out_units The units of the sizes.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowBackgroundMargins(FloatArray & out_size, TextMarginUnitsArray & out_units) const;

	/*! Shows the named style to be used in the drawing of text backgrounds.
	*	\param out_name The name of a style, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowBackgroundStyle(UTF8 & out_name) const;
};

/*!
<p>The HPS::TextAttributeControl class is a smart pointer that is tied to a database object. This object gives you access to all the attributes	associated with text, such as font, size, and rotation. Text characteristics such as bold, italic, and underline are also accessed through the HPS::TextAttributeControl. </p>

<p>Default values for the various fields of HPS::TextAttributeControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#text">here</a>.</p>
*/
class HPS_API TextAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit TextAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	TextAttributeControl(TextAttributeControl const & in_that);

	/*! The move constructor creates a TextAttributeControl by transferring the underlying impl of the rvalue reference to this TextAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextAttributeControl to take the impl from.*/
	TextAttributeControl(TextAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a TextAttributeControl to take the impl from.
	* \return A reference to this TextAttributeControl. */
	TextAttributeControl & operator=(TextAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~TextAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::TextAttributeControl;
	HPS::Type		ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the TextAttributeControl source.
	 *	\param in_that The TextAttributeControl source of the assignment.
	 *	\return A reference to this TextAttributeControl. */
	TextAttributeControl &	operator=(TextAttributeControl const & in_that);

	/*! Sets the alignment for text.
	*	\param in_alignment The alignment for text.
	*	\param in_reference_frame The reference frame for text.
	*	\param in_justification The justification for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetAlignment(Text::Alignment in_align, Text::ReferenceFrame in_ref = Text::ReferenceFrame::WorldAligned, Text::Justification in_justify = Text::Justification::Left);

	/*! Sets whether text should be bold.
	*	For fonts which do not have a bold variant, this setting will be ignored.
	*	\param in_state Whether text should be bold.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBold(bool in_state);

	/*! Sets whether text should be italic.
	*	For fonts which do not have an italic variant, this setting will be ignored.
	*	\param in_state Whether text should be italic.
	*	\return A reference to this object. */
	TextAttributeControl &	SetItalic(bool in_state);

	/*! Sets whether an overline should be drawn over text.
	*	\param in_state Whether an overline should be drawn over text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetOverline(bool in_state);

	/*! Sets whether a strikethrough should be drawn through text.
	 *	\param in_state Whether a strikethrough should be drawn through text.
	 *	\return A reference to this object. */
	TextAttributeControl &	SetStrikethrough(bool in_state);

	/*! Sets whether an underline should be drawn under text.
	*	\param in_state Whether an underline should be drawn under text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetUnderline(bool in_state);

	/*! Sets the slant angle for text.
	*	This determines how far the characters in the string are sheared to the left (negative angle) or right (positive angle) relative
	*	to the perpendicular.
	*	\param in_angle The angle in degrees to slant text.  This value must be in the range <span class='code'>[-75.0f,+75.0f]</span>.
	*	\return A reference to this object. */
	TextAttributeControl &	SetSlant(float in_angle);

	/*! Sets the line spacing multiplier for text.
	*	This is a multiple of the font size that will be used to determine spacing between lines in multi-line text string.
	*	\param in_multiplier The line spacing multiplier for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetLineSpacing(float in_multiplier);

	/*! Sets the angle characters should be rotated within text strings.
	*	\param in_state Whether and how to rotate the characters within text string.
	*	\param in_angle The angle in degrees to rotate each character within text strings.  This is only relevant if <span class='code'>in_state</span> is Text::Rotation::Rotate.
	*	\return A reference to this object. */
	TextAttributeControl &	SetRotation(Text::Rotation in_state, float in_angle = 0.0f);

	/*! Sets the angle characters should be rotated within text strings.
	*	This function implicitly sets a rotation state of Text::Rotation::Rotate.
	*	\param in_angle The angle in degrees to rotate each character within text strings.
	*	\return A reference to this object. */
	TextAttributeControl &	SetRotation(float in_angle);

	/*! Sets the amount of additional space to add between characters in a text string.
	*	\param in_state Whether to add additional space between characters in a text string.
	*	\param in_size The size of the additional space to add between characters.
	*	\param in_units The units of the size of the additional space to add between characters.
	*	\return A reference to this object. */
	TextAttributeControl &	SetExtraSpace(bool in_state, float in_size = 0.0f, Text::SizeUnits in_units = Text::SizeUnits::ObjectSpace);

	/*! Sets the amount of additional space to add between characters in a text string.
	*	This function implicitly enables the addition of extra space.
	*	\param in_size The size of the additional space to add between characters.
	*	\param in_units The units of the size of the additional space to add between characters.
	*	\return A reference to this object. */
	TextAttributeControl &	SetExtraSpace(float in_size, Text::SizeUnits in_units);

	/*! Sets the greeking settings to use for text.
	*	\param in_state Whether greeking is enabled for text.
	*	\param in_size The size below which to draw a simple symbol in place of a character.
	*	\param in_units The units of the size below which to draw a simple glyph in place of a character.
	*	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.
	*	\return A reference to this object. */
	TextAttributeControl &	SetGreeking(bool in_state, float in_size = 0.0f, Text::GreekingUnits in_units = Text::GreekingUnits::ObjectSpace, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the greeking settings to use for text.  This function implicitly enables text greeking.
	*	\param in_size The size below which to draw a simple symbol in place of a character.
	*	\param in_units The units of the size below which to draw a simple glyph in place of a character.
	*	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.
	*	\return A reference to this object. */
	TextAttributeControl &	SetGreeking(float in_size, Text::GreekingUnits in_units = Text::GreekingUnits::ObjectSpace, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the size tolerance settings to use for text.
	*	These settings control how to render text strings which request a size not available for a bitmap font.
	*	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	*	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.
	*	This setting has no effect for True Type or Open Type fonts.
	*	\param in_state Whether a size tolerance is enabled for text.
	*	\param in_size The size for the tolerance.
	*	\param in_units The units of the size for the tolerance.
	*	\return A reference to this object. */
	TextAttributeControl &	SetSizeTolerance(bool in_state, float in_size = 50.0f, Text::SizeToleranceUnits in_units = Text::SizeToleranceUnits::Percent);

	/*! Sets the size tolerance settings to use for text.
	*	These settings control how to render text strings which request a size not available for a bitmap font.
	*	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	*	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.
	*	This setting has no effect for True Type or Open Type fonts.
	*	This function implicitly enables a size tolerance.
	*	\param in_size The size for the tolerance.
	*	\param in_units The units of the size for the tolerance.
	*	\return A reference to this object. */
	TextAttributeControl &	SetSizeTolerance(float in_size, Text::SizeToleranceUnits in_units);

	/*! Sets the font size to use for text.
	*	\param in_size The size for text.
	*	\param in_units The units of the size for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetSize(float in_size, Text::SizeUnits in_units);

	/*! Sets the font to use for text.
	*	This must either be a builtin font or a font Visualize can locate in the directories specified by World::SetFontDirectories.
	*	If the requested font cannot be found, the stroked font will be used.
	*	\param in_name UTF8-encoded font name to use for text.
	*	\return A reference to this TextKey.
	*	\sa World::SetFontDirectories */
	TextAttributeControl &	SetFont(char const * in_name);

	/*! Sets the transform behavior for text.
	*	\param in_transform The transform behavior for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetTransform(Text::Transform in_trans);

	/*! Sets the renderer for text.
	*	\param in_renderer The renderer for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetRenderer(Text::Renderer in_rend);

	/*! Sets the font type preference for text.
	*	This function implicitly sets the same font type for all text sizes.
	*	\param in_preference The font type preference for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetPreference(Text::Preference in_pref);

	/*! Sets the preference for text.
	*	This setting controls which font type is used for text for "large" and "small" sizes and the cutoff at which this distinction is made.
	*	\param in_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	*	\param in_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	*	\param in_smaller The font type preference for strings below the cutoff size.
	*	\param in_larger The font type preference for strings above the cutoff size.
	*	\return A reference to this object. */
	TextAttributeControl &	SetPreference(float in_cutoff, Text::SizeUnits in_units, Text::Preference in_smaller, Text::Preference in_larger);

	/*! Sets the path for text.
	*	This setting controls the vector along which text strings will be displayed.
	*	\param in_path The path for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetPath(Vector const & in_path);

	/*! Sets the spacing multiplier for text.
	*	This setting controls the spacing between adjacent characters within a string.
	*	A value of <span class='code'>0.0f</span> would result in all characters being drawn on top of each other,
	*	a value of <span class='code'>1.0f</span> would be the standard spacing between characters,
	*	a value of <span class='code'>2.0f</span> would insert twice as much space as would normally be between two characters, and so on.
	*	\param in_multiplier The spacing multiplier for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetSpacing(float in_multiplier);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackground(bool in_state, char const * in_name);

	/*! Sets the background to be used with text.
	*	The state is implicitly on.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackground(char const * in_name);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackground(bool in_state);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	\param in_size The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackgroundMargins(float in_size, Text::MarginUnits in_units = Text::MarginUnits::Percent);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_size The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackgroundMargins(FloatArray const & in_size, TextMarginUnitsArray const & in_units);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_count The number of elements in each array.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackgroundMargins(size_t in_count, float const in_sizes [], HPS::Text::MarginUnits const in_units []);

	/*! Allows specifying a named style to be used in the drawing of text backgrounds.
	*	If no style is specified, backgrounds inherit the face and edge attributes from the containing segment.
	*	\param in_name The name of a style, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	TextAttributeControl &	SetBackgroundStyle(char const * in_name);


	/*! Removes the alignment setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetAlignment();

	/*! Removes the bold setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetBold();

	/*! Removes the italic setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetItalic();

	/*! Removes the overline setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetOverline();

	/*! Removes the strikethrough setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetStrikethrough();

	/*! Removes the underline setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetUnderline();

	/*! Removes the slant setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetSlant();

	/*! Removes the line spacing setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetLineSpacing();

	/*! Removes the rotation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetRotation();

	/*! Removes the extra space setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetExtraSpace();

	/*! Removes the greeking setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetGreeking();

	/*! Removes the size tolerance setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetSizeTolerance();

	/*! Removes the size setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetSize();

	/*! Removes the font setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetFont();

	/*! Removes the transform setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetTransform();

	/*! Removes the renderer setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetRenderer();

	/*! Removes the preference setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetPreference();

	/*! Removes the path setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetPath();

	/*! Removes the spacing setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetSpacing();

	/*! Removes the background setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetBackground();

	/*! Removes the background margin setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetBackgroundMargins();

	/*! Removes the background style setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetBackgroundStyle();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by TextAttributeKit::GetDefault().
	*	\return A reference to this object. */
	TextAttributeControl &	UnsetEverything();


	/*! Shows the alignment for text.
	*	\param out_alignment The alignment for text.
	*	\param out_reference_frame The reference frame for text.
	*	\param out_justification The justification for text.
	*	\return <span class='code'>true</span> if an alignment was set, <span class='code'>false</span> otherwise. */
	bool					ShowAlignment(Text::Alignment & out_align, Text::ReferenceFrame & out_ref, Text::Justification & out_justify) const;

	/*! Shows whether text should be bold.
	*	\param out_state Whether text should be bold.
	*	\return <span class='code'>true</span> if a bold setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowBold(bool & out_state) const;

	/*! Shows whether text should be italic.
	*	\param out_state Whether text should be italic.
	*	\return <span class='code'>true</span> if an italic setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowItalic(bool & out_state) const;

	/*! Shows whether an overline should be drawn over text.
	*	\param out_state Whether an overline should be drawn over text.
	*	\return <span class='code'>true</span> if an overline setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowOverline(bool & out_state) const;

	/*! Shows whether a strikethrough should be drawn through text.
	*	\param out_state Whether a strikethrough should be drawn through text.
	*	\return <span class='code'>true</span> if a strikethrough setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowStrikethrough(bool & out_state) const;

	/*! Shows whether an underline should be drawn under text.
	*	\param out_state Whether an underline should be drawn under text.
	*	\return <span class='code'>true</span> if an underline setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowUnderline(bool & out_state) const;

	/*! Shows the slant angle for text.
	*	\param out_angle The angle in degrees to slant text.
	*	\return <span class='code'>true</span> if a slang angle was set, <span class='code'>false</span> otherwise. */
	bool					ShowSlant(float & out_angle) const;

	/*! Shows the line spacing multiplier for text.
	*	\param out_multiplier The line spacing multiplier for text.
	*	\return <span class='code'>true</span> if a line space multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowLineSpacing(float & out_multiplier) const;

	/*! Shows the angle characters should be rotated within text strings.
	*	\param out_rot Whether to rotate the characters within text strings, and if so, what the angle should be measured with repect to.
	*	\param out_angle The angle in degrees to rotate each character within text strings.
	*	\return <span class='code'>true</span> if a rotation setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowRotation(Text::Rotation & out_rot, float & out_angle) const;

	/*! Shows the amount of additional space to add between characters in a text string.
	*	\param out_state Whether to add additional space between characters in a text string.
	*	\param out_size The size of the additional space to add between characters.
	*	\param out_units The units of the size of the additional space to add between characters.
	*	\return <span class='code'>true</span> if an extra space setting was set, <span class='code'>false</span> otherwise. */
	bool					ShowExtraSpace(bool & out_state, float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the greeking settings to use for text.
	*	\param out_state Whether greeking is enabled for text.
	*	\param out_size The size below which to draw a simple symbol in place of a character.
	*	\param out_units The units of the size below which to draw a simple glyph in place of a character.
	*	\param out_mode The type of symbol to draw for characters which are smaller than the greeking size.
	*	\return <span class='code'>true</span> if greeking settings were set, <span class='code'>false</span> otherwise. */
	bool					ShowGreeking(bool & out_state, float & out_size, Text::GreekingUnits & out_units, Text::GreekingMode & out_mode) const;

	/*! Shows the size tolerance settings to use for text.
	*	\param out_state Whether a size tolerance is enabled for text.
	*	\param out_size The size for the tolerance.
	*	\param out_units The units of the size for the tolerance.
	*	\return <span class='code'>true</span> if a size tolerance was set, <span class='code'>false</span> otherwise. */
	bool					ShowSizeTolerance(bool & out_state, float & out_size, Text::SizeToleranceUnits & out_units) const;

	/*! Shows the font size to use for text.
	*	\param out_size The size for text.
	*	\param out_units The units of the size for text.
	*	\return <span class='code'>true</span> if a size was set, <span class='code'>false</span> otherwise. */
	bool					ShowSize(float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the font to use for text.
	*	\param out_name UTF8-encoded font name to use for text.
	*	\return <span class='code'>true</span> if a font was set, <span class='code'>false</span> otherwise. */
	bool					ShowFont(UTF8 & out_name) const;

	/*! Shows the transform state for text.
	*	\param out_transform The transform state for text.
	*	\return <span class='code'>true</span> if a transform state was set, <span class='code'>false</span> otherwise. */
	bool					ShowTransform(Text::Transform & out_trans) const;

	/*! Shows the renderer for text.
	*	\param in_renderer The renderer for text.
	*	\return <span class='code'>true</span> if a renderer was set, <span class='code'>false</span> otherwise. */
	bool					ShowRenderer(Text::Renderer & out_rend) const;

	/*! Shows the preference for text.
	*	\param out_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	*	\param out_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	*	\param out_smaller The font type preference for strings below the cutoff size.
	*	\param out_larger The font type preference for strings above the cutoff size.
	*	\return <span class='code'>true</span> if a preference was set, <span class='code'>false</span> otherwise. */
	bool					ShowPreference(float & out_cutoff, Text::SizeUnits & out_units, Text::Preference & out_smaller, Text::Preference & out_larger) const;

	/*! Shows the path for text.
	*	\param out_path The path for text.
	*	\return <span class='code'>true</span> if a path was set, <span class='code'>false</span> otherwise. */
	bool					ShowPath(Vector & out_path) const;

	/*! Shows the spacing multiplier for text.
	*	\param out_multiplier The spacing multiplier for text.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowSpacing(float & out_multiplier) const;

	/*! Shows the background to be used with text.
	*	\param out_state Whether a background is drawn for text.
	*	\param out_name The name of a shape definition.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowBackground(bool & out_state, UTF8 & out_name) const;

	/*! Shows the amount of additional padding around text strings when backgrounds are used.
	*	\param out_size The size of the margins.
	*	\param out_units The units of the sizes.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowBackgroundMargins(FloatArray & out_size, TextMarginUnitsArray & out_units) const;

	/*! Shows the named style to be used in the drawing of text backgrounds.
	*	\param out_name The name of a style, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool					ShowBackgroundStyle(UTF8 & out_name) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	TextAttributeControl();
};





/*! The HPS::LineAttributeKit class is a user space object, useful for carrying a group of attribute settings related to lines. Calling HPS::LineAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#lines">this table</a>. */
class HPS_API LineAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	LineAttributeKit();

	/*! The copy constructor creates a new LineAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	LineAttributeKit(LineAttributeKit const & in_kit);

	/*! The move constructor creates a LineAttributeKit by transferring the underlying impl of the rvalue reference to this LineAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LineAttributeKit to take the impl from.*/
	LineAttributeKit(LineAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LineAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to an LineAttributeKit to take the impl from.
	* \return A reference to this LineAttributeKit. */
	LineAttributeKit & operator=(LineAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~LineAttributeKit();

	static const HPS::Type staticType = HPS::Type::LineAttributeKit;
	HPS::Type		ObjectType() const {return staticType;};

	/*! Creates a LineAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A LineAttributeKit with the default settings. */
	static LineAttributeKit GetDefault();

	/*! Copies all settings from the source LineAttributeKit into this object.
	* 	\param in_kit The source LineAttributeKit to copy. */
	void					Set(LineAttributeKit const & in_kit);

	/*! Copies all settings from this LineAttributeKit into the given LineAttributeKit.
	 * 	\param out_kit The LineAttributeKit to populate with the contents of this object. */
	void					Show(LineAttributeKit & out_kit) const;

	/*! Copies the source LineAttributeKit into this object.
	* 	\param in_kit The source LineAttributeKit to copy.
	 * 	\return A reference to this object. */
	LineAttributeKit &		operator=(LineAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source LineAttributeKit is equivalent to this object.
	*	\param in_kit The source LineAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(LineAttributeKit const & in_kit) const;

	/*!	Check if the source LineAttributeKit is equivalent to this object.
	*	\param in_kit The source LineAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(LineAttributeKit const & in_kit) const;

	/*!	Check if the source LineAttributeKit is not equivalent to this object.
	*	\param in_kit The source LineAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(LineAttributeKit const & in_kit) const;


	/*! Specifies the pattern of lines.
	*	\param in_name The name of a line pattern, defined in a portfolio that is accessible.
	*	\return A reference to this object.
	* 	\sa Programming Guide: <a href="../../prog_guide/0406_line_patterns.html">Line Patterns</a> */
	LineAttributeKit &		SetPattern(char const * in_name);

	/*! Specifies the pattern of lines.
	*	\param in_name The name of a line pattern, defined in a portfolio that is accessible.
	*	\param in_options A set of options that modify how the named line pattern is applied.
	*	\return A reference to this object.
	* 	\sa Programming Guide: <a href="../../prog_guide/0406_line_patterns.html">Line Patterns</a> */
	LineAttributeKit &		SetPattern(char const * in_name, LinePatternOptionsKit const & in_options);

	/*! Sets the weight of lines.
	*	\param in_weight The weight value for lines.
	*	\param in_units The units applied to in_weight.
	*	\return A reference to this object. */
	LineAttributeKit &		SetWeight(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);


	/*! Removes the line pattern setting for lines.
	*	\return A reference to this object. */
	LineAttributeKit &		UnsetPattern();

	/*! Removes the weight setting for lines.
	*	\return A reference to this object. */
	LineAttributeKit &		UnsetWeight();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	LineAttributeKit &		UnsetEverything();


	/*! Shows the pattern used to draw lines.
	*	\param out_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\param out_options A set of options that modify how the named line pattern is applied.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPattern(UTF8 & out_pattern, LinePatternOptionsKit & out_options) const;

	/*! Shows the weight of lines.
	*	\param out_weight The weight value for lines.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWeight(float & out_weight, Line::SizeUnits & out_units) const;
};

/*!
<p>The HPS::LineAttributeControl class is a smart pointer that is tied to a database object. This control allows you to manipulate the weight and pattern of lines and polylines. </p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#lines">This table</a> lists default values for the various segment attributes accessible from HPS::LineAttributeControl.</p>
*/
class HPS_API LineAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit LineAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	LineAttributeControl(LineAttributeControl const & in_that);

	/*! The move constructor creates a LineAttributeControl by transferring the underlying impl of the rvalue reference to this LineAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LineAttributeControl to take the impl from.*/
	LineAttributeControl(LineAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LineAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a LineAttributeControl to take the impl from.
	* \return A reference to this LineAttributeControl. */
	LineAttributeControl & operator=(LineAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~LineAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::LineAttributeControl;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the LineAttributeControl source.
	 *	\param in_that The LineAttributeControl source of the assignment.
	 *	\return A reference to this LineAttributeControl. */
	LineAttributeControl &	operator=(LineAttributeControl const & in_that);

	/*! Specifies the pattern of lines.
	*	\param in_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return A reference to this object.
	* 	\sa Programming Guide: <a href="../../prog_guide/0406_line_patterns.html">Line Patterns</a> */
	LineAttributeControl &	SetPattern(char const * in_pattern);

	/*! Specifies the pattern of lines.
	*	\param in_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\param in_options A set of options that modify how the named line pattern is applied.
	*	\return A reference to this object.
	* 	\sa Programming Guide: <a href="../../prog_guide/0406_line_patterns.html">Line Patterns</a> */
	LineAttributeControl &	SetPattern(char const * in_pattern, LinePatternOptionsKit const & in_options);

	/*! Sets the weight of lines.
	*	\param in_weight The weight value for lines.
	*	\param in_units The units applied to in_weight.
	*	\return A reference to this object. */
	LineAttributeControl &	SetWeight(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);


	/*! Removes the line pattern setting for lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by LineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	LineAttributeControl &	UnsetPattern();

	/*! Removes the weight setting for lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by LineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	LineAttributeControl &	UnsetWeight();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by LineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	LineAttributeControl &	UnsetEverything();


	/*! Shows the pattern used to draw lines.
	*	\param out_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\param out_options A set of options that modify how the named line pattern is applied.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPattern(UTF8 & out_pattern, LinePatternOptionsKit & out_options) const;

	/*! Shows the weight of lines.
	*	\param out_weight The weight value for lines.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWeight(float & out_weight, Line::SizeUnits & out_units) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	LineAttributeControl();
};



/*! The HPS::EdgeAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::EdgeAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#edges">this table</a>. */
class HPS_API EdgeAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	EdgeAttributeKit();

	/*! The copy constructor creates a new EdgeAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	EdgeAttributeKit(EdgeAttributeKit const & in_kit);

	/*! The move constructor creates an EdgeAttributeKit by transferring the underlying impl of the rvalue reference to this EdgeAttributeKit
	*	thereby avoiding a copy and allocation.
	*	\param in_that An rvalue reference to an EdgeAttributeKit to take the impl from.*/
	EdgeAttributeKit(EdgeAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EdgeAttributeKit thereby avoiding a copy.
	*	\param in_that An rvalue reference to an EdgeAttributeKit to take the impl from.
	*	\return A reference to this EdgeAttributeKit. */
	EdgeAttributeKit & operator=(EdgeAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~EdgeAttributeKit();

	static const HPS::Type staticType = HPS::Type::EdgeAttributeKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a EdgeAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A EdgeAttributeKit with the default settings. */
	static EdgeAttributeKit GetDefault();

	/*! Copies all settings from the source EdgeAttributeKit into this object.
	* 	\param in_kit The source EdgeAttributeKit to copy. */
	void					Set(EdgeAttributeKit const & in_kit);

	/*! Copies all settings from this EdgeAttributeKit into the given EdgeAttributeKit.
	 * 	\param out_kit The EdgeAttributeKit to populate with the contents of this object. */
	void					Show(EdgeAttributeKit & out_kit) const;

	/*! Copies the source EdgeAttributeKit into this object.
	* 	\param in_kit The source EdgeAttributeKit to copy.
	 * 	\return A reference to this object. */
	EdgeAttributeKit &		operator=(EdgeAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source EdgeAttributeKit is equivalent to this object.
	*	\param in_kit The source EdgeAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(EdgeAttributeKit const & in_kit) const;

	/*!	Check if the source EdgeAttributeKit is equivalent to this object.
	*	\param in_kit The source EdgeAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(EdgeAttributeKit const & in_kit) const;

	/*!	Check if the source EdgeAttributeKit is not equivalent to this object.
	*	\param in_kit The source EdgeAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(EdgeAttributeKit const & in_kit) const;


	/*! Specifies the pattern of edges.
	*	\param in_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return A reference to this object.
	* 	\sa Programming Guide: <a href="../../prog_guide/0406_line_patterns.html">Line Patterns</a> */
	EdgeAttributeKit &		SetPattern(char const * in_pattern_name);

	/*! Sets the weight of lines drawn in edge rendering.
	*	\param in_weight The weight value for edges.
	*	\param in_units The units applied to in_weight.
	*	\return A reference to this object. */
	EdgeAttributeKit &		SetWeight(float in_weight, Edge::SizeUnits in_units = Edge::SizeUnits::ScaleFactor);

	/*! Sets the angle between adjacent faces necessary for the edge between them to be considered a hard edge.
	*	\param in_angle The angle, in degrees, between the adjacent faces necessary for a hard edge.
	*	\return A reference to this object. */
	EdgeAttributeKit &		SetHardAngle(float in_angle);


	/*! Removes the line pattern setting for edges.
	*	\return A reference to this object. */
	EdgeAttributeKit &		UnsetPattern();

	/*! Removes the weight setting for edges.
	*	\return A reference to this object. */
	EdgeAttributeKit &		UnsetWeight();

	/*! Removes the hard edge angle setting.
	*	\return A reference to this object. */
	EdgeAttributeKit &		UnsetHardAngle();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	EdgeAttributeKit &		UnsetEverything();


	/*! Shows the line pattern of the edges.
	*	\param out_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPattern(UTF8 & out_pattern_name) const;

	/*! Shows the weight of lines drawn in edge rendering.
	*	\param out_weight The weight value for edges.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWeight(float & out_weight, Edge::SizeUnits & out_units) const;

	/*! Shows the weight of lines drawn in edge rendering.
	*	\param out_angle The angle, in degrees, between the adjacent faces necessary for a hard edge.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowHardAngle(float & out_angle) const;

};

/*!
<p>The HPS::EdgeAttributeControl class is a smart pointer that is tied to a database object. Using this control, you can manipulate the various attributes associated with geometry edges. Edges are present on any piece of facetted geometry.</p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#edges">This table</a> lists default values for the various segment attributes accessible from HPS::EdgeAttributeControl.</p>
*/
class HPS_API EdgeAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit EdgeAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	EdgeAttributeControl(EdgeAttributeControl const & in_that);

	/*! The move constructor creates an EdgeAttributeControl by transferring the underlying impl of the rvalue reference to this EdgeAttributeControl
	*	thereby avoiding a copy and allocation.
	*	\param in_that An rvalue reference to an EdgeAttributeControl to take the impl from.*/
	EdgeAttributeControl(EdgeAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EdgeAttributeControl thereby avoiding a copy.
	*	\param in_that An rvalue reference to an EdgeAttributeControl to take the impl from.
	*	\return A reference to this EdgeAttributeControl. */
	EdgeAttributeControl & operator=(EdgeAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~EdgeAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::EdgeAttributeControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the EdgeAttributeControl source.
	 *	\param in_that The EdgeAttributeControl source of the assignment.
	 *	\return A reference to this EdgeAttributeControl. */
	EdgeAttributeControl &		operator=(EdgeAttributeControl const & in_that);

	/*! Specifies the pattern of edges.
	*	\param in_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return A reference to this object.
	* 	\sa Programming Guide: <a href="../../prog_guide/0406_line_patterns.html">Line Patterns</a> */
	EdgeAttributeControl &		SetPattern(char const * in_pattern_name);

	/*! Sets the weight of lines drawn in edge rendering.
	*	\param in_weight The weight value for edges.
	*	\param in_units The units applied to in_weight.
	*	\return A reference to this object. */
	EdgeAttributeControl &		SetWeight(float in_weight, Edge::SizeUnits in_units = Edge::SizeUnits::ScaleFactor);

	/*! Sets the angle between adjacent faces necessary for the edge between them to be considered a hard edge.
	*	\param in_angle The angle, in degrees, between the adjacent faces necessary for a hard edge.
	*	\return A reference to this object. */
	EdgeAttributeControl &		SetHardAngle(float in_angle);


	/*! Removes the line pattern setting for edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by EdgeAttributeKit::GetDefault().
	*	\return A reference to this object. */
	EdgeAttributeControl &		UnsetPattern();

	/*! Removes the weight setting for edges. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by EdgeAttributeKit::GetDefault().
	*	\return A reference to this object. */
	EdgeAttributeControl &		UnsetWeight();

	/*! Removes the hard edge angle setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by EdgeAttributeKit::GetDefault().
	*	\return A reference to this object. */
	EdgeAttributeControl &		UnsetHardAngle();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by EdgeAttributeKit::GetDefault().
	*	\return A reference to this object. */
	EdgeAttributeControl &		UnsetEverything();


	/*! Shows the line pattern of the edges.
	*	\param out_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPattern(UTF8 & out_pattern_name) const;

	/*! Shows the weight of lines drawn in edge rendering.
	*	\param out_weight The weight value for edges.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWeight(float & out_weight, Edge::SizeUnits & out_units) const;

	/*! Shows the weight of lines drawn in edge rendering.
	*	\param out_angle The angle, in degrees, between the adjacent faces necessary for a hard edge.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowHardAngle(float & out_angle) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	EdgeAttributeControl();
};


/*! The HPS::CurveAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::CurveAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#curves">this table</a>. */
class HPS_API CurveAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	CurveAttributeKit();

	/*! The copy constructor creates a new CurveAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	CurveAttributeKit(CurveAttributeKit const & in_kit);

	/*! The move constructor creates a CurveAttributeKit by transferring the underlying impl of the rvalue reference to this CurveAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CurveAttributeKit to take the impl from.*/
	CurveAttributeKit(CurveAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CurveAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a CurveAttributeKit to take the impl from.
	* \return A reference to this CurveAttributeKit. */
	CurveAttributeKit & operator=(CurveAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~CurveAttributeKit();

	static const HPS::Type staticType = HPS::Type::CurveAttributeKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a CurveAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A CurveAttributeKit with the default settings. */
	static CurveAttributeKit GetDefault();

	/*! Copies all settings from the source CurveAttributeKit into this object.
	* 	\param in_kit The source CurveAttributeKit to copy. */
	void					Set(CurveAttributeKit const & in_kit);

	/*! Copies all settings from this CurveAttributeKit into the given CurveAttributeKit.
	 * 	\param out_kit The CurveAttributeKit to populate with the contents of this object. */
	void					Show(CurveAttributeKit & out_kit) const;

	/*! Copies the source CurveAttributeKit into this object.
	* 	\param in_kit The source CurveAttributeKit to copy.
	 * 	\return A reference to this object. */
	CurveAttributeKit &		operator=(CurveAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source CurveAttributeKit is equivalent to this object.
	*	\param in_kit The source CurveAttributeKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(CurveAttributeKit const & in_kit) const;

	/*!	Check if the source CurveAttributeKit is equivalent to this object.
	*	\param in_kit The source CurveAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(CurveAttributeKit const & in_kit) const;

	/*!	Check if the source CurveAttributeKit is not equivalent to this object.
	*	\param in_kit The source CurveAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(CurveAttributeKit const & in_kit) const;

	//Set
	CurveAttributeKit &		SetBudget(size_t in_budget);

	/*! Sets the number of additional vertices will be allocated to the overall curve for each control point beyond the degree of the curve plus one.
	*	A curve with a number of control points equal to the degree plus one will have a number of vertices equal to the budget.
	*	Curves with more control points than that number will have additional vertices equal to the continued budget for each extra control point.
	*	\param in_state Whether the continued budget will be used at all.
	*	\param in_budget The number of additional vertices that will be allocated to the overall curve.
	*	\return A reference to this object. */
	CurveAttributeKit &		SetContinuedBudget(bool in_state, size_t in_budget = 0);

	/*! Sets the number of additional vertices will be allocated to the overall curve for each control point beyond the degree of the curve plus one.
	*	A curve with a number of control points equal to the degree plus one will have a number of vertices equal to the budget.
	*	Curves with more control points than that number will have additional vertices equal to the continued budget for each extra control point.
	*	The state is implicitly on.
	*	\param in_budget The number of additional vertices that will be allocated to the overall curve.
	*	\return A reference to this object. */
	CurveAttributeKit &		SetContinuedBudget(size_t in_budget);


	/*! Sets whether curves should be rendered in a view-dependent or view-independent manner.
	*	The tessellation of view-dependent curves is adjusted to maintain a smooth curve with the current camera setting.
	*	View-independent curves are statically tessellated based on the curve attribute settings.
	*	View-independent is less computationally intensive but can result in curves that do not look smooth with certain camera settings.
	*	\param in_state Whether curves should be rendered in a view-dependent manner.
	*	\return A reference to this object. */
	CurveAttributeKit &		SetViewDependent(bool in_state);

	/*! Sets the distance in object space from the parametric definition of the curve to its tessellated counterpart.
	*	\param in_deviation The distance in object space from the parametric definition.
	*	\return A reference to this object. */
	CurveAttributeKit &		SetMaximumDeviation(float in_deviation);

	/*! Sets the largest angle allowed, in degrees, between adjacent line segments in the tessellated representation.
	*	Applies to view-independent curves only.
	*	\param in_degrees The largest angle allowed between adjacent line segments.
	*	\return A reference to this object. */
	CurveAttributeKit &		SetMaximumAngle(float in_degrees);

	/*! Sets the largest allowable length, in the curve's normalized [0,1] parametric space, of any line segment.
	*	Applies to view-independent curves only.
	*	\param in_length The largest allowable length of any line segment.
	*	\return A reference to this object. */
	CurveAttributeKit &		SetMaximumLength(float in_length);


	/*! Removes the budget setting.
	* 	\return A reference to this object. */
	CurveAttributeKit &		UnsetBudget();

	/*! Removes the continued budget setting.
	* 	\return A reference to this object. */
	CurveAttributeKit &		UnsetContinuedBudget();

	/*! Removes the view-dependent setting.
	* 	\return A reference to this object. */
	CurveAttributeKit &		UnsetViewDependent();

	/*! Removes the maximum deviation setting.
	* 	\return A reference to this object. */
	CurveAttributeKit &		UnsetMaximumDeviation();

	/*! Removes the maximum angle setting.
	* 	\return A reference to this object. */
	CurveAttributeKit &		UnsetMaximumAngle();

	/*! Removes the maximum length setting.
	* 	\return A reference to this object. */
	CurveAttributeKit &		UnsetMaximumLength();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	CurveAttributeKit &		UnsetEverything();


	/*! Shows the upper boundary of the number of vertices that will be allowed in the tessellation of curves, regardless of view settings.
	*	\param out_budget The number of vertices that will be allowed in the tessellation of curves.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowBudget(size_t & out_budget) const;

	/*! Shows the number of additional vertices will be allocated to the overall curve for each control point beyond the degree of the curve plus one.
	*	\param out_state Whether the continued budget will be used at all.
	*	\param out_budget The number of additional vertices that will be allocated to the overall curve.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowContinuedBudget(bool & out_state, size_t & out_budget) const;

	/*! Shows whether curves should be rendered in a view-dependent or view-independent manner.
	*	\param out_state Whether curves should be rendered in a view-dependent manner.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowViewDependent(bool & out_state) const;

	/*! Shows the distance in object space from the parametric definition of the curve to its tessellated counterpart.
	*	Applies to view-independent curves only.
	*	\param out_deviation The distance in object space from the parametric definition.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMaximumDeviation(float & out_deviation) const;

	/*! Shows the largest angle allowed, in degrees, between adjacent line segments in the tessellated representation.
	*	Applies to view-independent curves only.
	*	\param out_degrees The largest angle allowed between adjacent line segments.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMaximumAngle(float & out_degrees) const;

	/*! Shows the largest allowable length, in the curve's normalized [0,1] parametric space, of any line segment.
	*	Applies to view-independent curves only.
	*	\param out_length The largest allowable length of any line segment.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMaximumLength(float & out_length) const;
};


/*!
<p>The HPS::CurveAttributeControl class is a smart pointer that is tied to a database object. This object is used to manipulate the various attributes related to curved lines, such as budget, angle, deviation, and length. <a href="../../prog_guide/appendix_default_attribute_values.html#curves">This table</a> lists default values for the various segment attributes accessible from HPS::CurveAttributeControl.</p>
*/
class HPS_API CurveAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit CurveAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	CurveAttributeControl(CurveAttributeControl const & in_that);

	/*! The move constructor creates a CurveAttributeControl by transferring the underlying impl of the rvalue reference to this CurveAttributeControl
	*	thereby avoiding a copy and allocation.
	*	\param in_that An rvalue reference to a CurveAttributeControl to take the impl from.*/
	CurveAttributeControl(CurveAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CurveAttributeControl thereby avoiding a copy.
	*	\param in_that An rvalue reference to a CurveAttributeControl to take the impl from.
	*	\return A reference to this CurveAttributeControl. */
	CurveAttributeControl & operator=(CurveAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~CurveAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::CurveAttributeControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the CurveAttributeControl source.
	 *	\param in_that The CurveAttributeControl source of the assignment.
	 *	\return A reference to this CurveAttributeControl. */
	CurveAttributeControl &		operator=(CurveAttributeControl const & in_that);

	/*! Sets the upper boundary of the number of vertices that will be allowed in the tessellation of curves, regardless of view settings.
	*	\param in_budget The number of vertices that will be allowed in the tessellation of curves.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetBudget(size_t in_budget);

	/*! Sets the number of additional vertices will be allocated to the overall curve for each control point beyond the degree of the curve plus one.
	*	A curve with a number of control points equal to the degree plus one will have a number of vertices equal to the budget.
	*	Curves with more control points than that number will have additional vertices equal to the continued budget for each extra control point.
	*	\param in_state Whether the continued budget will be used at all.
	*	\param in_budget The number of additional vertices that will be allocated to the overall curve.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetContinuedBudget(bool in_state, size_t in_budget = 0);

	/*! Sets the number of additional vertices will be allocated to the overall curve for each control point beyond the degree of the curve plus one.
	*	A curve with a number of control points equal to the degree plus one will have a number of vertices equal to the budget.
	*	Curves with more control points than that number will have additional vertices equal to the continued budget for each extra control point.
	*	The state is implicitly on.
	*	\param in_budget The number of additional vertices that will be allocated to the overall curve.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetContinuedBudget(size_t in_budget);

	/*! Sets whether curves should be rendered in a view-dependent or view-independent manner.
	*	The tessellation of view-dependent curves is adjusted to maintain a smooth curve with the current camera setting.
	*	View-independent curves are statically tessellated based on the curve attribute settings.
	*	View-independent is less computationally intensive but can result in curves that do not look smooth with certain camera settings.
	*	\param in_state Whether curves should be rendered in a view-dependent manner.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetViewDependent(bool in_state);

	/*! Sets the distance in object space from the parametric definition of the curve to its tessellated counterpart.
	*	\param in_deviation The distance in object space from the parametric definition.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetMaximumDeviation(float in_deviation);

	/*! Sets the largest angle allowed, in degrees, between adjacent line segments in the tessellated representation.
	*	Applies to view-independent curves only.
	*	\param in_degrees The largest angle allowed between adjacent line segments.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetMaximumAngle(float in_degrees);

	/*! Sets the largest allowable length, in the curve's normalized [0,1] parametric space, of any line segment.
	*	Applies to view-independent curves only.
	*	\param in_length The largest allowable length of any line segment.
	*	\return A reference to this object. */
	CurveAttributeControl &		SetMaximumLength(float in_length);


	/*! Removes the budget setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	* 	\return A reference to this object. */
	CurveAttributeControl &		UnsetBudget();

	/*! Removes the continued budget setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	* 	\return A reference to this object. */
	CurveAttributeControl &		UnsetContinuedBudget();

	/*! Removes the view-dependent setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	* 	\return A reference to this object. */
	CurveAttributeControl &		UnsetViewDependent();

	/*! Removes the maximum deviation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	* 	\return A reference to this object. */
	CurveAttributeControl &		UnsetMaximumDeviation();

	/*! Removes the maximum angle setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	* 	\return A reference to this object. */
	CurveAttributeControl &		UnsetMaximumAngle();

	/*! Removes the maximum length setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	* 	\return A reference to this object. */
	CurveAttributeControl &		UnsetMaximumLength();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	CurveAttributeControl &		UnsetEverything();


	/*! Shows the upper boundary of the number of vertices that will be allowed in the tessellation of curves, regardless of view settings.
	*	\param out_budget The number of vertices that will be allowed in the tessellation of curves.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowBudget(size_t & out_budget) const;

	/*! Shows the number of additional vertices will be allocated to the overall curve for each control point beyond the degree of the curve plus one.
	*	\param out_state Whether the continued budget will be used at all.
	*	\param out_budget The number of additional vertices that will be allocated to the overall curve.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowContinuedBudget(bool & out_state, size_t & out_budget) const;

	/*! Shows whether curves should be rendered in a view-dependent or view-independent manner.
	*	\param out_state Whether curves should be rendered in a view-dependent manner.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowViewDependent(bool & out_state) const;

	/*! Shows the distance in object space from the parametric definition of the curve to its tessellated counterpart.
	*	Applies to view-independent curves only.
	*	\param out_deviation The distance in object space from the parametric definition.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowMaximumDeviation(float & out_deviation) const;

	/*! Shows the largest angle allowed, in degrees, between adjacent line segments in the tessellated representation.
	*	Applies to view-independent curves only.
	*	\param out_degrees The largest angle allowed between adjacent line segments.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowMaximumAngle(float & out_degrees) const;

	/*! Shows the largest allowable length, in the curve's normalized [0,1] parametric space, of any line segment.
	*	Applies to view-independent curves only.
	*	\param out_length The largest allowable length of any line segment.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowMaximumLength(float & out_length) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	CurveAttributeControl();
};

/*! The MatrixKit class is a user space object, useful for carrying a group attribute settings. */
class HPS_API MatrixKit
{
public:
	float data[16];

	/*! Initializes an identity matrix. */
	MatrixKit();

	/*! The copy constructor creates a new MatrixKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	MatrixKit(MatrixKit const & in_other);

	/*! This constructor allows implicit construction from an array of floats.
	*	\param in_matrix_source An array of floats that will be used to construct a new matrix.
	*	If this array is not at least 16 elements in length, only the valid members will be used, leaving the remainder initialized as the identity matrix. */
	MatrixKit(FloatArray const & in_matrix_source);

	/*! This constructor allows implicit construction from an array of floats.
	*	\param in_matrix_source An array of floats that will be used to construct a new matrix.
	*	This array is assumed to be at least 16 elements in length.  If it is not, the behavior is undefined. */
	MatrixKit(float const in_matrix_source[]);

	/*! This constructor allows implicit construction from a quaternion.
	*	\param in_quaternion A quaternion used to construct a new matrix. */
	MatrixKit(Quaternion const & in_quaternion);	//implicit conversion from quaternion

	/*! Destroy this kit. */
	virtual ~MatrixKit();

	/*! Creates a MatrixKit representing the identity matrix.
	*	\return An identity MatrixKit. */
	static MatrixKit		GetDefault();

	/*!	Check if the source MatrixKit is equivalent to this object.
	*	\param in_kit The source MatrixKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(MatrixKit const & in_kit) const;

	/*!	Check if the source MatrixKit is equivalent to this object.
	*	\param in_kit The source MatrixKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(MatrixKit const & in_kit) const;

	/*!	Check if the source MatrixKit is not equivalent to this object.
	*	\param in_kit The source MatrixKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(MatrixKit const & in_kit) const;

	/*! Computes the matrix determinant of this matrix.
	*	\param out_determinant The matrix determinant.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDeterminant(float & out_determinant) const;

	/*! Computes the matrix inverse of this matrix.  Fails if this matrix is singular (determinant = 0).
	*	\param out_matrix The matrix inverse of this matrix.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowInverse(MatrixKit & out_matrix) const;

	/*! Computes the matrix adjoint of this matrix.  The adjoint is similar to the inverse but is
	*	always guaranteed to exist, even for singular matrices.
	*	\param out_matrix The matrix adjoint of this matrix.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowAdjoint(MatrixKit & out_matrix) const;

	/*!	Sets this kit to an identity matrix.
	*	\return A reference to this kit.
	*	\deprecated This function exists for compatibility and Reset should be preferred.*/
	MatrixKit &			UnsetEverything();

	/*!	Sets this kit to an identity matrix.*/
	void				Reset();

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise.
	*	\deprecated This function exists for compatibility and will always return false. */
	bool				Empty() const;

	/*! Copies the data from the source MatrixKit into this object.
	*	\param in_other The source MatrixKit to copy. */
	void				Set(MatrixKit const & other);

	/*! Shows a single matrix element.
	*	\param in_row The row index.  Valid range is [0, 3].
	*	\param in_column The column index.  Valid range is [0, 3].
	*	\param out_value The matrix element.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowElement(size_t in_row, size_t in_column, float & out_value) const;

	/*! Shows a single matrix element, indexed as a linear array in row-major order.
	*	\param in_ordinal_zero_to_fifteen The offset into the matrix.  Valid range is [0, 15].
	*	\param out_value The matrix element.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowElement(size_t in_ordinal_zero_to_fifteen, float & out_value) const;

	/*! Shows all elements of this matrix as an array.
	*	\param out_matrix The contents of the matrix arranged as a linear array in row-major order.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowElements(FloatArray & out_matrix) const;

#ifndef HPS_GULP_CLANG
	/*! Shows all elements of this matrix as an array.
	*	\param out_matrix The contents of the matrix arranged as a linear array in row-major order.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowElements(float out_matrix[]) const;
#endif

	/*! Concatenates a rotation matrix to this matrix with rotation around the primary axes.
	*	\param in_x The number of degrees to rotate around the x-axis.
	*	\param in_y The number of degrees to rotate around the y-axis.
	*	\param in_z The number of degrees to rotate around the z-axis.
	*	\return A reference to this object. */
	MatrixKit &			Rotate(float in_x, float in_y, float in_z);

	/*! Concatenates a rotation matrix to this matrix with rotation around an arbitrary vector.
	*	\param in_vector The vector to rotate around.
	*	\param in_theta the number of degrees to rotate around the specified vector
	*	\return A reference to this object. */
	MatrixKit &			RotateOffAxis(Vector const & in_vector, float in_theta);

	/*! Concatenates a translation matrix to this matrix that moves geometry.
	*	\param in_x The number of units to translate along the x-axis.
	*	\param in_y The number of units to translate along the y-axis.
	*	\param in_z The number of units to translate along the z-axis.
	*	\return A reference to this object. */
	MatrixKit &			Translate(float in_x, float in_y, float in_z);

	/*! Concatenates a translation matrix to this matrix that moves geometry.
	*	\param in_translation A vector distance to translate by.
	*	\return A reference to this object. */
	MatrixKit &			Translate(Vector const & in_translation);

	/*! Concatenates a scale matrix to this matrix that represents a uniform scaling of the scene.
	*	\param in_x The scale multiplier along the x-axis.
	*	\param in_y The scale multiplier along the y-axis.
	*	\param in_z The scale multiplier along the z-axis.
	*	\return A reference to this object. */
	MatrixKit &			Scale(float in_x, float in_y, float in_z);

	/*! Replaces this matrix with the matrix product of itself multiplied by another matrix.
	*	\param in_kit the right side operand of the matrix multiplication.
	*	\return A reference to this object. */
	MatrixKit &			Concatenate(MatrixKit const & in_kit);

	/*! Divides this matrix by its determinant. If this matrix is singular (determinant = 0), it will be unchanged.
	*	\return A reference to this object. */
	MatrixKit &			Normalize();

	/*! Replaces this matrix with it's matrix inverse.  If this matrix is singular (determinant = 0), it will be unchanged.
	*	\return A reference to this object. */
	MatrixKit &			Invert();

	/*! Replaces this matrix with it's matrix adjoint.  The adjoint is similar to the inverse but is
	*	always guaranteed to exist, even for singular matrices.
	*	\return A reference to this object. */
	MatrixKit &			Adjoint();

	/*! Indicates whether or not this matrix is an identity matrix
	*	\return Whether this matrix is an identity matrix. */
	bool				IsIdentity() const;

	/*! Performs a matrix multiplication with this object as the left operand.
	*	\param in_right A matrix used as the right operand of a matrix multiplication.
	*	\return A new MatrixKit representing the product. */
	MatrixKit				Multiply(MatrixKit const & in_right) const;

	/*! Performs a matrix multiplication with this object as the left operand and then assigns it to this object.
	*	\param in_right A matrix used as the right operand of a matrix multiplication.
	*	\return A reference to this object after the multiplication. */
	MatrixKit &			MultiplyAndAssign(MatrixKit const & in_right);

	/*! Performs a scalar multiplication of this matrix.
	*	\param in_scalar A scalar to multiply this object by.
	*	\return A new MatrixKit representing the product. */
	MatrixKit				Multiply(float in_scalar) const;

	/*! Performs a scalar multiplication of this matrix and then assigns it to this object.
	*	\param in_scalar A scalar to multiply this object by.
	*	\return A reference to this object after the multiplication. */
	MatrixKit &			MultiplyAndAssign(float in_scalar);

	/*! Sets a single matrix element.
	*	\param in_row The row index.  Valid range is [0, 3].
	*	\param in_column The column index.  Valid range is [0, 3].
	*	\param in_value The matrix element.
	*	\return A reference to this object. */
	MatrixKit &			SetElement(size_t in_row, size_t in_column, float in_value);

	/*! Sets a single matrix element, indexed as a linear array in row-major order.
	*	\param in_ordinal_zero_to_fifteen The offset into the matrix.  Valid range is [0, 15].
	*	\param in_value The matrix element.
	*	\return A reference to this object. */
	MatrixKit &			SetElement(size_t in_ordinal_zero_to_fifteen, float in_value);

	/*! Sets some or all elements in the matrix from an array, starting with the first element.
	*	\param in_values An array of float values in row-major order that should replace the values in the matrix.
	*	\return A reference to this object. */
	MatrixKit &			SetElements(FloatArray const & in_values);

	/*! Sets some or all elements in the matrix from an array, starting with the first element.
	*	\param in_value_count the number of elements in the input array.  Valid range is [0, 16].
	*	\param in_values An array of float values in row-major order that should replace the values in the matrix.
	*	\return A reference to this object. */
	MatrixKit &			SetElements(size_t in_value_count, float const in_values[]);

	/*! Transform a point through this matrix.
	*	\param in_source The point to apply a transformation to.
	*	\return A new point representing the transformed point. */
	Point				Transform(Point const & in_source) const;

	/*! Transform an array of points through this matrix.
	*	\param in_source An array of points to apply a transformation to.
	*	\return A new point array representing the transformed points. */
	PointArray			Transform(PointArray const & in_source) const;

	/*! Transform an array of points through this matrix.
	*	\param in_count The number of elements in the source array.
	*	\param in_source An array of points to apply a transformation to.
	*	\return A new point array representing the transformed points. */
	PointArray			Transform(size_t in_count, Point const in_source[]) const;

	/*! Transform a vector through this matrix.
	*	\param in_source The vector to apply a transformation to.
	*	\return A new vector representing the transformed vector. */
	Vector				Transform(Vector const & in_source) const;

	/*! Transform an array of vectors through this matrix.
	*	\param in_source An array of vectors to apply a transformation to.
	*	\return A new vector array representing the transformed vectors. */
	VectorArray			Transform(VectorArray const & in_source) const;

	/*! Transform an array of vectors through this matrix.
	*	\param in_count The number of elements in the source array.
	*	\param in_source An array of vectors to apply a transformation to.
	*	\return A new vector array representing the transformed vectors. */
	VectorArray			Transform(size_t in_count, Vector const in_source[]) const;

	/*! Transform a plane through this matrix.
	*	\param in_source The plane to apply a transformation to.
	*	\return A new plane representing the transformed plane. */
	Plane				Transform(Plane const & in_source) const;

	/*! Transform an array of planes through this matrix.
	*	\param in_source An array of planes to apply a transformation to.
	*	\return A new plane array representing the transformed planes. */
	PlaneArray			Transform(PlaneArray const & in_source) const;

	/*! Transform an array of planes through this matrix.
	*	\param in_count The number of elements in the source array.
	*	\param in_source An array of planes to apply a transformation to.
	*	\return A new plane array representing the transformed planes. */
	PlaneArray			Transform(size_t in_count, Plane const in_source[]) const;

	/*! Transform a SimpleCuboid through this matrix.
	*	\param in_source The cuboid to apply a transformation to.
	*	\return A new SimpleCuboid representing the transformed cuboid. */
	SimpleCuboid		Transform(SimpleCuboid const & in_source) const;

	/*! Transform a SimpleSphere through this matrix.
	*	\param in_source The sphere to apply a transformation to.
	*	\return A new SimpleSphere representing the transformed sphere. */
	SimpleSphere		Transform(SimpleSphere const & in_source) const;

	/*! Copies the source MatrixKit into this object.
	* 	\param in_kit The source MatrixKit to copy.
	* 	\return A reference to this object. */
	MatrixKit &		operator=(MatrixKit const & in_kit);

	/*! Performs a matrix multiplication with this object as the left operand.
	*	\param in_right A matrix used as the right operand of a matrix multiplication.
	*	\return A new MatrixKit representing the product. */
	MatrixKit			operator*(MatrixKit const & in_right) const;

	/*! Performs a matrix multiplication with this object as the left operand and then assigns it to this object.
	*	\param in_right A matrix used as the right operand of a matrix multiplication.
	*	\return A reference to this object after the multiplication. */
	MatrixKit const &	operator*=(MatrixKit const & in_right);

	/*! Performs a scalar multiplication of this matrix.
	*	\param in_scalar A scalar to multiply this object by.
	*	\return A new MatrixKit representing the product. */
	MatrixKit			operator*(float in_scalar) const;

	/*! Performs a scalar multiplication of this matrix and then assigns it to this object.
	*	\param in_scalar A scalar to multiply this object by.
	*	\return A reference to this object after the multiplication. */
	MatrixKit const &	operator*=(float in_scalar);
};

/*! The ModellingMatrixControl class is a smart pointer that is tied to a database object. This control gives you access to
	a segment's modelling matrix. You can set an entire matrix or individual elements. Additionally, this class provides a
	small set of utility methods for all the basic transformations, as well as getting the matrix adjoint and determinant. Elements of modelling matrices are in row-major order. */
class HPS_API ModellingMatrixControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit ModellingMatrixControl(SegmentKey const & in_seg);

	/*! Initializes a control tied to the geometry reference in_ref. */
	explicit ModellingMatrixControl(ReferenceKey const & in_ref);

	/*! Initializes a control tied to the same object as in_that. */
	ModellingMatrixControl(ModellingMatrixControl const & in_that);

	/*! The move constructor creates a ModellingMatrixControl by transferring the underlying impl of the rvalue reference to this ModellingMatrixControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ModellingMatrixControl to take the impl from.*/
	ModellingMatrixControl(ModellingMatrixControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ModellingMatrixControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a ModellingMatrixControl to take the impl from.
	* \return A reference to this ModellingMatrixControl. */
	ModellingMatrixControl & operator=(ModellingMatrixControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~ModellingMatrixControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::ModellingMatrixControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the ModellingMatrixControl source.
	 *	\param in_that The ModellingMatrixControl source of the assignment.
	 *	\return A reference to this ModellingMatrixControl. */
	ModellingMatrixControl &	operator=(ModellingMatrixControl const & in_that);

	/*! Copies all settings from the source MatrixKit into this object.
	*	\param in_matrix The source MatrixKit to copy. */
	ModellingMatrixControl &	Set(MatrixKit const & in_matrix);

	/*! Sets a single matrix element.
	*	\param in_row The row index.  Valid range is [0, 3].
	*	\param in_column The column index.  Valid range is [0, 3].
	*	\param in_value The matrix element.
	*	\return A reference to this object. */
	ModellingMatrixControl &	SetElement(size_t in_row, size_t in_column, float in_value);

	/*! Sets a single matrix element, indexed as a linear array in row-major order.
	*	\param in_ordinal_zero_to_fifteen The offset into the matrix.  Valid range is [0, 15].
	*	\param in_value The matrix element.
	*	\return A reference to this object. */
	ModellingMatrixControl &	SetElement(size_t in_ordinal_zero_to_fifteen, float in_value);

	/*! Sets some or all elements in the matrix from an array, starting with the first element.
	*	\param in_values An array of float values in row-major order that should replace the values in the matrix.
	*	\return A reference to this object. */
	ModellingMatrixControl &	SetElements(FloatArray const & in_values);

	/*! Sets some or all elements in the matrix from an array, starting with the first element.
	*	\param in_value_count the number of elements in the input array.  Valid range is [0, 16].
	*	\param in_values An array of float values in row-major order that should replace the values in the matrix.
	*	\return A reference to this object. */
	ModellingMatrixControl &	SetElements(size_t in_value_count, float const in_values []);


	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	ModellingMatrixControl &	UnsetEverything();

	/*! Copies all settings from this control into the given MatrixKit.
	*	\param out_matrix The MatrixKit to populate with the contents of this object. */
	bool						Show(MatrixKit & out_matrix) const;

	/*! Shows a single matrix element.
	*	\param in_row The row index.  Valid range is [0, 3].
	*	\param in_column The column index.  Valid range is [0, 3].
	*	\param out_value The matrix element.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowElement(size_t in_row, size_t in_column, float & out_value) const;

	/*! Shows a single matrix element, indexed as a linear array in row-major order.
	*	\param in_ordinal_zero_to_fifteen The offset into the matrix.  Valid range is [0, 15].
	*	\param out_value The matrix element.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowElement(size_t in_ordinal_zero_to_fifteen, float & out_value) const;

	/*! Shows all elements of this matrix as an array.
	*	\param out_matrix The contents of the matrix arranged as a linear array in row-major order.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowElements(FloatArray & out_matrix) const;

	/*! Computes the matrix determinant of this matrix.
	*	\param out_determinant The matrix determinant.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDeterminant(float & out_determinant) const;

	/*! Computes the matrix inverse of this matrix.  Fails if this matrix is singular (determinant = 0).
	*	\param out_matrix The matrix inverse of this matrix.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowInverse(MatrixKit & out_matrix) const;

	/*! Computes the matrix adjoint of this matrix.  The adjoint is similar to the inverse but is
	*	always guaranteed to exist, even for singular matrices.
	*	\param out_matrix The matrix adjoint of this matrix.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAdjoint(MatrixKit & out_matrix) const;

	/*! Concatenates a rotation matrix to this matrix with rotation around the primary axes.
	*	\param in_x The number of degrees to rotate around the x-axis.
	*	\param in_y The number of degrees to rotate around the y-axis.
	*	\param in_z The number of degrees to rotate around the z-axis.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Rotate(float in_x, float in_y, float in_z);

	/*! Concatenates a rotation matrix to this matrix with rotation around an arbitrary vector.
	*	\param in_vector The vector to rotate around.
	*	\param in_theta the number of degrees to rotate around the specified vector
	*	\return A reference to this object. */
	ModellingMatrixControl &	RotateOffAxis(Vector const & in_vector, float in_theta);

	/*! Concatenates a translation matrix to this matrix that moves geometry.
	*	\param in_x The number of units to translate along the x-axis.
	*	\param in_y The number of units to translate along the y-axis.
	*	\param in_z The number of units to translate along the z-axis.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Translate(float in_x, float in_y, float in_z);

	/*! Concatenates a translation matrix to this matrix that moves geometry.
	*	\param in_translation A vector distance to translate by.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Translate(Vector const & in_translation);

	/*! Concatenates a scale matrix to this matrix that represents a uniform scaling of the scene.
	*	\param in_x The scale multiplier along the x-axis.
	*	\param in_y The scale multiplier along the y-axis.
	*	\param in_z The scale multiplier along the z-axis.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Scale(float in_x, float in_y, float in_z);

	/*! Replaces this matrix with the matrix product of itself multiplied by another matrix.
	*	\param in_kit the right side operand of the matrix multiplication.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Concatenate(MatrixKit const & in_kit);

	/*! Divides this matrix by its determinant. If this matrix is singular (determinant = 0), it will be unchanged.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Normalize();

	/*! Replaces this matrix with it's matrix inverse.  If this matrix is singular (determinant = 0), it will be unchanged.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Invert();

	/*! Replaces this matrix with it's matrix adjoint.  The adjoint is similar to the inverse but is
	*	always guaranteed to exist, even for singular matrices.
	*	\return A reference to this object. */
	ModellingMatrixControl &	Adjoint();

private:
	//! Private default constructor to prevent instantiation without a segment.
	ModellingMatrixControl();
};

/*! The TextureMatrixControl class is a smart pointer that is tied to a database object. It controls the various attributes related
	to texture matrices. */
class HPS_API TextureMatrixControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit TextureMatrixControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	TextureMatrixControl(const TextureMatrixControl & in_that);

	/*! The move constructor creates a TextureMatrixControl by transferring the underlying impl of the rvalue reference to this TextureMatrixControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextureMatrixControl to take the impl from.*/
	TextureMatrixControl(TextureMatrixControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextureMatrixControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a TextureMatrixControl to take the impl from.
	* \return A reference to this TextureMatrixControl. */
	TextureMatrixControl & operator=(TextureMatrixControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~TextureMatrixControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::TextureMatrixControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the TextureMatrixControl source.
	 *	\param in_that The TextureMatrixControl source of the assignment.
	 *	\return A reference to this TextureMatrixControl. */
	TextureMatrixControl &		operator=(TextureMatrixControl const & in_that);

	/*! Copies all settings from the source MatrixKit into this object.
	*	\param in_matrix The source MatrixKit to copy. */
	TextureMatrixControl &		Set(MatrixKit const & in_matrix);

	/*! Sets a single matrix element.
	*	\param in_row The row index.  Valid range is [0, 3].
	*	\param in_column The column index.  Valid range is [0, 3].
	*	\param in_value The matrix element.
	*	\return A reference to this object. */
	TextureMatrixControl &		SetElement(size_t in_row, size_t in_column, float in_value);

	/*! Sets a single matrix element, indexed as a linear array in row-major order.
	*	\param in_ordinal_zero_to_fifteen The offset into the matrix.  Valid range is [0, 15].
	*	\param in_value The matrix element.
	*	\return A reference to this object. */
	TextureMatrixControl &		SetElement(size_t in_ordinal_zero_to_fifteen, float in_value);

	/*! Sets some or all elements in the matrix from an array, starting with the first element.
	*	\param in_values An array of float values in row-major order that should replace the values in the matrix.
	*	\return A reference to this object. */
	TextureMatrixControl &		SetElements(FloatArray const & in_values);

	/*! Sets some or all elements in the matrix from an array, starting with the first element.
	*	\param in_value_count the number of elements in the input array.  Valid range is [0, 16].
	*	\param in_values An array of float values in row-major order that should replace the values in the matrix.
	*	\return A reference to this object. */
	TextureMatrixControl &		SetElements(size_t in_value_count, float const in_values []);


	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	TextureMatrixControl &		UnsetEverything();


	/*! Copies all settings from this control into the given MatrixKit.
	*	\param out_matrix The MatrixKit to populate with the contents of this object. */
	bool						Show(MatrixKit & out_matrix) const;

	/*! Shows a single matrix element.
	*	\param in_row The row index.  Valid range is [0, 3].
	*	\param in_column The column index.  Valid range is [0, 3].
	*	\param out_value The matrix element.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowElement(size_t in_row, size_t in_column, float & out_value) const;

	/*! Shows a single matrix element, indexed as a linear array in row-major order.
	*	\param in_ordinal_zero_to_fifteen The offset into the matrix.  Valid range is [0, 15].
	*	\param out_value The matrix element.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowElement(size_t in_ordinal_zero_to_fifteen, float & out_value) const;

	/*! Shows all elements of this matrix as an array.
	*	\param out_matrix The contents of the matrix arranged as a linear array in row-major order.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowElements(FloatArray & out_matrix) const;

	/*! Computes the matrix determinant of this matrix.
	*	\param out_determinant The matrix determinant.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDeterminant(float & out_determinant) const;

	/*! Computes the matrix inverse of this matrix.  Fails if this matrix is singular (determinant = 0).
	*	\param out_matrix The matrix inverse of this matrix.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowInverse(MatrixKit & out_matrix) const;

	/*! Computes the matrix adjoint of this matrix.  The adjoint is similar to the inverse but is
	*	always guaranteed to exist, even for singular matrices.
	*	\param out_matrix The matrix adjoint of this matrix.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAdjoint(MatrixKit & out_matrix) const;

	/*! Concatenates a rotation matrix to this matrix with rotation around the primary axes.
	*	\param in_x The number of degrees to rotate around the x-axis.
	*	\param in_y The number of degrees to rotate around the y-axis.
	*	\param in_z The number of degrees to rotate around the z-axis.
	*	\return A reference to this object. */
	TextureMatrixControl &		Rotate(float in_x, float in_y, float in_z);

	/*! Concatenates a rotation matrix to this matrix with rotation around an arbitrary vector.
	*	\param in_vector The vector to rotate around.
	*	\param in_theta the number of degrees to rotate around the specified vector
	*	\return A reference to this object. */
	TextureMatrixControl &		RotateOffAxis(Vector const & in_vector, float in_theta);

	/*! Concatenates a translation matrix to this matrix that moves geometry.
	*	\param in_x The number of units to translate along the x-axis.
	*	\param in_y The number of units to translate along the y-axis.
	*	\param in_z The number of units to translate along the z-axis.
	*	\return A reference to this object. */
	TextureMatrixControl &		Translate(float in_x, float in_y, float in_z);

	/*! Concatenates a scale matrix to this matrix that represents a uniform scaling of the scene.
	*	\param in_x The scale multiplier along the x-axis.
	*	\param in_y The scale multiplier along the y-axis.
	*	\param in_z The scale multiplier along the z-axis.
	*	\return A reference to this object. */
	TextureMatrixControl &		Scale(float in_x, float in_y, float in_z);

	/*! Replaces this matrix with the matrix product of itself multiplied by another matrix.
	*	\param in_kit the right side operand of the matrix multiplication.
	*	\return A reference to this object. */
	TextureMatrixControl &		Concatenate(MatrixKit const & in_kit);

	/*! Divides this matrix by its determinant. If this matrix is singular (determinant = 0), it will be unchanged.
	*	\return A reference to this object. */
	TextureMatrixControl &		Normalize();

	/*! Replaces this matrix with it's matrix inverse.  If this matrix is singular (determinant = 0), it will be unchanged.
	*	\return A reference to this object. */
	TextureMatrixControl &		Invert();

	/*! Replaces this matrix with it's matrix adjoint.  The adjoint is similar to the inverse but is
	*	always guaranteed to exist, even for singular matrices.
	*	\return A reference to this object. */
	TextureMatrixControl &		Adjoint();

private:
	//! Private default constructor to prevent instantiation without a segment.
	TextureMatrixControl();
};


/*! The HPS::MaterialMappingKit class is a user space object, used for grouping attribute settings related to materials.
	A HPS::MaterialMappingKit is assigned to a portfolio, which in turn associates the materials to various geometry or subgeometry. Calling HPS::MaterialMappingKit::GetDefault() will return a material mapping kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#material-mapping">this table</a>. */
class HPS_API MaterialMappingKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	MaterialMappingKit();

	/*! The copy constructor creates a new MaterialMappingKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	MaterialMappingKit(MaterialMappingKit const & in_kit);

	/*! The move constructor creates a MaterialMappingKit by transferring the underlying impl of the rvalue reference to this MaterialMappingKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MaterialMappingKit to take the impl from.*/
	MaterialMappingKit(MaterialMappingKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MaterialMappingKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a MaterialMappingKit to take the impl from.
	* \return A reference to this MaterialMappingKit. */
	MaterialMappingKit & operator=(MaterialMappingKit && in_that);

	/*! Destroy this kit. */
	~MaterialMappingKit();

	static const HPS::Type staticType = HPS::Type::MaterialMappingKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a HPS::MaterialMappingKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A MaterialMappingKit with the default settings. */
	static MaterialMappingKit GetDefault();

	/*! Copies all settings from the source MaterialMappingKit into this object.
	*	\param in_kit The source MaterialMappingKit to copy. */
	void					Set(MaterialMappingKit const & in_kit);

	/*! Copies all settings from this MaterialMappingKit into the given MaterialMappingKit.
	*	\param out_kit The MaterialMappingKit to populate with the contents of this object. */
	void					Show(MaterialMappingKit & out_kit) const;

	/*! Copies the source MaterialMappingKit into this object.
	*	\param in_kit The source MaterialMappingKit to copy.
	*	\return A reference to this object. */
	MaterialMappingKit &	operator=(MaterialMappingKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source MaterialMappingKit is equivalent to this object.
	*	\param in_kit The source MaterialMappingKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(MaterialMappingKit const & in_kit) const;

	/*!	Check if the source MaterialMappingKit is equivalent to this object.
	*	\param in_kit The source MaterialMappingKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(MaterialMappingKit const & in_kit) const;

	/*!	Check if the source MaterialMappingKit is not equivalent to this object.
	*	\param in_kit The source MaterialMappingKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(MaterialMappingKit const & in_kit) const;

	//Set

	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetAmbientLightUpColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetAmbientLightUpMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetAmbientLightDownColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetAmbientLightDownMaterialByIndex(float in_material_index);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets alpha on the diffuse channel on the back face, replacing any previous mapping to that channel on this geometry type.
	*  If diffuse channel isn't set, white is defaulted as the diffuse color with in_alpha the alpha value.
	*	\param in_alpha An alpha to apply to the specified channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceAlpha(float in_alpha);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetBackFaceMaterialByIndex(float in_material_index);

	/*! Sets a color on a particular channel using an RGBAColor  on the front face, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets alpha on the diffuse channel on the front face, replacing any previous mapping to that channel on this geometry type.
	*  If diffuse channel isn't set, white is defaulted as the diffuse color with in_alpha the alpha value.
	*	\param in_alpha An alpha to apply to the specified channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceAlpha(float in_alpha);

	/*! Sets a texture in_texture_name on the channel in_channel  on the front face, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFrontFaceMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutEdgeColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutEdgeMaterialByIndex(float in_material_index);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets alpha on the diffuse channel on the cut face, replacing any previous mapping to that channel on this geometry type.
	*  If diffuse channel isn't set, white is defaulted as the diffuse color with in_alpha the alpha value.
	*	\param in_alpha An alpha to apply to the specified channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceAlpha(float in_alpha);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutFaceMaterialByIndex(float in_material_index);

	/*! Sets alpha on the diffuse channel on the edge, replacing any previous mapping to that channel on this geometry type.
	*  If diffuse channel isn't set, white is defaulted as the diffuse color with in_alpha as the alpha value.
	*	\param in_alpha An alpha to apply to the specified channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetEdgeMaterialByIndex(float in_material_index);

	/*! Sets alpha on the diffuse channel on the face, replacing any previous mapping to that channel on this geometry type.
	*  If diffuse channel isn't set, white is defaulted as the diffuse color with in_alpha as the alpha value.
	*	\param in_alpha An alpha to apply to the specified channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceMaterialByIndex(float in_material_index);

	/*! Internal use only - customers should not use. Applies a shader by name, replacing any previous mapping to the DiffuseTexture channel on this geometry type.
	*	\param in_shader_name The name of a shader, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetFaceShader(char const * in_shader_name);





	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetLightColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetLightMaterialByIndex(float in_material_index);


	/*! Sets alpha on the diffuse channel on the line, replacing any previous mapping to that channel on this geometry type.
	*	\param in_alpha The alpha value to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetLineAlpha(float in_alpha);

	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	 *  Note that this function implicitly sets an alpha value for lines if an RGBColor is passed in.
	 *  The alpha value can be modified either by calling this function again, or by calling SetLineAlpha.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetLineColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetLineMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetMarkerColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetMarkerMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetTextColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetTextMaterialByIndex(float in_material_index);

	/*! Sets alpha on the diffuse channel on the vertex, replacing any previous mapping to that channel on this geometry type.
	*  If diffuse channel isn't set, white is defaulted as the diffuse color with in_alpha as the alpha value.
	*	\param in_alpha An alpha to apply to the specified channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexMaterialByIndex(float in_material_index);

	/*! Internal use only - customers should not use. Applies a shader by name, replacing any previous mapping to the DiffuseTexture channel on this geometry type.
	*	\param in_shader_name The name of a shader, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetVertexShader(char const * in_shader_name);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color An RGBA color that will be applied to this geometry types.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetWindowColor(RGBAColor const & in_rgba_color);

	/*! Sets a color by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetWindowMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color An RGBA color that will be applied to this geometry types.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetWindowContrastColor(RGBAColor const & in_rgba_color);

	/*! Sets a color by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetWindowContrastMaterialByIndex(float in_material_index);

	//Aggregate Sets

	/*! Sets a color on both cut edges and cut faces using an RGBAColor, replacing any previous mapping to those geometry types.
	*	\param in_rgba_color An RGBA color that will be applied to those geometry types.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutGeometryColor(RGBAColor const & in_rgba_color);

	/*! Sets a color on both cut edges and cut faces by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to those geometry types.
	*	\param in_color_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetCutGeometryMaterialByIndex(float in_color_index);


	/*! Sets a color on both ambient and ambient down using an RGBAColor, replacing any previous mapping to those geometry types.
	*	\param in_rgba_color An RGBA color that will be applied to those geometry types.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetAmbientLightColor(RGBAColor const & in_rgba_color);

	/*! Sets a color on both ambient and ambient down by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to those geometry types.  Because these geometry types only support a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetAmbientLightMaterialByIndex(float in_material_index);

	//Aggregate set

	/*! Sets a color on all basic geometry types (faces, edges, lines, markers, vertices, text) using an RGBAColor, replacing any previous mapping to those geometry types.
	*	\param in_rgba_color An RGBA color that will be applied to all basic geometry types. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingKit &	SetGeometryColor(RGBAColor const & in_rgba_color);

	//Unset

	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetAmbientLightUpColor();


	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetAmbientLightDownColor();


	/*! Removes the material mapping for all channels of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetBackFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetBackFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetBackFaceChannel(Material::Channel in_channel, size_t in_layer);

	/*! Removes the material mapping for all channels of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetFrontFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetFrontFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetFrontFaceChannel(Material::Channel in_channel, size_t in_layer);



	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetCutEdgeColor();


	/*! Removes the material mapping for all channels of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetCutFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetCutFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetCutFaceChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for all channels of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetEdgeMaterial();

	/*! Removes the material mapping for one channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetEdgeChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetEdgeChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for all channels of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetFaceChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetLightColor();


	/*! Removes the alpha setting for lines.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetLineAlpha();

	/*! Removes the material mapping for this geometry type.
	*  Note that this also unsets alpha settings for lines specified in this kit.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetLineColor();


	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetMarkerColor();


	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetTextColor();


	/*! Removes the material mapping for all channels of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetVertexMaterial();

	/*! Removes the material mapping for one channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetVertexChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetVertexChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetWindowColor();


	/*! Removes the material mapping for this geometry type.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetWindowContrastColor();


	//Aggregate Unsets

	/*! Removes the material mapping for both cut edges and cut faces.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetCutGeometryColor();

	/*! Removes the material mapping for both ambient light up and ambient light down.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetAmbientLightColor();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	MaterialMappingKit &	UnsetEverything();


	//Show

	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowAmbientLightUpColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;

	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowAmbientLightDownColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowBackFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowBackFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowBackFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFrontFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFrontFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFrontFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;



	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCutEdgeColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCutFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCutFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCutFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEdgeChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEdgeChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEdgeMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLightColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the alpha setting for lines.
	*	\param out_alpha The alpha value for lines.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLineAlpha(float & out_alpha) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLineColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowMarkerColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowTextColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowVertexChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowVertexChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowVertexMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowContrastColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;
};



/*! The HPS::PBRMaterialKit class is a user space object, used for grouping attribute settings related to PBR materials. */
class HPS_API PBRMaterialKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	PBRMaterialKit();

	/*! The copy constructor creates a new PBRMaterialKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	PBRMaterialKit(PBRMaterialKit const & in_kit);

	/*! The move constructor creates a PBRMaterialKit by transferring the underlying impl of the rvalue reference to this MaterialMappingKit
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to a PBRMaterialKit to take the impl from.*/
	PBRMaterialKit(PBRMaterialKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PBRMaterialKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a PBRMaterialKit to take the impl from.
	* \return A reference to this PBRMaterialKit. */
	PBRMaterialKit & operator=(PBRMaterialKit && in_that);

	/*! Destroy this kit. */
	~PBRMaterialKit();

	static const HPS::Type staticType = HPS::Type::PBRMaterialKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Creates a HPS::PBRMaterialKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A PBRMaterialKit with the default settings. */
	static PBRMaterialKit GetDefault();

	/*! Copies all settings from the source PBRMaterialKit into this object.
	*	\param in_kit The source PBRMaterialKit to copy. */
	void					Set(PBRMaterialKit const & in_kit);

	/*! Copies all settings from this PBRMaterialKit into the given PBRMaterialKit.
	*	\param out_kit The PBRMaterialKit to populate with the contents of this object. */
	void					Show(PBRMaterialKit & out_kit) const;

	/*! Copies the source PBRMaterialKit into this object.
	*	\param in_kit The source PBRMaterialKit to copy.
	*	\return A reference to this object. */
	PBRMaterialKit &	operator=(PBRMaterialKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source PBRMaterialKit is equivalent to this object.
	*	\param in_kit The source PBRMaterialKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(PBRMaterialKit const & in_kit) const;

	/*!	Check if the source PBRMaterialKit is equivalent to this object.
	*	\param in_kit The source PBRMaterialKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(PBRMaterialKit const & in_kit) const;

	/*!	Check if the source PBRMaterialKit is not equivalent to this object.
	*	\param in_kit The source PBRMaterialKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(PBRMaterialKit const & in_kit) const;

	//Set

	/*! Sets the base color map.
	*	\param in_texture_name The base color factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetBaseColorMap(char const * in_texture_name);

	/*! Sets the normal map.
	*	\param in_texture_name The base color factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetNormalMap(char const * in_texture_name);

	/*! Sets the emissive map.
	*	\param in_texture_name The base color factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetEmissiveMap(char const * in_texture_name);

	/*! Sets the metalness map.
	*	\param in_texture_name The base color factor to use.
	*	\param in_channel The color channel from the map to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetMetalnessMap(char const * in_texture_name, HPS::Material::Texture::ChannelMapping in_channel = HPS::Material::Texture::ChannelMapping::Red);

	/*! Sets the roughness map.
	*	\param in_texture_name The base color factor to use.
	*	\param in_channel The color channel from the map to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetRoughnessMap(char const * in_texture_name, HPS::Material::Texture::ChannelMapping in_channel = HPS::Material::Texture::ChannelMapping::Green);

	/*! Sets the occlusion map.
	*	\param in_texture_name The base color factor to use.
	*	\param in_channel The color channel from the map to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetOcclusionMap(char const * in_texture_name, HPS::Material::Texture::ChannelMapping in_channel = HPS::Material::Texture::ChannelMapping::Blue);

	/*! Sets the base color factor which either scales the base color map or acts as a base color directly if no map exists.
	*	\param in_color The base color factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetBaseColorFactor(HPS::RGBAColor const & in_color);

	/*! Sets the normal factor which scales the normal map.
	*	\param in_factor The factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetNormalFactor(float in_factor);

	/*! Sets the metalness factor which scales the metalness map or acts as the metalness if no map exists.
	*	\param in_factor The factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetMetalnessFactor(float in_factor);

	/*! Sets the roughness factor which scales the roughness map or acts as the roughness if no map exists.
	*	\param in_factor The factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetRoughnessFactor(float in_factor);

	/*! Sets the occlusion factor which scales the occlusion map.
	*	\param in_factor The factor to use.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetOcclusionFactor(float in_factor);

	/*! Sets the alpha factor which scales the alpha map or acts as the alpha if no map exists.
	*	\param in_factor The factor to use.
	*	\param in_mask Sets if the alpha acts as a mask.
	*	\return A reference to this object. */
	PBRMaterialKit &	SetAlphaFactor(float in_factor, bool in_mask = false);

	//Unset
	/*! Removes the base color map from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetBaseColorMap();

	/*! Removes the normal map from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetNormalMap();

	/*! Removes the emissive map from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetEmissiveMap();

	/*! Removes the metalness map from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetMetalnessMap();

	/*! Removes the roughness map from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetRoughnessMap();

	/*! Removes the occlusion map from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetOcclusionMap();

	/*! Removes the base color factor from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetBaseColorFactor();

	/*! Removes the normal factor from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetNormalFactor();

	/*! Removes the metalness factor from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetMetalnessFactor();

	/*! Removes the roughness factor from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetRoughnessFactor();

	/*! Removes the occlusion factor from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetOcclusionFactor();

	/*! Removes the alpha factor from this kit type.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetAlphaFactor();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	PBRMaterialKit &	UnsetEverything();

	//Show

	/*! Shows the base color map name.
	*	\param out_texture_name The base color map name if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowBaseColorMap(UTF8 & out_texture_name) const;

	/*! Shows the normal map name.
	*	\param out_texture_name The normal map name if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowNormalMap(UTF8 & out_texture_name) const;

	/*! Shows the emissive map name.
	*	\param out_texture_name The emissive map name if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowEmissiveMap(UTF8 & out_texture_name) const;

	/*! Shows the metalness map name.
	*	\param out_texture_name The metalness map name if set.
	*	\param out_channel The channel.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowMetalnessMap(UTF8 & out_texture_name, HPS::Material::Texture::ChannelMapping & out_channel) const;

	/*! Shows the roughness map name.
	*	\param out_texture_name The roughness map name if set.
	*	\param out_channel The channel.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowRoughnessMap(UTF8 & out_texture_name, HPS::Material::Texture::ChannelMapping & out_channel) const;

	/*! Shows the occlusion map name.
	*	\param out_texture_name The occlusion map name if set.
	*	\param out_channel The channel.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowOcclusionMap(UTF8 & out_texture_name, HPS::Material::Texture::ChannelMapping & out_channel) const;

	/*! Shows the base color factor.
	*	\param out_color The base color factor if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowBaseColorFactor(HPS::RGBAColor & out_color) const;

	/*! Shows the normal factor.
	*	\param out_factor The normal factor if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowNormalFactor(float & out_factor) const;

	/*! Shows the metalness factor.
	*	\param out_factor The metalness if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowMetalnessFactor(float & out_factor) const;

	/*! Shows the roughness factor.
	*	\param out_factor The roughness if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowRoughnessFactor(float & out_factor) const;

	/*! Shows the occlusion factor.
	*	\param out_factor The occlusion if set.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowOcclusionFactor(float & out_factor) const;

	/*! Shows the alpha factor and alpha mask.
	*	\param out_factor The alpha factor if set.
	*	\param out_mask The alpha mask value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool	ShowAlphaFactor(float & out_factor, bool & out_mask) const;
};


/*!
<p>The HPS::MaterialMappingControl class is a smart pointer that is tied to a database object. This object allows you to manipulate materials at the segment level. Examples of materials include texture, color, and gloss, among other things. Materials can be applied to geometry faces, edges, vertices, and text. Light color can also be set using this control. Materials can be applied at the segment, entity, or subentity level. In all MaterialMappingControl functions that take an RGBAColor, the alpha channel is ignored.</p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#material-mapping">This table</a> lists default values for the various segment attributes accessible from HPS::MaterialMappingControl.</p>
*/
class HPS_API MaterialMappingControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit MaterialMappingControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	MaterialMappingControl(MaterialMappingControl const & in_that);

	/*! The move constructor creates a MaterialMappingControl by transferring the underlying impl of the rvalue reference to this MaterialMappingControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MaterialMappingControl to take the impl from.*/
	MaterialMappingControl(MaterialMappingControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MaterialMappingControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a MaterialMappingControl to take the impl from.
	* \return A reference to this MaterialMappingControl. */
	MaterialMappingControl & operator=(MaterialMappingControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~MaterialMappingControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::MaterialMappingControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the MaterialMappingControl source.
	 *	\param in_that The MaterialMappingControl source of the assignment.
	 *	\return A reference to this MaterialMappingControl. */
	MaterialMappingControl &	operator=(MaterialMappingControl const & in_that);

	//Set

	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetAmbientLightUpColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetAmbientLightUpMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetAmbientLightDownColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetAmbientLightDownMaterialByIndex(float in_material_index);

	/*! Sets an alpha on the diffuse channel using in_alpha on the back face, replacing any previous mapping to that channel on this geometry type.
	*	If diffuse channel doesn't exist, white is used as the default value on diffuse channel with alpha value of in_alpha
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor on the back face, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel on the back face, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture. Only textures defined with modulation enabled support this. Alpha channel is ignored.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetBackFaceMaterialByIndex(float in_material_index);


	/*! Sets an alpha on the diffuse channel using in_alpha, replacing any previous mapping to that channel on this geometry type.
	*	If diffuse channel doesn't exist, white is used as the default value on diffuse channel with alpha value of in_alpha
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this. Alpha channel is ignored.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFrontFaceMaterialByIndex(float in_material_index);

	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutEdgeColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutEdgeMaterialByIndex(float in_material_index);

	/*! Sets an alpha on the diffuse channel using in_alpha, replacing any previous mapping to that channel on this geometry type.
	*	If diffuse channel doesn't exist, white is used as the default value on diffuse channel with alpha value of in_alpha
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this. Alpha channel is ignored.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutFaceMaterialByIndex(float in_material_index);

	/*! Sets an alpha on the diffuse channel using in_alpha, replacing any previous mapping to that channel on this geometry type.
	*	If diffuse channel doesn't exist, white is used as the default value on diffuse channel with alpha value of in_alpha
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this. Alpha channel is ignored.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetEdgeMaterialByIndex(float in_material_index);

	/*! Sets an alpha on the diffuse channel using in_alpha, replacing any previous mapping to that channel on this geometry type.
	*   This function sets the alpha for both the front and back faces.
	*	If diffuse channel doesn't exist, white is used as the default value on diffuse channel with alpha value of in_alpha
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceAlpha(float in_alpha);

	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*   This function sets the color for both the front and back faces.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this. Alpha channel is ignored.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceMaterialByIndex(float in_material_index);

	/*! Internal use only - customers should not use. Applies a shader by name, replacing any previous mapping to the DiffuseTexture channel on this geometry type.
	*	\param in_shader_name The name of a shader, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetFaceShader(char const * in_shader_name);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetLightColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetLightMaterialByIndex(float in_material_index);

	/*! Sets an alpha on the diffuse channel using in_alpha, replacing any previous mapping to that channel on this geometry type.
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetLineAlpha(float in_alpha);

	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*  Note that this function implicitly sets an alpha value for lines if an RGBColor is passed in.
	*  The alpha value can be modified either by calling this function again, or by calling SetLineAlpha.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetLineColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetLineMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetMarkerColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetMarkerMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color A color to apply to this geometry type. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetTextColor(RGBAColor const & in_rgba_color);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetTextMaterialByIndex(float in_material_index);


	/*! Sets an alpha on the diffuse channel using in_alpha, replacing any previous mapping to that channel on this geometry type.
	*	If diffuse channel doesn't exist, white is used as the default value on diffuse channel with alpha value of in_alpha
	*	\param in_alpha A color to apply to the diffuse channel of this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexAlpha(float in_alpha);


	/*! Sets a color on a particular channel using an RGBAColor, replacing any previous mapping to that channel on this geometry type.
	*	\param in_rgba_color A color to apply to the specified channel of this geometry type.
	*		Currently only the DiffuseColor channel supports alpha, it is ignored otherwise.
	*	\param in_channel The color channel to apply the color to.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexColor(RGBAColor const & in_rgba_color, Material::Color::Channel in_channel = Material::Color::Channel::DiffuseColor);

	/*! Sets a texture in_texture_name on the channel in_channel, replacing any previous mapping to that channel on this geometry type.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexTexture(char const * in_texture_name, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets a texture on a particular channel, replacing any previous mapping to that channel on this geometry type.
	*	The texture will be modulated by the specified color.
	*	The DiffuseTexture channel additionally supports mapping textures to multiple layers with higher layers appearing on top of lower layers.
	*	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color a color that is used to tint the texture.  Only textures defined with modulation enabled support this. Alpha channel is ignored.
	*	\param in_channel The texture channel to apply the texture to.
	*	\param in_layer The specific layer of in_channel to apply the texture to.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexModulatedTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, Material::Texture::Channel in_channel = Material::Texture::Channel::DiffuseTexture, size_t in_layer = 0);

	/*! Sets the gloss -- general "shininess" -- of this geometry type.
	*	\param in_value A gloss value is always positive, and most surfaces have a gloss in the range from 1.0 to 30.0.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexGloss(float in_value);

	/*! Sets a material for all channels on this geometry type, replacing any previous mapping to this geometry type.
	*	\param in_material A material kit to be applied to all channels on this geometry type.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexMaterial(MaterialKit const & in_material);

	/*! Sets a material by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexMaterialByIndex(float in_material_index);

	/*! Internal use only - customers should not use. Applies a shader by name, replacing any previous mapping to the DiffuseTexture channel on this geometry type.
	*	\param in_shader_name The name of a shader, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetVertexShader(char const * in_shader_name);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color An RGBA color that will be applied to this geometry types. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetWindowColor(RGBAColor const & in_rgba_color);

	/*! Sets a color by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetWindowMaterialByIndex(float in_material_index);


	/*! Sets a color using an RGBAColor, replacing any previous mapping to this geometry type.
	*	\param in_rgba_color An RGBA color that will be applied to this geometry types. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetWindowContrastColor(RGBAColor const & in_rgba_color);

	/*! Sets a color by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to this geometry type.  Because this geometry only supports a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetWindowContrastMaterialByIndex(float in_material_index);

	//Aggregate Sets

	/*! Sets a color on both cut edges and cut faces using an RGBAColor, replacing any previous mapping to those geometry types.
	*	\param in_rgba_color An RGBA color that will be applied to those geometry types. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutGeometryColor(RGBAColor const & in_rgba_color);

	/*! Sets a color on both cut edges and cut faces by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to those geometry types.
	*	\param in_color_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetCutGeometryMaterialByIndex(float in_color_index);


	/*! Sets a color on both ambient and ambient down using an RGBAColor, replacing any previous mapping to those geometry types.
	*	\param in_rgba_color An RGBA color that will be applied to those geometry types. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetAmbientLightColor(RGBAColor const & in_rgba_color);

	/*! Sets a color on both ambient and ambient down by using in_material_index to index into the active material palette, replacing
	*	any previous mapping to those geometry types.  Because these geometry types only support a simple color,
	*	only the diffuse channel of the material will be used.
	*	\param in_material_index An index into the active material palette.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetAmbientLightMaterialByIndex(float in_material_index);


	//Aggregate set

	/*! Sets a color on all basic geometry types (faces, edges, lines, markers, vertices, text) using an RGBAColor, replacing any previous mapping to those geometry types.
	*	\param in_rgba_color An RGBA color that will be applied to all basic geometry types. Alpha channel is ignored.
	*	\return A reference to this object. */
	MaterialMappingControl &	SetGeometryColor(RGBAColor const & in_rgba_color);


	//Unset

	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetAmbientLightUpColor();


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetAmbientLightDownColor();


	/*! Removes the material mapping for all channels of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetFrontFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetFrontFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetFrontFaceChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for all channels of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetBackFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetBackFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetBackFaceChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetCutEdgeColor();


	/*! Removes the material mapping for all channels of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetCutFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetCutFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetCutFaceChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for all channels of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetEdgeMaterial();

	/*! Removes the material mapping for one channel of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetEdgeChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetEdgeChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for all channels of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetFaceMaterial();

	/*! Removes the material mapping for one channel of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetFaceChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetFaceChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetLightColor();


	/*! Removes the line alpha setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetLineAlpha();

	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	Note that this function also unsets alpha values specified for lines through SetLineAlpha on this control.
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetLineColor();


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetMarkerColor();


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetTextColor();


	/*! Removes the material mapping for all channels of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetVertexMaterial();

	/*! Removes the material mapping for one channel of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetVertexChannel(Material::Channel in_channel);

	/*! Removes the material mapping for one layer of one channel (usually DiffuseTexture) of this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetVertexChannel(Material::Channel in_channel, size_t in_layer);


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetWindowColor();


	/*! Removes the material mapping for this geometry type. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetWindowContrastColor();


	//Aggregate Unsets

	/*! Removes the material mapping for both cut edges and cut faces. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetCutGeometryColor();

	/*! Removes the material mapping for both ambient light up and ambient light down. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetAmbientLightColor();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by MaterialMappingKit::GetDefault().
	*	\return A reference to this object. */
	MaterialMappingControl &	UnsetEverything();


	//Show

	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAmbientLightUpColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAmbientLightDownColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowBackFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowBackFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowBackFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFrontFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFrontFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFrontFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowCutEdgeColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowCutFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowCutFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowCutFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEdgeChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEdgeChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEdgeMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaceChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor or RGBColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.  If out_type is DiffuseChannelAlpha, this value contains the alpha value.
	*		If out_type is GlossValue, this value contains the gloss value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaceChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaceMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLightColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the alpha setting for lines.
	*	\param out_alpha The alpha value for lines.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLineAlpha(float & out_alpha) const;

	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLineColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowMarkerColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTextColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexChannel(Material::Channel in_channel, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for the channel in_channel and layer in_layer of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param in_channel The channel to query.
	*	\param in_layer The specific layer of in_channel to query.  Currently only relevant for DiffuseTexture, ignored otherwise.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.  If out_type is ModulatedTexture, this value contains the modulating color.
	*	\param out_texture_name If out_type is TextureName or ModulatedTexture, this value contains the name of the texture.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexChannel(Material::Channel in_channel, size_t in_layer, Material::Type & out_type, RGBAColor & out_rgba_color, UTF8 & out_texture_name, float & out_value) const;

	/*! Shows the material mapping for all channels of this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_kit If out_type is FullMaterial, this value contains the material.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexMaterial(Material::Type & out_type, MaterialKit & out_kit, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWindowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;


	/*! Shows the material mapping for this geometry type.  The out_type parameter indicates which of the other arguments is valid.
	*	\param out_type Indicates the type of material.
	*	\param out_rgba_color If out_type is RGBAColor, this value contains the color.
	*	\param out_value If out_type is MaterialIndex, this value contains the index.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWindowContrastColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_value) const;

private:
	MaterialMappingControl();
};


/*! The PortfolioControl class is a smart pointer that is tied to a database object.  Controls are used
	for manipulating settings within the database. */
class HPS_API PortfolioControl : public Control
{
public:
	/*! Initializes a control tied to the segment in_seg. */
	explicit PortfolioControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	PortfolioControl(PortfolioControl const & in_that);

	/*! The move constructor creates a PortfolioControl by transferring the underlying impl of the rvalue reference to this StyleControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PortfolioControl to take the impl from.*/
	PortfolioControl(PortfolioControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PortfolioControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a PortfolioControl to take the impl from.
	* \return A reference to this PortfolioControl. */
	PortfolioControl &		operator=(PortfolioControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~PortfolioControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::PortfolioControl;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the PortfolioControl source.
	 *	\param in_that The PortfolioControl source of the assignment.
	 *	\return A reference to this PortfolioControl. */
	PortfolioControl &		operator=(PortfolioControl const & in_that);

	/*! Returns the number of portfolios in use here. */
	size_t					GetCount() const;


	/*! Adds a portfolio to the top of the portfolio use stack.
	*	Existing portfolios in use are unmodified but portfolios on top take precedence if there are conflicting definitions.
	*	\param in_portfolio The portfolio to push to the top of the portfolio use stack.
	*	\return A reference to this object. */
	PortfolioControl &		Push(PortfolioKey const & in_portfolio);

	/*! Removes the top portfolio from the portfolio use stack.
	*	\return <span class='code'>true</span> if a portfolio was present, <span class='code'>false</span> otherwise. */
	bool					Pop();

	/*! Removes the top portfolio from the portfolio use stack and gives information about it to the user.
	*	\param out_portfolio The source portfolio.
	*	\return <span class='code'>true</span> if a portfolio was present, <span class='code'>false</span> otherwise. */
	bool					Pop(PortfolioKey & out_portfolio);


	/*! Sets a portfolio as the only portfolio in use, replacing any existing portfolios in use.
	*	\param in_portfolio A portfolio containing definitions that should be imported.
	*	\return A reference to this object. */
	PortfolioControl &		Set(PortfolioKey const & in_portfolio);

	/*! Sets a collection of portfolios as the only portfolios in use, replacing any existing portfolios in use.
	*	\param in_portfolios An array of source portfolios to be used.
	*	\return A reference to this object. */
	PortfolioControl &		Set(PortfolioKeyArray const & in_portfolios);

	/*! Sets a collection of portfolios as the only portfolios in use, replacing any existing portfolios in use.
	*	\param in_count The length of the source array.
	*	\param in_portfolios An array of source portfolios to be used.
	*	\return A reference to this object. */
	PortfolioControl &		Set(size_t in_count, PortfolioKey const in_portfolios[]);


	/*! Removes the top portfolio from the portfolio use stack.
	*	\return A reference to this object. */
	PortfolioControl &		UnsetTop();

	/*! Removes all portfolios from the portfolio use stack.
	*	\return A reference to this object. */
	PortfolioControl &		UnsetEverything();


	/*! Shows the top portfolio on the portfolio use stack.
	*	\param out_portfolio The portfolio on top of the stack.
	*	\return <span class='code'>true</span> if a portfolio was present, <span class='code'>false</span> otherwise. */
	bool					ShowTop(PortfolioKey & out_portfolio) const;

	/*! Shows all portfolios in use on this segment.
	*	\param out_portfolios Keys to all portfolios in use on this segment.
	*	\return <span class='code'>true</span> if any portfolio was present, <span class='code'>false</span> otherwise. */
	bool					Show(PortfolioKeyArray & out_portfolios) const;

private:
	PortfolioControl();
};



/*! The StyleControl class is a smart pointer that is tied to a database object.  Controls are used
	for manipulating settings within the database. */
class HPS_API StyleControl : public Control
{
public:
	/*! Initializes a control tied to the segment in_seg. */
	explicit StyleControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	StyleControl(StyleControl const & in_that);

	/*! The move constructor creates a StyleControl by transferring the underlying impl of the rvalue reference to this StyleControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a StyleControl to take the impl from.*/
	StyleControl(StyleControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this StyleControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a StyleControl to take the impl from.
	* \return A reference to this StyleControl. */
	StyleControl & operator=(StyleControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~StyleControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::StyleControl;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the StyleControl source.
	 *	\param in_that The StyleControl source of the assignment.
	 *	\return A reference to this StyleControl. */
	StyleControl &			operator=(StyleControl const & in_that);

	/*! Returns the number of styles set here. */
	size_t					GetCount() const;

	/*! Adds a named style to the top of the style stack.  Existing styles are unmodified but styles on top take precedence if there are duplicate settings. */
	StyleKey				PushNamed(char const * in_style_name);

	/*! Adds a conditional named style to the top of the style stack.  Existing styles are unmodified but styles on top take precedence if there are duplicate settings.
	 *	Conditional styles are only applied if their condition(s) are satisfied.
	 *	\param in_style_name The name of the named style which should be defined in an accessible portfolio.
	 *	\param in_conditional A conditional expression that must be satisfied in order for the style to be applied.
	 *	\return a StyleKey that can be used to interact with the style.  */
	StyleKey				PushNamed(char const * in_style_name, ConditionalExpression const & in_conditional);

	/*! Appends a conditional expression to an existing style or conditional style.  If the style does not currently exist, a new conditional style is pushed.
	 *	Conditional styles are only applied if their condition(s) are satisfied.
	 *	\param in_style_name The name of the named style which should be defined in an accessible portfolio.
	 *	\param in_conditional A conditional expression that must be satisfied in order for the style to be applied.
	 *	\param in_mode The behavior of the conditional expression if another conditional style is currently applied with the same style.
	 *	\return a StyleKey that can be used to interact with the style.  */
	StyleKey				AppendNamed(char const * in_style_name, ConditionalExpression const & in_conditional, Style::AppendMode in_mode = Style::AppendMode::Or);

	/*! Creates a new style based on in_style_source and places it on the top of the style stack.
	 *	Existing styles are unmodified but styles on top take precedence if there are duplicate settings.
	 *	\param	in_style_source The segment to use as the source for the attributes that should be styled.
	 *	\return a StyleKey that can be used to interact with the style.  */
	StyleKey				PushSegment(SegmentKey const & in_style_source);

	/*! Creates a new style based on in_style_source and places it on the top of the style stack.
	 *	Existing styles are unmodified but styles on top take precedence if there are duplicate settings.
	 *	\param	in_style_source The segment to use as the source for the attributes that should be styled.
	 *	\param in_conditional A conditional expression that must be satisfied in order for the style to be applied.
	 *	\return a StyleKey that can be used to interact with the style.  */
	StyleKey				PushSegment(SegmentKey const & in_style_source, ConditionalExpression const & in_conditional);

	/*! Appends a conditional expression to an existing style or conditional style.  If the style does not currently exist, a new conditional style is pushed.
	 *	Conditional styles are only applied if their condition(s) are satisfied.
	 *	\param	in_style_source The segment to use as the source for the attributes that should be styled.
	 *	\param in_conditional A conditional expression that must be satisfied in order for the style to be applied.
	 *	\param in_mode The behavior of the conditional expression if another conditional style is currently applied with the same style.
	 *	\return a StyleKey that can be used to interact with the style.  */
	StyleKey				AppendSegment(SegmentKey const & in_style_source, ConditionalExpression const & in_conditional, Style::AppendMode in_mode = Style::AppendMode::Or);



	/*! Removes the most recent style.
	\return <span class='code'>true</span> if a style was present, <span class='code'>false</span> otherwise. */
	bool					Pop();

	/*! Removes the most recent style and gives information about it to the user.
		\param out_type Indicates the type of the style.
		\param out_segment_source If out_type was Segment, this value contains the source segment for the style.
		\param out_style_name If out_type was Named, this value contains the name of the style (defined in a portfolio).
		\param out_conditional The conditions, if any, set on the style when it was applied.
		\return <span class='code'>true</span> if a style was present, <span class='code'>false</span> otherwise. */
	bool					Pop(Style::Type & out_type, SegmentKey & out_segment_source, UTF8 & out_style_name, ConditionalExpression & out_conditional);

	/*! Removes any styles on the associated segment which refer to the provided style source.  The styles will be removed regardless if there is a conditional expression
	 *	associated with the style or not.
	 *	\param in_style_source The style source used to identify which styles to remove. */
	void					Flush(SegmentKey const & in_style_source);

	/*! Removes any styles on the associated segment which refer to the provided style source with the provided condition.  If a style is found which references the style
	 *	source and has an associated conditional expression which contains the provided conditional expression, the provided conditional expression will be removed from
	 *	the conditional expression associated with the style.  If removing the provided conditional expression from the style results in the complete removal of the conditional
	 *	expression for the style, the style itself will be completely removed.
	 *	\param in_style_source The style source used to identify which styles to remove or modify.
	 *	\param in_conditional The conditional expression to remove from styles which refer to the provided style source. */
	void					Flush(SegmentKey const & in_style_source, ConditionalExpression const & in_conditional);

	/*! Removes any styles on the associated segment which refer to the provided style name.  The styles will be removed regardless if there is a conditional expression
	 *	associated with the style or not.
	 *	\param in_style_name The style name used to identify which styles to remove. */
	void					Flush(char const * in_style_name);

	/*! Removes any styles on the associated segment which refer to the provided style name with the provided condition.  If a style is found which references the style
	 *	name and has an associated conditional expression which contains the provided conditional expression, the provided conditional expression will be removed from
	 *	the conditional expression associated with the style.  If removing the provided conditional expression from the style results in the complete removal of the conditional
	 *	expression for the style, the style itself will be completely removed.
	 *	\param in_style_name The style name used to identify which styles to remove or modify.
	 *	\param in_conditional The conditional expression to remove from styles which refer to the provided style name. */
	void					Flush(char const * in_style_name, ConditionalExpression const & in_conditional);


	/*! Sets in_style_name as the only active style, replacing any existing styles.
		\param in_style_name The name of the style to apply. If the name does not exist in the active portfolio, no style is applied. */
	StyleKey				SetNamed(char const * in_style_name);

	/*! Sets in_style_name as the only active style, replacing any existing styles.
		\param in_style_name The name of the style to apply. If the name does not exist in the active portfolio, no style is applied.
		\param in_conditional A condition or conditions that must be met for a style to be activated. */
	StyleKey				SetNamed(char const * in_style_name, ConditionalExpression const & in_conditional);


	/*! Sets in_style_source as the only active style, replacing any existing styles.
		\param in_style_source A segment containing attributes that should be styled. */
	StyleKey				SetSegment(SegmentKey const & in_style_source);

	/*! Sets in_style_source as the only active style, replacing any existing styles.
		\param in_style_source A segment containing attributes that should be styled.
		\param in_conditional A condition or conditions that must be met for a style to be activated. */
	StyleKey				SetSegment(SegmentKey const & in_style_source, ConditionalExpression const & in_conditional);


	/*! Sets a collection of styles, replacing any existing styles.
		\param in_types Indicates the type of each style.
		\param in_segment_sources For each entry, if in_type was Segment, this value must contain the source segment for the style.
		\param in_style_names For each entry, if in_type was Named, this value must contain the name of the style (defined in a portfolio).
		\param in_conditions The conditions to set on each style. */
	void					Set(StyleTypeArray const & in_types, SegmentKeyArray const & in_segment_sources, UTF8Array const & in_style_names, ConditionalExpressionArray const & in_conditions);

	/*! Sets a collection of styles, replacing any existing styles.
		\param in_types Indicates the type of each style.
		\param in_segment_sources For each entry, if in_type was Segment, this value must contain the source segment for the style.
		\param in_style_names For each entry, if in_type was Named, this value must contain the name of the style (defined in a portfolio). */
	void					Set(StyleTypeArray const & in_types, SegmentKeyArray const & in_segment_sources, UTF8Array const & in_style_names);

	/*! Sets a collection of styles, replacing any existing styles.
		\param in_count The length of all arrays
		\param in_types Indicates the type of each style.
		\param in_segment_sources For each entry, if in_type was Segment, this value must contain the source segment for the style.
		\param in_style_names For each entry, if in_type was Named, this value must contain the name of the style (defined in a portfolio).
		\param in_conditions The conditions, if any, to set on each style.  Passing a null pointer indicates no conditions are requested. */
	void					Set(size_t in_count, Style::Type const in_types[], SegmentKey const in_segment_sources[], UTF8 const in_style_names[], ConditionalExpression const in_conditions[]);



	/*! Unsets the most recent style on this segment. */
	void					UnsetTop();

	/*! Unsets all segment styles on this segment. */
	void					UnsetAllSegment();

	/*! Unsets all named styles on this segment. */
	void					UnsetAllNamed();

	/*! Unsets all styles on this segment. */
	void					UnsetEverything();


	/*! Shows the most recent style applied to this segment.
		\param out_type Indicates the type of the style.
		\param out_segment_source If <span class='code'>out_type</span> was Style::Type::Segment, this value contains the source segment for the style.
		\param out_style_name If <span class='code'>out_type</span> was Style::Type::Named, this value contains the name of the style (defined in a portfolio).
		\param out_conditional The conditions, if any, set on the style when it was applied.
		\return <span class='code'>true</span> if a style was present, <span class='code'>false</span> otherwise. */
	bool					ShowTop(Style::Type & out_type, SegmentKey & out_segment_source, UTF8 & out_style_name, ConditionalExpression & out_conditional) const;

	/*!	Shows the most recent style applied to this segment.
	 *	\param out_style The StyleKey for the most recent style applied to this segment.
	 *	\return <span class='code'>true</span> if a style was present, <span class='code'>false</span> otherwise. */
	bool					ShowTop(StyleKey & out_style) const;

	/*! Shows all styles on this segment.
		\param out_types Indicates the type of each style.
		\param out_segment_sources For each entry, if <span class='code'>out_type</span> was Style::Type::Segment, this value contains the source segment for the style.
		\param out_style_names For each entry, if <span class='code'>out_type</span> was Style::Type::Named, this value contains the name of the style (defined in a portfolio).
		\param out_conditions The conditions, if any, set on each style when it was applied.
		\return <span class='code'>true</span> if any style was present, <span class='code'>false</span> otherwise. */
	bool					Show(StyleTypeArray & out_types, SegmentKeyArray & out_segment_sources, UTF8Array & out_style_names, ConditionalExpressionArray & out_conditions) const;

	/*!	Shows the all styles on this segment.
	 *	\param out_styles The StyleKey for each style on this segment.
	 *	\return <span class='code'>true</span> if any style was present, <span class='code'>false</span> otherwise. */
	bool					Show(StyleKeyArray & out_styles) const;

	/*! Shows all segment styles on this segment.
		\param out_segments Keys to all segments styled onto this segment.
		\param out_conditions The conditions, if any, set on each style when it was applied.
		\return <span class='code'>true</span> if any style of the correct type was present, <span class='code'>false</span> otherwise. */
	bool					ShowAllSegment(SegmentKeyArray & out_segments, HPS::ConditionalExpressionArray & out_conditions) const;

	/*!	Shows the all segment styles on this segment.
	 *	\param out_styles The StyleKey for each segment style on this segment.
	 *	\return <span class='code'>true</span> if any segment style was present, <span class='code'>false</span> otherwise. */
	bool					ShowAllSegment(StyleKeyArray & out_styles) const;

	/*! Shows all named styles on this segment.
		\param out_names Names of all named styles set on this segment.
		\param out_conditions The conditions, if any, set on each style when it was applied.
		\return <span class='code'>true</span> if any style of the correct type was present, <span class='code'>false</span> otherwise. */
	bool					ShowAllNamed(UTF8Array & out_names, HPS::ConditionalExpressionArray & out_conditions) const;

	/*!	Shows the all named styles on this segment.
	 *	\param out_styles The StyleKey for each named style on this segment.
	 *	\return <span class='code'>true</span> if any named style was present, <span class='code'>false</span> otherwise. */
	bool					ShowAllNamed(StyleKeyArray & out_styles) const;

private:
	StyleControl();
};


/*! The ConditionControl class is a smart pointer that is tied to a database object. This class is used to set and unset conditions on a
	segment. A condition can be used to control when a style is applied, or to control when an included segment is included. */
class HPS_API ConditionControl : public Control
{
public:
	/*! Initializes a control tied to the segment in_seg. */
	explicit ConditionControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	ConditionControl(ConditionControl const & in_that);

	/*! The move constructor creates a ConditionControl by transferring the underlying impl of the rvalue reference to this ConditionControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ConditionControl to take the impl from.*/
	ConditionControl(ConditionControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ConditionControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a ConditionControl to take the impl from.
	* \return A reference to this ConditionControl. */
	ConditionControl & operator=(ConditionControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~ConditionControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::ConditionControl;
	HPS::Type		ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the ConditionControl source.
	 *	\param in_that The ConditionControl source of the assignment.
	 *	\return A reference to this ConditionControl. */
	ConditionControl &		operator=(ConditionControl const & in_that);

	/*!	Retrieves the number of conditions set on this segment.
		\return The number of conditions set on this segment. */
	size_t					GetCount() const;

	/*! Adds a condition to the collection of active conditions on this segment.
		\param in_condition the condition to enable.
		\return a reference to this object. */
	ConditionControl &		AddCondition(char const * in_condition);


	/*! Sets a condition as the only active condition on this segment, replacing any existing conditions.
		\param in_condition the condition to enable.
		\return a reference to this object. */
	ConditionControl &		SetCondition(char const * in_condition);

	/*! Sets a collection of conditions as the only active conditions on this segment, replacing any existing conditions.
		\param in_conditions An array of conditions to enable.
		\return a reference to this object. */
	ConditionControl &		SetConditions(UTF8Array const & in_conditions);

	/*! Sets a collection of conditions as the only active conditions on this segment, replacing any existing conditions.
		\param in_count the number of conditions in the array.
		\param in_conditions An array of conditions to enable.
		\return a reference to this object. */
	ConditionControl &		SetConditions(size_t in_count, UTF8 const in_conditions []);


	/*! Removes a specified condition from the active conditions on this segment.
		\param in_condition The condition to remove.
		\return a reference to this object. */
	ConditionControl &		UnsetCondition(char const * in_condition);

	/*! Unsets all conditions on this segment.
		\return a reference to this object. */
	ConditionControl &		UnsetEverything();


	/*! Queries the existence of one condition on this segment.
	*	\param in_condition The condition in question.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCondition(char const * in_condition) const;

	/*! Shows all conditions on this segment.
	*	\param out_conditions An array of conditions that are active on the segment.
	*	\return <span class='code'>true</span> if any conditions are set, <span class='code'>false</span> otherwise. */
	bool					ShowConditions(UTF8Array & out_conditions) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	ConditionControl();
};


/*! The MaterialKit class is a user space object, useful for carrying a group of attribute settings.
	A MaterialKit can be associated with various geometry or subgeometery types using a material mapping kit or control. */
class HPS_API MaterialKit : public Kit
{
public:

	/*! The default constructor creates an empty MaterialKit object. */
	MaterialKit();

	/*! The copy constructor creates a new MaterialKit object that contains the same settings as the source.
		\param in_kit The source MaterialKit to copy. */
	MaterialKit(MaterialKit const & in_kit);

	/*! The move constructor creates a MaterialKit by transferring the underlying impl of the rvalue reference to this MaterialKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MaterialKit to take the impl from.*/
	MaterialKit(MaterialKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MaterialKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a MaterialKit to take the impl from.
	* \return A reference to this MaterialKit. */
	MaterialKit & operator=(MaterialKit && in_that);

	/*! Destroy this kit. */
	~MaterialKit();

	static const HPS::Type staticType = HPS::Type::MaterialKit;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Copies all settings from the source MaterialKit into this object.
	* 	\param in_kit The source MaterialKit to copy. */
	void				Set(MaterialKit const & in_kit);

	/*! Copies all settings from this MaterialKit into the given MaterialKit.
	 * 	\param out_kit The MaterialKit to populate with the contents of this object. */
	void				Show(MaterialKit & out_kit) const;

	/*! Copies the source MaterialKit into this object.
	* 	\param in_kit The source MaterialKit to copy.
	 * 	\return A reference to this object. */
	MaterialKit &		operator=(MaterialKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source MaterialKit is equivalent to this object.
	*	\param in_kit The source MaterialKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(MaterialKit const & in_kit) const;

	/*!	Check if the source MaterialKit is equivalent to this object.
	*	\param in_kit The source MaterialKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(MaterialKit const & in_kit) const;

	/*!	Check if the source MaterialKit is not equivalent to this object.
	*	\param in_kit The source MaterialKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(MaterialKit const & in_kit) const;


	//Set

	/*! Applies an RGB color to the whole diffuse channel, replacing any diffuse textures or shaders.
	 * 	\param in_color The color to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuse(RGBColor const & in_color);

	/*! Applies an RGBA color to the whole diffuse channel, replacing any diffuse textures or shaders.
	 * 	\param in_color The color to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuse(RGBAColor const & in_color);

	/*! Applies an RGB color to the diffuse color channel.  Only one diffuse color may be set at a time but it can coexist with diffuse textures if they have transparency.
	 * 	\param in_color The color to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseColor(RGBColor const & in_color);

	/*! Applies an RGBA color to the diffuse color channel.  Only one diffuse color may be set at a time but it can coexist with diffuse textures if they have transparency.
	 * 	\param in_color The color to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseColor(RGBAColor const & in_color);

	/*! Applies an alpha channel the diffuse color channel.  Only one diffuse color may be set at a time but it can coexist with diffuse textures if they have transparency.
	 *  If diffuse color has not been set, white will be set as a default value in the diffuse color channel with a transparent value of in_alpha.
	 * 	\param in_alpha The alpha to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseAlpha(float in_alpha);

	/*! Applies a named texture to the specified layer of the diffuse texture channel, replacing any other textures on that layer.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.  There are two special values that can be passed in here.
	 *		A null pointer removes the texture name from that layer, allowing the texture on that layer to be inherited from above in the tree.
	 *		Passing an empty string, "", removes the texture from that layer but indicates that no texture should be inherited from above, an explicit blank.
	 *	\param in_layer The layer to apply the texture to.  Higher numbered layers are applied on top of lower numbered ones.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseTexture(char const * in_texture_name, size_t in_layer=0);

	/*! Applies a modulated named texture to the specified layer of the diffuse texture channel, replacing any other textures on that layer.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.  There are two special values that can be passed in here.
	 *		A null pointer removes the texture name from that layer, allowing the texture on that layer to be inherited from above in the tree.
	 *		Passing an empty string, "", removes the texture from that layer but indicates that no texture should be inherited from above, an explicit blank.
	 *	\param in_modulating_color A color that will be applied as a filter to the texture.
	 *	\param in_layer The layer to apply the texture to.  Higher numbered layers are applied on top of lower numbered ones.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseTexture(char const * in_texture_name, RGBAColor const & in_modulating_color, size_t in_layer=0);

	/*! Applies named textures to each of the specified layers of the diffuse texture channel, replacing any other textures on those layers.
	 * 	\param in_texture_names The names of textures, one per layer.  Uninitialized strings are ignored.
	 *		An empty string, "", removes the texture from that layer but indicates that no texture should be inherited from above, an explicit blank.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseTexture(UTF8Array const & in_texture_names);

	/*! Applies named textures to each of the specified layers of the diffuse texture channel, replacing any other textures on those layers.
	*	\param in_count the number of elements in the array of names.
	 * 	\param in_texture_names The names of textures, one per layer.  Uninitialized strings are ignored.
	 *		An empty string, "", removes the texture from that layer but indicates that no texture should be inherited from above, an explicit blank.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseTexture(size_t in_count, UTF8 const in_texture_names []);

	/*! Applies named textures, possibly modulated, to each of the specified layers of the diffuse texture channel, replacing any other textures on those layers.
	 * 	\param in_texture_names The names of textures, one per layer.  Uninitialized strings are ignored.
	 *		An empty string, "", removes the texture from that layer but indicates that no texture should be inherited from above, an explicit blank.
	 *	\param in_modulating_colors An array of modulating colors to be applied to the corresponding layer.
	 *		If a color in the this array is uninitialized, the texture on that layer will be unmodulated.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseTexture(UTF8Array const & in_texture_names, RGBAColorArray const & in_modulating_colors);

	/*! Applies named textures, possibly modulated, to each of the specified layers of the diffuse texture channel, replacing any other textures on those layers.
	*	\param in_count the number of elements in the both arrays.
	 * 	\param in_texture_names The names of textures, one per layer.  Uninitialized strings are ignored.
	 *		An empty string, "", removes the texture from that layer but indicates that no texture should be inherited from above, an explicit blank.
	 *	\param in_modulating_colors An array of modulating colors to be applied to the corresponding layer.
	 *		If a color in the this array is uninitialized, the texture on that layer will be unmodulated.
	 * 	\return A reference to this object. */
	MaterialKit &		SetDiffuseTexture(size_t in_count, UTF8 const in_texture_names [], RGBAColor const in_modulating_colors []);


	/*! Internal use only - customers should not use. Applies a shader which replaces the diffuse texture at layer 0.  It may also replace all diffuse textures depending on the multitexture setting of the shader.
	*	\param in_shader_name The name of a shader, defined in a portfolio that is accessible.
	* 	\return A reference to this object. */
	MaterialKit &		SetShader(char const * in_shader_name);



	/*! Applies an RGBA color to the specular channel, replacing any other color or texture on that channel.
	 * 	\param in_rgba_color The color to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetSpecular(RGBAColor const & in_rgba_color);

	/*! Applies a named texture to the specular channel, replacing any other color or texture on that channel.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	 * 	\return A reference to this object. */
	MaterialKit &		SetSpecular(char const * in_texture_name);

	/*! Applies a modulated named texture to the specular channel, replacing any other color or texture on that channel.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	 *	\param in_modulating_color A color that will be applied as a filter to the texture.
	 * 	\return A reference to this object. */
	MaterialKit &		SetSpecular(char const * in_texture_name, RGBAColor const & in_modulating_color);



	/*! Applies an RGBA color to the mirror channel, replacing any other color or texture on that channel.
	 * 	\param in_rgba_color The color to be applied.
	 * 	\return A reference to this object. */
	MaterialKit &		SetMirror(RGBAColor const & in_rgba_color);

	/*! Applies a named texture to the mirror channel, replacing any other color or texture on that channel.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	 * 	\return A reference to this object. */
	MaterialKit &		SetMirror(char const * in_texture_name);

	/*! Applies a modulated named texture to the mirror channel, replacing any other color or texture on that channel.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	 *	\param in_modulating_color A color that will be applied as a filter to the texture.
	 * 	\return A reference to this object. */
	MaterialKit &		SetMirror(char const * in_texture_name, RGBAColor const & in_modulating_color);



	/*! Applies a named texture to the transmission channel, replacing any other color or texture on that channel.
	 * 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	 * 	\return A reference to this object. */
	MaterialKit &		SetTransmission(char const * in_texture_name);

	/*! Applies a modulated named texture to the transmission channel, replacing any other color or texture on that channel.
	* 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color A color that will be applied as a filter to the texture.
	* 	\return A reference to this object. */
	MaterialKit &		SetTransmission(char const * in_texture_name, RGBAColor const & in_modulating_color);



	/*! Applies an RGBA color to the emission channel, replacing any other color or texture on that channel.
	* 	\param in_rgba_color The color to be applied.
	* 	\return A reference to this object. */
	MaterialKit &		SetEmission(RGBAColor const & in_rgba_color);

	/*! Applies a named texture to the emission channel, replacing any other color or texture on that channel.
	* 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	* 	\return A reference to this object. */
	MaterialKit &		SetEmission(char const * in_texture_name);

	/*! Applies a modulated named texture to the emission channel, replacing any other color or texture on that channel.
	* 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color A color that will be applied as a filter to the texture.
	* 	\return A reference to this object. */
	MaterialKit &		SetEmission(char const * in_texture_name, RGBAColor const & in_modulating_color);



	/*! Applies a named texture to the environment channel, replacing any other texture or cube map on that channel.
	* 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	* 	\return A reference to this object. */
	MaterialKit &		SetEnvironmentTexture(char const * in_texture_name);

	/*! Applies a modulated named texture to the environment channel, replacing any other texture or cube map on that channel.
	* 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color A color that will be applied as a filter to the texture.
	* 	\return A reference to this object. */
	MaterialKit &		SetEnvironmentTexture(char const * in_texture_name, RGBAColor const & in_modulating_color);

	/*! Applies a named cube map to the environment channel, replacing any other texture or cube map on that channel.
	* 	\param in_cubemap_name The name of a texture, defined in a portfolio that is accessible.
	* 	\return A reference to this object. */
	MaterialKit &		SetEnvironmentCubeMap(char const * in_cubemap_name);

	/*! Applies a modulated named cube map to the environment channel, replacing any other texture or cube map on that channel.
	* 	\param in_cubemap_name The name of a texture, defined in a portfolio that is accessible.
	*	\param in_modulating_color A color that will be applied as a filter to the cube map.
	* 	\return A reference to this object. */
	MaterialKit &		SetEnvironmentCubeMap(char const * in_cubemap_name, RGBAColor const & in_modulating_color);

	/*! Cancels any other texture or cube map on the environment channel.
	* 	\return A reference to this object. */
	MaterialKit &		SetEnvironmentTexture();


	/*! Applies a named texture to the bump channel, replacing any other texture on that channel.
	* 	\param in_texture_name The name of a texture, defined in a portfolio that is accessible.
	* 	\return A reference to this object. */
	MaterialKit &		SetBump(char const * in_texture_name);



	/*! Gloss is a setting that helps to determine the specular response of a material.
	*	It is a single floating point value that describes the "focus" of specular reflections off a surface.
	*	The gloss value changes the area of the "glare" off a surface.  A high gloss value gives a small, focused glare;
	*	a low gloss value results in a less polished, more scattered reflection.
	* 	\param in_gloss Gloss is always positive, and most surfaces have a gloss in the range of 1.0 to 30.0.
	* 	\return A reference to this object. */
	MaterialKit &		SetGloss(float in_gloss);

	/*! Removes all settings applied to the diffuse rgb channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetDiffuseColorRGB();

	/*! Removes all settings applied to the diffuse color channel including alpha.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetDiffuseColor();

	/*! Removes all settings applied to the diffuse alpha channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetDiffuseAlpha();

	/*! Removes all settings applied to all layers of the diffuse texture channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetDiffuseTexture();

	/*! Removes all settings applied to the specified layer of the diffuse texture channel.
	*	\param in_layer The layer to remove the setting from.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetDiffuseTexture(size_t in_layer);

	/*! Internal use only - customers should not use. Removes any shader applied to this material.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetShader();

	/*! Removes all settings applied to the specular channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetSpecular();

	/*! Removes all settings applied to the mirror channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetMirror();

	/*! Removes all settings applied to the transmission channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetTransmission();

	/*! Removes all settings applied to the emission channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetEmission();

	/*! Removes all settings applied to the environment channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetEnvironment();

	/*! Removes all settings applied to the bump channel.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetBump();

	/*! Removes the gloss setting applied to this material.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetGloss();

	/*! Removes all setting from this material.
	* 	\return A reference to this object. */
	MaterialKit &		UnsetEverything();


	/*! If the diffuse color will override textures and shaders.
	 *	\return <span class='code'>true</span> if the diffuse color will override textures and shaders, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuse() const;

	/*! Retrieves RGB color set on the diffuse RGB channel.
	 *	\param out_rgb_color The RGB color set on the diffuse RGB channel.
	 *	\return <span class='code'>true</span> if the diffuse RGB color is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuseColor(RGBColor & out_rgb_color) const;

	/*! Retrieves RGBA color set on the diffuse color channel.
	 *	\param out_rgba_color The RGBA color set on the diffuse color channel.
	 *	\return <span class='code'>true</span> if the diffuse RGB color is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuseColor(RGBAColor & out_rgba_color) const;

	/*! Retrieves alpha set on the diffuse alpha channel.
	 *	\param out_alpha The color set on the diffuse alpha channel.
	 *	\return <span class='code'>true</span> if the internal selection limit is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuseAlpha(float & out_alpha) const;

	/*! Retrieves the possibly modulated texture applied to layer 0 of the diffuse texture channel.
	 *	\param out_type Indicates which of the following arguments is valid.  If the type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
	 *	\param out_color A modulating color applied as a filter to the named texture, only valid if out_type is ModulatedTexture.
	 *	\param out_texture_name The name of a texture applied to this channel.
	 *	\return <span class='code'>true</span> if a texture has been set on layer 0 of the diffuse texture channel, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuseTexture(Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;

	/*! Retrieves the possibly modulated texture applied to the specified layer of the diffuse texture channel.
	 *	\param in_layer The layer number to query for a texture.
	 *	\param out_type Indicates which of the following arguments is valid.  If the type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
	 *	\param out_color A modulating color applied as a filter to the named texture, only valid if out_type is ModulatedTexture.
	 *	\param out_texture_name The name of a texture applied to this channel.
	 *	\return <span class='code'>true</span> if a texture has been set on the specified layer of the diffuse texture channel, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuseTexture(size_t in_layer, Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;

	/*! Retrieves the possibly modulated textures applied to all layers of the diffuse texture channel.
	 *	\param out_types An array of types indicating which of the following arguments is valid for each layer.  If a type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If a type is ModulatedTexture, both the texture name and the modulating color are valid.  If a type is Nothing, there is no texture applied to that layer
	 *	\param out_colors An array of modulating colors applied as filters to the named textures,  each entry is only valid if the corresponding entry in out_types is ModulatedTexture.
	 *	\param out_texture_names An array of names of a textures applied to this channel, indexed by layer.
	 *	\return <span class='code'>true</span> if any texture has been set on the diffuse texture channel, <span class='code'>false</span> otherwise. */
	bool				ShowDiffuseTexture(MaterialTypeArray & out_types, RGBAColorArray & out_colors, UTF8Array & out_texture_names) const;

	/*! Internal use only - customers should not use. Retrieves the shader applied to this material
	 *	\param out_shader_name The name of a shader applied to this material.
	 *	\return <span class='code'>true</span> if a shader has been set on this material, <span class='code'>false</span> otherwise. */
	bool				ShowShader(UTF8 & out_shader_name) const;

	/*! Retrieves the color, texture, or modulated texture applied to the specular channel.
	 *	\param out_type Indicates which of the following arguments is valid.
	 *		If the type is RGBAColor, only out_color is valid, the texture name should be ignored.
	 *		If the type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
	 *	\param out_color A color used either for the entire channel or to modulate a texture on this channel.  See out_type to determine if this color is valid.
	 *	\param out_texture_name The name of a possibly modulated texture applied to this channel.  See out_type to determine if this texture name is valid.
	 *	\return <span class='code'>true</span> if any color or texture has been set on the specular channel, <span class='code'>false</span> otherwise. */
	bool				ShowSpecular(Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;

	/*! Retrieves the color, texture, or modulated texture applied to the mirror channel.
	 *	\param out_type Indicates which of the following arguments is valid.
	 *		If the type is RGBAColor, only out_color is valid, the texture name should be ignored.
	 *		If the type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
	 *	\param out_color A color used either for the entire channel or to modulate a texture on this channel.  See out_type to determine if this color is valid.
	 *	\param out_texture_name The name of a possibly modulated texture applied to this channel.  See out_type to determine if this texture name is valid.
	 *	\return <span class='code'>true</span> if any color or texture has been set on the mirror channel, <span class='code'>false</span> otherwise. */
	bool				ShowMirror(Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;



	/*! Retrieves the color, texture, or modulated texture applied to the transmission channel.
	 *	\param out_type Indicates which of the following arguments is valid.
	 *		If the type is RGBAColor, only out_color is valid, the texture name should be ignored.
	 *		If the type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
	 *	\param out_color A color used either for the entire channel or to modulate a texture on this channel.  See out_type to determine if this color is valid.
	 *	\param out_texture_name The name of a possibly modulated texture applied to this channel.  See out_type to determine if this texture name is valid.
	 *	\return <span class='code'>true</span> if any color or texture has been set on the transmission channel, <span class='code'>false</span> otherwise. */
	bool				ShowTransmission(Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;


	/*! Retrieves the color, texture, or modulated texture applied to the emission channel.
		 *	\param out_type Indicates which of the following arguments is valid.
		 *		If the type is RGBAColor, only out_color is valid, the texture name should be ignored.
		 *		If the type is TextureName, only the texture name is valid, the color should be ignored.
		 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
		 *	\param out_color A color used either for the entire channel or to modulate a texture on this channel.  See out_type to determine if this color is valid.
		 *	\param out_texture_name The name of a possibly modulated texture applied to this channel.  See out_type to determine if this texture name is valid.
		 *	\return <span class='code'>true</span> if any color or texture has been set on the emission channel, <span class='code'>false</span> otherwise. */
	bool				ShowEmission(Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;


	/*! Retrieves the color, texture, or modulated texture applied to the environment channel.
	 *	\param out_type Indicates which of the following arguments is valid.
	 *		If the type is RGBAColor, only out_color is valid, the texture name should be ignored.
	 *		If the type is TextureName, only the texture name is valid, the color should be ignored.
	 *		If the type is ModulatedTexture, both the texture name and the modulating color are valid.
	 *	\param out_color A color used either for the entire channel or to modulate a texture on this channel.  See out_type to determine if this color is valid.
	 *	\param out_texture_name The name of a possibly modulated texture applied to this channel.  See out_type to determine if this texture name is valid.
	 *	\return <span class='code'>true</span> if any color or texture has been set on the environment channel, <span class='code'>false</span> otherwise. */
	bool				ShowEnvironment(Material::Type & out_type, RGBAColor & out_color, UTF8 & out_texture_name) const;


	/*! Retrieves the texture applied to the bump channel.
	 *	\param out_texture_name The name of a texture applied to this channel.
	 *	\return <span class='code'>true</span> if a texture has been set on the bump channel, <span class='code'>false</span> otherwise. */
	bool				ShowBump(UTF8 & out_texture_name) const;

	/*! Retrieves the gloss of this material.  Gloss is a single floating point value that describes the "focus" of specular reflections off a surface.
	*	\sa SetGloss().
	*	\param out_gloss The gloss value of this material.  Gloss is always positive, and most surfaces have a gloss in the range of 1.0 to 30.0.
	*	\return <span class='code'>true</span> if gloss has been specified for this material, <span class='code'>false</span> otherwise. */
	bool				ShowGloss(float & out_gloss) const;
};


/*! The HPS::NURBSSurfaceAttributeKit class is a user space object that contains settings related to NURBS surfaces. Calling HPS::NURBSSurfaceAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#nurbs-surfaces">this table</a>. */
class HPS_API NURBSSurfaceAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	NURBSSurfaceAttributeKit();

	/*! The copy constructor creates a new NURBSSurfaceAttributeKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	NURBSSurfaceAttributeKit(NURBSSurfaceAttributeKit const & in_kit);

	/*! The move constructor creates a NURBSSurfaceAttributeKit by transferring the underlying impl of the rvalue reference to this NURBSSurfaceAttributeKit
	*	thereby avoiding a copy and allocation.
	*	\param in_that An rvalue reference to a NURBSSurfaceAttributeKit to take the impl from.*/
	NURBSSurfaceAttributeKit(NURBSSurfaceAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NURBSSurfaceAttributeKit thereby avoiding a copy.
	*	\param in_that An rvalue reference to a NURBSSurfaceAttributeKit to take the impl from.
	*	\return A reference to this NURBSSurfaceAttributeKit. */
	NURBSSurfaceAttributeKit & operator=(NURBSSurfaceAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~NURBSSurfaceAttributeKit();

	static const HPS::Type staticType = HPS::Type::NURBSSurfaceAttributeKit;
	HPS::Type						ObjectType() const {return staticType;};

	/*! Creates a NURBSSurfaceAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A NURBSSurfaceAttributeKit with the default settings. */
	static NURBSSurfaceAttributeKit GetDefault();

	/*! Copies the source NURBSSurfaceAttributeKit into this object.
	*	\param in_kit The source object to copy. */
	void							Set(NURBSSurfaceAttributeKit const & in_kit);

	/*! Copies this object into the given NURBSSurfaceAttributeKit.
	*	\param out_kit The NURBSSurfaceAttributeKit to populate with the contents of this object. */
	void							Show(NURBSSurfaceAttributeKit & out_kit) const;

	/*! Copies the source NURBSSurfaceAttributeKit into this object.
	*	\param in_kit The source NURBSSurfaceAttributeKit to copy.
	*	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		operator=(NURBSSurfaceAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool							Empty() const;

	/*!	Check if the source NURBSSurfaceAttributeKit is equivalent to this object.
	*	\param in_kit The source NURBSSurfaceAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							Equals(NURBSSurfaceAttributeKit const & in_kit) const;

	/*!	Check if the source NURBSSurfaceAttributeKit is equivalent to this object.
	*	\param in_kit The source NURBSSurfaceAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							operator==(NURBSSurfaceAttributeKit const & in_kit) const;

	/*!	Check if the source NURBSSurfaceAttributeKit is not equivalent to this object.
	*	\param in_kit The source NURBSSurfaceAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool							operator!=(NURBSSurfaceAttributeKit const & in_kit) const;


	/*! Sets an upper bound on the number of vertices that will be allowed in the tessellation of NURBS surfaces.
	* 	\param in_budget The maximum number of vertices to be used in NURBS surface tessellation.
	* 	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		SetBudget(size_t in_budget);

	/*! Sets an upper bound for the distance, in object space, of the tessellation to the parametric definition of the surface.
	 *	Note that since this setting is in object space, it should be set differently depending on the scale of the NURBS control points.
	 *	\param in_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the surface.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		SetMaximumDeviation(float in_deviation);

	/*! Sets the largest angle allowed between the surface tangents evaluated at any two corners of a given facet. Expressed in degrees.
	 *	\param in_degrees The maximum angle allowed between the surface tangents, in degrees.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		SetMaximumAngle(float in_degrees);

	/*! The largest allowable length, in the NURBS surface's normalized [0..1] parametric space, of any facet's edge.
	 *	\param in_width The largest allowable length of any facet's edge.  Valid range is [0, sqrt(2)].
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		SetMaximumWidth(float in_width);

	/*! Sets an upper bound on the number of vertices that will be allowed in the tessellation of a trim curve.
	 *	\param in_budget The maximum number of vertices to be used in trim curve tessellation.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		SetTrimBudget(size_t in_budget);

	/*! Sets an upper bound for the distance, in the NURBS surface's normalized [0..1] parametric space,
	 *	of trim curve vertices from the parametric definition of the trimming curve.
	 *	\param in_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the trimming curve.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		SetMaximumTrimDeviation(float in_deviation);


	/*! Removes the NURBS surface tessellation budget.
	*	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetBudget();

	/*! Removes the upper bound of the difference between the NURBS surface and its parametric definition.
	*	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetMaximumDeviation();

	/*! Removes the largest angle allowed between the surface tangents.
	*	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetMaximumAngle();

	/*! Removes the setting for the largest allowable length of any facet's edge.
	*	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetMaximumWidth();

	/*! Removes the upper bound of vertices to be used in trim curve tessellation.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetTrimBudget();

	/*! Removes the upper bound of trim curve vertices from the parametric definition of the trimming curve.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetMaximumTrimDeviation();

	/*! Removes all settings from this object.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeKit &		UnsetEverything();

	/*! Shows the NURBS surface tessellation budget.
	 *	\param out_budget The maximum number of vertices to be used in NURBS surface tessellation.
	 *	\return <span class='code'>true</span> if the budget is valid, <span class='code'>false</span> otherwise. */
	bool							ShowBudget(size_t & out_budget) const;

	/*! Shows the upper bound of the difference between the NURBS surface and its parametric definition.
	 *	\param out_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the surface.
	 *	\return <span class='code'>true</span> if the maximum deviation is valid, <span class='code'>false</span> otherwise. */
	bool							ShowMaximumDeviation(float & out_deviation) const;

	/*! Shows the largest angle allowed between the surface tangents.
	 *	\param out_degrees The maximum angle allowed between the surface tangents, in degrees.
	 *	\return <span class='code'>true</span> if the maximum angle is valid, <span class='code'>false</span> otherwise. */
	bool							ShowMaximumAngle(float & out_degrees) const;

	/*! Shows the setting for the largest allowable length of any facet's edge.
	 *	\param out_width The largest allowable length of any facet's edge..
	 *	\return <span class='code'>true</span> if the maximum width is valid, <span class='code'>false</span> otherwise. */
	bool							ShowMaximumWidth(float & out_width) const;

	/*! Shows the upper bound of vertices to be used in trim curve tessellation.
	 *	\param out_budget The maximum number of vertices to be used in trim curve tessellation.
	 *	\return <span class='code'>true</span> if the budget is valid, <span class='code'>false</span> otherwise. */
	bool							ShowTrimBudget(size_t & out_budget) const;

	/*! Shows the upper bound of trim curve vertices from the parametric definition of the trimming curve.
	 *	\param out_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the trimming curve.
	 *	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowMaximumTrimDeviation(float & out_deviation) const;
};

/*!
<p>The HPS::NURBSSurfaceAttributeControl class is a smart pointer that is tied to a database object. This object allows you to manipulate various settings related to NURBS surfaces, such as budget, angle, deviation, and width. </p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#nurbs-surfaces">This table</a> lists default values for the various segment attributes accessible from HPS::NURBSSurfaceAttributeControl.</p>
*/
class HPS_API NURBSSurfaceAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit NURBSSurfaceAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	NURBSSurfaceAttributeControl(NURBSSurfaceAttributeControl const & in_that);

	/*! The move constructor creates a NURBSSurfaceAttributeControl by transferring the underlying impl of the rvalue reference to this NURBSSurfaceAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a NURBSSurfaceAttributeControl to take the impl from.*/
	NURBSSurfaceAttributeControl(NURBSSurfaceAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NURBSSurfaceAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a NURBSSurfaceAttributeControl to take the impl from.
	* \return A reference to this NURBSSurfaceAttributeControl. */
	NURBSSurfaceAttributeControl & operator=(NURBSSurfaceAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~NURBSSurfaceAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::NURBSSurfaceAttributeControl;
	HPS::Type							ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the NURBSSurfaceAttributeControl source.
	 *	\param in_that The NURBSSurfaceAttributeControl source of the assignment.
	 *	\return A reference to this NURBSSurfaceAttributeControl. */
	NURBSSurfaceAttributeControl &		operator=(NURBSSurfaceAttributeControl const & in_that);

	/*! Sets an upper bound on the number of vertices that will be allowed in the tessellation of NURBS surfaces.
	 * 	\param in_budget The maximum number of vertices to be used in NURBS surface tessellation.
	 * 	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		SetBudget(size_t in_budget);

	/*! Sets an upper bound for the distance, in object space, of the tessellation to the parametric definition of the surface.
	 *	Note that since this setting is in object space, it should be set differently depending on the scale of the NURBS control points.
	 *	\param in_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the surface.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		SetMaximumDeviation(float in_deviation);

	/*! Sets the largest angle allowed between the surface tangents evaluated at any two corners of a given facet. Expressed in degrees.
	 *	\param in_degrees The maximum angle allowed between the surface tangents, in degrees.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		SetMaximumAngle(float in_degrees);

	/*! The largest allowable length, in the NURBS surface's normalized [0..1] parametric space, of any facet's edge.
	 *	\param in_width The largest allowable length of any facet's edge.  Valid range is [0, sqrt(2)].
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		SetMaximumWidth(float in_width);

	/*! Sets an upper bound on the number of vertices that will be allowed in the tessellation of a trim curve.
	 *	\param in_budget The maximum number of vertices to be used in trim curve tessellation.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		SetTrimBudget(size_t in_budget);

	/*! Sets an upper bound for the distance, in the NURBS surface's normalized [0..1] parametric space,
	 *	of trim curve vertices from the parametric definition of the trimming curve.
	 *	\param in_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the trimming curve.
	 *	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		SetMaximumTrimDeviation(float in_deviation);


	/*! Unsets the NURBS surface tessellation budget. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetBudget();

	/*! Removes the upper bound of the difference between the NURBS surface and its parametric definition. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetMaximumDeviation();

	/*! Removes the largest angle allowed between the surface tangents. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetMaximumAngle();

	/*! Removes the setting for the largest allowable length of any facet's edge. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetMaximumWidth();

	/*! Removes the upper bound of vertices to be used in trim curve tessellation. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetTrimBudget();

	/*! Removes the upper bound of trim curve vertices from the parametric definition of the trimming curve. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetMaximumTrimDeviation();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by CurveAttributeKit::GetDefault().
	*	\return A reference to this object. */
	NURBSSurfaceAttributeControl &		UnsetEverything();


	/*! Shows the NURBS surface tessellation budget.
	 *	\param out_budget The maximum number of vertices to be used in NURBS surface tessellation.
	 *	\return <span class='code'>true</span> if the budget is valid, <span class='code'>false</span> otherwise. */
	bool								ShowBudget(size_t & out_budget) const;

	/*! Shows the upper bound of the difference between the NURBS surface and its parametric definition.
	 *	\param out_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the surface.
	 *	\return <span class='code'>true</span> if the maximum deviation is valid, <span class='code'>false</span> otherwise. */
	bool								ShowMaximumDeviation(float & out_deviation) const;

	/*! Shows the largest angle allowed between the surface tangents.
	 *	\param out_degrees The maximum angle allowed between the surface tangents, in degrees.
	 *	\return <span class='code'>true</span> if the maximum angle is valid, <span class='code'>false</span> otherwise. */
	bool								ShowMaximumAngle(float & out_degrees) const;

	/*! Shows the setting for the largest allowable length of any facet's edge.
	 *	\param out_width The largest allowable length of any facet's edge..
	 *	\return <span class='code'>true</span> if the maximum width is valid, <span class='code'>false</span> otherwise. */
	bool								ShowMaximumWidth(float & out_width) const;

	/*! Shows the upper bound of vertices to be used in trim curve tessellation.
	 *	\param out_budget The maximum number of vertices to be used in trim curve tessellation.
	 *	\return <span class='code'>true</span> if the budget is valid, <span class='code'>false</span> otherwise. */
	bool								ShowTrimBudget(size_t & out_budget) const;

	/*! Shows the upper bound of trim curve vertices from the parametric definition of the trimming curve.
	 *	\param out_deviation The maximum distance, in object space, of the tessellation to the parametric definition of the trimming curve.
	 *	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool								ShowMaximumTrimDeviation(float & out_deviation) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	NURBSSurfaceAttributeControl();
};



/*! The HPS::PerformanceKit class is a user space object, useful for carrying a group of attribute settings related to performance settings. Calling HPS::PerformanceKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#performance">this table</a>. */
class HPS_API PerformanceKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	PerformanceKit();

	/*! The copy constructor creates a new PerformanceKit object that contains the same settings as the source object.
	* 	\param in_kit The source object to copy. */
	PerformanceKit(PerformanceKit const & in_kit);

	/*! The move constructor creates a PerformanceKit by transferring the underlying impl of the rvalue reference to this PerformanceKit
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to a PerformanceKit to take the impl from.*/
	PerformanceKit(PerformanceKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PerformanceKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a PerformanceKit to take the impl from.
	* \return A reference to this PerformanceKit. */
	PerformanceKit & operator=(PerformanceKit && in_that);

	/*! Destroy this kit. */
	virtual ~PerformanceKit();

	static const HPS::Type staticType = HPS::Type::PerformanceKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a PerformanceKit which contains the default settings.  The returned object will not necessarily have values
	* 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	* 	\return A PerformanceKit with the default settings. */
	static PerformanceKit		GetDefault();

	/*! Copies the source PerformanceKit into this object.
	* 	\param in_kit The source object to copy. */
	void						Set(PerformanceKit const & in_kit);

	/*! Copies this object into the given PerformanceKit.
	* 	\param out_kit The PerformanceKit to populate with the contents of this object. */
	void						Show(PerformanceKit & out_kit) const;

	/*! Copies the source PerformanceKit into this object.
	* 	\param in_kit The source PerformanceKit to copy.
	* 	\return A reference to this object. */
	PerformanceKit &			operator=(PerformanceKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source PerformanceKit is equivalent to this object.
	*	\param in_kit The source PerformanceKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(PerformanceKit const & in_kit) const;

	/*!	Check if the source PerformanceKit is equivalent to this object.
	 *	\param in_kit The source PerformanceKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(PerformanceKit const & in_kit) const;

	/*!	Check if the source PerformanceKit is not equivalent to this object.
	 *	\param in_kit The source PerformanceKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(PerformanceKit const & in_kit) const;


	/*! Sets the display list state.  Display lists enables the drivers to cache data in video card memory for improved rendering performance.
	*	\param in_display_list The type of display lists, if any, that should be used.
	*	\return A reference to this object. */
	PerformanceKit &			SetDisplayLists(Performance::DisplayLists in_display_list = Performance::DisplayLists::Segment);

	/*! Sets the static tree state.  This will create a compiled draw tree for the scene which should result in better rendering performance.
	*	It is important to note that the compiled tree will need to be regenerated if a change occurs within the segment tree.
	*	\param in_model_type The type of static tree, if any, that should be used.
	*	\return A reference to this object. */
	PerformanceKit &			SetStaticModel(Performance::StaticModel in_model_type);

	/*! Sets the static conditions handling mode
	*	\param in_conditions The type of handling that should be used.
	*	\return A reference to this object. */
	PerformanceKit &			SetStaticConditions(Performance::StaticConditions in_conditions);


	/*! Removes the display list setting.
	*	\return A reference to this object. */
	PerformanceKit &			UnsetDisplayLists();

	/*! Removes the static model state, releasing the compiled draw tree.
	*	\return A reference to this object. */
	PerformanceKit &			UnsetStaticModel();

	/*! Removes the static condition handling state
	*	\return A reference to this object. */
	PerformanceKit &			UnsetStaticConditions();

	/*! Removes all settings from this object.
	 *	\return A reference to this object. */
	PerformanceKit &			UnsetEverything();

	/*! Shows the display list state.
	*	\param out_display_list The type of display lists, if any.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDisplayLists(Performance::DisplayLists & out_display_list) const;

	/*! Shows the static model state.
	*	\param out_model_type The type of static tree, if any
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowStaticModel(Performance::StaticModel & out_model_type) const;

	/*! Shows the static conditions handling state.
	*	\param out_conditions The type of static condition handline
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowStaticConditions(Performance::StaticConditions & out_conditions) const;
};


/*!
<p>The HPS::PerformanceControl class is a smart pointer that is tied to a database object. This object is used to enable and disable performance-related attributes, such as display lists and static model. </p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#performance">This table</a> lists default values for the various segment attributes accessible from HPS::PerformanceControl.</p>
*/
class HPS_API PerformanceControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit PerformanceControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	PerformanceControl(PerformanceControl const & in_that);

	/*! The move constructor creates a PerformanceControl by transferring the underlying impl of the rvalue reference to this PerformanceControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PerformanceControl to take the impl from.*/
	PerformanceControl(PerformanceControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PerformanceControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a PerformanceControl to take the impl from.
	* \return A reference to this PerformanceControl. */
	PerformanceControl & operator=(PerformanceControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~PerformanceControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::PerformanceControl;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the PerformanceControl source.
	 *	\param in_that The PerformanceControl source of the assignment.
	 *	\return A reference to this PerformanceControl. */
	PerformanceControl &		operator=(PerformanceControl const & in_that);

	/*! Sets the display list state.  Display lists enables the drivers to cache data in video card memory for improved rendering performance.
	*	\param in_display_list The type of display lists, if any, that should be used.
	*	\return A reference to this object. */
	PerformanceControl &		SetDisplayLists(Performance::DisplayLists in_display_list = Performance::DisplayLists::Segment);

	/*! Sets the static tree state.  This will create a compiled draw tree for the scene which should result in better rendering performance.
	*	It is important to note that the compiled tree will need to be regenerated if a change occurs within the segment tree.
	*	\param in_model_type The type of static tree, if any, that should be used.
	*	\return A reference to this object. */
	PerformanceControl &		SetStaticModel(Performance::StaticModel in_model_type);

	/*! Sets the mode for processing conditional expressions inn a static tree.
	*	\param in_conditions The type of conditional processing that should be used.
	*	\return A reference to this object. */
	PerformanceControl &		SetStaticConditions(Performance::StaticConditions in_conditions);


	/*! Removes the display list setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PerformanceKit::GetDefault().
	*	\return A reference to this object. */
	PerformanceControl &		UnsetDisplayLists();

	/*! Removes the static model state, releasing the compiled draw tree. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PerformanceKit::GetDefault().
	*	\return A reference to this object. */
	PerformanceControl &		UnsetStaticModel();

	/*! Removes the static condition state.
	*   setting as specified by PerformanceKit::GetDefault().
	*	\return A reference to this object. */
	PerformanceControl &		UnsetStaticConditions();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by PerformanceKit::GetDefault().
	 *	\return A reference to this object. */
	PerformanceControl &		UnsetEverything();


	/*! Shows the display list state.
	*	\param out_display_list The type of display lists, if any.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDisplayLists(Performance::DisplayLists & out_display_list) const;

	/*! Shows the static model state.
	*	\param out_model_type The type of static tree, if any
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowStaticModel(Performance::StaticModel & out_model_type) const;

	/*! Shows the static conditions state.
	*	\param out_conditions The type of conditional expression processing
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowStaticConditions(Performance::StaticConditions & out_conditions) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	PerformanceControl();
};



/*! The HPS::HiddenLineAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::HiddenLineAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#hidden-lines">this table</a>. */
class HPS_API HiddenLineAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	HiddenLineAttributeKit();

	/*! The copy constructor creates a new HiddenLineAttributeKit object that contains the same settings as the source object.
	* 	\param in_kit The source object to copy. */
	HiddenLineAttributeKit(HiddenLineAttributeKit const & in_kit);

	/*! The move constructor creates a HiddenLineAttributeKit by transferring the underlying impl of the rvalue reference to this HiddenLineAttributeKit
	*	thereby avoiding a copy and allocation.
	*	\param in_that An rvalue reference to a HiddenLineAttributeKit to take the impl from.*/
	HiddenLineAttributeKit(HiddenLineAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HiddenLineAttributeKit thereby avoiding a copy.
	*	\param in_that An rvalue reference to a HiddenLineAttributeKit to take the impl from.
	*	\return A reference to this HiddenLineAttributeKit. */
	HiddenLineAttributeKit & operator=(HiddenLineAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~HiddenLineAttributeKit();

	static const HPS::Type staticType = HPS::Type::HiddenLineAttributeKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a HiddenLineAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A HiddenLineAttributeKit with the default settings. */
	static HiddenLineAttributeKit GetDefault();

	/*! Copies the source HiddenLineAttributeKit into this object.
	*	\param in_kit The source object to copy. */
	void						Set(HiddenLineAttributeKit const & in_kit);

	/*! Copies this object into the given HiddenLineAttributeKit.
	*	\param out_kit The HiddenLineAttributeKit to populate with the contents of this object. */
	void						Show(HiddenLineAttributeKit & out_kit) const;

	/*! Copies the source HiddenLineAttributeKit into this object.
	*	\param in_kit The source HiddenLineAttributeKit to copy.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	operator=(HiddenLineAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source HiddenLineAttributeKit is equivalent to this object.
	*	\param in_kit The source HiddenLineAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(HiddenLineAttributeKit const & in_kit) const;

	/*!	Check if the source HiddenLineAttributeKit is equivalent to this object.
	*	\param in_kit The source HiddenLineAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(HiddenLineAttributeKit const & in_kit) const;

	/*!	Check if the source HiddenLineAttributeKit is not equivalent to this object.
	*	\param in_kit The source HiddenLineAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(HiddenLineAttributeKit const & in_kit) const;


	/*! Specifies the sorting algorithm that should be used to sort faces that have been made visible by the SetRenderFaces method.
	*   Default is ZBuffer.
	*	\param in_algorithm The algorithm used to sort visible faces.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetAlgorithm(HiddenLine::Algorithm in_algorithm);

	/*! Sets the color to be applied to the hidden lines and markers.
	*	\param in_color The color hidden line geometry should be drawn in.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetColor(RGBAColor const & in_color);

	/*! Specifies the fraction of the current line color's R, G, and B channels to use for the color
	*	of hidden lines and markers. By default, Visualize will automatically take a fraction of the RGB
	*	values to darken the hidden lines and markers.
	*	\param in_zero_to_one A multiplier, between [0,1], applied to each channel of the hidden line color.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetDimFactor(float in_zero_to_one);

	/*! Specifies how many units to push faces away from the camera. This can help improve hidden line scene
	*	quality if distinct polylines/lines are being used to denote user-defined edges on shell/mesh
	*	regions, but are not exactly coincident with the actual shell/mesh edges. Note:
	*	hidden line face displacement is separate from the general face displacement value set with the
	*	DrawingAttributeKit::SetFaceDisplacement.
	*	\param in_buckets The number of units to move faces in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move faces toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object.
	*	\sa DrawingAttributeKit::SetFaceDisplacement() */
	HiddenLineAttributeKit &	SetFaceDisplacement(float in_buckets);

	/*! Specifies the pattern of the hidden lines.
	*	\param in_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetLinePattern(char const * in_pattern);

	/*! Species whether hidden lines are sorted, and if so, what the threshold for sorting is.
	*	If Hidden %Line Sorting is activated, lines will be drawn in proper z-order. If this option
	*	is not activated, the order in which lines are drawn is non-deterministic.
	*	Enabling this option will result in slower performance. Due to the poor performance, this option
	*   is not recommended for screen drawing. However, it may be useful for hardcopy export. Use the functions
	*   <span class="code">\ref HPS::Hardcopy::GDI::ExportOptionsKit::SetHiddenLineSorting()</span>
    *   or <span class="code">\ref HPS::Hardcopy::File::ExportOptionsKit::SetHiddenLineSorting()</span> to
	*   enable this option for hardcopy export.
	*	\param in_state Should hidden lines be sorted.
	*	\param in_threshold What is the minimum size of hidden lines that are sorted. Lines thinner
	*	than this will not be sorted.
	*	\param in_units What units in_threshold is specified in.
	*	\return A reference to this object.*/
	HiddenLineAttributeKit & SetLineSorting(bool in_state, float in_threshold=2.0f, Line::SizeUnits in_units=HPS::Line::SizeUnits::Pixels);

	/*! Specifies whether triangles will be displayed during a hidden-line rendering.
	*	\param in_state Whether triangles will displayed during a hidden-line rendering.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetRenderFaces(bool in_state);

	/*! Specifies whether text will be displayed during a hidden-line rendering.
	*	\param in_state Whether text will displayed during a hidden-line rendering.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetRenderText(bool in_state);

	/*! Silhouette edges can show unpleasant "fishtail" patterns at points on smooth surfaces where curvature in one
	*	orientation is very different from the curvature in another (e.g. the inside of a torus).
	*	Silhouette cleanup causes a post-process to remove most of these patterns.
	*	\param in_state Whether hidden line rendering should be post-processed to remove visual artifacts.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetSilhouetteCleanup(bool in_state);

	/*! Specifies the threshold for when transparent objects are considered opaque.
	*	Objects with transparency greater than the cutoff will be considered opaque while objects with transparency
	*	less than the cutoff will treated as transparent.
	*	\param in_zero_to_one The cutoff value, between [0,1].
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetTransparencyCutoff(float in_zero_to_one);

	/*! Specifies whether hidden lines and markers should be displayed.
	*	\param in_state The algorithm to be used during hidden line rendering.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetVisibility(bool in_state);

	/*! Sets the weight of lines drawn in hidden line rendering.
	*	\param in_weight The weight value for hidden lines.
	*	\param in_units The units applied to in_weight.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	SetWeight(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);

	/*! Removes the hidden line algorithm setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetAlgorithm();

	/*! Removes the hidden line color setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetColor();

	/*! Removes the dim factor setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetDimFactor();

	/*! Removes the face displacement setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetFaceDisplacement();

	/*! Removes the line pattern setting for hidden lines.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetLinePattern();

	/*! Removes the line sorting setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetLineSorting();

	/*! Removes the face rendering setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetRenderFaces();

	/*! Removes the text rendering setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetRenderText();

	/*! Removes the silhouette cleanup setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetSilhouetteCleanup();

	/*! Removes the transparency cutoff setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetTransparencyCutoff();

	/*! Removes the hidden line visibility setting.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetVisibility();

	/*! Removes the weight setting for hidden line.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetWeight();

	/*! Removes all settings from this object.
	*	\return A reference to this object. */
	HiddenLineAttributeKit &	UnsetEverything();


	/*! Shows  the sorting algorithm that will be used to sort faces that have been made visible by the SetRenderFaces method.
	*	\param out_algorithm The algorithm used to sort visible faces.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAlgorithm(HiddenLine::Algorithm & out_algorithm) const;

	/*! Shows the color applied to hidden lines and markers.
	*	\param out_color The color of hidden line geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowColor(RGBAColor & out_color) const;

	/*! Shows the dim factor multiplier applied to each channel of the hidden line color.
	*	\param out_zero_to_one A multiplier, between [0,1], applied to each channel of the hidden line color.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDimFactor(float & out_zero_to_one) const;

	/*! Shows the number of units to push faces away from the camera.
	*	\param out_buckets The number of "z buckets" to push faces away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaceDisplacement(float & out_buckets) const;

	/*! Shows the pattern of the hidden lines.
	*	\param out_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLinePattern(UTF8 & out_pattern) const;

	/*!	Shows the hidden line sorting options.
	*	\param out_state Whether hidden line sorting is on or off.
	*	\param out_threshold The minimum width at which hidden lines are sorted.
	*	\param out_units The units that out_threshold is measured in.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLineSorting(bool & out_state, float & out_threshold, Line::SizeUnits & out_units) const;

	/*! Shows whether triangles will be displayed during a hidden-line rendering.
	*	\param out_state Whether triangles will displayed during a hidden-line rendering.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowRenderFaces(bool & out_state) const;

	/*! Shows whether text will be displayed during a hidden-line rendering.
	*	\param out_state Whether text will displayed during a hidden-line rendering.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowRenderText(bool & out_state) const;

	/*! Shows whether hidden line rendering should be post-processed to remove visual artifacts of silhouette edges.
	*	\param out_state Whether hidden line rendering should be post-processed to remove visual artifacts.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSilhouetteCleanup(bool & out_state) const;

	/*! Shows the threshold for when transparent objects are considered opaque.
	*	\param out_zero_to_one The cutoff value, between [0,1].
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTransparencyCutoff(float & out_zero_to_one) const;

	/*! Shows whether hidden lines and markers should be displayed.
	*	\param out_state Whether hidden lines and markers should be displayed.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVisibility(bool & out_state) const;

	/*! Shows the weight of lines drawn in hidden line rendering.
	*	\param out_weight The weight value for hidden lines.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWeight(float & out_weight, Line::SizeUnits & out_units) const;
};


/*!
<p>The HPS::HiddenLineAttributeControl class is a smart pointer that is tied to a database object. This control allows you to manipulate the various attributes associated with hidden lines. Hidden line is a rendering mode that applies to the scene as a whole. You should not set disparate hidden line attributes in your scene. </p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#hidden-lines">This table</a> lists default values for the various segment attributes accessible from HPS::HiddenLineAttributeControl.</p>
*/
class HPS_API HiddenLineAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit HiddenLineAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	HiddenLineAttributeControl(HiddenLineAttributeControl const & in_that);

	/*! The move constructor creates a HiddenLineAttributeKit by transferring the underlying impl of the rvalue reference to this HiddenLineAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a HiddenLineAttributeKit to take the impl from.*/
	HiddenLineAttributeControl(HiddenLineAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HiddenLineAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a HiddenLineAttributeKit to take the impl from.
	* \return A reference to this HiddenLineAttributeKit. */
	HiddenLineAttributeControl & operator=(HiddenLineAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~HiddenLineAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::HiddenLineAttributeControl;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the HiddenLineAttributeControl source.
	 *	\param in_that The HiddenLineAttributeControl source of the assignment.
	 *	\return A reference to this HiddenLineAttributeControl. */
	HiddenLineAttributeControl &	operator=(HiddenLineAttributeControl const & in_that);

	/*! Specifies the sorting algorithm that should be used to sort faces that have been made visible by the SetRenderFaces method.
	*   Default is ZBuffer.
	*	\param in_algorithm The algorithm used to sort visible faces.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetAlgorithm(HiddenLine::Algorithm in_algorithm);

	/*! Sets the color to be applied to the hidden lines and markers.
	*	\param in_color The color hidden line geometry should be drawn in.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetColor(RGBAColor const & in_color);

	/*! Specifies the fraction of the current line color's R, G, and B channels to use for the color
	*	of hidden lines and markers. By default, Visualize will automatically take a fraction of the RGB
	*	values to darken the hidden lines and markers.
	*	\param in_zero_to_one A multiplier, between [0,1], applied to each channel of the hidden line color.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetDimFactor(float in_zero_to_one);

	/*! Specifies how many units to push faces away from the camera. This can help improve hidden line scene
	*	quality if distinct polylines/lines are being used to denote user-defined edges on shell/mesh
	*	regions, but are not exactly coincident with the actual shell/mesh edges. Note:
	*	hidden line face displacement is separate from the general face displacement value set with the
	*	DrawingAttributeKit::SetFaceDisplacement.
	*	\param in_buckets The number of units to move faces in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move faces toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object.
	*	\sa DrawingAttributeKit::SetFaceDisplacement() */
	HiddenLineAttributeControl &	SetFaceDisplacement(float in_buckets);

	/*! Specifies the pattern of the hidden lines.
	*	\param in_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetLinePattern(char const * in_pattern);

	/*! Species whether hidden lines are sorted, and if so, what the threshold for sorting is.
	*	If Hidden %Line Sorting is activated, lines will be draw in proper z-order.If this option
	*	is not activated, the order in which lines are drawn is non-deterministic.
	*	Enabling this option will result in slower performance. Due to the poor performance, this option
	*   is not recommended for screen drawing. However, it may be useful for hardcopy export. Use the functions
	*   <span class="code">\ref HPS::Hardcopy::GDI::ExportOptionsKit::SetHiddenLineSorting()</span>
    *   or <span class="code">\ref HPS::Hardcopy::File::ExportOptionsKit::SetHiddenLineSorting()</span> to
	*   enable this option for hardcopy export.
	*	\param in_on Whether to sort or not.
	*	\param in_activation_weight Lines thicker than this will be sorted. Thinner ones will be ignored.
	*	\param in_units Units applied to in_activation_weight.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetLineSorting(bool in_on, float in_activation_weight = 2, Line::SizeUnits in_units = Line::SizeUnits::Pixels);

	/*! Specifies whether triangles will be displayed during a hidden-line rendering.
	*	\param in_state Whether triangles will displayed during a hidden-line rendering.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetRenderFaces(bool in_state);

	/*! Specifies whether text will be displayed during a hidden-line rendering.
	*	\param in_state Whether text will displayed during a hidden-line rendering.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetRenderText(bool in_state);

	/*! Silhouette edges can show unpleasant "fishtail" patterns at points on smooth surfaces where curvature in one
	*	orientation is very different from the curvature in another (e.g. the inside of a torus).
	*	Silhouette cleanup causes a post-process to remove most of these patterns.
	*	\param in_state Whether hidden line rendering should be post-processed to remove visual artifacts.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetSilhouetteCleanup(bool in_state);

	/*! Specifies the threshold for when transparent objects are considered opaque.
	*	Objects with transparency greater than the cutoff will be considered opaque while objects with transparency
	*	less than the cutoff will treated as transparent.
	*	\param in_zero_to_one The cutoff value, between [0,1].
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetTransparencyCutoff(float in_zero_to_one);

	/*! Specifies whether hidden lines and markers should be displayed.
	*	\param in_state The algorithm to be used during hidden line rendering.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetVisibility(bool in_state);

	/*! Sets the weight of lines drawn in hidden line rendering.
	*	\param in_weight The weight value for hidden lines.
	*	\param in_units The units applied to in_weight.
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	SetWeight(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);

	/*! Removes the hidden line algorithm setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetAlgorithm();

	/*! Removes the hidden line color setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetColor();

	/*! Removes the dim factor setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetDimFactor();

	/*! Removes the face displacement setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetFaceDisplacement();

	/*! Removes the line pattern setting for hidden lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetLinePattern();

	/*! Removes the line sorting settings for hidden lines. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetLineSorting();

	/*! Removes the face rendering setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetRenderFaces();

	/*! Removes the text rendering setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetRenderText();

	/*! Removes the silhouette cleanup setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetSilhouetteCleanup();

	/*! Removes the transparency cutoff setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetTransparencyCutoff();

	/*! Removes the hidden line visibility setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetVisibility();

	/*! Removes the weight setting for hidden line. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetWeight();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by HiddenLineAttributeKit::GetDefault().
	*	\return A reference to this object. */
	HiddenLineAttributeControl &	UnsetEverything();


	/*! Shows the algorithm to be used during hidden line rendering.
	*	\param out_algorithm The algorithm used for hidden line rendering.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowAlgorithm(HiddenLine::Algorithm & out_algorithm) const;

	/*! Shows the color applied to hidden lines and markers.
	*	\param out_color The color of hidden line geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowColor(RGBAColor & out_color) const;

	/*! Shows the dim factor multiplier applied to each channel of the hidden line color.
	*	\param out_zero_to_one A multiplier, between [0,1], applied to each channel of the hidden line color.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowDimFactor(float & out_zero_to_one) const;

	/*! Shows the number of units to push faces away from the camera.
	*	\param out_buckets The number of "z buckets" to push faces away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowFaceDisplacement(float & out_buckets) const;

	/*! Shows the pattern of the hidden lines.
	*	\param out_pattern The name of a line pattern, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowLinePattern(UTF8 & out_pattern) const;

	/*!	Shows the hidden line sorting options.
	*	\param out_state Whether hidden line sorting is on or off.
	*	\param out_threshold The minimum width at which hidden lines are sorted.
	*	\param out_units The units that out_threshold is measured in.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowLineSorting(bool & out_state, float & out_threshold, Line::SizeUnits & out_units) const;

	/*! Shows whether triangles will be displayed during a hidden-line rendering.
	*	\param out_state Whether triangles will displayed during a hidden-line rendering.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowRenderFaces(bool & out_state) const;

	/*! Shows whether text will be displayed during a hidden-line rendering.
	*	\param out_state Whether text will displayed during a hidden-line rendering.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowRenderText(bool & out_state) const;

	/*! Shows whether hidden line rendering should be post-processed to remove visual artifacts of silhouette edges.
	*	\param out_state Whether hidden line rendering should be post-processed to remove visual artifacts.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowSilhouetteCleanup(bool & out_state) const;

	/*! Shows the threshold for when transparent objects are considered opaque.
	*	\param out_zero_to_one The cutoff value, between [0,1].
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowTransparencyCutoff(float & out_zero_to_one) const;

	/*! Shows whether hidden lines and markers should be displayed.
	*	\param out_state Whether hidden lines and markers should be displayed.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowVisibility(bool & out_state) const;

	/*! Shows the weight of lines drawn in hidden line rendering.
	*	\param out_weight The weight value for hidden lines.
	*	\param out_units The units applied to in_weight.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowWeight(float & out_weight, Line::SizeUnits & out_units) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	HiddenLineAttributeControl();
};



/*! The HPS::DrawingAttributeKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::DrawingAttributeKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#drawing">this table</a>. */
class HPS_API DrawingAttributeKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	DrawingAttributeKit();

	/*! The copy constructor creates a new DrawingAttributeKit object that contains the same settings as the source object.
	* 	\param in_kit The source object to copy. */
	DrawingAttributeKit(DrawingAttributeKit const & in_kit);

	/*! The move constructor creates a DrawingAttributeKit by transferring the underlying impl of the rvalue reference to this DrawingAttributeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DrawingAttributeKit to take the impl from.*/
	DrawingAttributeKit(DrawingAttributeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DrawingAttributeKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a DrawingAttributeKit to take the impl from.
	* \return A reference to this DrawingAttributeKit. */
	DrawingAttributeKit & operator=(DrawingAttributeKit && in_that);

	/*! Destroy this kit. */
	virtual ~DrawingAttributeKit();

	static const HPS::Type staticType = HPS::Type::DrawingAttributeKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a DrawingAttributeKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A DrawingAttributeKit with the default settings. */
	static DrawingAttributeKit	GetDefault();

	/*! Copies the source DrawingAttributeKit into this object.
	*	\param in_kit The source object to copy. */
	void						Set(DrawingAttributeKit const & in_kit);

	/*! Copies this object into the given DrawingAttributeKit.
	*	\param out_kit The DrawingAttributeKit to populate with the contents of this object. */
	void						Show(DrawingAttributeKit & out_kit) const;

	/*! Copies the source DrawingAttributeKit into this object.
	*	\param in_kit The source DrawingAttributeKit to copy.
	*	\return A reference to this object. */
	DrawingAttributeKit &		operator=(DrawingAttributeKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source DrawingAttributeKit is equivalent to this object.
	*	\param in_kit The source DrawingAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(DrawingAttributeKit const & in_kit) const;

	/*!	Check if the source DrawingAttributeKit is equivalent to this object.
	*	\param in_kit The source DrawingAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(DrawingAttributeKit const & in_kit) const;

	/*!	Check if the source DrawingAttributeKit is not equivalent to this object.
	*	\param in_kit The source DrawingAttributeKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(DrawingAttributeKit const & in_kit) const;

	/*!	In order to perform back face culling, there must be some
	*	definition of a polygon's "front" and "back" faces.
	*	This orientation is determined by the order in which the polygon's
	*   vertices were originally defined and the polygon handedness setting
	*   (not the world handedness).
	*
	*	If you wrap the fingers of the chosen hand along the vertices of
	*   the polygon, with your wrist at the first vertex and your
	*   fingertips at the last, then extend your thumb perpendicular to
	*	your fingers, your thumb is extending out of the front face of the
	*	polygon.
	*	\param in_handedness The handedness to be used for geometry.
	*	\return A reference to this object.
	*	\sa SetWorldHandedness()
	*	\sa CullingKit::SetBackFace() */
	DrawingAttributeKit &		SetPolygonHandedness(Drawing::Handedness in_handedness);

	/*!	The world handedness determines the orientation of the Z-axis in the Cartesian coordinate system.
	*	If you curl the fingers of your appropriate hand from the X-axis towards the Y-axis, your thumb will point in the direction of the Z-axis.
	*	\param in_handedness The handedness of the underlying coordinate system.
	*	\return A reference to this object.
	*	\sa SetPolygonHandedness() */
	DrawingAttributeKit &		SetWorldHandedness(Drawing::Handedness in_handedness);

	/*!	Compresses effective Z values into a subset of what they would otherwise have been.
	*	This allows certain pieces of the scene to be drawn on top at all times without additional sub-windows.
    *   Values of (0,0) will force all geometry into the frontmost bucket, but will have the drawback that it will cause z-fighting amongst the geometry that shares
    *   that setting. To get such pieces of geometry to resolve reasonably well against each other, a range of (0,0.1) should perform reasonably well.
	*
    *   Depth range settings are not cumulative, and have no effect when the rendering algorithm is Priority, or is not set.
	*
    *   The default is (0,1)
	*
	*	\param in_near The portion of the depth range closest to the camera.  Valid range is [0,1] with in_near &lt;= in_far.
	*	\param in_far The portion of the depth range furthest to the camera.  Valid range is [0,1] with in_near &lt;= in_far.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetDepthRange(float in_near, float in_far);

	/*!	Specifies a number of Z-buffer units that rendered faces should be pushed away from the camera.
	*	This can be used to reduce edge stitching by ensuring that coincident edges lay on top of the faces.
	*	Negative face displacements will push faces toward the camera.
	*	\param in_state Whether face displacement should be used.
	*	\param in_buckets The number of units to move faces in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move faces toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetFaceDisplacement(bool in_state, int in_buckets=0);

	/*!	Specifies a number of Z-buffer units that rendered faces should be pushed away from the camera.
	*	\param in_buckets The number of units to move faces in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move faces toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object.
	*	\sa SetFaceDisplacement(bool in_state, int in_buckets) */
	DrawingAttributeKit &		SetFaceDisplacement(int in_buckets);

	/*!	Specifies a number of Z-buffer units that all geometry should be pushed away from the camera.
	*	This can be used to ensure that certain geometry is drawn on top of or behind the rest of the scene.
	*	Negative general displacements will push geometry toward the camera.
	*	\param in_state Whether general displacement should be used.
	*	\param in_buckets The number of units to move rendered geometry in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move geometry toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetGeneralDisplacement(bool in_state, int in_buckets=0);

	/*!	Specifies a number of Z-buffer units that all geometry should be pushed away from the camera.
	*	\param in_buckets The number of units to move rendered geometry in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move geometry toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object.
	*	\sa SetGeneralDisplacement(bool in_state, int in_buckets) */
	DrawingAttributeKit &		SetGeneralDisplacement(int in_buckets);

	/*!	Specifies a number of Z-buffer units that vertices should be pushed away from the camera.
	*	This can be used to ensure that vertices are drawn on top of or behind other geometry.
	*	Negative general displacements will push vertices toward the camera.
	*	\param in_state Whether vertex displacement should be used.
	*	\param in_buckets The number of units to move vertices in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move vertices toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetVertexDisplacement(bool in_state, int in_buckets=0);

	/*!	Specifies a number of Z-buffer units that vertices should be pushed away from the camera.  The state is implicitly on.
	*	\param in_buckets The number of units to move vertices in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move vertices toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetVertexDisplacement(int in_buckets);

	/*! Specifies an amount of vertices to draw 1 draws them all.
	*	\param in_zero_to_one An amount, between [0,1], of vertices to draw.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetVertexDecimation(float in_zero_to_one);

	/*! Specifies vertices should be drawn in a random order.
	*	\param in_state If true the vertices for a point cloud will be randomized.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetVertexRandomization(bool in_state);

	/*! Specifies internal color of line styles, glyphs and similar items should be overridden.
	*	\param in_kit Which types should internal colors should be overridden.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetOverrideInternalColor(VisibilityKit const & in_kit);

	/*!	Allows moving, editing, or deleting to take place in a segment without triggering a full-screen redraw.
	*	\param in_overlay The type of overlay, if any, to be used.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetOverlay(Drawing::Overlay in_overlay);

	/*!	Specifies a drawing order for a segment during timed updates.  Segments with a lower deferral value will be drawn before segments with a higher value.
	*	This attribute does not inherit like most attributes and segments have a default value of 0.
	*	\param in_deferral A drawing priority, with larger values drawing later than usual.  Should be non-negative.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetDeferral(int in_deferral);

	/*!	Sets a polygonal clip region.
	*	\param in_points An array of points describing the clip region.
	*	\param in_space The coordinate space in which in_points are specified.
	*	\param in_operation The operation performed by the clip region.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetClipRegion(PointArray const & in_points, Drawing::ClipSpace in_space = Drawing::ClipSpace::World, Drawing::ClipOperation in_operation = Drawing::ClipOperation::Keep);

	/*!	Sets a polygonal clip region.
	*	\param in_point_count The number of points in in_points.
	*	\param in_points An array of points describing the clip region.
	*	\param in_space The coordinate space in which in_points are specified.
	*	\param in_operation The operation performed by the clip region.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetClipRegion(size_t in_point_count, Point const in_points [], Drawing::ClipSpace in_space = Drawing::ClipSpace::World, Drawing::ClipOperation in_operation = Drawing::ClipOperation::Keep);

	/*!	Sets a complex polygonal clip region defined by the XOR of a series of loops.
	*	\param in_loops An array of loops describing clip regions.
	*	\param in_space The coordinate space in which in_loops are specified.
	*	\param in_operation The operation performed by the clip region.
	*	\return A reference to this object. */
	DrawingAttributeKit &		SetClipRegion(PointArrayArray const & in_loops, Drawing::ClipSpace in_space = Drawing::ClipSpace::World, Drawing::ClipOperation in_operation = Drawing::ClipOperation::Keep);

	/*!	Removes a polygon handedness setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetPolygonHandedness();

	/*!	Removes a world handedness setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetWorldHandedness();

	/*!	Removes a depth range setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetDepthRange();

	/*!	Removes a face displacement setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetFaceDisplacement();

	/*!	Removes a general displacement setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetGeneralDisplacement();

	/*!	Removes a vertex displacement setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetVertexDisplacement();

	/*!	Removes a vertex decimation setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetVertexDecimation();

	/*!	Removes a vertex randomization setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetVertexRandomization();

	/*!	Removes a override internal color setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetOverrideInternalColor();

	/*!	Removes an overlay setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetOverlay();

	/*!	Removes a deferral setting.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetDeferral();

	/*!	Removes a clip region.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetClipRegion();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	DrawingAttributeKit &		UnsetEverything();

	/*! Shows the polygon handedness.
	*	\param out_handedness The handedness used for geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPolygonHandedness(Drawing::Handedness & out_handedness) const;

	/*! Shows the world handedness.
	*	\param out_handedness The handedness of the underlying coordinate system.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWorldHandedness(Drawing::Handedness & out_handedness) const;

	/*! Shows the depth range setting.
	*	\param out_near The portion of the depth range closest to the camera.  Valid range is [0,1] with out_near &lt;= out_far.
	*	\param out_far The portion of the depth range furthest to the camera.  Valid range is [0,1] with out_near &lt;= out_far.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDepthRange(float & out_near, float & out_far) const;

	/*! Shows the face displacement setting.
	*	\param out_state Whether face displacement will be used.
	*	\param out_buckets The distance to move rendered faces away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaceDisplacement(bool & out_state, int & out_buckets) const;

	/*! Shows the general displacement setting.
	*	\param out_state Whether general displacement will be used.
	*	\param out_buckets The distance to move rendered geometry away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowGeneralDisplacement(bool & out_state, int & out_buckets) const;

	/*! Shows the vertex displacement setting.
	*	\param out_state Whether vertex displacement will be used.
	*	\param out_buckets The distance to move vertices away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexDisplacement(bool & out_state, int & out_buckets) const;

	/*! Shows the vertex decimation setting.
	*	\param out_zero_to_one The value set for vertex decimation.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexDecimation(float & out_zero_to_one) const;

	/*! Shows the vertex randomization setting.
	*	\param out_state Whether vertex randomization will be used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexRandomization(bool & out_state) const;

	/*! Shows the override internal color settings.
	*	\param out_kit Which override internal color types will be used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOverrideInternalColor(VisibilityKit & out_kit) const;

	/*! Shows the overlay setting.
	*	\param out_overlay The type of overlay, if any, used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOverlay(Drawing::Overlay & out_overlay) const;

	/*! Shows the deferral setting.
	*	\param out_defer_batch A drawing priority, with negative values drawing earlier than usual and positive values drawing later than usual.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDeferral(int & out_defer_batch) const;

	/*! Shows the clip region settings.
	*	\param out_loops An array of loops describing the clip region.
	*	\param out_space The coordinate space in which out_loops are described.
	*	\param out_operation The operation performed by the clip region
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowClipRegion(PointArrayArray & out_loops, Drawing::ClipSpace & out_space, Drawing::ClipOperation & out_operation) const;

};


/*!
<p>The HPS::DrawingAttributeControl class is a smart pointer that is tied to a database object. This object is used to manipulate various high-level
settings, such as depth range, priority, and displacement. Note that some of the attributes available through this control should only be set for an
entire window, while others can be set at multiple places.
</p>

<p><strong>Global attributes:</strong> <br />
%World handedness, polygon handedness, priority, depth range
</p>

<p><strong>Segment-level attributes:</strong><br />
overlay, deferral, face displacement, general displacement, clip regions
</p>

<p><a href="../../prog_guide/appendix_default_attribute_values.html#drawing">This table</a> lists default values for the various segment attributes accessible from HPS::DrawingAttributeControl.</p>
*/
class HPS_API DrawingAttributeControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit DrawingAttributeControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	DrawingAttributeControl(DrawingAttributeControl const & in_that);

	/*! The move constructor creates a DrawingAttributeControl by transferring the underlying impl of the rvalue reference to this DrawingAttributeControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DrawingAttributeControl to take the impl from.*/
	DrawingAttributeControl(DrawingAttributeControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DrawingAttributeControl thereby avoiding a copy.
	* \param in_that An rvalue reference to an DrawingAttributeControl to take the impl from.
	* \return A reference to this DrawingAttributeControl. */
	DrawingAttributeControl & operator=(DrawingAttributeControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~DrawingAttributeControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::DrawingAttributeControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the DrawingAttributeControl source.
	 *	\param in_that The DrawingAttributeControl source of the assignment.
	 *	\return A reference to this DrawingAttributeControl. */
	DrawingAttributeControl &	operator=(DrawingAttributeControl const & in_that);

	/*!	In order to do a back face culling, there must be some definition of a polygon's "front" and "back".
	*	This orientation is determined by the order in which the polygon's vertices were originally defined
	*	and the polygon handedness setting (not the world handedness).
	*	If you wrap the fingers of the chosen hand along the vertices of the polygon, with your wrist at the first vertex and your fingertips at the last,
	*	then extend your thumb perpendicular to your fingers, your thumb is extending out of the front face of the polygon.
	*	\param in_handedness The handedness to be used for geometry.
	*	\return A reference to this object.
	*	\sa SetWorldHandedness()
	*	\sa CullingKit::SetBackFace() */
	DrawingAttributeControl &	SetPolygonHandedness(Drawing::Handedness in_handedness);

	/*!	The world handedness determines the orientation of the Z-axis in the Cartesian coordinate system.
	*	If you curl the fingers of your appropriate hand from the X-axis towards the Y-axis, your thumb will point in the direction of the Z-axis.
	*	\param in_handedness The handedness of the underlying coordinate system.
	*	\return A reference to this object.
	*	\sa SetPolygonHandedness() */
	DrawingAttributeControl &	SetWorldHandedness(Drawing::Handedness in_handedness);

	/*!	Compresses effective Z values into a subset of what they would otherwise have been.
	*	This allows certain pieces of the scene to be drawn on top at all times without additional sub-windows.
    *   Values of (0,0) will force all geometry into the frontmost bucket, but will have the drawback that it will cause z-fighting amongst the geometry that shares
    *   that setting. To get such pieces of geometry to resolve reasonably well against each other, a range of (0,0.1) should perform reasonably well.
	*
    *   Depth range settings are not cumulative, and have no effect when the rendering algorithm is Priority, or is not set.
	*
    *   The default is (0,1)
	*
	*	\param in_near The portion of the depth range closest to the camera.  Valid range is [0,1] with in_near &lt;= in_far.
	*	\param in_far The portion of the depth range furthest to the camera.  Valid range is [0,1] with in_near &lt;= in_far.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetDepthRange(float in_near, float in_far);

	/*!	Specifies a number of Z-buffer units that rendered faces should be pushed away from the camera.
	*	This can be used to reduce edge stitching by ensuring that coincident edges lay on top of the faces.
	*	Negative face displacements will push faces toward the camera.
	*	\param in_state Whether face displacement should be used.
	*	\param in_buckets The number of units to move faces in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move faces toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetFaceDisplacement(bool in_state, int in_buckets=0);

	/*!	Specifies a number of Z-buffer units that rendered faces should be pushed away from the camera.  The state is implicitly on.
	*	\param in_buckets The number of units to move faces in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move faces toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object.
	*	\sa SetFaceDisplacement(bool in_state, int in_buckets) */
	DrawingAttributeControl &	SetFaceDisplacement(int in_buckets);

	/*!	Specifies a number of Z-buffer units that all geometry should be pushed away from the camera.
	*	This can be used to ensure that certain geometry is drawn on top of or behind the rest of the scene.
	*	Negative general displacements will push geometry toward the camera.
	*	\param in_state Whether general displacement should be used.
	*	\param in_buckets The number of units to move rendered geometry in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move geometry toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetGeneralDisplacement(bool in_state, int in_buckets=0);

	/*!	Specifies a number of Z-buffer units that all geometry should be pushed away from the camera.  The state is implicitly on.
	*	\param in_buckets The number of units to move rendered geometry in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move geometry toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object.
	*	\sa SetGeneralDisplacement(bool in_state, int in_buckets) */
	DrawingAttributeControl &	SetGeneralDisplacement(int in_buckets);

	/*!	Specifies a number of Z-buffer units that vertices should be pushed away from the camera.
	*	This can be used to ensure that vertices are drawn on top of or behind other geometry.
	*	Negative general displacements will push vertices toward the camera.
	*	\param in_state Whether vertex displacement should be used.
	*	\param in_buckets The number of units to move vertices in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move vertices toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetVertexDisplacement(bool in_state, int in_buckets=0);

	/*!	Specifies a number of Z-buffer units that vertices should be pushed away from the camera.  The state is implicitly on.
	*	\param in_buckets The number of units to move vertices in the Z-Buffer. The units are
	*   1/2^24 in the normalized depth range [0,1]. Negative values will move vertices toward the camera,
	*   positive values away from the camera.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetVertexDisplacement(int in_buckets);

	/*! Specifies an amount of vertices to draw 1 draws them all.
	*	\param in_zero_to_one An amount, between [0,1], of vertices to draw.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetVertexDecimation(float in_zero_to_one);

	/*! Specifies vertices should be drawn in a random order.
	*	\param in_state If true the vertices for a point cloud will be randomized.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetVertexRandomization(bool in_state);

	/*! Specifies internal color of line styles, glyphs and similar items should be overridden.
	*	\param in_kit Which types should internal colors should be overridden.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetOverrideInternalColor(VisibilityKit const & in_kit);

	/*!	Allows moving, editing, or deleting to take place in a segment without triggering a full-screen redraw.
	*	\param in_overlay The type of overlay, if any, to be used.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetOverlay(Drawing::Overlay in_overlay);

	/*!	Specifies a clip region.
	*	\param in_points An array of points specifying the shape of the clip region.
	*	\param in_space The space coordinated in which the points are specified.
	*	\param in_operation The operation performed by this clip region.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetClipRegion(PointArray const & in_points, Drawing::ClipSpace in_space = Drawing::ClipSpace::World, Drawing::ClipOperation in_operation = Drawing::ClipOperation::Keep);

	/*!	Specifies a clip region.
	*	\param in_point_count The number of elements in in_points
	*	\param in_points An array of points specifying the shape of the clip region.
	*	\param in_space The space coordinated in which the points are specified.
	*	\param in_operation The operation performed by this clip region.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetClipRegion(size_t in_point_count, Point const in_points [], Drawing::ClipSpace in_space = Drawing::ClipSpace::World, Drawing::ClipOperation in_operation = Drawing::ClipOperation::Keep);

	/*!	Sets a complex polygonal clip region defined by the XOR of a series of loops.
	*	\param in_loops An array of loops describing clip regions.
	*	\param in_space The coordinate space in which in_loops are specified.
	*	\param in_operation The operation performed by the clip region.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetClipRegion(PointArrayArray const & in_loops, Drawing::ClipSpace in_space = Drawing::ClipSpace::World, Drawing::ClipOperation in_operation = Drawing::ClipOperation::Keep);

	/*!	Specifies a drawing order for a segment during timed updates.  Segments with a lower deferral value will be drawn before segments with a higher value.
	*	This attribute does not inherit like most attributes. Segments have a default value of 0.
	*	\param in_deferral A drawing priority, with larger values drawing later than usual.  Should be non-negative.
	*	\return A reference to this object. */
	DrawingAttributeControl &	SetDeferral(int in_deferral);

	/*!	Removes a polygon handedness setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetPolygonHandedness();

	/*!	Removes a world handedness setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetWorldHandedness();

	/*!	Removes a depth range setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetDepthRange();

	/*!	Removes a face displacement setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetFaceDisplacement();

	/*!	Removes a general displacement setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetGeneralDisplacement();

	/*!	Removes a vertex displacement setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetVertexDisplacement();

	/*!	Removes a vertex decimation setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetVertexDecimation();

	/*!	Removes a vertex randomization setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetVertexRandomization();

	/*!	Removes an override internal color setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetOverrideInternalColor();

	/*!	Removes an overlay setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetOverlay();

	/*!	Removes a deferral setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetDeferral();

	/*!	Removes a clip region setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetClipRegion();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by DrawingAttributeKit::GetDefault().
	*	\return A reference to this object. */
	DrawingAttributeControl &	UnsetEverything();


	/*! Shows the polygon handedness.
	*	\param out_handedness The handedness used for geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPolygonHandedness(Drawing::Handedness & out_handedness) const;

	/*! Shows the world handedness.
	*	\param out_handedness The handedness of the underlying coordinate system.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWorldHandedness(Drawing::Handedness & out_handedness) const;

	/*! Shows the depth range setting.
	*	\param out_near The portion of the depth range closest to the camera.  Valid range is [0,1] with out_near &lt;= out_far.
	*	\param out_far The portion of the depth range furthest to the camera.  Valid range is [0,1] with out_near &lt;= out_far.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDepthRange(float & out_x, float & out_y) const;

	/*! Shows the face displacement setting.
	*	\param out_state Whether face displacement will be used.
	*	\param out_buckets The distance to move rendered faces away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFaceDisplacement(bool & out_state, int & out_buckets) const;

	/*! Shows the general displacement setting.
	*	\param out_state Whether general displacement will be used.
	*	\param out_buckets The distance to move rendered geometry away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowGeneralDisplacement(bool & out_state, int & out_buckets) const;

	/*! Shows the vertex displacement setting.
	*	\param out_state Whether vertex displacement will be used.
	*	\param out_buckets The distance to move vertices away from the camera.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexDisplacement(bool & out_state, int & out_buckets) const;

	/*! Shows the vertex decimation setting.
	*	\param out_zero_to_one The value set for vertex decimation.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexDecimation(float & out_zero_to_one) const;

	/*! Shows the vertex randomization setting.
	*	\param out_state Whether vertex randomization will be used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVertexRandomization(bool & out_state) const;

	/*! Shows the override internal color setting.
	*	\param out_kit Which override internal color types will be used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOverrideInternalColor(VisibilityKit & out_kit) const;

	/*! Shows the overlay setting.
	*	\param out_overlay The type of overlay, if any, used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOverlay(Drawing::Overlay & out_overlay) const;

	/*! Shows the deferral setting.
	*	\param out_defer_batch A drawing priority, with negative values drawing earlier than usual and positive values drawing later than usual.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDeferral(int & out_defer_batch) const;

	/*! Shows the clip region setting.
	*	\param out_loops An array of loops specifying the shape of the clip region.
	*	\param out_space The coordinate space the points are specified in.
	*	\param out_operation The operation performed by this clip region.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowClipRegion(PointArrayArray & out_loops, Drawing::ClipSpace & out_space, Drawing::ClipOperation & out_operation) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	DrawingAttributeControl();
};


/*! The HPS::PostProcessEffectsKit class is a user space object, useful for carrying a group of attribute settings related to post-process effects. Calling HPS::PostProcessEffectsKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#post-process-effects">this table</a>. */
class HPS_API PostProcessEffectsKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	PostProcessEffectsKit();

	/*! The copy constructor creates a new PostProcessEffectsKit object that contains the same settings as the source object.
	* 	\param in_kit The source object to copy. */
	PostProcessEffectsKit(PostProcessEffectsKit const & in_kit);

	/*! The move constructor creates a PostProcessEffectsKit by transferring the underlying impl of the rvalue reference to this PostProcessEffectsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PostProcessEffectsKit to take the impl from.*/
	PostProcessEffectsKit(PostProcessEffectsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PostProcessEffectsKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a PostProcessEffectsKit to take the impl from.
	* \return A reference to this PostProcessEffectsKit. */
	PostProcessEffectsKit & operator=(PostProcessEffectsKit && in_that);

	/*! Destroy this kit. */
	virtual ~PostProcessEffectsKit();

	static const HPS::Type staticType = HPS::Type::PostProcessEffectsKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a PostProcessEffectsKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A PostProcessEffectsKit with the default settings. */
	static PostProcessEffectsKit GetDefault();

	/*! Copies the source PostProcessEffectsKit into this object.
	*	\param in_kit The source object to copy. */
	void						Set(PostProcessEffectsKit const & in_kit);

	/*! Copies this object into the given PostProcessEffectsKit.
	*	\param out_kit The PostProcessEffectsKit to populate with the contents of this object. */
	void						Show(PostProcessEffectsKit & out_kit) const;

	/*! Copies the source PostProcessEffectsKit into this object.
	*	\param in_kit The source PostProcessEffectsKit to copy.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		operator=(PostProcessEffectsKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source PostProcessEffectsKit is equivalent to this object.
	*	\param in_kit The source PostProcessEffectsKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(PostProcessEffectsKit const & in_kit) const;

	/*!	Check if the source PostProcessEffectsKit is equivalent to this object.
	*	\param in_kit The source PostProcessEffectsKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(PostProcessEffectsKit const & in_kit) const;

	/*!	Check if the source PostProcessEffectsKit is not equivalent to this object.
	*	\param in_kit The source PostProcessEffectsKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(PostProcessEffectsKit const & in_kit) const;


	/*!	Ambient occlusion is a general term for shading that varies when nearby objects (occluders) would prevent some portion of ambient light from reaching a surface.
	*	This applies a filter that looks for small valleys in the depth buffer results, and slightly darkens these areas.
	*   \note Ambient occlusion uses the depth buffer that is generated when we render opaque geometry to approximate ambient occlusion. Drawing of transparent geometry is always deferred until after all opaque geometry is drawn, and doesn't write any depth information to the depth buffer. Thus, transparent geometry will effectively not exist for ambient occlusion calculations, and will therefore be unaffected by them. This also means that if all geometry in a scene is transparent, ambient occlusion is effectively disabled.
	*	\param in_state Whether ambient occlusion should be used.
	*	\param in_strength A multiplier on the default contribution of ambient occlusion in the regular lighting calculations.
	*		Higher values mean that ambient occlusion will make a stronger contribution.
	*	\param in_quality Indicates how much time should be spent improving the visual quality.
	*	\param in_radius A multiplier for the screen-space search radius.
	*	\param in_sharpness A value from 0.0f to 32.0f where lower values result in more blurred but softer edges and higher values will be blurred less with harder edges yet with more potential for banding.
	*		Higher values increase the search radius for occluding pixels, but may cause under-sampling artifacts.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetAmbientOcclusion(bool in_state, float in_strength = 1.0f, PostProcessEffects::AmbientOcclusion::Quality in_quality = PostProcessEffects::AmbientOcclusion::Quality::Fastest, float in_radius = 1.0f, float in_sharpness = 32.0f);

	/*!	Ambient occlusion is a general term for shading that varies when nearby objects (occluders) would prevent some portion of ambient light from reaching a surface.
	*	This applies a filter that looks for small valleys in the depth buffer results, and slightly darkens these areas.  The state is implicitly on.
	*   \note Ambient occlusion uses the depth buffer that is generated when we render opaque geometry to approximate ambient occlusion. Drawing of transparent geometry is always deferred until after all opaque geometry is drawn, and doesn't write any depth information to the depth buffer. Thus, transparent geometry will effectively not exist for ambient occlusion calculations, and will therefore be unaffected by them. This also means that if all geometry in a scene is transparent, ambient occlusion is effectively disabled.
	*	\param in_strength A multiplier on the default contribution of ambient occlusion in the regular lighting calculations.
	*		Higher values mean that ambient occlusion will make a stronger contribution.
	*	\param in_quality Indicates how much time should be spent improving the visual quality.
	*	\param in_radius A multiplier for the screen-space search radius.
	*	\param in_sharpness A value from 0.0f to 32.0f where lower values result in more blurred but softer edges and higher values will be blurred less with harder edges yet with more potential for banding.
	*		Higher values increase the search radius for occluding pixels, but may cause under-sampling artifacts.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetAmbientOcclusion(float in_strength, PostProcessEffects::AmbientOcclusion::Quality in_quality = PostProcessEffects::AmbientOcclusion::Quality::Fastest, float in_radius = 1.0f, float in_sharpness = 32.0f);

	/*!	Bloom causes bright objects to bleed into darker ones, simulating the imperfect focus inevitable with the human eye or any other type of lens.
	*	\param in_state Whether bloom should be used.
	*	\param in_strength A multiplier on the default contribution of bloom. Higher values mean that bloom will make a stronger contribution.  Valid range is [0,10].
	*	\param in_blur The number of blur passes to perform on the output. Higher values mean that bloom will affect a wider area and look smoother. Valid range is [1,8].
	*	\param in_shape The shape of the bloom effect.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetBloom(bool in_state, float in_strength = 1.0f, unsigned int in_blur = 5, PostProcessEffects::Bloom::Shape in_shape = PostProcessEffects::Bloom::Shape::Radial);

	/*!	Bloom causes bright objects to bleed into darker ones, simulating the imperfect focus inevitable with the human eye or any other type of lens.  The state is implicitly on.
	*	\param in_strength A multiplier on the default contribution of bloom. Higher values mean that bloom will make a stronger contribution.  Valid range is [0,10].
	*	\param in_blur The number of blur passes to perform on the output. Higher values mean that bloom will affect a wider area and look smoother. Valid range is [1,8].
	*	\param in_shape The shape of the bloom effect.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetBloom(float in_strength, unsigned int in_blur, PostProcessEffects::Bloom::Shape in_shape);

	/*!	Depth of Field is the distance between the nearest and farthest objects in a scene that appear sharp.
	*	\param in_state Whether depth of field should be used.
	*	\param in_strength A multiplier on the default blur radius. Higher values mean more blurring.
	*	\param in_near_distance The camera distance in front of which geometry will begin to appear out of focus.
	*	\param in_far_distance The camera distance beyond which geometry will appear out of focus.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetDepthOfField(bool in_state, float in_strength = 1.0f, float in_near_distance = Float::NegativeInfinity, float in_far_distance = Float::Infinity);

	/*!	Depth of Field is the distance between the nearest and farthest objects in a scene that appear sharp.  The state is implicitly on.
	*	\param in_strength A multiplier on the default blur radius. Higher values mean more blurring.
	*	\param in_near_distance The camera distance in front of which geometry will begin to appear out of focus.
	*	\param in_far_distance The camera distance beyond which geometry will appear out of focus.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetDepthOfField(float in_strength, float in_near_distance, float in_far_distance);

	/*!	Controls the shader-based fast drawing of silhouette edges.
	*	\param in_state Whether silhouette edges should be used.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect silhouettes.
	*		This allows the user to control the trade-off between silhouettes appearing where they shouldn't, vs disappearing in places they should be.
	*	\param in_heavy_exterior This option, when enabled, causes an extra thick border to be drawn at the boundary between geometry
	*		and the window background (as opposed to geometry on top of other geometry).
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetSilhouetteEdges(bool in_state, float in_tolerance = 1.0f, bool in_heavy_exterior = false);

	/*!	Controls the shader-based fast drawing of silhouette edges.  The state is implicitly on.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect silhouettes.
	*		This allows the user to control the trade-off between silhouettes appearing where they shouldn't, vs disappearing in places they should be.
	*	\param in_heavy_exterior This option, when enabled, causes an extra thick border to be drawn at the boundary between geometry
	*		and the window background (as opposed to geometry on top of other geometry).
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetSilhouetteEdges(float in_tolerance, bool in_heavy_exterior);

	/*!	Controls the shader-based eye-dome lighting effect.
	*   \param in_state Whether eye-dome lighting should be used.
	*	\param in_exponent An exponent used to attenuate the per-pixel occlusion computed by the eye-dome lighting algorithm.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect occlusion.
	*	\param in_strength A multiplier on the calculated per-pixel occlusion value.
	*		This allows the user to control the amount of occlusion added by neighboring pixels based on their relative depth difference.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetEyeDomeLighting(bool in_state, float in_exponent = 50.0f, float in_tolerance = 1.0f, float in_strength = 1.0f);

	/*!	Controls the shader-based eye-dome lighting effect.  The state is implicitly on.
	*	\param in_exponent An exponent used to attenuate the per-pixel occlusion computed by the eye-dome lighting algorithm.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect occlusion.
	*	\param in_strength A multiplier on the calculated per-pixel occlusion value.
	*		This allows the user to control the amount of occlusion added by neighboring pixels based on their relative depth difference.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetEyeDomeLighting(float in_exponent, bool in_tolerance, float in_strength);

	/*!	Sets a world scale value used by post process effects such as ambient occlusion.  If not set, scale is computed based on scene bounding.
	*	\param in_scale Scale value used by post process effect.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		SetWorldScale(float in_scale);

	/*!	Removes any ambient occlusion setting.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetAmbientOcclusion();

	/*!	Removes a bloom setting.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetBloom();

	/*!	Removes a depth of field setting.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetDepthOfField();

	/*!	Removes a silhouette edge setting.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetSilhouetteEdges();

	/*!	Removes an eye-dome lighting setting.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetEyeDomeLighting();

	/*!	Removes any world scale setting.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetWorldScale();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	PostProcessEffectsKit &		UnsetEverything();


	/*! Shows the ambient occlusion setting.
	*	\param out_state Whether ambient occlusion should be used.
	*	\param out_strength A multiplier on the default contribution of ambient occlusion in the regular lighting calculations.
	*		Higher values mean that ambient occlusion will make a stronger contribution.
	*	\param out_quality Indicates how much time should be spent improving the visual quality.
	*	\param out_radius A multiplier for the screen-space search radius.
	*	\param out_sharpness A value indicating the sharpness of the ambient occlusion edges.
	*		Higher values increase the search radius for occluding pixels, but may cause under-sampling artifacts.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAmbientOcclusion(bool & out_state, float & out_strength, PostProcessEffects::AmbientOcclusion::Quality & out_quality, float & out_radius, float & out_sharpness) const;

	/*! Shows the bloom setting.
	*	\param out_state Whether bloom should be used.
	*	\param out_strength A multiplier on the default contribution of bloom. Higher values mean that bloom will make a stronger contribution.
	*	\param out_blur The number of blur passes to perform on the output. Higher values mean that bloom will affect a wider area and look smoother.
	*	\param out_shape The shape of the bloom effect.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowBloom(bool & out_state, float & out_strength, unsigned int & out_blur, PostProcessEffects::Bloom::Shape & out_shape) const;

	/*! Shows the depth of field setting.
	*	\param out_state Whether depth of field should be used.
	*	\param out_strength A multiplier on the default blur radius. Higher values mean more blurring.
	*	\param out_near_distance The camera distance in front of which geometry will begin to appear out of focus.
	*	\param out_far_distance The camera distance beyond which geometry will appear out of focus.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDepthOfField(bool & out_state, float & out_strength, float & out_near_distance, float & out_far_distance) const;

	/*! Shows the silhouette edge setting.
	*	\param out_state Whether silhouette edges should be used.
	*	\param out_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect silhouettes.
	*		This allows the user to control the trade-off between silhouettes appearing where they shouldn't, vs disappearing in places they should be.
	*	\param out_heavy_exterior This option, when enabled, causes an extra thick border to be drawn at the boundary between geometry
	*		and the window background (as opposed to geometry on top of other geometry).
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSilhouetteEdges(bool & out_state, float & out_tolerance, bool & out_heavy_exterior) const;

	/*! Shows the eye-dome lighting setting.
	*	\param out_state Whether eye-dome lighting should be used.
	*	\param out_exponent An exponent used to attenuate the per-pixel occlusion computed by the eye-dome lighting algorithm.
	*	\param out_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect occlusion.
	*		This allows the user to control the amount of occlusion added by neighboring pixels based on their relative depth difference.
	*	\param out_strength A multiplier on the calculated per-pixel occlusion value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEyeDomeLighting(bool & out_state, float & out_exponent, float & out_tolerance, float & out_strength) const;

	/*! Shows the world scale setting.
	*	\param out_scale Scale value used by post process effects.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWorldScale(float & out_scale) const;

};


/*!
<p>The HPS::PostProcessEffectsControl class is a smart pointer that is tied to a database object. This object is effective only for the shader-based driver interfaces such as DirectX and OpenGL2. Ambient occlusion, bloom, silhouette edges, and depth of field are all enabled through this	control. Default values for the various fields of HPS::PostProcessEffectsControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#post-process-effects">here</a>.</p>
*/
class HPS_API PostProcessEffectsControl : public Control
{
public:

	/*! Initializes a control tied to the window segment in_seg. */
	explicit PostProcessEffectsControl(WindowKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	PostProcessEffectsControl(PostProcessEffectsControl const & in_that);

	/*! The move constructor creates a PostProcessEffectsControl by transferring the underlying impl of the rvalue reference to this PostProcessEffectsControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PostProcessEffectsControl to take the impl from.*/
	PostProcessEffectsControl(PostProcessEffectsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PostProcessEffectsControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a PostProcessEffectsControl to take the impl from.
	* \return A reference to this PostProcessEffectsControl. */
	PostProcessEffectsControl & operator=(PostProcessEffectsControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~PostProcessEffectsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::PostProcessEffectsControl;
	HPS::Type						ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the PostProcessEffectsControl source.
	 *	\param in_that The PostProcessEffectsControl source of the assignment.
	 *	\return A reference to this PostProcessEffectsControl. */
	PostProcessEffectsControl &		operator=(PostProcessEffectsControl const & in_that);

	/*!	Ambient occlusion is a general term for shading that varies when nearby objects (occluders) would prevent some portion of ambient light from reaching a surface.
	*	This applies a filter that looks for small valleys in the depth buffer results, and slightly darkens these areas.
	*   \note Ambient occlusion uses the depth buffer that is generated when we render opaque geometry to approximate ambient occlusion. Drawing of transparent geometry is always deferred until after all opaque geometry is drawn, and doesn't write any depth information to the depth buffer. Thus, transparent geometry will effectively not exist for ambient occlusion calculations, and will therefore be unaffected by them. This also means that if all geometry in a scene is transparent, ambient occlusion is effectively disabled.
	*	\param in_state Whether ambient occlusion should be used.
	*	\param in_strength A multiplier on the default contribution of ambient occlusion in the regular lighting calculations.
	*		Higher values mean that ambient occlusion will make a stronger contribution.
	*	\param in_quality Indicates how much time should be spent improving the visual quality.
	*	\param in_radius A multiplier for the screen-space search radius.
	*	\param in_sharpness A value from 0.0f to 32.0f where lower values result in more blurred but softer edges and higher values will be blurred less with harder edges yet with more potential for banding.
	*		Higher values increase the search radius for occluding pixels, but may cause under-sampling artifacts.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetAmbientOcclusion(bool in_state, float in_strength = 1.0f, PostProcessEffects::AmbientOcclusion::Quality in_quality = PostProcessEffects::AmbientOcclusion::Quality::Fastest, float in_radius = 1.0f, float in_sharpness = 32.0f);

	/*!	Ambient occlusion is a general term for shading that varies when nearby objects (occluders) would prevent some portion of ambient light from reaching a surface.
	*	This applies a filter that looks for small valleys in the depth buffer results, and slightly darkens these areas.  The state is implicitly on.
	*   \note Ambient occlusion uses the depth buffer that is generated when we render opaque geometry to approximate ambient occlusion. Drawing of transparent geometry is always deferred until after all opaque geometry is drawn, and doesn't write any depth information to the depth buffer. Thus, transparent geometry will effectively not exist for ambient occlusion calculations, and will therefore be unaffected by them. This also means that if all geometry in a scene is transparent, ambient occlusion is effectively disabled.
	*	\param in_strength A multiplier on the default contribution of ambient occlusion in the regular lighting calculations.
	*		Higher values mean that ambient occlusion will make a stronger contribution.
	*	\param in_quality Indicates how much time should be spent improving the visual quality.
	*	\param in_radius A multiplier for the screen-space search radius.
	*	\param in_sharpness A value from 0.0f to 32.0f where lower values result in more blurred but softer edges and higher values will be blurred less with harder edges yet with more potential for banding.
	*		Higher values increase the search radius for occluding pixels, but may cause under-sampling artifacts.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetAmbientOcclusion(float in_strength, PostProcessEffects::AmbientOcclusion::Quality in_quality = PostProcessEffects::AmbientOcclusion::Quality::Fastest, float in_radius = 1.0f, float in_sharpness = 32.0f);

	/*!	Bloom causes bright objects to bleed into darker ones, simulating the imperfect focus inevitable with the human eye or any other type of lens.
	*	\param in_state Whether bloom should be used.
	*	\param in_strength A multiplier on the default contribution of bloom. Higher values mean that bloom will make a stronger contribution.  Valid range is [0,10].
	*	\param in_blur The number of blur passes to perform on the output. Higher values mean that bloom will affect a wider area and look smoother. Valid range is [1,8].
	*	\param in_shape The shape of the bloom effect.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetBloom(bool in_state, float in_strength = 1.0f, unsigned int in_blur = 5, PostProcessEffects::Bloom::Shape in_shape = PostProcessEffects::Bloom::Shape::Radial);

	/*!	Bloom causes bright objects to bleed into darker ones, simulating the imperfect focus inevitable with the human eye or any other type of lens.  The state is implicitly on.
	*	\param in_strength A multiplier on the default contribution of bloom. Higher values mean that bloom will make a stronger contribution.  Valid range is [0,10].
	*	\param in_blur The number of blur passes to perform on the output. Higher values mean that bloom will affect a wider area and look smoother. Valid range is [1,8].
	*	\param in_shape The shape of the bloom effect.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetBloom(float in_strength, unsigned int in_blur, PostProcessEffects::Bloom::Shape in_shape);

	/*!	Depth of Field is the distance between the nearest and farthest objects in a scene that appear sharp.
	*	\param in_state Whether depth of field should be used.
	*	\param in_strength A multiplier on the default blur radius. Higher values mean more blurring.
	*	\param in_near_distance The camera distance in front of which geometry will begin to appear out of focus.
	*	\param in_far_distance The camera distance beyond which geometry will appear out of focus.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetDepthOfField(bool in_state, float in_strength = 1.0f, float in_near_distance = Float::NegativeInfinity, float in_far_distance = Float::Infinity);

	/*!	Depth of Field is the distance between the nearest and farthest objects in a scene that appear sharp.  The state is implicitly on.
	*	\param in_strength A multiplier on the default blur radius. Higher values mean more blurring.
	*	\param in_near_distance The camera distance in front of which geometry will begin to appear out of focus.
	*	\param in_far_distance The camera distance beyond which geometry will appear out of focus.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetDepthOfField(float in_strength, float in_near_distance, float in_far_distance);

	/*!	Controls the shader-based fast drawing of silhouette edges.
	*	\param in_state Whether silhouette edges should be used.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect silhouettes.
	*		This allows the user to control the trade-off between silhouettes appearing where they shouldn't, vs disappearing in places they should be.
	*	\param in_heavy_exterior This option, when enabled, causes an extra thick border to be drawn at the boundary between geometry
	*		and the window background (as opposed to geometry on top of other geometry).
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetSilhouetteEdges(bool in_state, float in_tolerance = 1.0f, bool in_heavy_exterior = false);

	/*!	Controls the shader-based fast drawing of silhouette edges.  The state is implicitly on.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect silhouettes.
	*		This allows the user to control the trade-off between silhouettes appearing where they shouldn't, vs disappearing in places they should be.
	*	\param in_heavy_exterior This option, when enabled, causes an extra thick border to be drawn at the boundary between geometry
	*		and the window background (as opposed to geometry on top of other geometry).
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetSilhouetteEdges(float in_tolerance, bool in_heavy_exterior);

	/*!	Controls the shader-based eye-dome lighting effect.
	*   \param in_state Whether eye-dome lighting should be used.
	*	\param in_exponent An exponent used to attenuate the per-pixel occlusion computed by the eye-dome lighting algorithm.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect occlusion.
	*		This allows the user to control the amount of occlusion added by neighboring pixels based on their relative depth difference.
	*	\param in_strength A multiplier on the calculated per-pixel occlusion value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	PostProcessEffectsControl &		SetEyeDomeLighting(bool in_state, float in_exponent = 50.0f, float in_tolerance = 1.0f, float in_strength = 1.0f);

	/*!	Controls the shader-based eye-dome lighting effect.  The state is implicitly on.
	*	\param in_exponent An exponent used to attenuate the per-pixel occlusion computed by the eye-dome lighting algorithm.
	*	\param in_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect occlusion.
	*		This allows the user to control the amount of occlusion added by neighboring pixels based on their relative depth difference.
	*	\param in_strength A multiplier on the calculated per-pixel occlusion value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	PostProcessEffectsControl &		SetEyeDomeLighting(float in_exponent, float in_tolerance, float in_strength);

	/*!	Sets a world scale value used by post process effects such as ambient occlusion.  If not set, scale is computed based on scene bounding.
	*	\param in_scale Scale value used by post process effect.
	*	\return A reference to this object. */
	PostProcessEffectsControl &		SetWorldScale(float in_scale);

	/*!	Removes any ambient occlusion setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetAmbientOcclusion();

	/*!	Removes a bloom setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetBloom();

	/*!	Removes a depth of field setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetDepthOfField();

	/*!	Removes a silhouette edge setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetSilhouetteEdges();

	/*!	Removes an eye-dome lighting setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetEyeDomeLighting();

	/*!	Removes any world scale setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetWorldScale();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by PostProcessEffectsKit::GetDefault().
	*	\return A reference to this object. */
	PostProcessEffectsControl &		UnsetEverything();


	/*! Shows the ambient occlusion setting.
	*	\param out_state Whether ambient occlusion should be used.
	*	\param out_strength A multiplier on the default contribution of ambient occlusion in the regular lighting calculations.
	*		Higher values mean that ambient occlusion will make a stronger contribution.
	*	\param out_quality Indicates how much time should be spent improving the visual quality.
	*	\param out_radius A multiplier for the screen-space search radius.
	*	\param out_sharpness A value indicating the sharpness of the ambient occlusion edges.
	*		Higher values increase the search radius for occluding pixels, but may cause under-sampling artifacts.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowAmbientOcclusion(bool & out_state, float & out_strength, PostProcessEffects::AmbientOcclusion::Quality & out_quality, float & out_radius, float & out_sharpness) const;

	/*! Shows the bloom setting.
	*	\param out_state Whether bloom should be used.
	*	\param out_strength A multiplier on the default contribution of bloom. Higher values mean that bloom will make a stronger contribution.
	*	\param out_blur The number of blur passes to perform on the output. Higher values mean that bloom will affect a wider area and look smoother.
	*	\param out_shape The shape of the bloom effect.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowBloom(bool & out_state, float & out_strength, unsigned int & out_blur, PostProcessEffects::Bloom::Shape & out_shape) const;

	/*! Shows the depth of field setting.
	*	\param out_state Whether depth of field should be used.
	*	\param out_strength A multiplier on the default blur radius. Higher values mean more blurring.
	*	\param out_near_distance The camera distance in front of which geometry will begin to appear out of focus.
	*	\param out_far_distance The camera distance beyond which geometry will appear out of focus.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowDepthOfField(bool & out_state, float & out_strength, float & out_near_distance, float & out_far_distance) const;

	/*! Shows the silhouette edge setting.
	*	\param out_state Whether silhouette edges should be used.
	*	\param out_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect silhouettes.
	*		This allows the user to control the trade-off between silhouettes appearing where they shouldn't, vs disappearing in places they should be.
	*	\param out_heavy_exterior This option, when enabled, causes an extra thick border to be drawn at the boundary between geometry
	*		and the window background (as opposed to geometry on top of other geometry).
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowSilhouetteEdges(bool & out_state, float & out_tolerance, bool & out_heavy_exterior) const;

	/*! Shows the eye-dome lighting setting.
	*	\param out_state Whether eye-dome lighting should be used.
	*	\param out_exponent An exponent used to attenuate the per-pixel occlusion computed by the eye-dome lighting algorithm.
	*	\param out_tolerance A multiplier on the threshold that the driver uses when comparing adjacent pixel depth values to detect occlusion.
	*		This allows the user to control the amount of occlusion added by neighboring pixels based on their relative depth difference.
	*	\param out_strength A multiplier on the calculated per-pixel occlusion value.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowEyeDomeLighting(bool & out_state, float & out_exponent, float & out_tolerance, float & out_strength) const;

	/*! Shows the world scale setting.
	*	\param out_scale Scale value used by post process effects.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool							ShowWorldScale(float & out_scale) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	PostProcessEffectsControl();
};

/*! The HPS::TransformMaskKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::TransformMaskKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#transform-mask">this table</a>. */
class HPS_API TransformMaskKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	TransformMaskKit();

	/*! Copies the kit in_kit into this kit. */
	TransformMaskKit(TransformMaskKit const & in_kit);

	/*! The move constructor creates a TransformMaskKit by transferring the underlying impl of the rvalue reference to this TransformMaskKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TransformMaskKit to take the impl from.*/
	TransformMaskKit(TransformMaskKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TransformMaskKit thereby avoiding a copy.
	* \param in_that An rvalue reference to an TransformMaskKit to take the impl from.
	* \return A reference to this TransformMaskKit. */
	TransformMaskKit & operator=(TransformMaskKit && in_that);

	/*! Destroy this kit. */
	virtual ~TransformMaskKit();

	static const HPS::Type staticType = HPS::Type::TransformMaskKit;
	HPS::Type				ObjectType() const {return staticType;};

	static TransformMaskKit	GetDefault();

	/*! Copies the kit in_kit into this kit. */
	void					Set(TransformMaskKit const & in_kit);

	/*! Copies this kit into out_kit. */
	void					Show(TransformMaskKit & out_kit) const;

	/*! Copies the kit in_kit into this kit. */
	TransformMaskKit &		operator=(TransformMaskKit const & in_kit);

	/*! Returns whether this kit has any values currently set on it. */
	bool					Empty() const;

	/*! Compares the contents of in_kit and this kit. */
	bool					Equals(TransformMaskKit const & in_kit) const;

	/*! Compares the contents of in_kit and this kit. */
	bool					operator==(TransformMaskKit const & in_kit) const;

	/*! Compares the contents of in_kit and this kit. */
	bool					operator!=(TransformMaskKit const & in_kit) const;


	/*! Applies a mask which removes transforms related to camera rotations.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraRotation(bool in_state);

	/*! Applies a mask which removes transforms related to camera scales.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraScale(bool in_state);

	/*! Applies a mask which removes transforms related to camera translations.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraTranslation(bool in_state);

	/*! Applies a mask which removes the perspective scale from perspective cameras.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraPerspectiveScale(bool in_state);

	/*! Applies a mask which removes the perspective projection and replaces it with an orthographic projection from perspective cameras.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraProjection(bool in_state);

	/*! Applies a mask which removes transforms related to camera offsets.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraOffset(bool in_state);

	/*! Applies a mask which removes transforms related to camera near limit.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraNearLimit(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix rotations.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetModellingMatrixRotation(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix scales.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetModellingMatrixScale(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix translation.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetModellingMatrixTranslation(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix offset.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetModellingMatrixOffset(bool in_state);


	/*! Applies a mask which removes transforms related to camera.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetCameraEverything(bool in_state);

	/*! Applies a mask which removes transforms related to modelling matrix.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetModellingMatrixEverything(bool in_state);

	/*! Applies a mask which removes all transforms related to both modelling matrix and camera.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskKit &		SetEverything(bool in_state);


	/*! Removes the mask which removes transforms related to camera rotation.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraRotation();

	/*! Removes the mask which removes transforms related to camera scale.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraScale();

	/*! Removes the mask which removes transforms related to camera translation.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraTranslation();

	/*! Removes the mask which removes the perspective scale from perspective cameras.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraPerspectiveScale();

	/*! Removes the mask which removes the perspective projection from perspective cameras.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraProjection();

	/*! Removes the mask which removes transforms related to camera offset.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraOffset();

	/*! Removes the mask which removes transforms related to camera near limit.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraNearLimit();

	/*! Removes the mask which removes transforms related to camera.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetCameraEverything();

	/*! Removes the mask which removes transforms related to modelling matrix rotation.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetModellingMatrixRotation();

	/*! Removes the mask which removes transforms related to modelling matrix scale.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetModellingMatrixScale();

	/*! Removes the mask which removes transforms related to modelling matrix translation.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetModellingMatrixTranslation();

	/*! Removes the mask which removes transforms related to modelling matrix offset.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetModellingMatrixOffset();

	/*! Removes the mask which removes transforms related to modelling matrix everything.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetModellingMatrixEverything();

	/*! Removes the mask which removes transforms related to camera and modelling matrix.
	* \return A reference to this object. */
	TransformMaskKit &		UnsetEverything();


	/*! Shows the camera rotation mask setting
	*	\param out_state Whether the camera rotation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraRotation(bool & out_state) const;

	/*! Shows the camera scale mask setting
	*	\param out_state Whether the camera scale transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraScale(bool & out_state) const;

	/*! Shows the camera translation mask setting
	*	\param out_state Whether the camera translation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraTranslation(bool & out_state) const;

	/*! Shows the camera perspective scale mask setting
	*	\param out_state Whether the camera perspective scale transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraPerspectiveScale(bool & out_state) const;

	/*! Shows the camera perspective projection mask setting
	*	\param out_state Whether the camera perspective projection transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraProjection(bool & out_state) const;

	/*! Shows the camera offset mask setting
	*	\param out_state Whether the camera offset transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraOffset(bool & out_state) const;

	/*! Shows the camera near limit mask setting
	*	\param out_state Whether the camera near limit transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraNearLimit(bool & out_state) const;

	/*! Shows the modelling matrix rotation mask setting
	*	\param out_state Whether the modelling matrix rotation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixRotation(bool & out_state) const;

	/*! Shows the modelling matrix scale mask setting
	*	\param out_state Whether the modelling matrix scale transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixScale(bool & out_state) const;

	/*! Shows the modelling matrix translation mask setting
	*	\param out_state Whether the modelling matrix translation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixTranslation(bool & out_state) const;

	/*! Shows the modelling matrix offset mask setting
	*	\param out_state Whether the modelling matrix offset transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixOffset(bool & out_state) const;
};


/*! The HPS::TransformMaskControl class is a smart pointer that is tied to a database object. This class allows you to manipulate
	the settings associated with a transform mask. A transform mask allows a segment to ignore its inherited transform. For example,
	if you want to be able to rotate a scene at a high level, but have a piece of geometry ignore rotations, you could achieve
	that effect using a transform mask. <a href="../../prog_guide/appendix_default_attribute_values.html#transform-mask">This table</a> lists default values for the various segment attributes accessible from HPS::TransformMaskControl.*/
class HPS_API TransformMaskControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit TransformMaskControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	TransformMaskControl(TransformMaskControl const & in_that);

	/*! The move constructor creates a TransformMaskControl by transferring the underlying impl of the rvalue reference to this TransformMaskControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TransformMaskControl to take the impl from.*/
	TransformMaskControl(TransformMaskControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TransformMaskControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a TransformMaskControl to take the impl from.
	* \return A reference to this TransformMaskControl. */
	TransformMaskControl & operator=(TransformMaskControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~TransformMaskControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::TransformMaskControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the TransformMaskControl source.
	 *	\param in_that The TransformMaskControl source of the assignment.
	 *	\return A reference to this TransformMaskControl. */
	TransformMaskControl &		operator=(TransformMaskControl const & in_that);

	/*! Applies a mask which removes transforms related to camera rotations.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraRotation(bool in_state);

	/*! Applies a mask which removes transforms related to camera scales.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraScale(bool in_state);

	/*! Applies a mask which removes transforms related to camera translations.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraTranslation(bool in_state);

	/*! Applies a mask which removes transforms related to the camera perspective scale.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraPerspectiveScale(bool in_state);

	/*! Applies a mask which removes transforms related to the camera perspective projection.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraProjection(bool in_state);

	/*! Applies a mask which removes transforms related to camera offsets.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraOffset(bool in_state);

	/*! Applies a mask which removes transforms related to camera near limit.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraNearLimit(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix rotations.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetModellingMatrixRotation(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix scales.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetModellingMatrixScale(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix translation.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetModellingMatrixTranslation(bool in_state);

	/*! Applies a mask which removes transforms related to all modelling matrix offset.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetModellingMatrixOffset(bool in_state);


	/*! Applies a mask which removes transforms related to camera.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetCameraEverything(bool in_state);

	/*! Applies a mask which removes transforms related to modelling matrix.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetModellingMatrixEverything(bool in_state);

	/*! Applies a mask which removes all transforms related to both modelling matrix and camera.
	* \param in_state Whether the mask should be applied.
	* \return A reference to this object. */
	TransformMaskControl &		SetEverything(bool in_state);


	/*! Removes the mask which removes transforms related to camera rotation. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraRotation();

	/*! Removes the mask which removes transforms related to camera scale. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraScale();

	/*! Removes the mask which removes transforms related to camera translation. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraTranslation();

	/*! Removes the mask which removes transforms related to the camera perspective scale. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraPerspectiveScale();

	/*! Removes the mask which removes transforms related to the camera perspective projection. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraProjection();

	/*! Removes the mask which removes transforms related to camera offset. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraOffset();

	/*! Removes the mask which removes transforms related to camera near limit. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraNearLimit();

	/*! Removes the mask which removes transforms related to camera. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetCameraEverything();

	/*! Removes the mask which removes transforms related to modelling matrix rotation. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetModellingMatrixRotation();

	/*! Removes the mask which removes transforms related to modelling matrix scale. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetModellingMatrixScale();

	/*! Removes the mask which removes transforms related to modelling matrix translation. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetModellingMatrixTranslation();

	/*! Removes the mask which removes transforms related to modelling matrix offset. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetModellingMatrixOffset();

	/*! Removes the mask which removes transforms related to modelling matrix everything. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetModellingMatrixEverything();

	/*! Removes the mask which removes transforms related to camera and modelling matrix. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by TransformMaskKit::GetDefault().
	* \return A reference to this object. */
	TransformMaskControl &		UnsetEverything();


	/*! Shows the camera rotation mask setting
	*	\param out_state Whether the camera rotation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraRotation(bool & out_state) const;

	/*! Shows the camera scale mask setting
	*	\param out_state Whether the camera scale transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraScale(bool & out_state) const;

	/*! Shows the camera translation mask setting
	*	\param out_state Whether the camera translation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraTranslation(bool & out_state) const;

	/*! Shows the camera perspective scale mask setting
	*	\param out_state Whether the camera perspective scale transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraPerspectiveScale(bool & out_state) const;

	/*! Shows the camera perspective projection mask setting
	*	\param out_state Whether the camera perspective projection transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraProjection(bool & out_state) const;

	/*! Shows the camera offset mask setting
	*	\param out_state Whether the camera offset transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraOffset(bool & out_state) const;

	/*! Shows the camera near limit mask setting
	*	\param out_state Whether the camera near limit transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCameraNearLimit(bool & out_state) const;

	/*! Shows the modelling matrix rotation mask setting
	*	\param out_state Whether the modelling matrix rotation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixRotation(bool & out_state) const;

	/*! Shows the modelling matrix scale mask setting
	*	\param out_state Whether the modelling matrix scale transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixScale(bool & out_state) const;

	/*! Shows the modelling matrix translation mask setting
	*	\param out_state Whether the modelling matrix translation transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixTranslation(bool & out_state) const;

	/*! Shows the modelling matrix offset mask setting
	*	\param out_state Whether the modelling matrix offset transform mask is applied
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowModellingMatrixOffset(bool & out_state) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	TransformMaskControl() {}
};



/*! The HPS::VisualEffectsKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::VisualEffectsKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#visual-effects">this table</a>. */
class HPS_API VisualEffectsKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	VisualEffectsKit();

	/*! The copy constructor creates a new VisualEffectsKit object that contains the same settings as the source object.
	*	\param in_kit The source object to copy. */
	VisualEffectsKit(VisualEffectsKit const & in_kit);

	/*! The move constructor creates a VisualEffectsKit by transferring the underlying impl of the rvalue reference to this VisualEffectsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a VisualEffectsKit to take the impl from.*/
	VisualEffectsKit(VisualEffectsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this VisualEffectsKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a VisualEffectsKit to take the impl from.
	* \return A reference to this VisualEffectsKit. */
	VisualEffectsKit & operator=(VisualEffectsKit && in_that);

	/*! Destroy this kit. */
	virtual ~VisualEffectsKit();

	static const HPS::Type staticType = HPS::Type::VisualEffectsKit;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Creates a VisualEffectsKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A VisualEffectsKit with the default settings. */
	static VisualEffectsKit GetDefault();

	/*! Copies the source VisualEffectsKit into this object.
	*	\param in_kit The source object to copy. */
	void					Set(VisualEffectsKit const & in_kit);

	/*! Copies this object into the given VisualEffectsKit.
	*	\param out_kit The VisualEffectsKit to populate with the contents of this object. */
	void					Show(VisualEffectsKit & out_kit) const;

	/*! Copies the source VisualEffectsKit into this object.
	*	\param in_kit The source VisualEffectsKit to copy.
	*	\return A reference to this object. */
	VisualEffectsKit &		operator=(VisualEffectsKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	*	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source VisualEffectsKit is equivalent to this object.
	*	\param in_kit The source VisualEffectsKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(VisualEffectsKit const & in_kit) const;

	/*!	Check if the source VisualEffectsKit is equivalent to this object.
	*	\param in_kit The source VisualEffectsKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(VisualEffectsKit const & in_kit) const;

	/*!	Check if the source VisualEffectsKit is not equivalent to this object.
	*	\param in_kit The source VisualEffectsKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(VisualEffectsKit const & in_kit) const;

	/*!	Allows all post-processing effects to be enabled or disabled en masse on a per segment basis.
	*	\param in_state Whether post-processing effects should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetPostProcessEffectsEnabled(bool in_state);

	/*!	Allows ambient occlusion to be enabled or disabled on a per segment basis.
	*	\param in_state Whether ambient occlusion should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetAmbientOcclusionEnabled(bool in_state);

	/*!	Allows bloom to be enabled or disabled on a per segment basis.
	*	\param in_state Whether bloom should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetBloomEnabled(bool in_state);

	/*!	Allows depth of field to be enabled or disabled on a per segment basis.
	*	\param in_state Whether depth of field should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetDepthOfFieldEnabled(bool in_state);

	/*!	Allows silhouette edges to be enabled or disabled on a per segment basis.
	*	\param in_state Whether silhouette edges should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSilhouetteEdgesEnabled(bool in_state);

	/*!	Allows eye dome lighting to be enabled or disabled on a per segment basis.
	*	\param in_state Whether eye dome lighting should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetEyeDomeLightingEnabled(bool in_state);

	/*!	Sets the color to use for the back of a point in a point cloud when rendered via eye dome lighting.
	 *	\note For this setting to have an effect, the points in a point cloud must have normals specified.
	 *	\param in_state Whether a back color should be used for eye dome lighting.
	 *	\param in_color The color to use for the back of a point for eye dome lighting.
	 *	\return A reference to this object. */
	VisualEffectsKit &		SetEyeDomeLightingBackColor(bool in_state, RGBColor const & in_color = RGBColor::Black());

	/*!	Sets the color to use for the back of a point in a point cloud when rendered via eye dome lighting.  The state is implicitly on.
	 *	\note For this setting to have an effect, the points in a point cloud must have normals specified.
	 *	\param in_color The color to use for the back of a point for eye dome lighting.
	 *	\return A reference to this object. */
	VisualEffectsKit &		SetEyeDomeLightingBackColor(RGBColor const & in_color);

	/*!	Manipulates the state of anti-aliasing(text and screen).
	*	\param in_state Whether anti-aliasing(text and screen) should be used.
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility and SetTextAntiAliasing(bool in_state) should be preferred in general usage. */
	VisualEffectsKit &		SetAntiAliasing(bool in_state);

	/*!	Manipulates the state of anti-aliasing.
	*	\param in_state Whether anti-aliasing should be used.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetTextAntiAliasing(bool in_state);

	/*!	Manipulates the state of shadow maps in the scene.
	*	\param in_state Whether shadow maps should be used.
	*	\param in_samples The number of locations in the shadow map used to determine the percentage value of light received by a pixel in the rendered scene.
	*	\param in_resolution The width and height of the shadow map. This value will be clamped up/down to 512, 1024 or 2048.
	*	\param in_view_dependent When enabled, the view frustum is taken into account when generating shadow maps.
			This results in significantly better visual quality, but at the cost of not being able to reuse shadow maps from previous frames,
			even if the lighting is constant with respect to the scene.
	*	\param in_jitter Turning this on causes stochastic sampling of shadow maps. This should reduce aliasing in the shadow map.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetShadowMaps(bool in_state, unsigned int in_samples = 4, unsigned int in_resolution = 1024, bool in_view_dependent = true, bool in_jitter = true);

	/*!	Manipulates the state of shadow maps in the scene.  The state is implicitly on.
	*	\param in_samples The number of locations in the shadow map used to determine the percentage value of light received by a pixel in the rendered scene.
	*	\param in_resolution The width and height of the shadow map. This value will be clamped up/down to 512, 1024 or 2048.
	*	\param in_view_dependent When enabled, the view frustum is taken into account when generating shadow maps.
			This results in significantly better visual quality, but at the cost of not being able to reuse shadow maps from previous frames,
			even if the lighting is constant with respect to the scene.
	*	\param in_jitter Turning this on causes stochastic sampling of shadow maps. This should reduce aliasing in the shadow map.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetShadowMaps(unsigned int in_samples, unsigned int in_resolution, bool in_view_dependent, bool in_jitter);

	/*!	Manipulates the state of simple shadows, projected onto a plane.
	*	\param in_state Whether simple shadows should be used.
	*	\param in_resolution The width and height of the simple shadow.  Valid range is [32, 1024].
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_ignore_transparency Whether any segment-level transparency setting should be ignored when rendering the simple shadow.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleShadow(bool in_state, unsigned int in_resolution = 256, unsigned int in_blurring = 1, bool in_ignore_transparency = false);

	/*!	Manipulates the state of simple shadows, projected onto a plane.  The state is implicitly on.
	*	\param in_resolution The width and height of the simple shadow. Valid range is [32, 1024].
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_ignore_transparency Whether any segment-level transparency setting should be ignored when rendering the simple shadow.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleShadow(unsigned int in_resolution, unsigned int in_blurring, bool in_ignore_transparency);

	/*!	Manipulates the location and orientation of the plane that simple shadows are projected onto.
	*	\param in_projected_onto The plane that simple shadows should be projected onto.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleShadowPlane(Plane const & in_projected_onto = Plane(0.0f, 1.0f, 0.0f, 1.0f));

	/*!	Sets the direction that the light source for a simple shadow is coming from.
	*	\param in_direction The direction that the light source for a simple shadow is coming from.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleShadowLightDirection(Vector const & in_direction = Vector(0.0f, 1.0f, 0.0f));

	/*!	Sets the color that simple shadows will be rendered in.
	*	\param in_color The color of simple shadows.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleShadowColor(RGBAColor const & in_color = RGBAColor(0.0f, 0.0f, 0.0f, 1.0f));

	/*!	Manipulates the state of simple reflections, projected onto a plane.
	*	\param in_state Whether simple shadows should be used.
	*	\param in_opacity An alpha value that sets the transparency level of the reflection plane.  Valid range is [0,1] with a value of zero making the plane completely transparent.
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_fading Whether the reflection plane should fade as it moves away from the camera.
	*	\param in_attenuation_near_distance The orthogonal distances (in world space) from the reflection plane that the model begins to fade.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\param in_attenuation_far_distance The orthogonal distances (in world space) from the reflection plane that the model is completely faded.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleReflection(bool in_state, float in_opacity = 0.5f, unsigned int in_blurring = 1, bool in_fading = false, float in_attenuation_near_distance = 0.0f, float in_attenuation_far_distance = Float::Infinity);

	/*!	Manipulates the state of simple reflections, projected onto a plane.  The state is implicitly on.
	*	\param in_opacity An alpha value that sets the transparency level of the reflection plane.  Valid range is [0,1] with a value of zero making the plane completely transparent.
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_fading Whether the reflection plane should fade as it moves away from the camera.
	*	\param in_attenuation_near_distance The orthogonal distances (in world space) from the reflection plane that the model begins to fade.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\param in_attenuation_far_distance The orthogonal distances (in world space) from the reflection plane that the model is completely faded.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleReflection(float in_opacity, unsigned int in_blurring, bool in_fading, float in_attenuation_near_distance, float in_attenuation_far_distance);

	/*!	Manipulates the location and orientation of the plane that simple reflections are projected onto.
	*	\param in_projected_onto The plane that simple reflections should be projected onto.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleReflectionPlane(Plane const & in_projected_onto = Plane(0.0f, 1.0f, 0.0f, 1.0f));

	/*!	Defines the visibility settings for the model when rendered in the reflection plane.
	*	\param in_reflected_types A collection of visibility settings that will be applied to the reflected geometry.
	*	\return A reference to this object. */
	VisualEffectsKit &		SetSimpleReflectionVisibility(VisibilityKit const & in_reflected_types);

	/*!	Removes any post-processing effects setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetPostProcessEffectsEnabled();

	/*!	Removes any ambient occlusion setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetAmbientOcclusionEnabled();

	/*!	Removes any silhouette edges setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSilhouetteEdgesEnabled();

	/*!	Removes any depth of field setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetDepthOfFieldEnabled();

	/*!	Removes any bloom setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetBloomEnabled();

	/*!	Removes any eye dome lighting setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetEyeDomeLightingEnabled();

	/*!	Removes any eye dome lighting back color setting.
	 *	\return A reference to this object. */
	VisualEffectsKit &		UnsetEyeDomeLightingBackColor();

	/*!	Removes any anti-alias setting(text and screen).
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility and UnsetTextAntiAliasing() should be preferred in general usage. */
	VisualEffectsKit &		UnsetAntiAliasing();

	/*!	Removes any text anti-alias setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetTextAntiAliasing();

	/*!	Removes any shadow maps setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetShadowMaps();

	/*!	Removes any simple shadow setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleShadow();

	/*!	Removes any simple shadow plane setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleShadowPlane();

	/*!	Removes any simple shadow light direction setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleShadowLightDirection();

	/*!	Removes any simple shadow color setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleShadowColor();

	/*!	Removes any simple reflection setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleReflection();

	/*!	Removes any simple reflection plane setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleReflectionPlane();

	/*!	Removes any simple reflection visibility setting.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetSimpleReflectionVisibility();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	VisualEffectsKit &		UnsetEverything();

	/*! Shows the post-processing effects setting.
	*	\param out_state Whether post-processing effects are enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPostProcessEffectsEnabled(bool & out_state) const;

	/*! Shows the ambient occlusion setting.
	*	\param out_state Whether ambient occlusion is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowAmbientOcclusionEnabled(bool & out_state) const;

	/*! Shows the silhouette edges setting.
	*	\param out_state Whether silhouette edges are enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSilhouetteEdgesEnabled(bool & out_state) const;

	/*! Shows the depth of field setting.
	*	\param out_state Whether depth of field is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowDepthOfFieldEnabled(bool & out_state) const;

	/*! Shows the bloom setting.
	*	\param out_state Whether bloom is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowBloomEnabled(bool & out_state) const;

	/*! Shows the eye dome lighting setting.
	*	\param out_state Whether eye dome lighting is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEyeDomeLightingEnabled(bool & out_state) const;

	/*! Shows the eye dome lighting back color setting.
	 *	\param out_state Whether a back color should be used for eye dome lighting.
	 *	\param out_color The color to use for the back of a point for eye dome lighting.
	 *	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEyeDomeLightingBackColor(bool & out_state, RGBColor & out_color) const;

	/*! Shows the anti-aliasing setting.
	*	\param out_state Whether anti-aliasing(text and screen) should be used.
	*	\return <span class='code'>true</span> if the setting(text and screen) is valid, <span class='code'>false</span> otherwise.
	*	\deprecated This function exists for compatibility and ShowTextAntiAliasing(bool & out_state) should be preferred in general usage. */
	bool					ShowAntiAliasing(bool & out_state) const;

	/*! Shows the text anti-aliasing setting.
	*	\param out_state Whether text anti-aliasing should be used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowTextAntiAliasing(bool & out_state) const;

	/*! Shows the shadow maps setting.
	*	\param out_state Whether shadow maps should be used.
	*	\param out_samples The number of locations in the shadow map used to determine the percentage value of light received by a pixel in the rendered scene.
	*	\param out_resolution The width and height of the shadow map.
	*	\param out_view_dependent When enabled, the view frustum is taken into account when generating shadow maps.
	*	\param out_jitter Whether stochastic sampling of shadow maps should be use to reduce aliasing in the shadow map.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowShadowMaps(bool & out_state, unsigned int & out_samples, unsigned int & out_resolution, bool & out_view_dependent, bool & out_jitter) const;

	/*! Shows the simple shadow setting.
	*	\param out_state Whether simple shadows should be used.
	*	\param out_resolution The width and height of the simple shadow.
	*	\param out_blurring The level of blurring (softening) that is applied to the shadow.
	*	\param out_ignore_transparency Whether any segment-level transparency setting should be ignored when rendering the simple shadow.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleShadow(bool & out_state, unsigned int & out_resolution, unsigned int & out_blurring, bool & out_ignore_transparency) const;

	/*! Shows the simple shadow plane setting.
	*	\param out_projected_onto The plane that simple shadows should be projected onto.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleShadowPlane(Plane & out_projected_onto) const;

	/*! Shows the simple shadow light direction setting.
	*	\param out_direction The direction that the light source for a simple shadow is coming from.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleShadowLightDirection(Vector & out_direction) const;

	/*! Shows the simple shadow color setting.
	*	\param out_color The color of simple shadows.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleShadowColor(RGBAColor & out_color) const;

	/*! Shows the simple reflection setting.
	*	\param out_state Whether simple shadows should be used.
	*	\param out_opacity An alpha value that sets the transparency level of the reflection plane.
	*	\param out_blurring The level of blurring (softening) that is applied to the shadow.
	*	\param out_fading Whether the reflection plane should fade as it moves away from the camera.
	*	\param out_attenuation_near_distance The orthogonal distances (in world space) from the reflection plane that the model begins to fade.
	*	\param out_attenuation_far_distance The orthogonal distances (in world space) from the reflection plane that the model is completely faded.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleReflection(bool & out_state, float & out_opacity, unsigned int & out_blurring, bool & out_fading, float & out_attenuation_near_distance, float & out_attenuation_far_distance) const;


	/*! Shows the simple reflection plane setting.
	*	\param out_projected_onto The plane that simple reflections should be projected onto.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleReflectionPlane(Plane & out_projected_onto) const;

	/*! Shows the simple shadow visibility setting.
	*	\param out_reflected_types A collection of visibility settings that will be applied to the reflected geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSimpleReflectionVisibility(VisibilityKit & out_reflected_types) const;
};


/*!
<p>The HPS::VisualEffectsControl class is a smart pointer that is tied to a database object. This object enables you to set and unset various visual effects, such as shadows (including shadow color), reflection planes, and anti-aliasing. </p>

<p>Default values for the various fields of HPS::VisualEffectsControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#visual-effects">here</a>.</p>
*/
class HPS_API VisualEffectsControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit VisualEffectsControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	VisualEffectsControl(VisualEffectsControl const & in_that);

	/*! The move constructor creates a VisualEffectsControl by transferring the underlying impl of the rvalue reference to this VisualEffectsControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a VisualEffectsControl to take the impl from.*/
	VisualEffectsControl(VisualEffectsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this VisualEffectsControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a VisualEffectsControl to take the impl from.
	* \return A reference to this VisualEffectsControl. */
	VisualEffectsControl & operator=(VisualEffectsControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~VisualEffectsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::VisualEffectsControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the VisualEffectsControl source.
	 *	\param in_that The VisualEffectsControl source of the assignment.
	 *	\return A reference to this VisualEffectsControl. */
	VisualEffectsControl &		operator=(VisualEffectsControl const & in_that);

	/*!	Allows all post-processing effects to be enabled or disabled en masse on a per segment basis.
	*	\param in_state Whether post-processing effects should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetPostProcessEffectsEnabled(bool in_state);

	/*!	Allows ambient occlusion to be enabled or disabled on a per segment basis.
	*	\param in_state Whether ambient occlusion should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetAmbientOcclusionEnabled(bool in_state);

	/*!	Allows silhouette edges to be enabled or disabled on a per segment basis.
	*	\param in_state Whether silhouette edges should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSilhouetteEdgesEnabled(bool in_state);

	/*!	Allows depth of field to be enabled or disabled en masse on a per segment basis.
	*	\param in_state Whether depth of field should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetDepthOfFieldEnabled(bool in_state);

	/*!	Allows bloom to be enabled or disabled on a per segment basis.
	*	\param in_state Whether bloom should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetBloomEnabled(bool in_state);

	/*!	Allows eye dome lighting to be enabled or disabled en masse on a per segment basis.
	*	\param in_state Whether eye dome lighting should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetEyeDomeLightingEnabled(bool in_state);

	/*!	Sets the color to use for the back of a point in a point cloud when rendered via eye dome lighting.
	 *	\note For this setting to have an effect, the points in a point cloud must have normals specified.
	 *	\param in_state Whether a back color should be used for eye dome lighting.
	 *	\param in_color The color to use for the back of a point for eye dome lighting.
	 *	\return A reference to this object. */
	VisualEffectsControl &		SetEyeDomeLightingBackColor(bool in_state, RGBColor const & in_color = RGBColor::Black());

	/*!	Sets the color to use for the back of a point in a point cloud when rendered via eye dome lighting.  The state is implicitly on.
	 *	\note For this setting to have an effect, the points in a point cloud must have normals specified.
	 *	\param in_color The color to use for the back of a point for eye dome lighting.
	 *	\return A reference to this object. */
	VisualEffectsControl &		SetEyeDomeLightingBackColor(RGBColor const & in_color);

	/*!	Manipulates the state of anti-aliasing(text and screen).
	*	\param in_state Whether anti-aliasing(text and screen) should be used.
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility and SetTextAntiAliasing(bool in_state) should be preferred in general usage. */
	VisualEffectsControl &		SetAntiAliasing(bool in_state);

	/*!	Manipulates the state of text anti-aliasing.
	*	\param in_state Whether text anti-aliasing should be used.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetTextAntiAliasing(bool in_state);

	/*!	Manipulates the state of shadow maps in the scene.
	*	\param in_state Whether shadow maps should be used.
	*	\param in_samples The number of locations in the shadow map used to determine the percentage value of light received by a pixel in the rendered scene.
	*	\param in_resolution The width and height of the shadow map. This value will be clamped up/down to 512, 1024 or 2048.
	*	\param in_view_dependent When enabled, the view frustum is taken into account when generating shadow maps.
			This results in significantly better visual quality, but at the cost of not being able to reuse shadow maps from previous frames,
			even if the lighting is constant with respect to the scene.
	*	\param in_jitter Turning this on causes stochastic sampling of shadow maps. This should reduce aliasing in the shadow map.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetShadowMaps(bool in_state, unsigned int in_samples = 4, unsigned int in_resolution = 1024, bool in_view_dependent = true, bool in_jitter = true);

	/*!	Manipulates the state of shadow maps in the scene.  The state is implicitly on.
	*	\param in_samples The number of locations in the shadow map used to determine the percentage value of light received by a pixel in the rendered scene.
	*	\param in_resolution The width and height of the shadow map. This value will be clamped up/down to 512, 1024 or 2048.
	*	\param in_view_dependent When enabled, the view frustum is taken into account when generating shadow maps.
			This results in significantly better visual quality, but at the cost of not being able to reuse shadow maps from previous frames,
			even if the lighting is constant with respect to the scene.
	*	\param in_jitter Turning this on causes stochastic sampling of shadow maps. This should reduce aliasing in the shadow map.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetShadowMaps(unsigned int in_samples, unsigned int in_resolution, bool in_view_dependent, bool in_jitter);

	/*!	Manipulates the state of simple shadows, projected onto a plane.
	*	\param in_state Whether simple shadows should be used.
	*	\param in_resolution The width and height of the simple shadow.  Valid range is [32, 1024].
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_ignore_transparency Whether any segment-level transparency setting should be ignored when rendering the simple shadow.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleShadow(bool in_state, unsigned int in_resolution = 256, unsigned int in_blurring = 1, bool in_ignore_transparency = false);

	/*!	Manipulates the state of simple shadows, projected onto a plane.  The state is implicitly on.
	*	\param in_resolution The width and height of the simple shadow. Valid range is [32, 1024].
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_ignore_transparency Whether any segment-level transparency setting should be ignored when rendering the simple shadow.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleShadow(unsigned int in_resolution, unsigned int in_blurring, bool in_ignore_transparency);

	/*!	Manipulates the location and orientation of the plane that simple shadows are projected onto.
	*	\param in_projected_onto The plane that simple shadows should be projected onto.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleShadowPlane(Plane const & in_projected_onto = Plane(0.0f, 1.0f, 0.0f, 1.0f));

	/*!	Sets the direction that the light source for a simple shadow is coming from.
	*	\param in_direction The direction that the light source for a simple shadow is coming from.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleShadowLightDirection(Vector const & in_direction = Vector(0.0f, 1.0f, 0.0f));

	/*!	Sets the color that simple shadows will be rendered in.
	*	\param in_color The color of simple shadows.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleShadowColor(RGBAColor const & in_color = RGBAColor(0.0f, 0.0f, 0.0f, 1.0f));

	/*!	Manipulates the state of simple reflections, projected onto a plane.
	*	\param in_state Whether simple shadows should be used.
	*	\param in_opacity An alpha value that sets the transparency level of the reflection plane.  Valid range is [0,1] with a value of zero making the plane completely transparent.
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_fading Whether the reflection plane should fade as it moves away from the camera.
	*	\param in_attenuation_near_distance The orthogonal distances (in world space) from the reflection plane that the model begins to fade.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\param in_attenuation_far_distance The orthogonal distances (in world space) from the reflection plane that the model is completely faded.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleReflection(bool in_state, float in_opacity = 0.5f, unsigned int in_blurring = 1, bool in_fading = false, float in_attenuation_near_distance = 0.0f, float in_attenuation_far_distance = Float::Infinity);

	/*!	Manipulates the state of simple reflections, projected onto a plane.  The state is implicitly on.
	*	\param in_opacity An alpha value that sets the transparency level of the reflection plane.  Valid range is [0,1] with a value of zero making the plane completely transparent.
	*	\param in_blurring The level of blurring (softening) that is applied to the shadow.  Valid range is [1,31].
	*	\param in_fading Whether the reflection plane should fade as it moves away from the camera.
	*	\param in_attenuation_near_distance The orthogonal distances (in world space) from the reflection plane that the model begins to fade.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\param in_attenuation_far_distance The orthogonal distances (in world space) from the reflection plane that the model is completely faded.
	*		Attenuation begins at in_attenuation_near_distance and increases linearly such that the model is not visible in the reflection beyond in_attenuation_far_distance.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleReflection(float in_opacity, unsigned int in_blurring, bool in_fading, float in_attenuation_near_distance, float in_attenuation_far_distance);

	/*!	Manipulates the location and orientation of the plane that simple reflections are projected onto.
	*	\param in_projected_onto The plane that simple reflections should be projected onto.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleReflectionPlane(Plane const & in_projected_onto = Plane(0.0f, 1.0f, 0.0f, 1.0f));

	/*!	Defines the visibility settings for the model when rendered in the reflection plane.
	*	\param in_reflected_types A collection of visibility settings that will be applied to the reflected geometry.
	*	\return A reference to this object. */
	VisualEffectsControl &		SetSimpleReflectionVisibility(VisibilityKit const & in_reflected_types);


	/*!	Removes any post-processing effects setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetPostProcessEffectsEnabled();

	/*!	Removes ambient occlusion setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetAmbientOcclusionEnabled();

	/*!	Removes any silhouette edges setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSilhouetteEdgesEnabled();

	/*!	Removes any depth of field setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetDepthOfFieldEnabled();

	/*!	Removes any bloom setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetBloomEnabled();

	/*!	Removes any eye dome lighting setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetEyeDomeLightingEnabled();

	/*!	Removes any eye dome lighting back color setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	 *	\return A reference to this object. */
	VisualEffectsControl &		UnsetEyeDomeLightingBackColor();

	/*!	Removes any anti-alias setting(text and screen). If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object.
	*	\deprecated This function exists for compatibility and UnsetTextAntiAliasing() should be preferred in general usage. */
	VisualEffectsControl &		UnsetAntiAliasing();

		/*!	Removes any text anti-alias setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetTextAntiAliasing();

	/*!	Removes any shadow maps setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetShadowMaps();

	/*!	Removes any simple shadow setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleShadow();

	/*!	Removes any simple shadow plane setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleShadowPlane();

	/*!	Removes any simple shadow light direction setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleShadowLightDirection();

	/*!	Removes any simple shadow color setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleShadowColor();

	/*!	Removes any simple reflection setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleReflection();

	/*!	Removes any simple reflection plane setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleReflectionPlane();

	/*!	Removes any simple reflection visibility setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetSimpleReflectionVisibility();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by VisualEffectsKit::GetDefault().
	*	\return A reference to this object. */
	VisualEffectsControl &		UnsetEverything();


	/*! Shows the post-processing effects setting.
	*	\param out_state Whether all post-processing effects are enabled for the segment.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPostProcessEffectsEnabled(bool & out_state) const;

	/*! Shows the ambient occlusion setting for the segment.
	*	\param out_state Whether ambient occlusion is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAmbientOcclusionEnabled(bool & out_state) const;

	/*! Shows the silhouette edges setting for the segment.
	*	\param out_state Whether silhouette edges are enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSilhouetteEdgesEnabled(bool & out_state) const;

	/*! Shows the depth of field setting for the segment.
	*	\param out_state Whether depth of field is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDepthOfFieldEnabled(bool & out_state) const;

	/*! Shows the bloom setting for the segment.
	*	\param out_state Whether bloom is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowBloomEnabled(bool & out_state) const;

	/*! Shows the eye dome lighting setting for the segment.
	*	\param out_state Whether eye dome lighting is enabled.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEyeDomeLightingEnabled(bool & out_state) const;

	/*! Shows the eye dome lighting back color setting.
	 *	\param out_state Whether a back color should be used for eye dome lighting.
	 *	\param out_color The color to use for the back of a point for eye dome lighting.
	 *	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowEyeDomeLightingBackColor(bool & out_state, RGBColor & out_color) const;

	/*! Shows the anti-aliasing setting.
	*	\param out_state Whether anti-aliasing(text and screen) should be used.
	*	\return <span class='code'>true</span> if the setting(text and screen) is valid, <span class='code'>false</span> otherwise.
	*	\deprecated This function exists for compatibility and ShowTextAntiAliasing(bool & out_state) should be preferred in general usage. */
	bool						ShowAntiAliasing(bool & out_state) const;

		/*! Shows the text anti-aliasing setting.
	*	\param out_state Whether anti-aliasing should be used.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTextAntiAliasing(bool & out_state) const;

	/*! Shows the shadow maps setting.
	*	\param out_state Whether shadow maps should be used.
	*	\param out_samples The number of locations in the shadow map used to determine the percentage value of light received by a pixel in the rendered scene.
	*	\param out_resolution The width and height of the shadow map.
	*	\param out_view_dependent When enabled, the view frustum is taken into account when generating shadow maps.
	*	\param out_jitter Whether stochastic sampling of shadow maps should be use to reduce aliasing in the shadow map.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowShadowMaps(bool & out_state, unsigned int & out_samples, unsigned int & out_resolution, bool & out_view_dependent, bool & out_jitter) const;

	/*! Shows the simple shadow setting.
	*	\param out_state Whether simple shadows should be used.
	*	\param out_resolution The width and height of the simple shadow.
	*	\param out_blurring The level of blurring (softening) that is applied to the shadow.
	*	\param out_ignore_transparency Whether any segment-level transparency setting should be ignored when rendering the simple shadow.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleShadow(bool & out_state, unsigned int & out_resolution, unsigned int & out_blurring, bool & out_ignore_transparency) const;

	/*! Shows the simple shadow plane setting.
	*	\param out_projected_onto The plane that simple shadows should be projected onto.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleShadowPlane(Plane & out_projected_onto) const;

	/*! Shows the simple shadow light direction setting.
	*	\param out_direction The direction that the light source for a simple shadow is coming from.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleShadowLightDirection(Vector & out_direction) const;

	/*! Shows the simple shadow color setting.
	*	\param out_color The color of simple shadows.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleShadowColor(RGBAColor & out_color) const;

	/*! Shows the simple reflection setting.
	*	\param out_state Whether simple shadows should be used.
	*	\param out_opacity An alpha value that sets the transparency level of the reflection plane.
	*	\param out_blurring The level of blurring (softening) that is applied to the shadow.
	*	\param out_fading Whether the reflection plane should fade as it moves away from the camera.
	*	\param out_attenuation_near_distance The orthogonal distances (in world space) from the reflection plane that the model begins to fade.
	*	\param out_attenuation_far_distance The orthogonal distances (in world space) from the reflection plane that the model is completely faded.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleReflection(bool & out_state, float & out_opacity, unsigned int & out_blurring, bool & out_fading, float & out_attenuation_near_distance, float & out_attenuation_far_distance) const;

	/*! Shows the simple reflection plane setting.
	*	\param out_projected_onto The plane that simple reflections should be projected onto.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleReflectionPlane(Plane & out_projected_onto) const;

	/*! Shows the simple shadow visibility setting.
	*	\param out_reflected_types A collection of visibility settings that will be applied to the reflected geometry.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSimpleReflectionVisibility(VisibilityKit & out_reflected_types) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	VisualEffectsControl();
};



/*! The HPS::ContourLineKit class is a user space object, useful for carrying a group of attribute settings. Calling HPS::ContourLineKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#contour-lines">this table</a>. */
class HPS_API ContourLineKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	ContourLineKit();

	/*! The copy constructor creates a new ContourLineKit object that contains the same settings as the source object.
	* 	\param in_kit The source object to copy. */
	ContourLineKit(ContourLineKit const & in_kit);

	/*! The move constructor creates a ContourLineKit by transferring the underlying impl of the rvalue reference to this ContourLineKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ContourLineKit to take the impl from.*/
	ContourLineKit(ContourLineKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ContourLineKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a ContourLineKit to take the impl from.
	* \return A reference to this ContourLineKit. */
	ContourLineKit & operator=(ContourLineKit && in_that);

	/*! Destroy this kit. */
	virtual ~ContourLineKit();

	static const HPS::Type staticType = HPS::Type::ContourLineKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Creates a ContourLineKit which contains the default settings.  The returned object will not necessarily have values
	* 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	* 	\return A ContourLineKit with the default settings. */
	static ContourLineKit	GetDefault();

	/*! Copies the source ContourLineKit into this object.
	* 	\param in_kit The source object to copy. */
	void					Set(ContourLineKit const & in_kit);

	/*! Copies this object into the given ContourLineKit.
	* 	\param out_kit The ContourLineKit to populate with the contents of this object. */
	void					Show(ContourLineKit & out_kit) const;

	/*! Copies the source ContourLineKit into this object.
	* 	\param in_kit The source ContourLineKit to copy.
	* 	\return A reference to this object. */
	ContourLineKit &		operator=(ContourLineKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source ContourLineKit is equivalent to this object.
	*	\param in_kit The source ContourLineKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(ContourLineKit const & in_kit) const;

	/*!	Check if the source ContourLineKit is equivalent to this object.
	 *	\param in_kit The source ContourLineKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(ContourLineKit const & in_kit) const;

	/*!	Check if the source ContourLineKit is not equivalent to this object.
	 *	\param in_kit The source ContourLineKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(ContourLineKit const & in_kit) const;


	/*! Determines whether contour lines should be rendered.
	*	\param in_state Whether contour lines should be rendered.
	*	\return A reference to this object. */
	ContourLineKit &		SetVisibility(bool in_state);

	/*! Controls the positioning of contour lines.  This variant creates them at regular intervals with an optional offset.
	*	\param in_interval The number of units between contour lines.
	*	\param in_offset The starting point for contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetPositions(float in_interval, float in_offset);

	/*! Controls the positioning of contour lines.  This variant defines explicit locations that contour lines should appear at.
	*	\param in_positions An array of explicit locations to draw contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetPositions(FloatArray const & in_positions);

	/*! Controls the positioning of contour lines.  This variant defines explicit locations that contour lines should appear at.
	*	\param in_count The number of elements in in_positions.
	*	\param in_positions An array of explicit locations to draw contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetPositions(size_t in_count, float const in_positions[]);

	/*! Sets the colors to be used for drawing contour lines.  If there are more contour lines than colors, the array will be cycled through.
	*	\param in_colors An array of colors to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetColors(RGBColorArray const & in_colors);

	/*! Sets the colors to be used for drawing contour lines.  If there are more contour lines than colors, the array will be cycled through.
	*	\param in_count The number of elements in in_colors.
	*	\param in_colors An array of colors to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetColors(size_t in_count, RGBColor const in_colors[]);

	/*! Sets the color to be used for drawing all contour lines.
	*	\param in_color The color to be used for drawing all contour lines
	*	\return A reference to this object. */
	ContourLineKit &		SetColors(RGBColor const & in_color);

	/*! Sets the line patterns to be used for drawing contour lines.  If there are more contour lines than patterns, the array will be cycled through.
	*	\param in_patterns An array of line pattern names, defined in an accessible portfolio, to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetPatterns(UTF8Array const & in_patterns);

	/*! Sets the line patterns to be used for drawing contour lines.  If there are more contour lines than patterns, the array will be cycled through.
	*	\param in_count The number of elements in in_patterns.
	*	\param in_patterns An array of line pattern names, defined in an accessible portfolio, to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetPatterns(size_t in_count, UTF8 const in_patterns[]);

	/*! Sets the line pattern to be used for drawing all contour lines.
	*	\param in_pattern The line pattern name, defined in an accessible portfolio, to be used for drawing all contour lines.
	*	\return A reference to this object. */
	ContourLineKit &		SetPatterns(char const * in_pattern);

	/*! Sets the line weights to be used for drawing contour lines.  If there are more contour lines than weights, the array will be cycled through.
	*	\param in_weights An array of line weights to be applied to contour lines.
	*	\param in_units An array of line weight units used with the corresponding entry in in_weights.
	*	\return A reference to this object. */
	ContourLineKit &		SetWeights(FloatArray const & in_weights, LineSizeUnitsArray const & in_units);

	/*! Sets the line weights to be used for drawing contour lines.  If there are more contour lines than weights, the array will be cycled through.
	*	\param in_count The number of elements in both in_weights and in_units.
	*	\param in_weights An array of line weights to be applied to contour lines.
	*	\param in_units An array of line weight units used with the corresponding entry in in_weights.
	*	\return A reference to this object. */
	ContourLineKit &		SetWeights(size_t in_count, float const in_weights[], Line::SizeUnits const in_units[]);

	/*! Sets the line weight to be used for drawing all contour lines.
	*	\param in_weight The line weight to be used for drawing all contour lines.
	*	\param in_units The units associated with in_weight.
	*	\return A reference to this object. */
	ContourLineKit &		SetWeights(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);

	/*! Controls whether contour lines are lit.
	*	\param in_state Whether contour lines are lit.
	*	\return A reference to this object. */
	ContourLineKit &		SetLighting(bool in_state);


	/*! Removes the contour line visibility setting.
	*	\return A reference to this object. */
	ContourLineKit &		UnsetVisibility();

	/*! Removes the contour line positions setting.
	*	\return A reference to this object. */
	ContourLineKit &		UnsetPositions();

	/*! Removes the contour line colors setting.
	*	\return A reference to this object. */
	ContourLineKit &		UnsetColors();

	/*! Removes the contour line patterns setting.
	*	\return A reference to this object. */
	ContourLineKit &		UnsetPatterns();

	/*! Removes the contour line weights setting.
	*	\return A reference to this object. */
	ContourLineKit &		UnsetWeights();

	/*! Removes the contour line lighting setting.
	*	\return A reference to this object. */
	ContourLineKit &		UnsetLighting();

	/*! Removes all settings from this object.
	 *	\return A reference to this object. */
	ContourLineKit &		UnsetEverything();


	/*! Shows the visibility state of contour lines.
	*	\param out_state Whether contour lines should be rendered.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowVisibility(bool & out_state) const;

	/*! Shows the positions of contour lines.
	*	\param out_mode Whether the positions repeat at some interval or are an explicit list.
	*	\param out_positions If out_mode is Repeating, this will contain the interval and offset, in that order.
			Otherwise it will contain the explicit list specified.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPositions(ContourLine::Mode & out_mode, FloatArray & out_positions) const;

	/*! Shows the colors of contour lines.
	*	\param out_colors An array of colors of contour lines
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowColors(RGBColorArray & out_colors) const;

	/*! Shows the line patterns of contour lines.
	*	\param out_patterns An array of line pattern names for contour lines.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPatterns(UTF8Array & out_patterns) const;

	/*! Shows the line weights of contour lines.
	*	\param out_weights An array of line weights for contour lines.
	*	\param out_units An array of line weight units, each is applied to the corresponding entry in out_weights
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWeights(FloatArray & out_weights, LineSizeUnitsArray & out_units) const;

	/*! Shows whether contour lines should be lit.
	*	\param out_state Whether contour lines should be lit.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLighting(bool & out_state) const;
};

/*!
<p>The HPS::ContourLineControl class is a smart pointer that is tied to a database object. As its name suggests, this object can be used to control the various attributes related to contour lines, such as pattern, position, color, and weight. <a href="../../prog_guide/appendix_default_attribute_values.html#contour-lines">This table</a> lists default values for the various segment attributes accessible from HPS::ContourLineControl.</p>
*/
class HPS_API ContourLineControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit ContourLineControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	ContourLineControl(ContourLineControl const & in_that);

	/*! The move constructor creates a ContourLineControl by transferring the underlying impl of the rvalue reference to this ContourLineControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ContourLineControl to take the impl from.*/
	ContourLineControl(ContourLineControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ContourLineControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a ContourLineControl to take the impl from.
	* \return A reference to this ContourLineControl. */
	ContourLineControl & operator=(ContourLineControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~ContourLineControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::ContourLineControl;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the ContourLineControl source.
	 *	\param in_that The ContourLineControl source of the assignment.
	 *	\return A reference to this ContourLineControl. */
	ContourLineControl &		operator=(ContourLineControl const & in_that);

	/*! Determines whether contour lines should be rendered.
	*	\param in_state Whether contour lines should be rendered.
	*	\return A reference to this object. */
	ContourLineControl &		SetVisibility(bool in_state);

	/*! Controls the positioning of contour lines.  This variant creates them at regular intervals with an optional offset.
	*	\param in_interval The number of units between contour lines.
	*	\param in_offset The starting point for contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetPositions(float in_interval, float in_offset);

	/*! Controls the positioning of contour lines.  This variant defines explicit locations that contour lines should appear at.
	*	\param in_positions An array of explicit locations to draw contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetPositions(FloatArray const & in_positions);

	/*! Controls the positioning of contour lines.  This variant defines explicit locations that contour lines should appear at.
	*	\param in_count The number of elements in in_positions.
	*	\param in_positions An array of explicit locations to draw contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetPositions(size_t in_count, float const in_positions[]);

	/*! Sets the colors to be used for drawing contour lines.  If there are more contour lines than colors, the array will be cycled through.
	*	\param in_colors An array of colors to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetColors(RGBColorArray const & in_colors);

	/*! Sets the colors to be used for drawing contour lines.  If there are more contour lines than colors, the array will be cycled through.
	*	\param in_count The number of elements in in_colors.
	*	\param in_colors An array of colors to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetColors(size_t in_count, RGBColor const in_colors[]);

	/*! Sets the color to be used for drawing all contour lines.
	*	\param in_rgb_color The color to be used for drawing all contour lines
	*	\return A reference to this object. */
	ContourLineControl &		SetColors(RGBColor const & in_rgb_color);

	/*! Sets the line patterns to be used for drawing contour lines.  If there are more contour lines than patterns, the array will be cycled through.
	*	\param in_patterns An array of line pattern names, defined in an accessible portfolio, to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetPatterns(UTF8Array const & in_patterns);

	/*! Sets the line patterns to be used for drawing contour lines.  If there are more contour lines than patterns, the array will be cycled through.
	*	\param in_count The number of elements in in_patterns.
	*	\param in_patterns An array of line pattern names, defined in an accessible portfolio, to be used for drawing contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetPatterns(size_t in_count, UTF8 const in_patterns[]);

	/*! Sets the line pattern to be used for drawing all contour lines.
	*	\param in_pattern The line pattern name, defined in an accessible portfolio, to be used for drawing all contour lines.
	*	\return A reference to this object. */
	ContourLineControl &		SetPatterns(char const * in_pattern);

	/*! Sets the line weights to be used for drawing contour lines.  If there are more contour lines than weights, the array will be cycled through.
	*	\param in_weights An array of line weights to be applied to contour lines.
	*	\param in_units An array of line weight units used with the corresponding entry in in_weights.
	*	\return A reference to this object. */
	ContourLineControl &		SetWeights(FloatArray const & in_weights, LineSizeUnitsArray const & in_units);

	/*! Sets the line weights to be used for drawing contour lines.  If there are more contour lines than weights, the array will be cycled through.
	*	\param in_count The number of elements in both in_weights and in_units.
	*	\param in_weights An array of line weights to be applied to contour lines.
	*	\param in_units An array of line weight units used with the corresponding entry in in_weights.
	*	\return A reference to this object. */
	ContourLineControl &		SetWeights(size_t in_count, float const in_weights[], Line::SizeUnits const in_units[]);

	/*! Sets the line weight to be used for drawing all contour lines.
	*	\param in_weight The line weight to be used for drawing all contour lines.
	*	\param in_units The units associated with in_weight.
	*	\return A reference to this object. */
	ContourLineControl &		SetWeights(float in_weight, Line::SizeUnits in_units = Line::SizeUnits::ScaleFactor);

	/*! Controls whether contour lines are lit.
	*	\param in_state Whether contour lines are lit.
	*	\return A reference to this object. */
	ContourLineControl &		SetLighting(bool in_state);


	/*! Removes the contour line visibility setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ContourLineKit::GetDefault().
	*	\return A reference to this object. */
	ContourLineControl &		UnsetVisibility();

	/*! Removes the contour line positions setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ContourLineKit::GetDefault().
	*	\return A reference to this object. */
	ContourLineControl &		UnsetPositions();

	/*! Removes the contour line colors setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ContourLineKit::GetDefault().
	*	\return A reference to this object. */
	ContourLineControl &		UnsetColors();

	/*! Removes the contour line patterns setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ContourLineKit::GetDefault().
	*	\return A reference to this object. */
	ContourLineControl &		UnsetPatterns();

	/*! Removes the contour line weights setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ContourLineKit::GetDefault().
	*	\return A reference to this object. */
	ContourLineControl &		UnsetWeights();

	/*! Removes the contour line lighting setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by ContourLineKit::GetDefault().
	*	\return A reference to this object. */
	ContourLineControl &		UnsetLighting();

	/*! Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by ContourLineKit::GetDefault().
	 *	\return A reference to this object. */
	ContourLineControl &		UnsetEverything();


	/*! Shows the visibility state of contour lines.
	*	\param out_state Whether contour lines should be rendered.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVisibility(bool & out_state) const;

	/*! Shows the positions of contour lines.
	*	\param out_mode Whether the positions repeat at some interval or are an explicit list.
	*	\param out_positions If out_mode is Repeating, this will contain the interval and offset, in that order.
			Otherwise it will contain the explicit list specified.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPositions(ContourLine::Mode & out_mode, FloatArray & out_positions) const;

	/*! Shows the colors of contour lines.
	*	\param out_colors An array of colors of contour lines
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowColors(RGBColorArray & out_colors) const;

	/*! Shows the line patterns of contour lines.
	*	\param out_patterns An array of line pattern names for contour lines.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPatterns(UTF8Array & out_patterns) const;

	/*! Shows the line weights of contour lines.
	*	\param out_weights An array of line weights for contour lines.
	*	\param out_units An array of line weight units, each is applied to the corresponding entry in out_weights
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowWeights(FloatArray & out_weights, LineSizeUnitsArray & out_units) const;

	/*! Shows whether contour lines should be lit.
	*	\param out_state Whether contour lines should be lit.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLighting(bool & out_state) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	ContourLineControl();
};



/*! The HPS::SubwindowKit class is a user space object, useful for carrying a group of attribute settings related to subwindows. Calling HPS::SubwindowKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#subwindows">this table</a>. */
class HPS_API SubwindowKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	SubwindowKit();

	/*! Copies the kit in_kit into this kit. */
	SubwindowKit(SubwindowKit const & in_kit);

	/*! The move constructor creates a SubwindowKit by transferring the underlying impl of the rvalue reference to this SubwindowKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SubwindowKit to take the impl from.*/
	SubwindowKit(SubwindowKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SubwindowKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a SubwindowKit to take the impl from.
	* \return A reference to this SubwindowKit. */
	SubwindowKit & operator=(SubwindowKit && in_that);

	/*! Destroy this kit. */
	virtual ~SubwindowKit();

	static const HPS::Type staticType = HPS::Type::SubwindowKit;
	HPS::Type			ObjectType() const {return staticType;}

	/*! Creates a SubwindowKit which contains the default settings.  The returned object will not necessarily have values
	* 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	* 	\return A SubwindowKit with the default settings. */
	static SubwindowKit GetDefault();

	/*! Copies the source SubwindowKit into this object.
	* 	\param in_kit The source object to copy. */
	void				Set(SubwindowKit const & in_kit);

	/*! Copies this object into the given SubwindowKit.
	* 	\param out_kit The SubwindowKit to populate with the contents of this object. */
	void				Show(SubwindowKit & out_kit) const;

	/*! Copies the source SubwindowKit into this object.
	* 	\param in_kit The source SubwindowKit to copy.
	* 	\return A reference to this object. */
	SubwindowKit &		operator=(SubwindowKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source SubwindowKit is equivalent to this object.
	*	\param in_kit The source SubwindowKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(SubwindowKit const & in_kit) const;

	/*!	Check if the source SubwindowKit is equivalent to this object.
	 *	\param in_kit The source SubwindowKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(SubwindowKit const & in_kit) const;

	/*!	Check if the source SubwindowKit is not equivalent to this object.
	 *	\param in_kit The source SubwindowKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(SubwindowKit const & in_kit) const;


	/*! Defines a portion of the containing window to act as a subwindow.
	*	Window segments have an implicit subwindow of -1 to 1 in both x and y directions that cannot be changed.
	*	Other segments can be constrained to some portion of that space.
	*	Most other subwindow-related settings are only relevant if they are applied on a segment that also contains a subwindow.
	*	\param in_subwindow_position The portion of the containing window that should be reserved for a subwindow.
	*		The subwindow is defined in the context of a rectangle extending out a single unit in each direction from the origin.
	*		For example, a subwindow rectangle defined as Rectangle(0, 1, -1, 0) would occupy the lower right quarter of the containing window.
	*	\param in_subwindow_type The type of subwindow to create.
	*	\return A reference to this object. */
	SubwindowKit &		SetSubwindow(Rectangle const & in_subwindow_position, Subwindow::Type in_subwindow_type = Subwindow::Type::Standard);


	/*! Defines a portion of the containing window to act as a subwindow.
	*	Window segments have an implicit subwindow of -1 to 1 in both x and y directions that cannot be changed.
	*	Other segments can be constrained to some portion of that space.
	*	Most other subwindow-related settings are only relevant if they are applied on a segment that also contains a subwindow.
	*	\param in_subwindow_position The portion of the containing window that should be reserved for a subwindow.
	*		The subwindow is defined in the context of a rectangle extending out a single unit in each direction from the origin.
	*		For example, a subwindow rectangle defined as Rectangle(0, 1, -1, 0) would occupy the lower right quarter of the containing window.
	*	\param in_subwindow_offsets The pixel-space offsets to apply to each side of the given window position.
	*	\param in_subwindow_type The type of subwindow to create.
	*	\return A reference to this object. */
	SubwindowKit &		SetSubwindow(Rectangle const & in_subwindow_position, IntRectangle const & in_subwindow_offsets, Subwindow::Type in_subwindow_type = Subwindow::Type::Standard);


	/*! Controls the type of background to be used for subwindows originating from this segment.
	*	This has no effect when applied to segments without a subwindow present.
	*	\param in_bg_type The type of background to be used for subwindows originating from this segment.
	*	\param in_definition_name the name of a definition to be used in the background.
	*		Only relevant if in_bg_type is Image or Cubemap.
	*	\return A reference to this object. */
	SubwindowKit &		SetBackground(Subwindow::Background in_bg_type, char const * in_definition_name = "");

	/*! Controls the type of border, if any, that should be drawn for subwindows originating from this segment.
	*	This has no effect when applied to segments without a subwindow present.
	*	\param in_border_type The type of border, if any, that should be drawn for subwindows originating from this segment.
	*	\return A reference to this object. */
	SubwindowKit &		SetBorder(Subwindow::Border in_border_type);

	/*!	Determines the algorithm used to remove objects (or parts of objects) that are hidden from view by other objects.
	*	This has no effect when applied to segments without a subwindow present.
	*	\param in_hsra The algorithm used to identify and remove hidden surfaces.
	*	\return A reference to this object. */
	SubwindowKit &		SetRenderingAlgorithm(Subwindow::RenderingAlgorithm in_hsra);

	/*!	Sets 'model compare' rendering mode which displays a visual diff between the two source segments in this subwindow.
	*	\param in_state Toggles compare mode on or off.
	*	\param in_source1 The first source model.
	*	\param in_source2 The second source model.
	*	\return A reference to this object. */
	SubwindowKit &		SetModelCompareMode(bool in_state, SegmentKey const & in_source1 = SegmentKey(), SegmentKey const & in_source2 = SegmentKey());

	/*!	Sets 'model compare' rendering mode which displays a visual diff between the two source segments in this subwindow.
	*	\param in_source1 The first source model.
	*	\param in_source2 The second source model.
	*	\return A reference to this object. */
	SubwindowKit &		SetModelCompareMode(SegmentKey const & in_source1, SegmentKey const & in_source2);

	/*!	Removes a subwindow setting.
	*	\return A reference to this object. */
	SubwindowKit &		UnsetSubwindow();

	/*!	Removes a subwindow background setting.
	*	\return A reference to this object. */
	SubwindowKit &		UnsetBackground();

	/*!	Removes a subwindow border setting.
	*	\return A reference to this object. */
	SubwindowKit &		UnsetBorder();

	/*!	Removes a rendering algorithm setting.
	*	\return A reference to this object. */
	SubwindowKit &		UnsetRenderingAlgorithm();

	/*!	Removes model compare setting.
	*	\return A reference to this object. */
	SubwindowKit &		UnsetModelCompareMode();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	SubwindowKit &		UnsetEverything();

	/*! Shows the subwindow setting.
	*	\param out_subwindow_position The portion of the containing window that should be reserved for a subwindow.
	*	\param out_subwindow_offsets The pixel-space offsets being applied to the subwindow position.
	*	\param out_subwindow_type The type of subwindow to create.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowSubwindow(Rectangle & out_subwindow_position, IntRectangle & out_subwindow_offsets, Subwindow::Type & out_subwindow_type) const;

	/*! Shows the window background setting
	*	\param out_bg_type The type of background to be used for subwindows originating from this segment.
	*	\param out_definition_name the name of a definition to be used in the background.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowBackground(Subwindow::Background & out_bg_type, UTF8 & out_definition_name) const;

	/*! Shows the subwindow border setting
	*	\param out_border_type The type of border, if any, that should be drawn for subwindows originating from this segment.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowBorder(Subwindow::Border & out_border_type) const;

	/*! Shows the rendering algorithm setting.
	*	\param out_hsra The algorithm used to identify and remove hidden surfaces.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowRenderingAlgorithm(Subwindow::RenderingAlgorithm & out_hsra) const;

	/*! Shows the model compare setting.
	*	\param out_state The model compare enabled state.
	*	\param out_source1 The first source model.
	*	\param out_source2 The second source model.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowModelCompareMode(bool & out_state, SegmentKey & out_source1, SegmentKey & out_source2) const;
};



/*!
<p>The HPS::SubwindowControl class is a smart pointer that is tied to a database object. The HPS::SubwindowControl allows you to manipulate the various settings associated with subwindows, such as border, background, and priority. As the main Visualize window is also an implicit subwindow, this control also allows you to set the rendering algorithm. The rendering algorithm should only have a single setting for each window or subwindow. Setting disparate rendering algorithms in multiple places in your scene can lead to unexpected results. </p>

<p>Default values for the various fields of HPS::SubwindowControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#subwindows">here</a>.</p>
*/
class HPS_API SubwindowControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit SubwindowControl(SegmentKey & in_seg);

	/*! Initializes a control tied to the same object as in_that. */
	SubwindowControl(SubwindowControl const & in_that);

	/*! The move constructor creates a SubwindowControl by transferring the underlying impl of the rvalue reference to this SubwindowControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SubwindowControl to take the impl from.*/
	SubwindowControl(SubwindowControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SubwindowControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a SubwindowControl to take the impl from.
	* \return A reference to this SubwindowControl. */
	SubwindowControl & operator=(SubwindowControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~SubwindowControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::SubwindowControl;
	HPS::Type			ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer of the SubwindowControl source.
	 *	\param in_that The SubwindowControl source of the assignment.
	 *	\return A reference to this SubwindowControl. */
	SubwindowControl &	operator=(SubwindowControl const & in_that);

	/*! Defines a portion of the containing window to act as a subwindow.
	*	Window segments have an implicit subwindow of -1 to 1 in both x and y directions that cannot be changed.
	*	Other segments can be constrained to some portion of that space.
	*	Most other subwindow-related settings are only relevant if they are applied on a segment that also contains a subwindow.
	*	\param in_window_position The portion of the containing window that should be reserved for a subwindow.
	*		The subwindow is defined in the context of a rectangle extending out a single unit in each direction from the origin.
	*		For example, a subwindow rectangle defined as Rectangle(0, 1, -1, 0) would occupy the lower right quarter of the containing window.
	*	\param in_type The type of subwindow to create.
	*	\return A reference to this object.
	*	\sa Subwindow <a href="../../prog_guide/appendix_default_attribute_values.html#implicit-subwindow">default value</a> */
	SubwindowControl &	SetSubwindow(Rectangle const & in_window_position, Subwindow::Type in_type = Subwindow::Type::Standard);

	/*! Defines a portion of the containing window to act as a subwindow.
	*	Window segments have an implicit subwindow of -1 to 1 in both x and y directions that cannot be changed.
	*	Other segments can be constrained to some portion of that space.
	*	Most other subwindow-related settings are only relevant if they are applied on a segment that also contains a subwindow.
	*	\param in_window_position The portion of the containing window that should be reserved for a subwindow.
	*		The subwindow is defined in the context of a rectangle extending out a single unit in each direction from the origin.
	*		For example, a subwindow rectangle defined as Rectangle(0, 1, -1, 0) would occupy the lower right quarter of the containing window.
	*	\param in_window_offsets The pixel-space offsets to apply to each side of the given window position.
	*	\param in_type The type of subwindow to create.
	*	\return A reference to this object.
	*	\sa Subwindow <a href="../../prog_guide/appendix_default_attribute_values.html#implicit-subwindow">default value</a> */
	SubwindowControl &	SetSubwindow(Rectangle const & in_window_position, IntRectangle const & in_window_offsets, Subwindow::Type in_type = Subwindow::Type::Standard);

	/*! Controls the type of background to be used for subwindows originating from this segment.
	*	This has no effect when applied to segments without a subwindow present.
	*	\param in_bg_type The type of background to be used for subwindows originating from this segment.
	*	\param in_definition_name the name of a definition to be used in the background.
	*		Only relevant if in_bg_type is Image or Cubemap.
	*	\return A reference to this object. */
	SubwindowControl &	SetBackground(Subwindow::Background in_bg_type, char const * in_definition_name = "");

	/*! Controls the type of border, if any, that should be drawn for subwindows originating from this segment.
	*	This has no effect when applied to segments without a subwindow present.
	*	\param in_border_type The type of border, if any, that should be drawn for subwindows originating from this segment.
	*	\return A reference to this object. */
	SubwindowControl &	SetBorder(Subwindow::Border in_border_type);

	/*!	Determines the algorithm used to remove objects (or parts of objects) that are hidden from view by other objects.
	*	This has no effect when applied to segments without a subwindow present.
	*	\param in_hsra The algorithm used to identify and remove hidden surfaces.
	*	\return A reference to this object.
	*	\sa Rendering algorithm <a href="../../prog_guide/appendix_default_attribute_values.html#hidden-surface-removal-algorithm">default value</a> */
	SubwindowControl &	SetRenderingAlgorithm(Subwindow::RenderingAlgorithm in_hsra);

	/*!	Sets 'model compare' rendering mode which displays a visual diff between the two source segments in this subwindow.
	*	\param in_state Toggles compare mode on or off.
	*	\param in_source1 The first source model.
	*	\param in_source2 The second source model.
	*	\return A reference to this object. */
	SubwindowControl &	SetModelCompareMode(bool in_state, SegmentKey const & in_source1 = SegmentKey(), SegmentKey const & in_source2 = SegmentKey());

	/*!	Sets 'model compare' rendering mode which displays a visual diff between the two source segments in this subwindow.
	*	\param in_source1 The first source model.
	*	\param in_source2 The second source model.
	*	\return A reference to this object. */
	SubwindowControl &	SetModelCompareMode(SegmentKey const & in_source1, SegmentKey const & in_source2);

	/*!	Removes a subwindow setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SubwindowKit::GetDefault().
	*	\return A reference to this object. */
	SubwindowControl &	UnsetSubwindow();

	/*!	Removes a subwindow background setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SubwindowKit::GetDefault().
	*	\return A reference to this object. */
	SubwindowControl &	UnsetBackground();

	/*!	Removes a subwindow border setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SubwindowKit::GetDefault().
	*	\return A reference to this object. */
	SubwindowControl &	UnsetBorder();

	/*!	Removes a rendering algorithm setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SubwindowKit::GetDefault().
	*	\return A reference to this object. */
	SubwindowControl &	UnsetRenderingAlgorithm();

	/*!	Removes model compare setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by SubwindowKit::GetDefault().
	*	\return A reference to this object. */
	SubwindowControl &	UnsetModelCompareMode();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by SubwindowKit::GetDefault().
	*	\return A reference to this object. */
	SubwindowControl &	UnsetEverything();

	/*! Shows the subwindow setting.
	*	\param out_subwindow_position The portion of the containing window that should be reserved for a subwindow.
	*	\param out_subwindow_offsets The pixel-space offsets being applied to the subwindow position.
	*	\param out_subwindow_type The type of subwindow to create.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowSubwindow(Rectangle & out_subwindow_position, IntRectangle & out_subwindow_offsets, Subwindow::Type & out_subwindow_type) const;

	/*! Shows the window background setting
	*	\param out_bg_type The type of background to be used for subwindows originating from this segment.
	*	\param out_definition_name the name of a definition to be used in the background.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowBackground(Subwindow::Background & out_bg_type, UTF8 & out_definition_name) const;

	/*! Shows the subwindow border setting
	*	\param out_border_type The type of border, if any, that should be drawn for subwindows originating from this segment.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowBorder(Subwindow::Border & out_border_type) const;

	/*! Shows the rendering algorithm setting.
	*	\param out_hsra The algorithm used to identify and remove hidden surfaces.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowRenderingAlgorithm(Subwindow::RenderingAlgorithm & out_hsra) const;

	/*! Shows the model compare setting.
	*	\param out_state The model compare enabled state.
	*	\param out_source1 The first source model.
	*	\param out_source2 The second source model.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowModelCompareMode(bool & out_state, SegmentKey & out_source1, SegmentKey & out_source2) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	SubwindowControl();
};



/*! The HPS::DebuggingKit class is a user space object, useful for carrying a group attribute settings. Calling HPS::DebuggingKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#debugging">this table</a>. */
class HPS_API DebuggingKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	DebuggingKit();

	/*! Copies the kit in_kit into this kit. */
	DebuggingKit(DebuggingKit const & in_kit);

	/*! The move constructor creates a DebuggingKit by transferring the underlying impl of the rvalue reference to this DebuggingKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DebuggingKit to take the impl from.*/
	DebuggingKit(DebuggingKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DebuggingKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a DebuggingKit to take the impl from.
	* \return A reference to this DebuggingKit. */
	DebuggingKit & operator=(DebuggingKit && in_that);

	/*! Destroy this kit. */
	virtual ~DebuggingKit();

	static const HPS::Type staticType = HPS::Type::DebuggingKit;
	HPS::Type				ObjectType() const {return staticType;}

	/*! Creates a DebuggingKit which contains the default settings.  The returned object will not necessarily have values
	* 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	* 	\return A DebuggingKit with the default settings. */
	static DebuggingKit		GetDefault();

	/*! Copies the source DebuggingKit into this object.
	* 	\param in_kit The source object to copy. */
	void					Set(DebuggingKit const & in_kit);

	/*! Copies this object into the given DebuggingKit.
	* 	\param out_kit The DebuggingKit to populate with the contents of this object. */
	void					Show(DebuggingKit & out_kit) const;

	/*! Copies the source DebuggingKit into this object.
	* 	\param in_kit The source DebuggingKit to copy.
	* 	\return A reference to this object. */
	DebuggingKit &			operator=(DebuggingKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source DebuggingKit is equivalent to this object.
	*	\param in_kit The source DebuggingKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(DebuggingKit const & in_kit) const;

	/*!	Check if the source DebuggingKit is equivalent to this object.
	 *	\param in_kit The source DebuggingKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(DebuggingKit const & in_kit) const;

	/*!	Check if the source DebuggingKit is not equivalent to this object.
	 *	\param in_kit The source DebuggingKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(DebuggingKit const & in_kit) const;


	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	DebuggingKit &			UnsetEverything();


	/*! Controls whether a small window will be drawn displaying a number of statistics about the last update.
	*	\param in_display Whether a small window will be drawn displaying a number of statistics about the last update.
	*	\return A reference to this object. */
	DebuggingKit &			SetResourceMonitor(bool in_display);


	/*!	Removes a resource monitor setting.
	*	\return A reference to this object. */
	DebuggingKit &			UnsetResourceMonitor();

	/*! Shows the resource monitor setting.
	*	\param out_display Whether a small window will be drawn displaying a number of statistics about the last update.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowResourceMonitor(bool & out_display) const;
};


/*! The HPS::DebuggingControl class is a smart pointer that is tied to a database object. Using this control, you are able to
	set and show the resource monitor. This control is only accessible from a HPS::WindowKey. <a href="../../prog_guide/appendix_default_attribute_values.html#debugging">This table</a> lists default values for the various segment attributes accessible from HPS::DebuggingControl. */
class HPS_API DebuggingControl : public Control
{
public:

	/*! Initializes a control tied to the window segment in_window. */
	explicit DebuggingControl(WindowKey & in_window);

	/*! Initializes a control tied to the same object as in_that. */
	DebuggingControl(DebuggingControl const & in_that);

	/*! The move constructor creates a DebuggingControl by transferring the underlying impl of the rvalue reference to this DebuggingControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DebuggingControl to take the impl from.*/
	DebuggingControl(DebuggingControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DebuggingControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a DebuggingControl to take the impl from.
	* \return A reference to this DebuggingControl. */
	DebuggingControl & operator=(DebuggingControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~DebuggingControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::DebuggingControl;
	HPS::Type				ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer of the DebuggingControl source.
	 *	\param in_that The DebuggingControl source of the assignment.
	 *	\return A reference to this DebuggingControl. */
	DebuggingControl &		operator=(DebuggingControl const & in_that);

	/*! Controls whether a small window will be drawn displaying a number of statistics about the last update.
	*	\param in_display Whether a small window will be drawn displaying a number of statistics about the last update.
	*	\return A reference to this object.
	*	\sa  Resource monitor <a href="../../prog_guide/appendix_default_attribute_values.html#display-debugging-resource-monitor">default value</a>. */
	DebuggingControl &		SetResourceMonitor(bool in_display);

	/*! Unsets the Resource Monitor setting for this control.  If the control is attached to a WindowKey this function restores the default setting
	 *  as specified by DebuggingKit::GetDefault().
	 *	\return A reference to this object. */
	DebuggingControl &		UnsetResourceMonitor();

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by DebuggingKit::GetDefault().
	*	\return A reference to this object. */
	DebuggingControl &		UnsetEverything();

	/*! Shows the resource monitor setting.
	*	\param out_display Whether a small window will be drawn displaying a number of statistics about the last update.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowResourceMonitor(bool & out_display) const;

private:
	//! Private default constructor to prevent instantiation without a segment.
	DebuggingControl();
};


/*! The WindowInfoKit class is a user space object, useful for carrying a group attribute settings. */
class HPS_API WindowInfoKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	WindowInfoKit();

	/*! Copies the kit in_kit into this kit. */
	WindowInfoKit(WindowInfoKit const & in_kit);

	/*! The move constructor creates a WindowInfoKit by transferring the underlying impl of the rvalue reference to this WindowInfoKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a WindowInfoKit to take the impl from.*/
	WindowInfoKit(WindowInfoKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this WindowInfoKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a WindowInfoKit to take the impl from.
	* \return A reference to this WindowInfoKit. */
	WindowInfoKit & operator=(WindowInfoKit && in_that);

	/*! Destroy this kit. */
	virtual ~WindowInfoKit();

	static const HPS::Type staticType = HPS::Type::WindowInfoKit;
	HPS::Type				ObjectType() const {return staticType;}

	/*! Copies the source WindowInfoKit into this object.
	* 	\param in_kit The source object to copy. */
	void					Set(WindowInfoKit const & in_kit);

	/*! Copies this object into the given WindowInfoKit.
	* 	\param out_kit The WindowInfoKit to populate with the contents of this object. */
	void					Show(WindowInfoKit & out_kit) const;

	/*! Copies the source WindowInfoKit into this object.
	* 	\param in_kit The source WindowInfoKit to copy.
	* 	\return A reference to this object. */
	WindowInfoKit &			operator=(WindowInfoKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source WindowInfoKit is equivalent to this object.
	*	\param in_kit The source WindowInfoKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(WindowInfoKit const & in_kit) const;

	/*!	Check if the source WindowInfoKit is equivalent to this object.
	 *	\param in_kit The source WindowInfoKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(WindowInfoKit const & in_kit) const;

	/*!	Check if the source WindowInfoKit is not equivalent to this object.
	 *	\param in_kit The source WindowInfoKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(WindowInfoKit const & in_kit) const;


	/*! Sets the number of pixels in the physical display (monitor, off-screen renderer, printer, etc.).
	*	\param in_width The width of the physical display in pixels.
	*	\param in_height The height of the physical display in pixels.
	*	\return A reference to this object. */
	WindowInfoKit &			SetPhysicalPixels(unsigned int in_width, unsigned int in_height);

	/*! Sets the size, in centimeters, of the physical display (monitor, off-screen renderer, printer, etc.).
	*	\param in_width The width of the physical display in centimeters.
	*	\param in_height The height of the physical display in centimeters.
	*	\return A reference to this object. */
	WindowInfoKit &			SetPhysicalSize(float in_width, float in_height);

	/*! Sets the number of pixels in the window.
	*	\param in_width The width of the window in pixels.
	*	\param in_height The height of the window in pixels.
	*	\return A reference to this object. */
	WindowInfoKit &			SetWindowPixels(unsigned int in_width, unsigned int in_height);

	/*! Sets the size, in centimeters, of the window.
	*	\param in_width The width of the window in centimeters.
	*	\param in_height The height of the window in centimeters.
	*	\return A reference to this object. */
	WindowInfoKit &			SetWindowSize(float in_width, float in_height);


	/*! Unsets the number of pixels in the physical display (monitor, off-screen renderer, printer, etc.).
	*	\return A reference to this object. */
	WindowInfoKit &			UnsetPhysicalPixels();

	/*! Unsets the size, in centimeters, of the physical display (monitor, off-screen renderer, printer, etc.).
	*	\return A reference to this object. */
	WindowInfoKit &			UnsetPhysicalSize();

	/*! Unsets the number of pixels in the window.
	*	\return A reference to this object. */
	WindowInfoKit &			UnsetWindowPixels();

	/*! Unsets the size, in centimeters, of the window.
	*	\return A reference to this object. */
	WindowInfoKit &			UnsetWindowSize();

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	WindowInfoKit &			UnsetEverything();


	/*! Shows the number of pixels in the physical display (monitor, off-screen renderer, printer, etc.).
	*	\param out_width The width of the physical display in pixels.
	*	\param out_height The height of the physical display in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPhysicalPixels(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the size, in centimeters, of the physical display (monitor, off-screen renderer, printer, etc.).
	*	\param out_width The width of the physical display in centimeters.
	*	\param out_height The height of the physical display in centimeters.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPhysicalSize(float & out_width, float & out_height) const;

	/*! Shows the number of pixels in the window.
	*	\param out_width The width of the window in pixels.
	*	\param out_height The height of the window in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowPixels(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the size, in centimeters, of the window.
	*	\param out_width The width of the window in centimeters.
	*	\param out_height The height of the window in centimeters.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowSize(float & out_width, float & out_height) const;

	/*! Shows both the horizontal and vertical resolution of the window. Resolution is computed as pixels per centimeter.
	*	If the size or the pixels are not set, this function will return <span class='code'>false</span>.
	*	\param out_horizontal The horizontal resolution of the window.
	*	\param out_vertical The vertical resolution of the window.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowResolution(float & out_horizontal, float & out_vertical) const;

	/*! Shows the aspect ratio of the window.  Aspect ratio is computed as width / height in centimeters.
	*	\param out_window_aspect The aspect ratio of the window defined as width / height in centimeters.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowAspectRatio(float & out_window_aspect) const;

	/*! Shows the aspect ratio of the window's pixels.  This is computed as the horizontal resolution divided by the vertical resolution.
	*	\param out_pixel_aspect The aspect ratio of the window defined as width / height in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPixelAspectRatio(float & out_pixel_aspect) const;
};


/*! The WindowInfoControl class is a smart pointer that is tied to a database object. This object allows you to query various
	attributes about a window, such as its size and aspect ratio. */
class HPS_API WindowInfoControl : public Control
{
public:

	/*! Initializes a control tied to the window segment in_window. */
	explicit WindowInfoControl(WindowKey & in_window);

	/*! Initializes a control tied to the same object as in_that. */
	WindowInfoControl(WindowInfoControl const & in_that);

	/*! The move constructor creates a WindowInfoControl by transferring the underlying impl of the rvalue reference to this WindowInfoControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a WindowInfoControl to take the impl from.*/
	WindowInfoControl(WindowInfoControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this WindowInfoControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a WindowInfoControl to take the impl from.
	* \return A reference to this WindowInfoControl. */
	WindowInfoControl & operator=(WindowInfoControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~WindowInfoControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::WindowInfoControl;
	HPS::Type				ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer of the WindowInfoControl source.
	 *	\param in_that The WindowInfoControl source of the assignment.
	 *	\return A reference to this WindowInfoControl. */
	WindowInfoControl &		operator=(WindowInfoControl const & in_that);

	/*! Shows the number of pixels in the physical display (monitor, off-screen renderer, printer, etc.).
	*	\param out_width The width of the physical display in pixels.
	*	\param out_height The height of the physical display in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPhysicalPixels(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the size, in centimeters, of the physical display (monitor, off-screen renderer, printer, etc.).
	*	\param out_width The width of the physical display in centimeters.
	*	\param out_height The height of the physical display in centimeters.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPhysicalSize(float & out_width, float & out_height) const;

	/*! Shows the number of pixels in the window.
	*	\param out_width The width of the window in pixels.
	*	\param out_height The height of the window in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowPixels(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the size, in centimeters, of the window.
	*	\param out_width The width of the window in centimeters.
	*	\param out_height The height of the window in centimeters.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowSize(float & out_width, float & out_height) const;

	/*! Shows both the horizontal and vertical resolution of the window. Resolution is computed as pixels per centimeter.
	*	If the size or the pixels are not set, this function will return <span class='code'>false</span>.
	*	\param out_horizontal The horizontal resolution of the window.
	*	\param out_vertical The vertical resolution of the window.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowResolution(float & out_horizontal, float & out_vertical) const;

	/*! Shows the aspect ratio of the window.  Aspect ratio is computed as width / height in centimeters.
	*	\param out_window_aspect The aspect ratio of the window defined as width / height in centimeters.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowWindowAspectRatio(float & out_window_aspect) const;

	/*! Shows the aspect ratio of the window's pixels.  This is computed as the horizontal resolution divided by the vertical resolution.
	*	\param out_pixel_aspect The aspect ratio of the window defined as width / height in pixels.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPixelAspectRatio(float & out_pixel_aspect) const;

	/*! Shows the maximum texture size that can be used.
	*	\param out_width The maximum texture width that can be used.
	*	\param out_height The maximum texture height that can be used.
	*	\return <span class='code'>true</span> if the maximum texture size can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowMaxTextureSize(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the time taken (in milliseconds) to complete the last update. This function is limited to the resolution of the system timer.
	*   In practice, that means that frame rates above 20 per second cannot be accurately measured in this manner.
	*	\param out_time The time taken (in milliseconds) to complete the last update.
	*	\return <span class='code'>false</span> if called before the initial update, <span class='code'>true</span> otherwise. */
	bool					ShowLastUpdateTime(Time & out_time) const;

	/*! Shows the number of depth peeling layers that are supported for this window associated with this control.
	*	\param out_layers The number of depth peeling layers that are supported for this window associated with this control.
	*	\return <span class='code'>true</span> if depth peeling layers can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowDepthPeelingLayers(size_t & out_layers) const;

	/*! Shows the number (in MB) of video memory available on the system.
	*	\param out_video_memory The number (in MB) of video memory available on the system.
	*	\return <span class='code'>true</span> if video memory can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowVideoMemory(size_t & out_video_memory) const;

	/*! Shows the number of bits used in this window's depth buffer.
	*	\param out_bits The number of bits used in this window's depth buffer.
	*	\return <span class='code'>true</span> if depth buffer size can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowDepthBufferSize(size_t & out_bits) const;

	/*! Shows the maximum number of lights that can be used within the window associated with this control.
	*	\param out_lights The maximum number of lights that can be used within the window associated with this control.
	*	\return <span class='code'>true</span> if the maximum light count can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowMaxLights(size_t & out_lights) const;

	/*! Shows the number of color bit planes present for each pixel in the frame buffer.
	*	\param out_planes The number of color bit planes present for each pixel in the frame buffer.
	*	\return <span class='code'>true</span> if the color bit plane count can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowColorBitPlanes(size_t & out_planes) const;

	/*! Shows information pertaining to the last performed update.
	*	\param out_info The information pertaining to the last performed update.
	*	\return <span class='code'>false</span> if called before the initial update, <span class='code'>true</span> otherwise. */
	bool					ShowLastUpdateInfo(UpdateInfo & out_info) const;

	/*! Shows the name of the GPU that is being used to render to this window.
	*	\param out_name The name of the GPU.
	*	\return <span class='code'>true</span> if the name can be queried from the hardware, <span class='code'>false</span> otherwise. */
	bool					ShowGPUName(UTF8 & out_name) const;

private:
	//! Private default constructor to prevent instantiation without a window.
	WindowInfoControl();
};

/*! The FontInfoState class is a user space object, useful for carrying a group attribute settings. */
class HPS_API FontInfoState : public Object
{
public:

	   /*! Initializes an empty State. */
	   FontInfoState();

	   /*! Copies the kit in_kit into this kit. */
	   FontInfoState(FontInfoState const & in_kit);

	   /*! The move constructor creates a FontInfoState by transferring the underlying impl of the rvalue reference to this FontInfoState
		*      thereby avoiding a copy and allocation.
		*      \param in_that An rvalue reference to a FontInfoState to take the impl from.*/
	   FontInfoState(FontInfoState && in_that);

	   /*! The move assignment operator transfers the underlying impl of the rvalue reference to this FontInfoState thereby avoiding a copy.
	   * \param in_that An rvalue reference to a FontInfoState to take the impl from.
	   * \return A reference to this FontInfoState. */
	   FontInfoState & operator=(FontInfoState && in_that);

	   /*! Destroy this kit. */
	   virtual ~FontInfoState();

	static const HPS::Type staticType = HPS::Type::FontInfoState;
	   HPS::Type                               ObjectType() const {return staticType;}

	   /*! Copies the source FontInfoState into this FontInfoState.
		*      \param in_that The source LocatorState to copy. */
	   void                                    Assign(FontInfoState const & in_that);

	   /*! Copies the source FontInfoState into this object.
	   *       \param in_kit The source object to copy. */
	   void                                    Set(FontInfoState const & in_kit);

	   /*! Copies this object into the given FontInfoState.
	   *       \param out_kit The FontInfoState to populate with the contents of this object. */
	   void                                    Show(FontInfoState & out_kit) const;

	   /*! Copies the source FontInfoState into this object.
	   *       \param in_kit The source FontInfoState to copy.
	   *       \return A reference to this object. */
	   FontInfoState &                 operator=(FontInfoState const & in_kit);

	   /*! Indicates whether this object has any values set on it.
	   *       \return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	   bool                                    Empty() const;

	   /*!     Check if the source FontInfoState is equivalent to this object.
	   *       \param in_kit The source FontInfoState to compare to this object.
	   *       \return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	   bool                                    Equals(FontInfoState const & in_kit) const;

	   /*!     Check if the source FontInfoState is equivalent to this object.
		*      \param in_kit The source FontInfoState to compare to this object.
		*      \return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	   bool                                    operator==(FontInfoState const & in_kit) const;

	   /*!     Check if the source FontInfoState is not equivalent to this object.
		*      \param in_kit The source FontInfoState to compare to this object.
		*      \return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	   bool                                    operator!=(FontInfoState const & in_kit) const;

	   /*! Gets the name of this font.
	   *       \return The name of the font in UTF8 format. */
	   UTF8                                    GetName() const;

	   /*! Shows the system name for this font.
		*	\return <span class='code'>true</span> if the system name is available, <span class='code'>false</span> otherwise. */
	   bool                                    ShowSystemName(HPS::UTF8 & out_name) const;

	   /*! Gets the shell convertibility of this font. This determines whether or not the font can be converted into a Visualize shell.
	   *       \return A reference to this object. */
	   bool                                    GetShellConvertibility() const;
};


/*! The HPS::AttributeLockKit class provides support for  attribute locking, which allows temporarily override of
	an attribute setting for a segment and its descendants. This control is used to set and unset attribute locks at the segment level.
	Calling HPS::AttributeLockKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#attribute-lock">this table</a>.
*/
class HPS_API AttributeLockKit : public Kit
{
public:

	/*! Initializes an empty kit. */
	AttributeLockKit();

	/*! Copies the kit in_kit into this kit. */
	AttributeLockKit(AttributeLockKit const & in_kit);

	/*! The move constructor creates a AttributeLockKit by transferring the underlying impl of the rvalue reference to this AttributeLockKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a AttributeLockKit to take the impl from.*/
	AttributeLockKit(AttributeLockKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this AttributeLockKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a AttributeLockKit to take the impl from.
	* \return A reference to this AttributeLockKit. */
	AttributeLockKit & operator=(AttributeLockKit && in_that);

	/*! Destroy this kit. */
	virtual ~AttributeLockKit();

	static const HPS::Type staticType = HPS::Type::AttributeLockKit;
	HPS::Type		ObjectType() const {return staticType;}

	/*! Creates an AttributeLockKit which contains the default settings.  The returned object will not necessarily have values
	* 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	* 	\return An AttributeLockKit with the default settings. */
	static AttributeLockKit GetDefault();

	/*! Copies the source AttributeLockKit into this object.
	* 	\param in_kit The source object to copy. */
	void					Set(AttributeLockKit const & in_kit);

	/*! Copies this object into the given AttributeLockKit.
	* 	\param out_kit The AttributeLockKit to populate with the contents of this object. */
	void					Show(AttributeLockKit & out_kit) const;

	/*! Copies the source AttributeLockKit into this object.
	* 	\param in_kit The source AttributeLockKit to copy.
	* 	\return A reference to this object. */
	AttributeLockKit &		operator=(AttributeLockKit const & in_kit);

	/*! Indicates whether this object has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this object, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source AttributeLockKit is equivalent to this object.
	*	\param in_kit The source AttributeLockKit to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(AttributeLockKit const & in_kit) const;

	/*!	Check if the source AttributeLockKit is equivalent to this object.
	 *	\param in_kit The source AttributeLockKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(AttributeLockKit const & in_kit) const;

	/*!	Check if the source AttributeLockKit is not equivalent to this object.
	 *	\param in_kit The source AttributeLockKit to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(AttributeLockKit const & in_kit) const;

	/*!	Applies an attribute lock that prevents attributes of the chosen type from being modified in child segments.
	*	\param in_type The type of attribute to lock or unlock.
	*	\param in_state Whether the attribute should be locked.
	*	\return A reference to this object.
	*	\sa Attribute lock <a href="../../prog_guide/appendix_default_attribute_values.html#attribute-lock">default value</a> */
	AttributeLockKit &		SetLock(AttributeLock::Type in_type, bool in_state = true);

	/*!	Applies attribute locks that prevents attributes of the chosen types from being modified in child segments.
	*	\param in_types An array of attribute types that should be locked or unlocked.
	*	\param in_states An array of bools with each one indicating whether the corresponding type in in_types should be locked.
	*	\return A reference to this object. */
	AttributeLockKit &		SetLock(AttributeLockTypeArray const & in_types, BoolArray const & in_states);

	/*!	Normally, if a segment applies an attribute lock it will defeat an existing lock set in a parent segment.
	*	This method designates a particular lock as a "super lock" that cannot be overridden by subsegments.
	*	\param in_type The type of attribute lock that should be ignored in subsegments.
	*	\param in_state Whether the attribute lock should override locks in subsegments.
	*	\return A reference to this object. */
	AttributeLockKit &		SetSubsegmentLockOverride(AttributeLock::Type in_type, bool in_state = true);

	/*!	Normally, if a segment applies an attribute lock it will defeat an existing lock set in a parent segment.
	*	This method designates a collection of locks as a "super locks" that cannot be overridden by subsegments.
	*	\param in_types An array of types of attribute locks that should be ignored in subsegments.
	*	\param in_states An array of bools with each one indicating whether the corresponding attribute lock in in_types should override locks in subsegments.
	*	\return A reference to this object. */
	AttributeLockKit &		SetSubsegmentLockOverride(AttributeLockTypeArray const & in_types, BoolArray const & in_states);


	/*!	Removes an attribute lock setting.
	*	\return A reference to this object. */
	AttributeLockKit &		UnsetLock(AttributeLock::Type in_type = AttributeLock::Type::Everything);

	/*!	Removes a collection of attribute lock settings.
	*	\return A reference to this object. */
	AttributeLockKit &		UnsetLock(AttributeLockTypeArray const & in_types);

	/*!	Removes a subsegment lock override setting.
	*	\return A reference to this object. */
	AttributeLockKit &		UnsetSubsegmentLockOverride(AttributeLock::Type in_type = AttributeLock::Type::Everything);

	/*!	Removes a collection of subsegment lock override settings.
	*	\return A reference to this object. */
	AttributeLockKit &		UnsetSubsegmentLockOverride(AttributeLockTypeArray const & in_types);

	/*!	Removes all settings from this object.
	*	\return A reference to this object. */
	AttributeLockKit &		UnsetEverything();


	/*! Shows the state of a particular attribute lock.
	*	\param in_type The type of attribute lock to be queried.
	*	\param out_state Whether the attribute is locked.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLock(AttributeLock::Type in_type, bool & out_state) const;

	/*! Shows the state of all attribute locks.
	*	\param out_types An array of types that have an attribute lock setting.
	*	\param out_states An array of bools with each indicating whether the corresponding entry in in_types is locked.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLock(AttributeLockTypeArray & out_types, BoolArray & out_states) const;

	/*! Shows the state of a particular subsegment lock override.
	*	\param in_type The type of attribute lock to be queried.
	*	\param out_state Whether the attribute lock will override locks in subsegments.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSubsegmentLockOverride(AttributeLock::Type in_type, bool & out_state) const;

	/*! Shows the state of all subsegment lock overrides.
	*	\param out_types An array of types that have a subsegment lock override setting.
	*	\param out_states An array of bools with each indicating whether the corresponding entry in in_types is will be ignored in subsegments.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSubsegmentLockOverride(AttributeLockTypeArray & out_types, BoolArray & out_states) const;
};


/*! The HPS::AttributeLockControl class provides support for  attribute locking, which allows temporarily override of
	an attribute setting for a segment and its descendants. This control is used to set and unset attribute locks at the segment level. For
	more information, see Core Graphics Programming Guide, section 1.2.4 - subsection "Attribute controls". <a href="../../prog_guide/appendix_default_attribute_values.html#attribute-lock">This table</a> lists default values for the various segment attributes accessible from HPS::AttributeLockControl.
*/
class HPS_API AttributeLockControl : public Control
{
public:

	/*! Initializes a control tied to the segment in_seg. */
	explicit AttributeLockControl(SegmentKey & in_seg);

	/*! The move constructor creates a AttributeLockKit by transferring the underlying impl of the rvalue reference to this AttributeLockKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a AttributeLockKit to take the impl from.*/
	AttributeLockControl(AttributeLockControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this AttributeLockControl thereby avoiding a copy.
	* \param in_that An rvalue reference to a AttributeLockControl to take the impl from.
	* \return A reference to this AttributeLockControl. */
	AttributeLockControl & operator=(AttributeLockControl && in_that);

	/*! Initializes a control tied to the same object as in_that. */
	AttributeLockControl(AttributeLockControl const & in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~AttributeLockControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::AttributeLockControl;
	HPS::Type				ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer of the AttributeLockControl source.
	 *	\param in_that The AttributeLockControl source of the assignment.
	 *	\return A reference to this AttributeLockControl. */
	AttributeLockControl &	operator=(AttributeLockControl const & in_that);

	/*!	Applies an attribute lock that prevents attributes of the chosen type from being modified in child segments.
	*	\param in_type The type of attribute to lock or unlock.
	*	\param in_state Whether the attribute should be locked.
	*	\return A reference to this object.
	*   \sa Attribute lock <a href="../../prog_guide/appendix_default_attribute_values.html#attribute-lock">default value</a> */
	AttributeLockControl &	SetLock(AttributeLock::Type in_type, bool in_state = true);

	/*!	Applies attribute locks that prevents attributes of the chosen types from being modified in child segments.
	*	\param in_types An array of attribute types that should be locked or unlocked.
	*	\param in_states An array of bools with each one indicating whether the corresponding type in in_types should be locked.
	*	\return A reference to this object. */
	AttributeLockControl &	SetLock(AttributeLockTypeArray const & in_types, BoolArray const & in_states);

	/*!	Normally, if a segment applies an attribute lock it will defeat an existing lock set in a parent segment.
	*	This method designates a particular lock as a "super lock" that cannot be overridden by subsegments.
	*	\param in_type The type of attribute lock that should be ignored in subsegments.
	*	\param in_state Whether the attribute lock should override locks in subsegments.
	*	\return A reference to this object. */
	AttributeLockControl &	SetSubsegmentLockOverride(AttributeLock::Type in_type, bool in_state = true);

	/*!	Normally, if a segment applies an attribute lock it will defeat an existing lock set in a parent segment.
	*	This method designates a collection of locks as a "super locks" that cannot be overridden by subsegments.
	*	\param in_type Ann array of types of attribute locks that should be ignored in subsegments.
	*	\param in_state An array of bools with each one indicating whether the corresponding attribute lock in in_types should override locks in subsegments.
	*	\return A reference to this object. */
	AttributeLockControl &	SetSubsegmentLockOverride(AttributeLockTypeArray const & in_types, BoolArray const & in_states);


	/*!	Removes an attribute lock setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by AttributeLockKit::GetDefault().
	*	\return A reference to this object. */
	AttributeLockControl &	UnsetLock(AttributeLock::Type in_type = AttributeLock::Type::Everything);

	/*!	Removes a collection of attribute lock settings. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by AttributeLockKit::GetDefault().
	*	\return A reference to this object. */
	AttributeLockControl &	UnsetLock(AttributeLockTypeArray const & in_types);

	/*!	Removes a subsegment lock override setting. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by AttributeLockKit::GetDefault().
	*	\return A reference to this object. */
	AttributeLockControl &	UnsetSubsegmentLockOverride(AttributeLock::Type in_type = AttributeLock::Type::Everything);

	/*!	Removes a collection of subsegment lock override settings. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by AttributeLockKit::GetDefault().
	*	\return A reference to this object. */
	AttributeLockControl &	UnsetSubsegmentLockOverride(AttributeLockTypeArray const & in_types);

	/*!	Removes all settings from this object. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by AttributeLockKit::GetDefault().
	*	\return A reference to this object. */
	AttributeLockControl &	UnsetEverything();


	/*! Shows the state of a particular attribute lock.
	*	\param in_type The type of attribute lock to be queried.
	*	\param out_state Whether the attribute is locked.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLock(AttributeLock::Type in_type, bool & out_state) const;

	/*! Shows the state of all attribute locks.
	*	\param out_types An array of types that have an attribute lock setting.
	*	\param out_states An array of bools with each indicating whether the corresponding entry in in_types is locked.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowLock(AttributeLockTypeArray & out_types, BoolArray & out_states) const;

	/*! Shows the state of a particular subsegment lock override.
	*	\param in_type The type of attribute lock to be queried.
	*	\param out_state Whether the attribute lock will override locks in subsegments.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSubsegmentLockOverride(AttributeLock::Type in_type, bool & out_state) const;

	/*! Shows the state of all subsegment lock overrides.
	*	\param out_types An array of types that have a subsegment lock override setting.
	*	\param out_states An array of bools with each indicating whether the corresponding entry in in_types is will be ignored in subsegments.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSubsegmentLockOverride(AttributeLockTypeArray & out_types, BoolArray & out_states) const;

private:
	//! Private default constructor to prevent instantiation without a window.
	AttributeLockControl();
};

//////////////////////////////////////////////////////////////////////
////////////////////////// Geometry and Keys /////////////////////////
//////////////////////////////////////////////////////////////////////

class HPS_API GeometryKey : public Key
{
public:
	/*! The default constructor creates an uninitialized GeometryKey object.  The Type() function will return Type::None. */
	GeometryKey();

	/*! This constructor creates a GeometryKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	a type of geometry key.  Otherwise the copy will fail and the resulting GeometryKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit GeometryKey(Key const & in_that);

	/*! The copy constructor creates a GeometryKey object that shares the underlying smart-pointer of the source GeometryKey.
	 *	\param in_that The source GeometryKey to copy. */
	GeometryKey(GeometryKey const & in_that);

	/*! Associate this GeometryKey with the same underlying impl as the source GeometryKey.
	 *	\param in_that The source GeometryKey for the assignment.
	 *	\return A reference to this GeometryKey. */
	GeometryKey & operator=(GeometryKey const & in_that);

	/*! The move constructor creates a GeometryKey by transferring the underlying impl of the rvalue reference to this GeometryKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a GeometryKey to take the impl from. */
	GeometryKey(GeometryKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this GeometryKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a GeometryKey to take the impl from.
	 *	\return A reference to this GeometryKey. */
	GeometryKey & operator=(GeometryKey && in_that);

	~GeometryKey();

	static const HPS::Type staticType = HPS::Type::GeometryKey;
	HPS::Type				ObjectType() const { return staticType; };


	/*! Shows the all the segments which contain references to this key.  Note that while a segment may only appear once in the returned array, that segment could have multiple references to this key.
	 *	\param out_segments The list of segments which contains references to this key.
	 *	\return The number of segments which contain references to this key. */
	size_t					ShowReferrers(SegmentKeyArray & out_segments) const;

	/*! Shows the all the references to this key.
	 *	\param out_references The list of all references to this key.
	 *	\return The number of references to this key. */
	size_t					ShowReferrers(ReferenceKeyArray & out_references) const;



	/*!	Assigns a drawing priority value to the geometry.  It affects the order in which the geometry is rendered
	 *	when the rendering algorithm is set to Priority.
	 *  All geometry has a default drawing priority assigned based on the order of insertion into the segment.
	 *	\param in_priority The drawing priority; higher priority items are drawn on top of lower priority items.
	 *	\return A reference to this object.
	 *	\sa SubwindowKit::SetRenderingAlgorithm() */
	GeometryKey &			SetPriority(int in_priority);

	/*!	Removes the drawing priority setting.
	 *	\return A reference to this object. */
	GeometryKey &			UnsetPriority();

	/*! Shows the drawing priority.
	 *	\param out_priority The drawing priority; higher priority items are drawn on top of lower priority items.
	 *	\return <span class='code'>true</span> if a priority was specified, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;


	/*! Sets user data on this key.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this key. */
	GeometryKey &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this key.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this key. */
	GeometryKey &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this key.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this key. */
	GeometryKey &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this key.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this key. */
	GeometryKey &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this key.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this key. */
	GeometryKey &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this key.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this key. */
	GeometryKey &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this key.
	 *	\return A reference to this key. */
	GeometryKey &			UnsetAllUserData();

	/*! Get the number of user data indices set on this key. */
	size_t					ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this key.
	 *	\param out_indices The user data indices set on this key.
	 *	\return The number of user data indices set on this key. */
	bool					ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this key.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool					ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this key.
	 *	\param out_indices An array of all user data indices set on this key.
	 *	\param out_data An array of all user data set on this key.
	 *	\return <span class='code'>true</span> if there is user data on this key, <span class='code'>false</span> otherwise. */
	bool					ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;

	/*! Shows the bounding of this geometry.
	\param out_kit The BoundingKit that is set on this GeometryKey
	\return False if no bounding exists.
	*/
	bool					ShowBounding(BoundingKit & out_kit) const;
};


/*! The LineKit class is a user space object.  It is a kit analog to a LineKey. */
class HPS_API LineKit : public Kit
{
public:
	/*! The default constructor creates an empty LineKit object. */
	LineKit();

	/*! The copy constructor creates a new LineKit object that contains the same settings as the source LineKit.
	 * 	\param in_kit The source LineKit to copy. */
	LineKit(LineKit const & in_kit);

	/*! The move constructor creates a LineKit by transferring the underlying impl of the rvalue reference to this LineKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LineKit to take the impl from. */
	LineKit(LineKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LineKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to an LineKit to take the impl from.
	 *	\return A reference to this LineKit. */
	LineKit & operator=(LineKit && in_that);

	virtual ~LineKit();

	static const HPS::Type staticType = HPS::Type::LineKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source LineKit into this LineKit and resets the source kit.
	 * 	\param in_kit The source LineKit to consume. */
	void				Consume(LineKit & in_kit);

	/*! Copies the source LineKit into this LineKit.
	 * 	\param in_kit The source LineKit to copy. */
	void				Set(LineKit const & in_kit);

	/*! Copies this LineKit into the given LineKit.
	 * 	\param out_kit The LineKit to populate with the contents of this LineKit. */
	void				Show(LineKit & out_kit) const;

	/*! Copies the source LineKit into this LineKit.
	 * 	\param in_kit The source LineKit to copy.
	 * 	\return A reference to this LineKit. */
	LineKit &			operator=(LineKit const & in_kit);

	/*! Indicates whether this LineKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this LineKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source LineKit is equivalent to this LineKit.
	 *	\param in_kit The source LineKit to compare to this LineKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(LineKit const & in_kit) const;

	/*!	Check if the source LineKit is equivalent to this LineKit.
	 *	\param in_kit The source LineKit to compare to this LineKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(LineKit const & in_kit) const;

	/*!	Check if the source LineKit is not equivalent to this LineKit.
	 *	\param in_kit The source LineKit to compare to this LineKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(LineKit const & in_kit) const;

	/*!	Retrieves the number of points in this line.
	 *	\return The number of points in this line. */
	size_t				GetPointCount() const;

		/*!	Assigns a specific drawing priority value to the LineKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	LineKit &			SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	LineKit &			UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;


	/*! Sets the points for this LineKit.
	 *	\param in_points The points for this LineKit.
	 *	\return A reference to this LineKit. */
	LineKit &			SetPoints(PointArray const & in_points);

	/*! Sets the points for this LineKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points for this LineKit.
	 *	\return A reference to this LineKit. */
	LineKit &			SetPoints(size_t in_count, Point const in_points []);


	/*! Removes the points for this LineKit.
	 *	\return A reference to this LineKit. */
	LineKit &			UnsetPoints();

	/*! Removes all settings from the LineKit.
	 *	\return A reference to this LineKit. */
	LineKit &			UnsetEverything();


	/*! Shows the points for this LineKit.
	 *	\param out_points The points for this LineKit.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this LineKit by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this LineKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this LineKit by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this LineKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this LineKit by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this LineKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Sets the points for this LineKit.
	*	\param in_points The points for this LineKit.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKit. */
	LineKit &			SetPoints(PointArray const & in_points, LineCoordinateSpaceArray const & in_spaces);

	/*! Sets the points for this LineKit.
	*	\param in_count Size of the following array.
	*	\param in_points The points for this LineKit.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKit. */
	LineKit &			SetPoints(size_t in_count, Point const in_points[], Line::CoordinateSpace const in_spaces[]);


	/*! Shows the points for this LineKit.
	*	\param out_points The points for this LineKit.
	*	\param out_coordinate_spaces The coordinate spaces for each point in this line.
	*	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points, LineCoordinateSpaceArray & out_coordinate_spaces) const;

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	*	\param in_count The number of points to unset.
	*	\param in_indices The list of point indices to unset.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKit. */
	LineKit &			SetPointCoordinateSpace(size_t in_count, size_t const in_indices[], Line::CoordinateSpace const in_spaces[]);

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	*	\param in_indices The list of point indices to unset.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKit. */
	LineKit &			SetPointCoordinateSpace(SizeTArray const & in_indices, LineCoordinateSpaceArray const & in_spaces);

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKit. */
	LineKit &			SetPointCoordinateSpace(LineCoordinateSpaceArray const & in_spaces);

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	*	\param in_count Size of the following array.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKit. */
	LineKit &			SetPointCoordinateSpace(size_t in_count, Line::CoordinateSpace const in_spaces[]);

	/*! Unsets the coordinate space for specified points on this line back to Coordinate::Space::Object.
	*	\param in_indices The list of point indices to unset.
	*	\return A reference to this LineKit. */
	LineKit &			UnsetPointCoordinateSpace(SizeTArray const & in_indices);

	/*! Unsets the coordinate space for specified points on this line back to Coordinate::Space::Object.
	*	\param in_count The number of points to unset.
	*	\param in_indices The list of point indices to unset.
	*	\return A reference to this LineKit. */
	LineKit &			UnsetPointCoordinateSpace(size_t in_count, size_t const in_indices[]);

	/*! Unsets the coordinate space for all points on this line back to Coordinate::Space::Object.
	*	\return A reference to this LineKit. */
	LineKit &			UnsetPointCoordinateSpace();

	/*! Shows the coordinate space that is being used for the points at the specified indices.
	*	\param in_count The number of points to show.
	*	\param in_indices The list of point indices to show.
	*	\param out_spaces The coordinate spaces for each index specified.
	*	\return <span class='code'>true</span> if line coordinates could be retrieved for this line <span class='code'>false</span> otherwise. */
	bool				ShowPointCoordinateSpace(size_t in_count, size_t const in_indices[], LineCoordinateSpaceArray & out_spaces) const;

	/*! Shows the coordinate space that is being used for the points at the specified indices.
	*	\param in_indices The list of point indices to show.
	*	\param out_spaces The coordinate spaces for each index specified.
	*	\return <span class='code'>true</span> if line coordinates could be retrieved for this line <span class='code'>false</span> otherwise. */
	bool				ShowPointCoordinateSpace(SizeTArray const & in_indices, LineCoordinateSpaceArray & out_spaces) const;

	/*! Shows the coordinate space that is being used for the points at the specified indices.
	*	\param out_spaces The coordinate spaces for each all points on this line.
	*	\return <span class='code'>true</span> if line coordinates could be retrieved for this line <span class='code'>false</span> otherwise. */
	bool				ShowPointCoordinateSpace(LineCoordinateSpaceArray & out_spaces) const;

	/*! Adds points to the point list for this LineKit.
	 *	\param in_offset The offset into the point list for the line at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this LineKit. */
	LineKit &			EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the point list for this LineKit.
	 *	\param in_offset The offset into the point list for the line at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this LineKit. */
	LineKit &			EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the point list for this LineKit.
	 *	\param in_offset The offset into the point list for the line at which to start removing points.  This value must be such that <span class='code'>in_offset<point_count</span> for deletion to succeed.
	 *	\param in_count The number of points to delete from the point list for the line.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the deletion to succeed.
	 *	\return A reference to this LineKit. */
	LineKit &			EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces points in the point list for this LineKit.
	 *	\param in_offset The offset into the point list for the line at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.
	 *	\return A reference to this LineKit. */
	LineKit &			EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces points in the point list for this LineKit.
	 *	\param in_offset The offset into the point list for the line at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.  This size of the array must be such that <span class='code'>in_offset+in_points.size()&lt;=point_count</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this LineKit. */
	LineKit &			EditPointsByReplacement(size_t in_offset, PointArray const & in_points);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	LineKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	LineKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	LineKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	LineKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	LineKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	LineKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	LineKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};

/*! The LineKey class is a smart pointer to a database object.  It is a handle to a line inserted via SegmentKey::InsertLine. */
class HPS_API LineKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized LineKey object.  The Type() function will return Type::None. */
	LineKey();

	/*! This constructor creates a LineKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a Line key.  Otherwise the copy will fail and the resulting LineKey will be invalid.
	 *	\param in_name The source Key to copy. */
	explicit LineKey(Key const & in_that);

	/*! The copy constructor creates a LineKey object that shares the underlying smart-pointer of the source LineKey.
	 *	\param in_that The source LineKey to copy. */
	LineKey(LineKey const & in_that);

	/*! Associate this LineKey with the same underlying impl as the source LineKey.
	 *	\param in_that The source LineKey for the assignment.
	 *	\return A reference to this LineKey. */
	LineKey & operator=(LineKey const & in_that);

	/*! The move constructor creates a LineKey by transferring the underlying impl of the rvalue reference to this LineKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LineKey to take the impl from. */
	LineKey(LineKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LineKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a LineKey to take the impl from.
	 *	\return A reference to this LineKey. */
	LineKey & operator=(LineKey && in_that);

	~LineKey();

	static const HPS::Type staticType = HPS::Type::LineKey;
	HPS::Type			ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this LineKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this LineKey. */
	void				Consume(LineKit & in_kit);

	/*! Copies the source LineKit into this LineKit.
	 * 	\param in_kit The source LineKit to copy. */
	void				Set(LineKit const & in_kit);

	/*! Copies this LineKit into the given LineKit.
	 * 	\param out_kit The LineKit to populate with the contents of this LineKit. */
	void				Show(LineKit & out_kit) const;

	/*!	Retrieves the number of points in this line.
	 *	\return The number of points in this line. */
	size_t				GetPointCount() const;

	/*! Sets the points for this LineKey.
	 *	\param in_points The points for this LineKey.
	 *	\return A reference to this LineKey. */
	LineKey &			SetPoints(PointArray const & in_points);

	/*! Sets the points for this LineKey.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points for this LineKey.
	 *	\return A reference to this LineKey. */
	LineKey &			SetPoints(size_t in_count, Point const in_points []);

	/*! Shows the points for this LineKey.
	 *	\param out_points The points for this LineKey.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this LineKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this LineKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this LineKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this LineKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this LineKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this LineKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Sets the points for this LineKey.
	*	\param in_points The points for this LineKey.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKey. */
	LineKey &			SetPoints(PointArray const & in_points, LineCoordinateSpaceArray const & in_spaces);

	/*! Sets the points for this LineKey.
	*	\param in_count Size of the following array.
	*	\param in_points The points for this LineKey.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKey. */
	LineKey &			SetPoints(size_t in_count, Point const in_points[], Line::CoordinateSpace const in_spaces[]);


	/*! Shows the points for this LineKey.
	*	\param out_points The points for this LineKey.
	*	\param out_coordinate_spaces The coordinate spaces for each point in this line.
	*	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points, LineCoordinateSpaceArray & out_coordinate_spaces) const;

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	 *	\param in_count The number of points to unset.
	 *	\param in_indices The list of point indices to unset.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKey. */
	LineKey &			SetPointCoordinateSpace(size_t in_count, size_t const in_indices[], Line::CoordinateSpace const in_spaces[]);

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	 *	\param in_indices The list of point indices to unset.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKey. */
	LineKey &			SetPointCoordinateSpace(SizeTArray const & in_indices, LineCoordinateSpaceArray const & in_spaces);

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKey. */
	LineKey &			SetPointCoordinateSpace(LineCoordinateSpaceArray const & in_spaces);

	/*! Sets the coordinate space to use for each point of this line. The default is Line::CoordinateSpace::Object.
	*	\param in_count Size of the following array.
	*	\param in_spaces The coordinate spaces for each point in the line.
	*	\return A reference to this LineKey. */
	LineKey &			SetPointCoordinateSpace(size_t in_count, Line::CoordinateSpace const in_spaces []);

	/*! Unsets the coordinate space for specified points on this line back to Coordinate::Space::Object.
	*	\param in_indices The list of point indices to unset.
	*	\return A reference to this LineKey. */
	LineKey &			UnsetPointCoordinateSpace(SizeTArray const & in_indices);

	/*! Unsets the coordinate space for specified points on this line back to Coordinate::Space::Object.
	 *	\param in_count The number of points to unset.
	 *	\param in_indices The list of point indices to unset.
	*	\return A reference to this LineKey. */
	LineKey &			UnsetPointCoordinateSpace(size_t in_count, size_t const in_indices[]);

	/*! Unsets the coordinate space for all points on this line back to Coordinate::Space::Object.
	*	\return A reference to this LineKey. */
	LineKey &			UnsetPointCoordinateSpace();

	/*! Shows the coordinate space that is being used for the points at the specified indices.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	*	\param out_spaces The coordinate spaces for each index specified.
	 *	\return <span class='code'>true</span> if line coordinates could be retrieved for this line <span class='code'>false</span> otherwise. */
	bool				ShowPointCoordinateSpace(size_t in_count, size_t const in_indices[], LineCoordinateSpaceArray & out_spaces) const;

	/*! Shows the coordinate space that is being used for the points at the specified indices.
	*	\param in_indices The list of point indices to show.
	*	\param out_spaces The coordinate spaces for each index specified.
	 *	\return <span class='code'>true</span> if line coordinates could be retrieved for this line <span class='code'>false</span> otherwise. */
	bool				ShowPointCoordinateSpace(SizeTArray const & in_indices, LineCoordinateSpaceArray & out_spaces) const;

	/*! Shows the coordinate space that is being used for the points at the specified indices.
	*	\param out_spaces The coordinate spaces for each all points on this line.
	*	\return <span class='code'>true</span> if line coordinates could be retrieved for this line <span class='code'>false</span> otherwise. */
	bool				ShowPointCoordinateSpace(LineCoordinateSpaceArray & out_spaces) const;

	/*! Adds points to the point list for this LineKey.
	 *	\param in_offset The offset into the point list for the line at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this LineKey. */
	LineKey &			EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the point list for this LineKey.
	 *	\param in_offset The offset into the point list for the line at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this LineKey. */
	LineKey &			EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the point list for this LineKey.
	 *	\param in_offset The offset into the point list for the line at which to start removing points.  This value must be such that <span class='code'>in_offset<point_count</span> for deletion to succeed.
	 *	\param in_count The number of points to delete from the point list for the line.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the deletion to succeed.
	 *	\return A reference to this LineKey. */
	LineKey &			EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces points in the point list for this LineKey.
	 *	\param in_offset The offset into the point list for the line at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.
	 *	\return A reference to this LineKey. */
	LineKey &			EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces points in the point list for this LineKey.
	 *	\param in_offset The offset into the point list for the line at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.  This size of the array must be such that <span class='code'>in_offset+in_points.size()&lt;=point_count</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this LineKey. */
	LineKey &			EditPointsByReplacement(size_t in_offset, PointArray const & in_points);
};



/*! The MarkerKit class is a user space object.  It is a kit analog to a MarkerKey. */
class HPS_API MarkerKit : public Kit
{
public:
	/*! The default constructor creates an empty MarkerKit object. */
	MarkerKit();

	/*! The copy constructor creates a new MarkerKit object that contains the same settings as the source MarkerKit.
	 * 	\param in_kit The source MarkerKit to copy. */
	MarkerKit(MarkerKit const & in_kit);

	/*! The move constructor creates a MarkerKit by transferring the underlying impl of the rvalue reference to this MarkerKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MarkerKit to take the impl from. */
	MarkerKit(MarkerKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MarkerKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a MarkerKit to take the impl from.
	 *	\return A reference to this MarkerKit. */
	MarkerKit & operator=(MarkerKit && in_that);

	virtual ~MarkerKit();

	static const HPS::Type staticType = HPS::Type::MarkerKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source MarkerKit into this MarkerKit and resets the source kit.
	 * 	\param in_kit The source LineKit to consume. */
	void				Consume(MarkerKit & in_kit);

	/*! Copies the source MarkerKit into this MarkerKit.
	 * 	\param in_kit The source MarkerKit to copy. */
	void				Set(MarkerKit const & in_kit);

	/*! Copies this MarkerKit into the given MarkerKit.
	 * 	\param out_kit The MarkerKit to populate with the contents of this MarkerKit. */
	void				Show(MarkerKit & out_kit) const;

	/*! Copies the source MarkerKit into this MarkerKit.
	 * 	\param in_kit The source MarkerKit to copy.
	 * 	\return A reference to this MarkerKit. */
	MarkerKit &			operator=(MarkerKit const & in_kit);

	/*! Indicates whether this MarkerKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this MarkerKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source MarkerKit is equivalent to this MarkerKit.
	 *	\param in_kit The source MarkerKit to compare to this MarkerKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(MarkerKit const & in_kit) const;

	/*!	Check if the source MarkerKit is equivalent to this MarkerKit.
	 *	\param in_kit The source MarkerKit to compare to this MarkerKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(MarkerKit const & in_kit) const;

	/*!	Check if the source MarkerKit is not equivalent to this MarkerKit.
	 *	\param in_kit The source MarkerKit to compare to this MarkerKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(MarkerKit const & in_kit) const;


	/*!	Assigns a specific drawing priority value to the MarkerKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	MarkerKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	MarkerKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;

	/*! Sets the point for this MarkerKit.
	 *	\param in_point The point for this MarkerKit.
	 *	\return A reference to this MarkerKit. */
	MarkerKit &			SetPoint(Point const & in_point);


	/*! Removes the point for the MarkerKit.
	 *	\return A reference to this MarkerKit. */
	MarkerKit &			UnsetPoint();

	/*! Removes all settings from the MarkerKit.
	 *	\return A reference to this MarkerKit. */
	MarkerKit &			UnsetEverything();


	/*! Shows the point for this MarkerKit.
	 *	\param out_point The point for this MarkerKit.
	 *	\return <span class='code'>true</span> if a point was set, <span class='code'>false</span> otherwise. */
	bool				ShowPoint(HPS::Point & out_point) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	MarkerKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	MarkerKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	MarkerKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	MarkerKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	MarkerKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	MarkerKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	MarkerKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};

/*! The MarkerKey class is a smart pointer to a database object.  It is a handle to a marker inserted via SegmentKey::InsertMarker. */
class HPS_API MarkerKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized MarkerKey object.  The Type() function will return Type::None. */
	MarkerKey();

	/*! This constructor creates a MarkerKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a Marker key.  Otherwise the copy will fail and the resulting MarkerKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit MarkerKey(Key const & in_that);

	/*! The copy constructor creates a MarkerKey object that shares the underlying smart-pointer of the source MarkerKey.
	 *	\param in_that The source MarkerKey to copy. */
	MarkerKey(MarkerKey const & in_that);

	/*! Associate this MarkerKey with the same underlying impl as the source MarkerKey.
	 *	\param in_that The source MarkerKey for the assignment.
	 *	\return A reference to this MarkerKey. */
	MarkerKey & operator=(MarkerKey const & in_that);

	/*! The move constructor creates a MarkerKey by transferring the underlying impl of the rvalue reference to this MarkerKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MarkerKey to take the impl from. */
	MarkerKey(MarkerKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MarkerKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a MarkerKey to take the impl from.
	 *	\return A reference to this MarkerKey. */
	MarkerKey & operator=(MarkerKey && in_that);

	~MarkerKey();

	static const HPS::Type staticType = HPS::Type::MarkerKey;
	HPS::Type			ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this MarkerKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this MarkerKey. */
	void				Consume(MarkerKit & in_kit);

	/*! Replace those settings on this MarkerKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this MarkerKey. */
	void				Set(MarkerKit const & in_kit);

	/*! Copy the contents of this MarkerKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this MarkerKey. */
	void				Show(MarkerKit & out_kit) const;


	/*! Sets the point for this MarkerKey.
	 *	\param in_point The point for this MarkerKey.
	 *	\return A reference to this MarkerKey. */
	MarkerKey &			SetPoint(Point const & in_point);

	/*! Shows the point for this MarkerKey.
	 *	\param out_point The point for this MarkerKey.
	 *	\return <span class='code'>true</span> if a point was set, <span class='code'>false</span> otherwise. */
	bool				ShowPoint(Point & out_point) const;
};



/*! The DistantLightKit class is a user space object.  It is a kit analog to a DistantLightKey. */
class HPS_API DistantLightKit : public Kit
{
public:
	/*! The default constructor creates an empty DistantLightKit object. */
	DistantLightKit();

	/*! The copy constructor creates a new DistantLightKit object that contains the same settings as the source DistantLightKit.
	 * 	\param in_kit The source DistantLightKit to copy. */
	DistantLightKit(DistantLightKit const & in_kit);

	/*! The move constructor creates a DistantLightKit by transferring the underlying impl of the rvalue reference to this DistantLightKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DistantLightKit to take the impl from.*/
	DistantLightKit(DistantLightKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DistantLightKit thereby avoiding a copy.
	* \param in_that An rvalue reference to a DistantLightKit to take the impl from.
	* \return A reference to this DistantLightKit. */
	DistantLightKit & operator=(DistantLightKit && in_that);

	virtual ~DistantLightKit();

	static const HPS::Type staticType = HPS::Type::DistantLightKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source DistantLightKit into this DistantLightKit and resets the source kit.
	 * 	\param in_kit The source DistantLightKit to consume. */
	void				Consume(DistantLightKit & in_kit);

	/*! Copies the source DistantLightKit into this DistantLightKit.
	 * 	\param in_kit The source DistantLightKit to copy. */
	void				Set(DistantLightKit const & in_kit);

	/*! Copies this DistantLightKit into the given DistantLightKit.
	 * 	\param out_kit The DistantLightKit to populate with the contents of this DistantLightKit. */
	void				Show(DistantLightKit & out_kit) const;

	/*! Copies the source DistantLightKit into this DistantLightKit.
	 * 	\param in_kit The source DistantLightKit to copy.
	 * 	\return A reference to this DistantLightKit. */
	DistantLightKit &	operator=(DistantLightKit const & in_kit);

	/*! Indicates whether this DistantLightKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this DistantLightKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source DistantLightKit is equivalent to this DistantLightKit.
	 *	\param in_kit The source DistantLightKit to compare to this DistantLightKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(DistantLightKit const & in_kit) const;

	/*!	Check if the source DistantLightKit is equivalent to this DistantLightKit.
	 *	\param in_kit The source DistantLightKit to compare to this DistantLightKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(DistantLightKit const & in_kit) const;

	/*!	Check if the source DistantLightKit is not equivalent to this DistantLightKit.
	 *	\param in_kit The source DistantLightKit to compare to this DistantLightKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(DistantLightKit const & in_kit) const;


	/*!	Assigns a specific drawing priority value to the DistantLightKit.  It affects the order in which the contents of the owning segment
	 *	are drawn if and only if the rendering algorithm is set to Priority.
	 *	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	 *	\return A reference to this object.
	 *	\sa SubwindowKit::SetPriority()
	 *	\sa SubwindowKit::SetRenderingAlgorithm() */
	DistantLightKit &	SetPriority(int in_priority);

	/*! Sets the direction in which this DistantLightKit lies.  The rays emitted by this light will travel in the opposite direction of this vector.
	 *	\param in_vector The direction in which this DistantLightKit lies.  The vector will either be treated as being in object space or in camera-relative units depending on the setting passed SetCameraRelative.
	 *	\return A reference to this DistantLightKit.
	 *	\sa SetCameraRelative<br/>
	*   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#camera-relative-lights-enabled">Default value</a> */
	DistantLightKit &	SetDirection(HPS::Vector const & in_vector);

	/*! Sets the RGBA color to use for this DistantLightKit.
	 *	\param in_rgba_color The RGBA color to use for this DistantLightKit.
	 *	\return A reference to this DistantLightKit. */
	DistantLightKit &	SetColor(RGBAColor const & in_rgba_color);

	/*! Sets the color index to use for this DistantLightKit.
	 *	\param in_index The color index to use for this DistantLightKit.
	 *	\return A reference to this DistantLightKit. */
	DistantLightKit &	SetColorByIndex(float in_index);

	/*! Sets the camera-relative setting for this DistantLightKit.
	 *	\param in_state Whether the direction of this DistantLightKit is treated as being in object space or camera-relative space.
	 *	\return A reference to this DistantLightKit.
	 *	\sa SetDirection<br/>
	*   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#camera-relative-lights-enabled">Default value</a> */
	DistantLightKit &	SetCameraRelative(bool in_state);


	/*!	Removes the drawing priority setting.
	 *	\return A reference to this object. */
	DistantLightKit &	UnsetPriority();

	/*! Removes the direction set on this DistantLightKit.
	 *	\return A reference to this DistantLightKit. */
	DistantLightKit &	UnsetDirection();

	/*! Removes the color (RGBA or material index) set on this DistantLightKit.
	 *	\return A reference to this DistantLightKit. */
	DistantLightKit &	UnsetColor();

	/*! Removes the camera-relative setting on this DistantLightKit.
	 *	\return A reference to this DistantLightKit. */
	DistantLightKit &	UnsetCameraRelative();

	/*! Removes all settings from the DistantLightKit.
	 *	\return A reference to this DistantLightKit. */
	DistantLightKit &	UnsetEverything();


	/*! Shows the drawing priority for this DistantLightKit.
	 *	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	 *	\return <span class='code'>true</span> if drawing priority was specified, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Shows the direction in which this DistantLightKit lies.
	 *	\param out_vector The direction in which this DistantLightKit lies.
	 *	\return <span class='code'>true</span> if a direction was set, <span class='code'>false</span> otherwise. */
	bool				ShowDirection(HPS::Vector & out_vector) const;

	/*! Shows the color for this DistantLightKit.
	 *	\param out_type The type of color for the distant light.
	 *	\param out_rgba_color The RGBA color for the distant light.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for the distant light.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_index) const;

	/*! Shows the camera-relative setting for this DistantLightKit.
	 *	\param out_state Whether the direction of this DistantLightKit is treated as being in object space or camera-relative space.
	 *	\return <span class='code'>true</span> if a camera-relative setting was specified, <span class='code'>false</span> otherwise. */
	bool				ShowCameraRelative(bool & out_state) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	DistantLightKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	DistantLightKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	DistantLightKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	DistantLightKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	DistantLightKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	DistantLightKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	DistantLightKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};



/*! The DistantLightKey class is a smart pointer to a database object.  It is a handle to a distant light inserted via SegmentKey::InsertDistantLight. */
class HPS_API DistantLightKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized DistantLightKey object.  The Type() function will return Type::None. */
	DistantLightKey();

	/*! This constructor creates a DistantLightKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a DistantLight key.  Otherwise the copy will fail and the resulting DistantLightKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit DistantLightKey(Key const & in_that);

	/*! The copy constructor creates a DistantLightKey object that shares the underlying smart-pointer of the source DistantLightKey.
	 *	\param in_that The source DistantLightKey to copy. */
	DistantLightKey(DistantLightKey const & in_that);

	/*! Associate this DistantLightKey with the same underlying impl as the source DistantLightKey.
	 *	\param in_that The source DistantLightKey for the assignment.
	 *	\return A reference to this DistantLightKey. */
	DistantLightKey & operator=(DistantLightKey const & in_that);

	/*! The move constructor creates a DistantLightKey by transferring the underlying impl of the rvalue reference to this DistantLightKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DistantLightKey to take the impl from. */
	DistantLightKey(DistantLightKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DistantLightKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a DistantLightKey to take the impl from.
	 *	\return A reference to this DistantLightKey. */
	DistantLightKey & operator=(DistantLightKey && in_that);

	~DistantLightKey();

	static const HPS::Type staticType = HPS::Type::DistantLightKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this DistantLightKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this DistantLightKey. */
	void				Consume(DistantLightKit & in_kit);

	/*! Replace those settings on this DistantLightKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this DistantLightKey. */
	void				Set(DistantLightKit const & in_kit);

	/*! Copy the contents of this DistantLightKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this DistantLightKey. */
	void				Show(DistantLightKit & out_kit) const;

	/*! Sets the direction in which this DistantLightKey lies.  The rays emitted by this light will travel in the opposite direction of this vector.
	 *	\param in_vector The direction in which this DistantLightKey lies.  The vector will either be treated as being in object space or in camera-relative units depending on the setting passed SetCameraRelative.
	 *	\return A reference to this DistantLightKey.
	 *	\sa SetCameraRelative */
	DistantLightKey &	SetDirection(HPS::Vector const & in_vector);

	/*! Sets the RGBA color to use for this DistantLightKey.
	 *	\param in_rgba_color The RGBA color to use for this DistantLightKey.
	 *	\return A reference to this DistantLightKey. */
	DistantLightKey &	SetColor(RGBAColor const & in_rgba_color);

	/*! Sets the color index to use for this DistantLightKey.
	 *	\param in_index The color index to use for this DistantLightKey.
	 *	\return A reference to this DistantLightKey. */
	DistantLightKey &	SetColorByIndex(float in_index);

	/*! Sets the camera-relative setting for this DistantLightKey.
	 *	\param in_state Whether the direction of this DistantLightKey is treated as being in object space or camera-relative space.
	 *	\return A reference to this DistantLightKey.
	 *	\sa SetDirection */
	DistantLightKey &	SetCameraRelative(bool in_state);


	/*! Removes the color (RGBA or material index) set on this DistantLightKey.
	 *	\return A reference to this DistantLightKey. */
	DistantLightKey &	UnsetColor();


	/*! Shows the direction in which this DistantLightKey lies.
	 *	\param out_vector The direction in which this DistantLightKey lies.
	 *	\return <span class='code'>true</span> if a direction was set, <span class='code'>false</span> otherwise. */
	bool				ShowDirection(HPS::Vector & out_vector) const;

	/*! Shows the color for this DistantLightKey.
	 *	\param out_type The type of color for the distant light.
	 *	\param out_rgba_color The RGBA color for the distant light.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for the distant light.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_index) const;

	/*! Shows the camera-relative setting for this DistantLightKey.
	 *	\param out_state Whether the direction of this DistantLightKey is treated as being in object space or camera-relative space.
	 *	\return <span class='code'>true</span> if a camera-relative setting was specified, <span class='code'>false</span> otherwise. */
	bool				ShowCameraRelative(bool & out_state) const;
};




/*! The CylinderKit class is a user space object.  It is a kit analog to a CylinderKey. */
class HPS_API CylinderKit : public Kit
{
public:
	/*! The default constructor creates an empty CylinderKit object. */
	CylinderKit();

	/*! The copy constructor creates a new CylinderKit object that contains the same settings as the source CylinderKit.
	 * 	\param in_kit The source CylinderKit to copy. */
	CylinderKit(CylinderKit const & in_kit);

	/*! The move constructor creates a CylinderKit by transferring the underlying impl of the rvalue reference to this CylinderKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CylinderKit to take the impl from. */
	CylinderKit(CylinderKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CylinderKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CylinderKit to take the impl from.
	 *	\return A reference to this CylinderKit. */
	CylinderKit & operator=(CylinderKit && in_that);

	virtual ~CylinderKit();

	static const HPS::Type staticType = HPS::Type::CylinderKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source CylinderKit into this CylinderKit and resets the source kit.
	 * 	\param in_kit The source CylinderKit to consume. */
	void				Consume(CylinderKit & in_kit);

	/*! Copies the source CylinderKit into this CylinderKit.
	 * 	\param in_kit The source CylinderKit to copy. */
	void				Set(CylinderKit const & in_kit);

	/*! Copies this CylinderKit into the given CylinderKit.
	 * 	\param out_kit The CylinderKit to populate with the contents of this CylinderKit. */
	void				Show(CylinderKit & out_kit) const;

	/*! Copies the source CylinderKit into this CylinderKit.
	 * 	\param in_kit The source CylinderKit to copy.
	 * 	\return A reference to this CylinderKit. */
	CylinderKit &		operator=(CylinderKit const & in_kit);

	/*! Indicates whether this CylinderKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this CylinderKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source CylinderKit is equivalent to this CylinderKit.
	 *	\param in_kit The source CylinderKit to compare to this CylinderKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(CylinderKit const & in_kit) const;

	/*!	Check if the source CylinderKit is equivalent to this CylinderKit.
	 *	\param in_kit The source CylinderKit to compare to this CylinderKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(CylinderKit const & in_kit) const;

	/*!	Check if the source CylinderKit is not equivalent to this CylinderKit.
	 *	\param in_kit The source CylinderKit to compare to this CylinderKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(CylinderKit const & in_kit) const;

	/*!	Retrieves the number of points in this cylinder.
	 *	\return The number of points in this cylinder. */
	size_t				GetPointCount() const;

	/*!	Assigns a specific drawing priority value to the CylinderKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	CylinderKit &		SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	CylinderKit &		UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;


	/*! Sets the points for this CylinderKit.
	 *	\param in_points The points for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetPoints(PointArray const & in_points);

	/*! Sets the points for this CylinderKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetPoints(size_t in_count, Point const in_points []);

	/*! Sets the radii for this CylinderKit.  If the size of the radii array is smaller than the point array, the radii array will be walked repeatedly to determine the radius for all points.
	 *	\param in_radii The radii for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetRadii(FloatArray const & in_radii);

	/*! Sets the radii for this CylinderKit.  If the size of the radii array is smaller than the point array, the radii array will be walked repeatedly to determine the radius for all points.
	 *	\param in_count Size of the following array.
	 *	\param in_radii The radii for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetRadii(size_t in_count, float const in_radii []);

	/*! Sets the capping for this CylinderKit.
	 *	\param in_capping The capping for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetCaps(Cylinder::Capping in_capping);


	/*! Removes the points for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetPoints();

	/*! Removes the radii for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetRadii();

	/*! Removes the capping for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetCaps();

	/*! Removes all settings from the CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetEverything();


	/*! Show the points for this CylinderKit.
	 *	\param out_points The points for this CylinderKit.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this CylinderKit by range.
	*	\param in_start_index The first point to show.
	*	\param in_count The number of points to show.
	*	\param out_points The requested points for this CylinderKit.
	*	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this CylinderKit by list.
	*	\param in_indices The list of point indices to show.
	*	\param out_points The requested points for this CylinderKit.
	*	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this CylinderKit by list.
	*	\param in_count The number of points to show.
	*	\param in_indices The list of point indices to show.
	*	\param out_points The requested points for this CylinderKit.
	*	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Show the radii for this CylinderKit.
	 *	\param out_radii The radii for this CylinderKit.
	 *	\return <span class='code'>true</span> if radii were set, <span class='code'>false</span> otherwise. */
	bool				ShowRadii(FloatArray & out_radii) const;

	/*! Show the capping for this CylinderKit.
	 *	\param out_caps The capping for this CylinderKit.
	 *	\return <span class='code'>true</span> if a capping was set, <span class='code'>false</span> otherwise. */
	bool				ShowCaps(Cylinder::Capping & out_caps) const;


	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this CylinderKit.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start setting colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this CylinderKit.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single RGB color on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices for this CylinderKit.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified cylinder component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const in_rgb_colors[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified cylinder component.  If the sizes of the vertex index array and the color array different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColorArray const & in_rgb_colors, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified cylinder component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const & in_rgb_color, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified cylinder component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColor const & in_rgb_color, Cylinder::Component in_apply_to = Cylinder::Component::Faces);


	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_indices The material indices to set on the vertices for this CylinderKit.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start setting colors.
	 *	\param in_indices The material indices to set on the vertices for this CylinderKit.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByRange(size_t in_start, FloatArray const & in_indices, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single material index on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices for this CylinderKit.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float in_index, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified cylinder component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float const in_indices[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified cylinder component.  If the sizes of the vertex index and material index arrays are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByList(SizeTArray const & in_vertices, FloatArray const & in_indices, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified cylinder component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float in_index, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified cylinder component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		SetVertexIndexColorsByList(SizeTArray const & in_vertices, float in_index, Cylinder::Component in_apply_to = Cylinder::Component::Faces);


	/*! Removes all vertex colors (RGB colors or material indices) for all cylinder components.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetVertexColors();

	/*! Removes the specified range of vertex colors (RGB colors or material indices) for all cylinder components starting at the specified offset.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start removing colors.
	 *	\param in_count The number of vertex colors to remove for this CylinderKit.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetVertexColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex colors (RGB colors or material indices) for all cylinder components on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetVertexColorsByList(SizeTArray const & in_vertices);


	/*! Removes all vertex colors (RGB colors or material indices) for the specified cylinder component.
	 *	\param in_apply_to The cylinder component for which to remove the colors.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetVertexColors(Cylinder::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors or material indices) for the specified cylinder component starting at the specified offset.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start removing colors.
	 *	\param in_count The number of vertex colors to remove for this CylinderKit.
	 *	\param in_apply_to The cylinder component for which to remove the colors.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetVertexColorsByRange(size_t in_start, size_t in_count, Cylinder::Component in_apply_to);

	/*! Removes the vertex colors (RGB colors or material indices) for the specified cylinder component on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\param in_apply_to The cylinder component for which to remove the colors.
	 *	\return A reference to this CylinderKit. */
	CylinderKit &		UnsetVertexColorsByList(SizeTArray const & in_vertices, Cylinder::Component in_apply_to);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this CylinderKit.
	*	\param in_vertices The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this CylinderKit. */
	CylinderKit &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this CylinderKit.
	*	\param in_vertices The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The cylinder component that should be unset.
	*	\return A reference to this CylinderKit. */
	CylinderKit &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[], Cylinder::Component in_apply_to);

	/*! Shows all the vertex colors of the specified cylinder component.
	 *	\param in_apply_to The cylinder component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex.  If a vertex does not have a vertex color set for the specified cylinder component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each vertex.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex colors were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColors(Cylinder::Component in_apply_to, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKit at which to start showing colors.
	 *	\param in_count The number of colors to show.
	 *	\param in_apply_to The cylinder component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex in the specified range.  If a vertex in the specified range does not have a vertex color set for the specified cylinder component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each vertex in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByRange(size_t in_start, size_t in_count, Cylinder::Component in_apply_to, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a selection of arbitrary vertices which apply to the specified cylinder component.  The order of the values in the ouput arrays is the same as the input vertex
	 *	index array, i.e., the values of <span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, <span class='code'>out_rgba_colors[i]</span>,
	 *	and <span class='code'>out_indices[i]</span>, correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the colors.
	 *	\param in_apply_to The cylinder component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex at the specified index.  If a vertex at a specified index does not have a vertex color set for the specified component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each vertex at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByList(SizeTArray const & in_vertices, Cylinder::Component in_apply_to, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CylinderKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CylinderKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	CylinderKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	CylinderKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CylinderKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CylinderKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	CylinderKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};



/*! The CylinderKey class is a smart pointer to a database object.  It is a handle to a cylinder inserted via SegmentKey::InsertCylinder. */
class HPS_API CylinderKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized CylinderKey object.  The Type() function will return Type::None. */
	CylinderKey();

	/*! This constructor creates a CylinderKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a Cylinder key.  Otherwise the copy will fail and the resulting CylinderKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit CylinderKey(Key const & in_that);

	/*! The copy constructor creates a CylinderKey object that shares the underlying smart-pointer of the source CylinderKey.
	 *	\param in_that The source CylinderKey to copy. */
	CylinderKey(CylinderKey const & in_that);

	/*! Associate this CylinderKey with the same underlying impl as the source CylinderKey.
	 *	\param in_that The source CylinderKey for the assignment.
	 *	\return A reference to this CylinderKey. */
	CylinderKey & operator=(CylinderKey const & in_that);

	/*! The move constructor creates a CylinderKey by transferring the underlying impl of the rvalue reference to this CylinderKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CylinderKey to take the impl from. */
	CylinderKey(CylinderKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CylinderKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CylinderKey to take the impl from.
	 *	\return A reference to this CylinderKey. */
	CylinderKey & operator=(CylinderKey && in_that);

	~CylinderKey();

	static const HPS::Type staticType = HPS::Type::CylinderKey;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this CylinderKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CylinderKey. */
	void					Consume(CylinderKit & in_kit);

	/*! Replace those settings on this CylinderKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CylinderKey. */
	void					Set(CylinderKit const & in_kit);


	/*! Adds points to the point list for this CylinderKey.
	 *	\param in_offset The offset into the point list for the cylinder at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the point list for this CylinderKey.
	 *	\param in_offset The offset into the point list for the cylinder at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the point list for this CylinderKey.
	 *	\param in_offset The offset into the point list for the cylinder at which to start removing points.  This value must be such that <span class='code'>in_offset<point_count</span> for deletion to succeed.
	 *	\param in_count The number of points to delete from the point list for the cylinder.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the deletion to succeed.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces points in the point list for this CylinderKey.
	 *	\param in_offset The offset into the point list for the cylidner at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces points in the point list for this CylinderKey.
	 *	\param in_offset The offset into the point list for the cylidner at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.  This size of the array must be such that <span class='code'>in_offset+in_points.size()&lt;=point_count</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Adds radii to the radius list for this CylinderKey.
	 *	\param in_offset The offset into the radius list for the cylinder at which to insert radii.  This value must be such that <span class='code'>in_offset&lt;radius_count</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_radii The radii to insert into the radius list at the specified offset.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditRadiiByInsertion(size_t in_offset, size_t in_count, float const in_radii[]);

	/*! Adds radii to the radius list for this CylinderKey.
	 *	\param in_offset The offset into the radius list for the cylinder at which to insert radii.  This value must be such that <span class='code'>in_offset&lt;radius_count</span> for insertion to succeed.
	 *	\param in_radii The radii to insert into the radius list at the specified offset.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditRadiiByInsertion(size_t in_offset, FloatArray const & in_radii);

	/*! Removes radii from the radius list for this CylinderKey.
	 *	\param in_offset The offset into the radius list for the cylinder at which to start removing radii.  This value must be such that <span class='code'>in_offset&lt;radius_count</span> for deletion to succeed.
	 *	\param in_count The number of radii to delete from the radius list for the cylinder.  This value must be such that <span class='code'>in_offset+in_count&lt;=radius_count</span> for the deletion to succeed.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditRadiiByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces radii in the radius list for this CylinderKey.
	 *	\param in_offset The offset into the radius list for the cylidner at which to start replacing radii.  This value must be such that <span class='code'>in_offset&lt;radius_count</span> for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=radius_count</span> for the replacement to succeed.
	 *	\param in_radii The radii to use to replace those in the radius list at the specified offset.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditRadiiByReplacement(size_t in_offset, size_t in_count, float const in_radii[]);

	/*! Replaces radii in the radius list for this CylinderKey.
	 *	\param in_offset The offset into the radius list for the cylidner at which to start replacing radii.  This value must be such that <span class='code'>in_offset&lt;radius_count</span> for replacement to succeed.
	 *	\param in_radii The radii to use to replace those in the radius list at the specified offset.  This size of the array must be such that <span class='code'>in_offset+in_points.size()&lt;=radius_count</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			EditRadiiByReplacement(size_t in_offset, FloatArray const & in_radii);


	/*! Copy the contents of this CylinderKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this CylinderKey. */
	void					Show(CylinderKit & out_kit) const;

	/*!	Retrieves the number of points in this cylinder.
	 *	\return The number of points in this cylinder. */
	size_t					GetPointCount() const;

	/*! Show the points for this CylinderKey.
	 *	\param out_points The points for this CylinderKey.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool					ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this CylinderKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this CylinderKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this CylinderKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this CylinderKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this CylinderKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this CylinderKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Show the radii for this CylinderKey.
	 *	\param out_radii The radii for this CylinderKey.
	 *	\return <span class='code'>true</span> if radii were set, <span class='code'>false</span> otherwise. */
	bool					ShowRadii(FloatArray & out_radii) const;

	/*! Show the capping for this CylinderKey.
	 *	\param out_caps The capping for this CylinderKey.
	 *	\return <span class='code'>true</span> if a capping was set, <span class='code'>false</span> otherwise. */
	bool					ShowCaps(Cylinder::Capping & out_caps) const;


	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this CylinderKey.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylilnder::Component::Faces.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this CylinderKey.  The size of the array must be such that <span class='code'>in_start+in_rgb_colors.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single RGB color on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the vertices for this CylinderKey.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color, Cylinder::Component in_apply_to = Cylinder::Component::Faces);


	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_indices The material indices to set on the vertices for this CylinderKey.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the vertices for this CylinderKey.  The size of the array must be such that <span class='code'>in_start+in_indices.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByRange(size_t in_start, FloatArray const & in_indices, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets a single material index on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_index The material index to set on the vertices for this CylinderKey.
	 *	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float in_index, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_rgb_colors The RGB colors to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const in_rgb_colors[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_rgb_colors The RGB colors to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColorArray const & in_rgb_colors, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_rgb_color The RGB color to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const & in_rgb_color, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_rgb_color The RGB color to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColor const & in_rgb_color, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_indices The material indices to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float const in_indices[], Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_indices The material indices to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, FloatArray const & in_indices, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_index The material index to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float in_index, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified cylinder component.
	*	\param in_vertices The indices of the vertices on which to set the colors.
	*	\param in_index The material index to set on the vertices.
	*	\param in_apply_to The cylinder component the colors should apply to.  Defaults to Cylinder::Component::Faces.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, float in_index, Cylinder::Component in_apply_to = Cylinder::Component::Faces);

	/*! Removes all vertex colors (RGB colors or material indices) for all cylinder components.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColors();

	/*! Removes the specified range of vertex colors (RGB colors or material indices) for all cylinder components starting at the specified offset.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start removing colors.  This value must be such that <span class='code'>in_start<point_count</span> for unsetting to succeed.
	 *	\param in_count The number of vertex colors to remove for this CylinderKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for unsetting to succeed.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColorsByRange(size_t in_start, size_t in_count);

	/*! Removes all vertex colors (RGB colors or material indices) for the specified cylinder component.
	 *	\param in_apply_to The cylinder component for which to remove the colors.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColors(Cylinder::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors or material indices) for the specified cylinder component starting at the specified offset.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start removing colors.  This value must be such that <span class='code'>in_start<point_count</span> for unsetting to succeed.
	 *	\param in_count The number of vertex colors to remove for this CylinderKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for unsetting to succeed.
	 *	\param in_apply_to The cylinder component for which to remove the colors.
	 *	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColorsByRange(size_t in_start, size_t in_count, Cylinder::Component in_apply_to);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this CylinderKey.
	*	\param in_vertices The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_vertices The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColorsByList(SizeTArray const & in_vertices);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this CylinderKey.
	*	\param in_vertices The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The cylinder component that should be unset.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[], Cylinder::Component in_apply_to);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this CylinderKey.
	*	\param in_vertices The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The cylinder component that should be unset.
	*	\return A reference to this CylinderKey. */
	CylinderKey &			UnsetVertexColorsByList(SizeTArray const & in_vertices, Cylinder::Component in_apply_to);

	/*! Shows all the vertex colors of the specified cylinder component.
	 *	\param in_apply_to The cylinder component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex.  If a vertex does not have a vertex color set for the specified cylinder component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each vertex.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex colors were shown, <span class='code'>false</span> otherwise. */
	bool					ShowVertexColors(Cylinder::Component in_apply_to, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a range of vertices starting at the specified offset which apply to the specified cylinder component.
	 *	\param in_start The offset into the vertices for this CylinderKey at which to start showing colors.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of colors to show.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for showing to succeed.
	 *	\param in_apply_to The cylinder component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex in the specified range.  If a vertex in the specified range does not have a vertex color set for the specified cylinder component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each vertex in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool					ShowVertexColorsByRange(size_t in_start, size_t in_count, Cylinder::Component in_apply_to, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a selection of arbitrary vertices which apply to the specified cylinder component.  The order of the values in the ouput arrays is the same as the input vertex
	 *	index array, i.e., the values of <span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, and <span class='code'>out_indices[i]</span>,
	 *	correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the colors.
	 *	\param in_apply_to The cylinder component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex at the specified index.  If a vertex at a specified index does not have a vertex color set for the specified component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each vertex at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool					ShowVertexColorsByList(SizeTArray const & in_vertices, Cylinder::Component in_apply_to, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;
};




/*! The SphereKit class is a user space object.  It is a kit analog to a SphereKey. */
class HPS_API SphereKit : public Kit
{
public:
	/*! The default constructor creates an empty SphereKit object. */
	SphereKit();

	/*! The copy constructor creates a new SphereKit object that contains the same settings as the source SphereKit.
	 * 	\param in_kit The source SphereKit to copy. */
	SphereKit(SphereKit const & in_kit);

	/*! The move constructor creates a SphereKit by transferring the underlying impl of the rvalue reference to this SphereKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SphereKit to take the impl from. */
	SphereKit(SphereKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SphereKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SphereKit to take the impl from.
	 *	\return A reference to this SphereKit. */
	SphereKit & operator=(SphereKit && in_that);

	virtual ~SphereKit();

	static const HPS::Type staticType = HPS::Type::SphereKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source SphereKit into this SphereKit and resets the source kit.
	 * 	\param in_kit The source SphereKit to consume. */
	void				Consume(SphereKit & in_kit);

	/*! Copies the source SphereKit into this SphereKit.
	 * 	\param in_kit The source SphereKit to copy. */
	void				Set(SphereKit const & in_kit);

	/*! Copies this SphereKit into the given SphereKit.
	 * 	\param out_kit The SphereKit to populate with the contents of this SphereKit. */
	void				Show(SphereKit & out_kit) const;

	/*! Copies the source SphereKit into this SphereKit.
	 * 	\param in_kit The source SphereKit to copy.
	 * 	\return A reference to this SphereKit. */
	SphereKit &			operator=(SphereKit const & in_kit);

	/*! Indicates whether this SphereKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this SphereKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source SphereKit is equivalent to this SphereKit.
	 *	\param in_kit The source SphereKit to compare to this SphereKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(SphereKit const & in_kit) const;

	/*!	Check if the source SphereKit is equivalent to this SphereKit.
	 *	\param in_kit The source SphereKit to compare to this SphereKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(SphereKit const & in_kit) const;

	/*!	Check if the source SphereKit is not equivalent to this SphereKit.
	 *	\param in_kit The source SphereKit to compare to this SphereKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(SphereKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the SphereKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	SphereKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	SphereKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;

	/*! Sets the center point for the SphereKit.
	 *	\param in_center The center point for the SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			SetCenter(Point const & in_center);

	/*! Sets the radius for the SphereKit.
	 *	\param in_radius The radius for the SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			SetRadius(float in_radius);

	/*! Sets the basis for the SphereKit.
	 *	\param in_vertical The vector to use as the vertical axis for the SphereKit.
	 *	\param in_horizontal The vector to use as the horizontal axis for the SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			SetBasis(Vector const & in_vertical, Vector const & in_horizontal);


	/*! Removes the center point for this SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			UnsetCenter();

	/*! Removes the radius for this SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			UnsetRadius();

	/*! Removes the basis for this SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			UnsetBasis();

	/*! Removes all settings from the SphereKit.
	 *	\return A reference to this SphereKit. */
	SphereKit &			UnsetEverything();


	/*! Shows the center point for this SphereKit.
	 *	\param out_center The center point for the SphereKit.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(Point & out_center) const;

	/*! Shows the radius for the SphereKit.
	 *	\param out_radius The radius for the SphereKit.
	 *	\return <span class='code'>true</span> if a radius was set, <span class='code'>false</span> otherwise. */
	bool				ShowRadius(float & out_radius) const;

	/*! Shows the basis for the SphereKit.
	 *	\param out_vertical The vector to use as the vertical axis for the SphereKit.
	 *	\param out_horizontal The vector to use as the horizontal axis for the SphereKit.
	 *	\return <span class='code'>true</span> if a basis was set, <span class='code'>false</span> otherwise. */
	bool				ShowBasis(Vector & out_vertical, Vector & out_horizontal) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	SphereKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	SphereKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	SphereKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	SphereKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	SphereKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	SphereKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	SphereKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};

/*! The SphereKey class is a smart pointer to a database object.  It is a handle to a sphere inserted via SegmentKey::InsertSphere. */
class HPS_API SphereKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized SphereKey object.  The Type() function will return Type::None. */
	SphereKey();

	/*! This constructor creates a SphereKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a Sphere key.  Otherwise the copy will fail and the resulting SphereKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit SphereKey(Key const & in_that);

	/*! The copy constructor creates a SphereKey object that shares the underlying smart-pointer of the source SphereKey.
	 *	\param in_that The source SphereKey to copy. */
	SphereKey(SphereKey const & in_that);

	/*! Associate this SphereKey with the same underlying impl as the source SphereKey.
	 *	\param in_that The source SphereKey for the assignment.
	 *	\return A reference to this SphereKey. */
	SphereKey & operator=(SphereKey const & in_that);

	/*! The move constructor creates a SphereKey by transferring the underlying impl of the rvalue reference to this SphereKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SphereKey to take the impl from. */
	SphereKey(SphereKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SphereKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SphereKey to take the impl from.
	 *	\return A reference to this SphereKey. */
	SphereKey & operator=(SphereKey && in_that);

	~SphereKey();

	static const HPS::Type staticType = HPS::Type::SphereKey;
	HPS::Type	ObjectType() const {return staticType;};

	/*! Completely replaces all settings on this SphereKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this SphereKey. */
	void				Consume(SphereKit & in_kit);

	/*! Replace those settings on this SphereKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this SphereKey. */
	void				Set(SphereKit const & in_kit);

	/*! Copy the contents of this SphereKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this SphereKey. */
	void				Show(SphereKit & out_kit) const;


	/*! Sets the center point for the SphereKey.
	 *	\param in_center The center point for the SphereKey.
	 *	\return A reference to this SphereKey. */
	SphereKey &			SetCenter(Point const & in_center);

	/*! Sets the radius for the SphereKey.
	 *	\param in_radius The radius for the SphereKey.
	 *	\return A reference to this SphereKey. */
	SphereKey &			SetRadius(float in_radius);

	/*! Sets the basis for the SphereKey.
	 *	\param in_vertical The vector to use as the vertical axis for the SphereKey.
	 *	\param in_horizontal The vector to use as the horizontal axis for the SphereKey.
	 *	\return A reference to this SphereKey. */
	SphereKey &			SetBasis(Vector const & in_vertical, Vector const & in_horizontal);


	/*! Shows the center point for this SphereKey.
	 *	\param out_center The center point for the SphereKey.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(Point & out_center) const;

	/*! Shows the radius for the SphereKey.
	 *	\param out_radius The radius for the SphereKey.
	 *	\return <span class='code'>true</span> if a radius was set, <span class='code'>false</span> otherwise. */
	bool				ShowRadius(float & out_radius) const;

	/*! Shows the basis for the SphereKey.
	 *	\param out_vertical The vector to use as the vertical axis for the SphereKey.
	 *	\param out_horizontal The vector to use as the horizontal axis for the SphereKey.
	 *	\return <span class='code'>true</span> if a basis was set, <span class='code'>false</span> otherwise. */
	bool				ShowBasis(Vector & out_vertical, Vector & out_horizontal) const;
};




/*! The HPS::CircleKit class is a user space object.  It is a kit analog to a HPS::CircleKey. */
class HPS_API CircleKit : public Kit
{
public:
	/*! The default constructor creates an empty CircleKit object. */
	CircleKit();

	/*! The copy constructor creates a new CircleKit object that contains the same settings as the source CircleKit.
	 * 	\param in_kit The source CircleKit to copy. */
	CircleKit(CircleKit const & in_kit);

	/*! The move constructor creates a CircleKit by transferring the underlying impl of the rvalue reference to this CircleKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircleKit to take the impl from. */
	CircleKit(CircleKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircleKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CircleKit to take the impl from.
	 *	\return A reference to this CircleKit. */
	CircleKit & operator=(CircleKit && in_that);

	virtual ~CircleKit();

	static const HPS::Type staticType = HPS::Type::CircleKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source CircleKit into this CircleKit and resets the source kit.
	 * 	\param in_kit The source CircleKit to consume. */
	void				Consume(CircleKit & in_kit);

	/*! Copies the source CircleKit into this CircleKit.
	 * 	\param in_kit The source CircleKit to copy. */
	void				Set(CircleKit const & in_kit);

	/*! Copies this CircleKit into the given CircleKit.
	 * 	\param out_kit The CircleKit to populate with the contents of this CircleKit. */
	void				Show(CircleKit & out_kit) const;

	/*! Copies the source CircleKit into this CircleKit.
	 * 	\param in_kit The source CircleKit to copy.
	 * 	\return A reference to this CircleKit. */
	CircleKit &			operator=(CircleKit const & in_kit);

	/*! Indicates whether this CircleKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this CircleKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source CircleKit is equivalent to this CircleKit.
	 *	\param in_kit The source CircleKit to compare to this CircleKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(CircleKit const & in_kit) const;

	/*!	Check if the source CircleKit is equivalent to this CircleKit.
	 *	\param in_kit The source CircleKit to compare to this CircleKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(CircleKit const & in_kit) const;

	/*!	Check if the source CircleKit is not equivalent to this CircleKit.
	 *	\param in_kit The source CircleKit to compare to this CircleKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(CircleKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the CircleKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	CircleKit &				SetPriority(int const in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	CircleKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;



	/*! Sets the center point for this CircleKit.
	 *	\param in_center The center point for this CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			SetCenter(Point const & in_center);

	/*! Sets the radius for this CircleKit.
	 *	\param in_radius The radius for this CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			SetRadius(float in_radius);

	/*! Sets the normal for this CircleKit.  This is the normal for the plane in which the circle lies.
	 *	\param in_normal The normal for this CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			SetNormal(Vector const & in_normal);


	/*! Removes the center point for this CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			UnsetCenter();

	/*! Removes the radius for this CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			UnsetRadius();

	/*! Removes the normal for this CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			UnsetNormal();

	/*! Removes all settings from the CircleKit.
	 *	\return A reference to this CircleKit. */
	CircleKit &			UnsetEverything();


	/*! Shows the center point for this CircleKit.
	 *	\param out_center The center point for this CircleKit.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(Point & out_center) const;

	/*! Shows the radius for this CircleKit.
	 *	\param out_radius The radius for this CircleKit.
	 *	\return <span class='code'>true</span> if a radius was set, <span class='code'>false</span> otherwise. */
	bool				ShowRadius(float & out_radius) const;

	/*! Shows the normal for this CircleKit.
	 *	\param out_normal The normal for this CircleKit.
	 *	\return <span class='code'>true</span> if a normal was set, <span class='code'>false</span> otherwise. */
	bool				ShowNormal(Vector & out_normal) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CircleKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CircleKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	CircleKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	CircleKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CircleKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CircleKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	CircleKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The CircleKey class is a smart pointer to a database object.  It is a handle to a circle inserted via SegmentKey::InsertCircle.
 *	A circle has face geometry contained within its circumference.  The visualization of the circle will be determined by attribute settings affecting faces and edges. */
class HPS_API CircleKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized CircleKey object.  The Type() function will return Type::None. */
	CircleKey();

	/*! This constructor creates a CircleKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a Circle key.  Otherwise the copy will fail and the resulting CircleKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit CircleKey(Key const & in_that);

	/*! The copy constructor creates a CircleKey object that shares the underlying smart-pointer of the source CircleKey.
	 *	\param in_that The source CircleKey to copy. */
	CircleKey(CircleKey const & in_that);

	/*! Associate this CircleKey with the same underlying impl as the source CircleKey.
	 *	\param in_that The source CircleKey for the assignment.
	 *	\return A reference to this CircleKey. */
	CircleKey & operator=(CircleKey const & in_that);

	/*! The move constructor creates a CircleKey by transferring the underlying impl of the rvalue reference to this CircleKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircleKey to take the impl from. */
	CircleKey(CircleKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircleKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CircleKey to take the impl from.
	 *	\return A reference to this CircleKey. */
	CircleKey & operator=(CircleKey && in_that);

	~CircleKey();

	static const HPS::Type staticType = HPS::Type::CircleKey;
	HPS::Type			ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this CircleKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CircleKey. */
	void				Consume(CircleKit & in_kit);

	/*! Replace those settings on this CircleKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CircleKey. */
	void				Set(CircleKit const & in_kit);

	/*! Copy the contents of this CircleKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this CircleKey. */
	void				Show(CircleKit & out_kit) const;


	/*! Sets the center point for this CircleKey.
	 *	\param in_center The center point for this CircleKey.
	 *	\return A reference to this CircleKey. */
	CircleKey &			SetCenter(Point const & in_center);

	/*! Sets the radius for this CircleKey.
	 *	\param in_radius The radius for this CircleKey.
	 *	\return A reference to this CircleKey. */
	CircleKey &			SetRadius(float in_radius);

	/*! Sets the normal for this CircleKey.  This is the normal for the plane in which the circle lies.
	 *	\param in_normal The normal for this CircleKey.
	 *	\return A reference to this CircleKey. */
	CircleKey &			SetNormal(Vector const & in_normal);


	/*! Shows the center point for this CircleKey.
	 *	\param out_center The center point for this CircleKey.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(Point & out_center) const;

	/*! Shows the radius for this CircleKey.
	 *	\param out_radius The radius for this CircleKey.
	 *	\return <span class='code'>true</span> if a radius was set, <span class='code'>false</span> otherwise. */
	bool				ShowRadius(float & out_radius) const;

	/*! Shows the normal for this CircleKey.
	 *	\param out_normal The normal for this CircleKey.
	 *	\return <span class='code'>true</span> if a normal was set, <span class='code'>false</span> otherwise. */
	bool				ShowNormal(Vector & out_normal) const;
};




/*! The CircularArcKit class is a user space object.  It is a kit analog to a CircularArcKey. */
class HPS_API CircularArcKit : public Kit
{
public:
	/*! The default constructor creates an empty CircularArcKit object. */
	CircularArcKit();

	/*! The copy constructor creates a new CircularArcKit object that contains the same settings as the source CircularArcKit.
	 * 	\param in_kit The source CircularArcKit to copy. */
	CircularArcKit(CircularArcKit const & in_kit);

	/*! The move constructor creates a CircularArcKit by transferring the underlying impl of the rvalue reference to this CircularArcKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircularArcKit to take the impl from. */
	CircularArcKit(CircularArcKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircularArcKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CircularArcKit to take the impl from.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit & operator=(CircularArcKit && in_that);

	virtual ~CircularArcKit();

	static const HPS::Type staticType = HPS::Type::CircularArcKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source CircularArcKit into this CircularArcKit and resets the source kit.
	 * 	\param in_kit The source LineKit to consume. */
	void					Consume(CircularArcKit & in_kit);

	/*! Copies the source CircularArcKit into this CircularArcKit.
	 * 	\param in_kit The source CircularArcKit to copy. */
	void					Set(CircularArcKit const & in_kit);

	/*! Copies this CircularArcKit into the given CircularArcKit.
	 * 	\param out_kit The CircularArcKit to populate with the contents of this CircularArcKit. */
	void					Show(CircularArcKit & out_kit) const;

	/*! Copies the source CircularArcKit into this CircularArcKit.
	 * 	\param in_kit The source CircularArcKit to copy.
	 * 	\return A reference to this CircularArcKit. */
	CircularArcKit &		operator=(CircularArcKit const & in_kit);

	/*! Indicates whether this CircularArcKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this CircularArcKit, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source CircularArcKit is equivalent to this CircularArcKit.
	 *	\param in_kit The source CircularArcKit to compare to this CircularArcKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(CircularArcKit const & in_kit) const;

	/*!	Check if the source CircularArcKit is equivalent to this CircularArcKit.
	 *	\param in_kit The source CircularArcKit to compare to this CircularArcKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(CircularArcKit const & in_kit) const;

	/*!	Check if the source CircularArcKit is not equivalent to this CircularArcKit.
	 *	\param in_kit The source CircularArcKit to compare to this CircularArcKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(CircularArcKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the CircularArcKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	CircularArcKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	CircularArcKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;


	/*! Sets the start point for this CircularArcKit.  This is the point on the circumference of the circle at which the circular arc starts.
	 *	\param in_start The start point for this CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		SetStart(Point const & in_start);

	/*! Sets the middle point for this CircularArcKit.  This is a point on the circumference of the circle between the start and end points for the circular arc.
	 *	\param in_middle The middle point for this CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		SetMiddle(Point const & in_middle);

	/*! Sets the end point for this CircularArcKit.  This is the point on the circumference of the circle at which the circular arc ends.
	 *	\param in_end The end point for this CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		SetEnd(Point const & in_end);


	/*! Removes the start point for this CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		UnsetStart();

	/*! Removes the middle point for this CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		UnsetMiddle();

	/*! Removes the end point for this CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		UnsetEnd();

	/*! Removes all settings from the CircularArcKit.
	 *	\return A reference to this CircularArcKit. */
	CircularArcKit &		UnsetEverything();


	/*! Shows the start point for this CircularArcKit.
	 *	\param out_start The start point for this CircularArcKit.
	 *	\return <span class='code'>true</span> if a start point was set, <span class='code'>false</span> otherwise. */
	bool					ShowStart(Point & out_start) const;

	/*! Shows the middle point for this CircularArcKit.
	 *	\param out_middle The middle point for this CircularArcKit.
	 *	\return <span class='code'>true</span> if a middle point was set, <span class='code'>false</span> otherwise. */
	bool					ShowMiddle(Point & out_middle) const;

	/*! Shows the end point for this CircularArcKit.
	 *	\param out_end The end point for this CircularArcKit.
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool					ShowEnd(Point & out_end) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CircularArcKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CircularArcKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	CircularArcKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	CircularArcKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CircularArcKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CircularArcKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	CircularArcKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};

/*! The CircularArcKey class is a smart pointer to a database object.  It is handle to a circular arc inserted via SegmentKey::InsertCircularArc.
 *	A circular arc is the line geometry, as such its visualization will be determined by attributes affecting lines. */
class HPS_API CircularArcKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized CircularArcKey object.  The Type() function will return Type::None. */
	CircularArcKey();

	/*! This constructor creates a CircularArcKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a CircularArc key.  Otherwise the copy will fail and the resulting CircularArcKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit CircularArcKey(Key const & in_that);

	/*! The copy constructor creates a CircularArcKey object that shares the underlying smart-pointer of the source CircularArcKey.
	 *	\param in_that The source CircularArcKey to copy. */
	CircularArcKey(CircularArcKey const & in_that);

	/*! Associate this CircularArcKey with the same underlying impl as the source CircularArcKey.
	 *	\param in_that The source CircularArcKey for the assignment.
	 *	\return A reference to this CircularArcKey. */
	CircularArcKey & operator=(CircularArcKey const & in_that);

	/*! The move constructor creates a CircularArcKey by transferring the underlying impl of the rvalue reference to this CircularArcKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircularArcKey to take the impl from. */
	CircularArcKey(CircularArcKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircularArcKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CircularArcKey to take the impl from.
	 *	\return A reference to this CircularArcKey. */
	CircularArcKey & operator=(CircularArcKey && in_that);

	~CircularArcKey();

	static const HPS::Type staticType = HPS::Type::CircularArcKey;
	HPS::Type				ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this CircularArcKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CircularArcKey. */
	void					Consume(CircularArcKit & in_kit);

	/*! Replace those settings on this CircularArcKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CircularArcKey. */
	void					Set(CircularArcKit const & in_kit);

	/*! Copy the contents of this CircularArcKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this CircularArcKey. */
	void					Show(CircularArcKit & out_kit) const;


	/*! Sets the start point for this CircularArcKey.  This is the point on the circumference of the circle at which the circular arc starts.
	 *	\param in_start The start point for this CircularArcKey.
	 *	\return A reference to this CircularArcKey. */
	CircularArcKey &		SetStart(Point const & in_start);

	/*! Sets the middle point for this CircularArcKey.  This is a point on the circumference of the circle between the start and end points for the circular arc.
	 *	\param in_middle The middle point for this CircularArcKey.
	 *	\return A reference to this CircularArcKey. */
	CircularArcKey &		SetMiddle(Point const & in_middle);

	/*! Sets the end point for this CircularArcKey.  This is the point on the circumference of the circle at which the circular arc ends.
	 *	\param in_end The end point for this CircularArcKey.
	 *	\return A reference to this CircularArcKey. */
	CircularArcKey &		SetEnd(Point const & in_end);


	/*! Shows the start point for this CircularArcKey.
	 *	\param out_start The start point for this CircularArcKey.
	 *	\return <span class='code'>true</span> if a start point was set, <span class='code'>false</span> otherwise. */
	bool					ShowStart(Point & out_start) const;

	/*! Shows the middle point for this CircularArcKey.
	 *	\param out_middle The middle point for this CircularArcKey.
	 *	\return <span class='code'>true</span> if a middle point was set, <span class='code'>false</span> otherwise. */
	bool					ShowMiddle(Point & out_middle) const;

	/*! Shows the end point for this CircularArcKey.
	 *	\param out_end The end point for this CircularArcKey.
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool					ShowEnd(Point & out_end) const;
};



/*! The CircularWedgeKit class is a user space object.  It is a kit analog to a CircularWedgeKey. */
class HPS_API CircularWedgeKit : public Kit
{
public:
	/*! The default constructor creates an empty CircularWedgeKit object. */
	CircularWedgeKit();

	/*! The copy constructor creates a new CircularWedgeKit object that contains the same settings as the source CircularWedgeKit.
	 * 	\param in_kit The source CircularWedgeKit to copy. */
	CircularWedgeKit(CircularWedgeKit const & in_kit);

	/*! The move constructor creates a CircularWedgeKit by transferring the underlying impl of the rvalue reference to this CircularWedgeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircularWedgeKit to take the impl from. */
	CircularWedgeKit(CircularWedgeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircularWedgeKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CircularWedgeKit to take the impl from.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit & operator=(CircularWedgeKit && in_that);

	virtual ~CircularWedgeKit();

	static const HPS::Type staticType = HPS::Type::CircularWedgeKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source CircularWedgeKit into this CircularWedgeKit and resets the source kit.
	 * 	\param in_kit The source CircularWedgeKit to consume. */
	void					Consume(CircularWedgeKit & in_kit);

	/*! Copies the source CircularWedgeKit into this CircularWedgeKit.
	 * 	\param in_kit The source CircularWedgeKit to copy. */
	void					Set(CircularWedgeKit const & in_kit);

	/*! Copies this CircularWedgeKit into the given CircularWedgeKit.
	 * 	\param out_kit The CircularWedgeKit to populate with the contents of this CircularWedgeKit. */
	void					Show(CircularWedgeKit & out_kit) const;

	/*! Copies the source CircularWedgeKit into this CircularWedgeKit.
	 * 	\param in_kit The source CircularWedgeKit to copy.
	 * 	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		operator=(CircularWedgeKit const & in_kit);

	/*! Indicates whether this CircularWedgeKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this CircularWedgeKit, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source CircularWedgeKit is equivalent to this CircularWedgeKit.
	 *	\param in_kit The source CircularWedgeKit to compare to this CircularWedgeKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(CircularWedgeKit const & in_kit) const;

	/*!	Check if the source CircularWedgeKit is equivalent to this CircularWedgeKit.
	 *	\param in_kit The source CircularWedgeKit to compare to this CircularWedgeKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(CircularWedgeKit const & in_kit) const;

	/*!	Check if the source CircularWedgeKit is not equivalent to this CircularWedgeKit.
	 *	\param in_kit The source CircularWedgeKit to compare to this CircularWedgeKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(CircularWedgeKit const & in_kit) const;


	/*!	Assigns a specific drawing priority value to the CircularWedgeKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	CircularWedgeKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	CircularWedgeKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;


	/*! Sets the start point for this CircularWedgeKit.  This is the point on the circumference of the circle at which the circular wedge starts.
	 *	\param in_start The start point for this CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		SetStart(Point const & in_start);

	/*! Sets the middle point for this CircularWedgeKit.  This is a point on the circumference of the circle between the start and end points for the circular wedge.
	 *	\param in_middle The middle point for this CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		SetMiddle(Point const & in_middle);

	/*! Sets the end point for this CircularWedgeKit.  This is the point on the circumference of the circle at which the circular wedge ends.
	 *	\param in_end The end point for this CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		SetEnd(Point const & in_end);


	/*! Removes the start point for this CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		UnsetStart();

	/*! Removes the middle point for this CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		UnsetMiddle();

	/*! Removes the end point for this CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		UnsetEnd();

	/*! Removes all settings from the CircularWedgeKit.
	 *	\return A reference to this CircularWedgeKit. */
	CircularWedgeKit &		UnsetEverything();


	/*! Shows the start point for this CircularWedgeKit.
	 *	\param out_start The start point for this CircularWedgeKit.
	 *	\return <span class='code'>true</span> if a start point was set, <span class='code'>false</span> otherwise. */
	bool					ShowStart(Point & out_start) const;

	/*! Shows the middle point for this CircularWedgeKit.
	 *	\param out_middle The middle point for this CircularWedgeKit.
	 *	\return <span class='code'>true</span> if a middle point was set, <span class='code'>false</span> otherwise. */
	bool					ShowMiddle(Point & out_middle) const;

	/*! Shows the end point for this CircularWedgeKit.
	 *	\param out_end The end point for this CircularWedgeKit.
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool					ShowEnd(Point & out_end) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	CircularWedgeKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The CircularWedgeKey class is a smart pointer to a database object.  It is a handle to a circular wedge inserted via SegmentKey::InsertCircularWedge.
 *	A circular wedge has face geometry contained within the boundary edges of the circular wedge.  The visualization of the wedge will be determined by attribute settings
 *	affecting faces and edges. */
class HPS_API CircularWedgeKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized CircularWedgeKey object.  The Type() function will return Type::None. */
	CircularWedgeKey();

	/*! This constructor creates a CircularWedgeKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a CircularWedge key.  Otherwise the copy will fail and the resulting CircularWedgeKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit CircularWedgeKey(Key const & in_that);

	/*! The copy constructor creates a CircularWedgeKey object that shares the underlying smart-pointer of the source CircularWedgeKey.
	 *	\param in_that The source CircularWedgeKey to copy. */
	CircularWedgeKey(CircularWedgeKey const & in_that);

	/*! Associate this CircularWedgeKey with the same underlying impl as the source CircularWedgeKey.
	 *	\param in_that The source CircularWedgeKey for the assignment.
	 *	\return A reference to this CircularWedgeKey. */
	CircularWedgeKey & operator=(CircularWedgeKey const & in_that);

	/*! The move constructor creates a CircularWedgeKey by transferring the underlying impl of the rvalue reference to this CircularWedgeKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircularWedgeKey to take the impl from. */
	CircularWedgeKey(CircularWedgeKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircularWedgeKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CircularWedgeKey to take the impl from.
	 *	\return A reference to this CircularWedgeKey. */
	CircularWedgeKey & operator=(CircularWedgeKey && in_that);

	~CircularWedgeKey();

	static const HPS::Type staticType = HPS::Type::CircularWedgeKey;
	HPS::Type			ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this CircularWedgeKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CircularWedgeKey. */
	void					Consume(CircularWedgeKit & in_kit);

	/*! Replace those settings on this CircularWedgeKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CircularWedgeKey. */
	void					Set(CircularWedgeKit const & in_kit);

	/*! Copy the contents of this CircularWedgeKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this CircularWedgeKey. */
	void					Show(CircularWedgeKit & out_kit) const;


	/*! Sets the start point for this CircularWedgeKey.  This is the point on the circumference of the circle at which the circular wedge starts.
	 *	\param in_start The start point for this CircularWedgeKey.
	 *	\return A reference to this CircularWedgeKey. */
	CircularWedgeKey &		SetStart(Point const & in_start);

	/*! Sets the middle point for this CircularWedgeKey.  This is a point on the circumference of the circle between the start and end points for the circular wedge.
	 *	\param in_middle The middle point for this CircularWedgeKey.
	 *	\return A reference to this CircularWedgeKey. */
	CircularWedgeKey &		SetMiddle(Point const & in_middle);

	/*! Sets the end point for this CircularWedgeKey.  This is the point on the circumference of the circle at which the circular wedge ends.
	 *	\param in_end The end point for this CircularWedgeKey.
	 *	\return A reference to this CircularWedgeKey. */
	CircularWedgeKey &		SetEnd(Point const & in_end);


	/*! Shows the start point for this CircularWedgeKey.
	 *	\param out_start The start point for this CircularWedgeKey.
	 *	\return <span class='code'>true</span> if a start point was set, <span class='code'>false</span> otherwise. */
	bool					ShowStart(Point & out_start) const;

	/*! Shows the middle point for this CircularWedgeKey.
	 *	\param out_middle The middle point for this CircularWedgeKey.
	 *	\return <span class='code'>true</span> if a middle point was set, <span class='code'>false</span> otherwise. */
	bool					ShowMiddle(Point & out_middle) const;

	/*! Shows the end point for this CircularWedgeKey.
	 *	\param out_end The end point for this CircularWedgeKey.
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool					ShowEnd(Point & out_end) const;
};



/*! The CuttingSectionKit class is a user space object.  It is a kit analog to a CuttingSectionKey. */
class HPS_API CuttingSectionKit : public Kit
{
public:
	/*! The default constructor creates an empty CuttingSectionKit object. */
	CuttingSectionKit();

	/*! The copy constructor creates a new CuttingSectionKit object that contains the same settings as the source CuttingSectionKit.
	 * 	\param in_kit The source CuttingSectionKit to copy. */
	CuttingSectionKit(CuttingSectionKit const & in_kit);

	/*! The move constructor creates a CuttingSectionKit by transferring the underlying impl of the rvalue reference to this CuttingSectionKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CuttingSectionKit to take the impl from. */
	CuttingSectionKit(CuttingSectionKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CuttingSectionKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CuttingSectionKit to take the impl from.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit & operator=(CuttingSectionKit && in_that);

	virtual ~CuttingSectionKit();

	static const HPS::Type staticType = HPS::Type::CuttingSectionKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source CuttingSectionKit into this CuttingSectionKit and resets the source kit.
	 * 	\param in_kit The source CuttingSectionKit to consume. */
	void					Consume(CuttingSectionKit & in_kit);

	/*! Copies the source CuttingSectionKit into this CuttingSectionKit.
	 * 	\param in_kit The source CuttingSectionKit to copy. */
	void					Set(CuttingSectionKit const & in_kit);

	/*! Copies this CuttingSectionKit into the given CuttingSectionKit.
	 * 	\param out_kit The CuttingSectionKit to populate with the contents of this CuttingSectionKit. */
	void					Show(CuttingSectionKit & out_kit) const;

	/*! Copies the source CuttingSectionKit into this CuttingSectionKit.
	 * 	\param in_kit The source CuttingSectionKit to copy.
	 * 	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		operator=(CuttingSectionKit const & in_kit);

	/*! Indicates whether this CuttingSectionKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this CuttingSectionKit, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source CuttingSectionKit is equivalent to this CuttingSectionKit.
	 *	\param in_kit The source CuttingSectionKit to compare to this CuttingSectionKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(CuttingSectionKit const & in_kit) const;

	/*!	Check if the source CuttingSectionKit is equivalent to this CuttingSectionKit.
	 *	\param in_kit The source CuttingSectionKit to compare to this CuttingSectionKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(CuttingSectionKit const & in_kit) const;

	/*!	Check if the source CuttingSectionKit is not equivalent to this CuttingSectionKit.
	 *	\param in_kit The source CuttingSectionKit to compare to this CuttingSectionKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(CuttingSectionKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the CuttingSectionKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	CuttingSectionKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	CuttingSectionKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;


	/*! Sets a single cutting plane for this CuttingSectionKit.
	 *	\param in_plane The cutting plane for this CuttingSectionKit.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		SetPlanes(Plane const & in_plane);

	/*! Sets multiple cutting planes for this CuttingSectionKit.
	 *	\param in_planes The cutting planes for this CuttingSectionKit.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		SetPlanes(PlaneArray const & in_planes);

	/*! Sets multiple cutting planes for this CuttingSectionKit.
	 *	\param in_count Size of the following array.
	 *	\param in_planes The cutting planes for this CuttingSectionKit.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		SetPlanes(size_t in_count, Plane const in_planes[]);

	/*! Sets visualization to use for this CuttingSectionKit.
	 *	\param in_mode The mode for the CuttingSectionKit.
	 *	\param in_color The RGBA color for the CuttingSectionKit.
	 *	\param in_scale The scale to apply to the visualization geometry for this CuttingSectionKit.  Defaults to <span class='code'>1.0f</span>.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		SetVisualization(CuttingSection::Mode in_mode, RGBAColor const & in_color, float in_scale = 1.0f);


	/*! Removes the cutting planes for this CuttingSectionKit.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		UnsetPlanes();

	/*! Removes the visualization settings for this CuttingSectionKit.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		UnsetVisualization();

	/*! Removes all settings from the CuttingSectionKit.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		UnsetEverything();


	/*! Gets the number of cutting planes for this CuttingSectionKit.
	 *	\return The number of cutting planes for this CuttingSectionKit. */
	size_t					GetPlaneCount() const;

	/*! Shows the cutting planes for this CuttingSectionKit.
	 *	\param out_planes The cutting planes for this CuttingSectionKit.
	 *	\return <span class='code'>true</span> if any cutting planes were set, <span class='code'>false</span> otherwise. */
	bool					ShowPlanes(HPS::PlaneArray & out_planes) const;

	/*! Shows the visualization to use for this CuttingSectionKit.
	 *	\param out_mode The mode for this CuttingSectionKit.
	 *	\param out_color The RGBA color for this CuttingSectionKit.
	 *	\param out_scale The scale to apply to the visualization geometry for this CuttingSectionKit.
	 *	\return <span class='code'>true</span> if visualization options were set, <span class='code'>false</span> otherwise. */
	bool					ShowVisualization(CuttingSection::Mode & out_mode, RGBAColor & out_color, float & out_scale) const;


	/*! Adds cutting planes to this CuttingSectionKit.
	 *	\param in_offset The offset into the cutting plane list for the CuttingSectionKit at which to insert planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_planes The planes to insert into the cutting plane list at the specified offset.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		EditPlanesByInsertion(size_t in_offset, size_t in_count, Plane const in_planes[]);

	/*! Adds cutting planes to this CuttingSectionKit.
	 *	\param in_offset The offset into the cutting plane list for the CuttingSectionKit at which to insert planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for insertion to succeed.
	 *	\param in_planes The planes to insert into the cutting plane list at the specified offset.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		EditPlanesByInsertion(size_t in_offset, PlaneArray const & in_planes);

	/*! Removes planes from the cutting plane list for this CuttingSectionKit.
	 *	\param in_offset The offset into the cutting planes for this CuttingSectionKit at which to start removing planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of planes to remove from the cutting plane list for this CuttingSectionKit.  This value must be such that <span class='code'>in_offset+in_count&lt;=cutting_plane_count</span>
	 *		for the deletion to succeed.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		EditPlanesByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces planes in the cutting plane list for this CuttingSectionKit.
	 *	\param in_offset The offset into the cutting plane list for this CuttingSectionKit at which to start replacing planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=cutting_plane_count</span> for the replacement to succeed.
	 *	\param in_planes The planes to use to replace those in the cutting plane list at the specified offset.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		EditPlanesByReplacement(size_t in_offset, size_t in_count, Plane const in_planes[]);

	/*! Replaces planes in the cutting plane list for this CuttingSectionKit.
	 *	\param in_offset The offset into the cutting plane list for this CuttingSectionKit at which to start replacing planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=cutting_plane_count</span> for the replacement to succeed.
	 *	\param in_planes The planes to use to replace those in the cutting plane list at the specified offset.  The size of this array must be such that
	 *		<span class='code'>in_offset+in_planes.size()&lt;=cutting_plane_count</span> for the replacement to succeed.
	 *	\return A reference to this CuttingSectionKit. */
	CuttingSectionKit &		EditPlanesByReplacement(size_t in_offset, PlaneArray const & in_planes);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	CuttingSectionKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The CuttingSectionKey class is a smart pointer to a database object.  It is a handle to a cutting section inserted via SegmentKey::InsertCuttingSection. */
class HPS_API CuttingSectionKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized CuttingSectionKey object.  The Type() function will return Type::None. */
	CuttingSectionKey();

	/*! This constructor creates a CuttingSectionKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a CuttingSection key.  Otherwise the copy will fail and the resulting CuttingSectionKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit CuttingSectionKey(Key const & in_that);

	/*! The copy constructor creates a CuttingSectionKey object that shares the underlying smart-pointer of the source CuttingSectionKey.
	 *	\param in_that The source CuttingSectionKey to copy. */
	CuttingSectionKey(CuttingSectionKey const & in_that);

	/*! Associate this CuttingSectionKey with the same underlying impl as the source CuttingSectionKey.
	 *	\param in_that The source CuttingSectionKey for the assignment.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey & operator=(CuttingSectionKey const & in_that);

	/*! The move constructor creates a CuttingSectionKey by transferring the underlying impl of the rvalue reference to this CuttingSectionKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CuttingSectionKey to take the impl from. */
	CuttingSectionKey(CuttingSectionKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CuttingSectionKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CuttingSectionKey to take the impl from.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey & operator=(CuttingSectionKey && in_that);

	~CuttingSectionKey();

	static const HPS::Type staticType = HPS::Type::CuttingSectionKey;
	HPS::Type				ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this CuttingSectionKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CuttingSectionKey. */
	void					Consume(CuttingSectionKit & in_kit);

	/*! Replace those settings on this CuttingSectionKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this CuttingSectionKey. */
	void					Set(CuttingSectionKit const & in_kit);

	/*! Copy the contents of this CuttingSectionKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this CuttingSectionKey. */
	void					Show(CuttingSectionKit & out_kit) const;


	/*! Sets a single cutting plane for this CuttingSectionKey.
	 *	\param in_plane The cutting plane for this CuttingSectionKey.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		SetPlanes(Plane const & in_plane);

	/*! Sets multiple cutting planes for this CuttingSectionKey.
	 *	\param in_planes The cutting planes for this CuttingSectionKey.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		SetPlanes(PlaneArray const & in_planes);

	/*! Sets multiple cutting planes for this CuttingSectionKey.
	 *	\param in_count Size of the following array.
	 *	\param in_planes The cutting planes for this CuttingSectionKey.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		SetPlanes(size_t in_count, Plane const in_planes[]);

	/*! Sets visualization to use for this CuttingSectionKey.
	 *	\param in_mode The mode for the CuttingSectionKey.
	 *	\param in_color The RGBA color for the CuttingSectionKey.
	 *	\param in_scale The scale to apply to the visualization geometry for this CuttingSectionKey.  Defaults to <span class='code'>1.0f</span>.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		SetVisualization(CuttingSection::Mode in_mode, RGBAColor const & in_color, float in_scale = 1.0f);


	/*! Gets the number of cutting planes for this CuttingSectionKey.
	 *	\return The number of cutting planes for this CuttingSectionKey. */
	size_t					GetPlaneCount() const;

	/*! Shows the cutting planes for this CuttingSectionKey.
	 *	\param out_planes The cutting planes for this CuttingSectionKey.
	 *	\return <span class='code'>true</span> if any cutting planes were set, <span class='code'>false</span> otherwise. */
	bool					ShowPlanes(HPS::PlaneArray & out_planes) const;

	/*! Shows the visualization to use for this CuttingSectionKey.
	 *	\param out_mode The mode for this CuttingSectionKey.
	 *	\param out_color The RGBA color for this CuttingSectionKey.
	 *	\param out_scale The scale to apply to the visualization geometry for this CuttingSectionKey.
	 *	\return <span class='code'>true</span> if visualization options were set, <span class='code'>false</span> otherwise. */
	bool					ShowVisualization(CuttingSection::Mode & out_mode, RGBAColor & out_color, float & out_scale) const;


	/*! Adds cutting planes to this CuttingSectionKey.
	 *	\param in_offset The offset into the cutting plane list for the CuttingSectionKey at which to insert planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_planes The planes to insert into the cutting plane list at the specified offset.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		EditPlanesByInsertion(size_t in_offset, size_t in_count, Plane const in_planes[]);

	/*! Adds cutting planes to this CuttingSectionKey.
	 *	\param in_offset The offset into the cutting plane list for the CuttingSectionKey at which to insert planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for insertion to succeed.
	 *	\param in_planes The planes to insert into the cutting plane list at the specified offset.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		EditPlanesByInsertion(size_t in_offset, PlaneArray const & in_planes);

	/*! Removes planes from the cutting plane list for this CuttingSectionKey.
	 *	\param in_offset The offset into the cutting planes for this CuttingSectionKey at which to start removing planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of planes to remove from the cutting plane list for this CuttingSectionKey.  This value must be such that <span class='code'>in_offset+in_count&lt;=cutting_plane_count</span>
	 *		for the deletion to succeed.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		EditPlanesByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces planes in the cutting plane list for this CuttingSectionKey.
	 *	\param in_offset The offset into the cutting plane list for this CuttingSectionKey at which to start replacing planes.  This value must be such that <span class='code'>in_offset&lt;cutting_plane_count</span>
	 *		for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=cutting_plane_count</span> for the replacement to succeed.
	 *	\param in_planes The planes to use to replace those in the cutting plane list at the specified offset.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		EditPlanesByReplacement(size_t in_offset, size_t in_count, Plane const in_planes[]);

	/*! Replaces planes in the cutting plane list for this CuttingSectionKey.
	 *	\param in_offset The offset into the cutting plane list for this CuttingSectionKey at which to start replacing planes.  This value must be such that <span class='code'>in_offset &lt; cutting_plane_count</span> for replacement to succeed.
	 *	\param in_planes The planes to use to replace those in the cutting plane list at the specified offset.  The size of this array must be such that
	 *		<span class='code'>in_offset+in_planes.size()&lt;=cutting_plane_count</span> for the replacement to succeed.
	 *	\return A reference to this CuttingSectionKey. */
	CuttingSectionKey &		EditPlanesByReplacement(size_t in_offset, PlaneArray const & in_planes);
};



/*! The InfiniteLineKit class is a user space object.  It is a kit analog to an InfiniteLineKey. */
class HPS_API InfiniteLineKit : public Kit
{
public:
	/*! The default constructor creates an empty InfiniteLineKit object. */
	InfiniteLineKit();

	/*! The copy constructor creates a new InfiniteLineKit object that contains the same settings as the source InfiniteLineKit.
	 * 	\param in_kit The source InfiniteLineKit to copy. */
	InfiniteLineKit(InfiniteLineKit const & in_kit);

	/*! The move constructor creates an InfiniteLineKit by transferring the underlying impl of the rvalue reference to this InfiniteLineKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an InfiniteLineKit to take the impl from. */
	InfiniteLineKit(InfiniteLineKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this InfiniteLineKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to an InfiniteLineKit to take the impl from.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit & operator=(InfiniteLineKit && in_that);

	virtual ~InfiniteLineKit();

	static const HPS::Type staticType = HPS::Type::InfiniteLineKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source InfiniteLineKit into this InfiniteLineKit and resets the source kit.
	 * 	\param in_kit The source InfiniteLineKit to consume. */
	void					Consume(InfiniteLineKit & in_kit);

	/*! Copies the source InfiniteLineKit into this InfiniteLineKit.
	 * 	\param in_kit The source InfiniteLineKit to copy. */
	void					Set(InfiniteLineKit const & in_kit);

	/*! Copies this InfiniteLineKit into the given InfiniteLineKit.
	 * 	\param out_kit The InfiniteLineKit to populate with the contents of this InfiniteLineKit. */
	void					Show(InfiniteLineKit & out_kit) const;

	/*! Copies the source InfiniteLineKit into this InfiniteLineKit.
	 * 	\param in_kit The source InfiniteLineKit to copy.
	 * 	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		operator=(InfiniteLineKit const & in_kit);

	/*! Indicates whether this InfiniteLineKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this InfiniteLineKit, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source InfiniteLineKit is equivalent to this InfiniteLineKit.
	 *	\param in_kit The source InfiniteLineKit to compare to this InfiniteLineKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(InfiniteLineKit const & in_kit) const;

	/*!	Check if the source InfiniteLineKit is equivalent to this InfiniteLineKit.
	 *	\param in_kit The source InfiniteLineKit to compare to this InfiniteLineKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(InfiniteLineKit const & in_kit) const;

	/*!	Check if the source InfiniteLineKit is not equivalent to this InfiniteLineKit.
	 *	\param in_kit The source InfiniteLineKit to compare to this InfiniteLineKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(InfiniteLineKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the InfiniteLineKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	InfiniteLineKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	InfiniteLineKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;


	/*! Sets the first point for this InfiniteLineKit.
	 *	\param in_first The first point for this InfiniteLineKit.  If the type is InfiniteLine::Type::Ray, this will be the point at which the ray starts.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		SetFirst(Point const & in_first);

	/*! Sets the second point for this InfiniteLineKit.
	 *	\param in_second The second point for this InfiniteLineKit.  If the type is InfiniteLine::Type::Ray, this will be the point through which the ray passes.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		SetSecond(Point const & in_second);

	/*! Sets the type of this InfiniteLineKit.
	 *	\param in_type The type of this InfiniteLineKit.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		SetType(InfiniteLine::Type in_type);


	/*! Removes the first point for this InfiniteLineKit.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		UnsetFirst();

	/*! Removes the second point for this InfiniteLineKit.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		UnsetSecond();

	/*! Removes the type of this InfiniteLineKit.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		UnsetType();

	/*! Removes all settings from the InfiniteLineKit.
	 *	\return A reference to this InfiniteLineKit. */
	InfiniteLineKit &		UnsetEverything();


	/*! Shows the first point for this InfiniteLineKit.
	 *	\param out_first The first point for this InfiniteLineKit.
	 *	\return <span class='code'>true</span> if a first point was set, <span class='code'>false</span> otherwise. */
	bool					ShowFirst(Point & out_first) const;

	/*! Shows the second point for this InfiniteLineKit.
	 *	\param out_second The second point for this InfiniteLineKit.
	 *	\return <span class='code'>true</span> if a second point was set, <span class='code'>false</span> otherwise. */
	bool					ShowSecond(Point & out_second) const;

	/*! Shows the type of this InfiniteLineKit.
	 *	\param out_type The type of this InfiniteLineKit.
	 *	\return <span class='code'>true</span> if a type was set, <span class='code'>false</span> otherwise. */
	bool					ShowType(InfiniteLine::Type & out_type) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	InfiniteLineKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The InfiniteLineKey class is a smart pointer to a database object.  It is a handle to an infinite line or ray inserted via SegmentKey::InsertInfiniteLine. */
class HPS_API InfiniteLineKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized InfiniteLineKey object.  The Type() function will return Type::None. */
	InfiniteLineKey();

	/*! This constructor creates an InfiniteLineKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of an InfiniteLine key.  Otherwise the copy will fail and the resulting InfiniteLineKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit InfiniteLineKey(Key const & in_that);

	/*! The copy constructor creates an InfiniteLineKey object that shares the underlying smart-pointer of the source InfiniteLineKey.
	 *	\param in_that The source InfiniteLineKey to copy. */
	InfiniteLineKey(InfiniteLineKey const & in_that);

	/*! Associate this InfiniteLineKey with the same underlying impl as the source InfiniteLineKey.
	 *	\param in_that The source InfiniteLineKey for the assignment.
	 *	\return A reference to this InfiniteLineKey. */
	InfiniteLineKey & operator=(InfiniteLineKey const & in_that);

	/*! The move constructor creates an InfiniteLineKey by transferring the underlying impl of the rvalue reference to this InfiniteLineKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a InfiniteLineKey to take the impl from. */
	InfiniteLineKey(InfiniteLineKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this InfiniteLineKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to an InfiniteLineKey to take the impl from.
	 *	\return A reference to this InfiniteLineKey. */
	InfiniteLineKey & operator=(InfiniteLineKey && in_that);

	~InfiniteLineKey();

	static const HPS::Type staticType = HPS::Type::InfiniteLineKey;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this InfiniteLineKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this InfiniteLineKey. */
	void					Consume(InfiniteLineKit & in_kit);

	/*! Replace those settings on this InfiniteLineKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this InfiniteLineKey. */
	void					Set(InfiniteLineKit const & in_kit);

	/*! Copy the contents of this InfiniteLineKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this InfiniteLineKey. */
	void					Show(InfiniteLineKit & out_kit) const;


	/*! Sets the first point for this InfiniteLineKey.
	 *	\param in_first The first point for this InfiniteLineKey.  If the type is InfiniteLine::Type::Ray, this will be the point at which the ray starts.
	 *	\return A reference to this InfiniteLineKey. */
	InfiniteLineKey &		SetFirst(Point const & in_first);

	/*! Sets the second point for this InfiniteLineKey.
	 *	\param in_second The second point for this InfiniteLineKey.  If the type is InfiniteLine::Type::Ray, this will be the point through which the ray passes.
	 *	\return A reference to this InfiniteLineKey. */
	InfiniteLineKey &		SetSecond(Point const & in_second);

	/*! Sets the type of this InfiniteLineKey.
	 *	\param in_type The type of this InfiniteLineKey.
	 *	\return A reference to this InfiniteLineKey. */
	InfiniteLineKey &		SetType(InfiniteLine::Type in_type);


	/*! Shows the first point for this InfiniteLineKey.
	 *	\param out_first The first point for this InfiniteLineKey.
	 *	\return <span class='code'>true</span> if a first point was set, <span class='code'>false</span> otherwise. */
	bool					ShowFirst(Point & out_first) const;

	/*! Shows the second point for this InfiniteLineKey.
	 *	\param out_second The second point for this InfiniteLineKey.
	 *	\return <span class='code'>true</span> if a second point was set, <span class='code'>false</span> otherwise. */
	bool					ShowSecond(Point & out_second) const;

	/*! Shows the type of this InfiniteLineKey.
	 *	\param out_type The type of this InfiniteLineKey.
	 *	\return <span class='code'>true</span> if a type was set, <span class='code'>false</span> otherwise. */
	bool					ShowType(InfiniteLine::Type & out_type) const;
};



/*!
<p>The HPS::SpotlightKit class is a user space object. It is the kit counterpart to a HPS::SpotlightKey. Calling HPS::SpotlightKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#spotlights">this table</a>.</p>
*/
class HPS_API SpotlightKit : public Kit
{
public:
	/*! The default constructor creates an empty SpotlightKit object. */
	SpotlightKit();

	/*! The copy constructor creates a new SpotlightKit object that contains the same settings as the source SpotlightKit.
	 * 	\param in_kit The source SpotlightKit to copy. */
	SpotlightKit(SpotlightKit const & in_kit);

	/*! The move constructor creates a SpotlightKit by transferring the underlying impl of the rvalue reference to this SpotlightKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SpotlightKit to take the impl from.*/
	SpotlightKit(SpotlightKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SpotlightKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SpotlightKit to take the impl from.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit & operator=(SpotlightKit && in_that);

	virtual ~SpotlightKit();

	static const HPS::Type staticType = HPS::Type::SpotlightKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Creates a SpotlightKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A SpotlightKit with the default settings. */
	static SpotlightKit	GetDefault();

	/*! Copies the source SpotlightKit into this SpotlightKit and resets the source kit.
	 * 	\param in_kit The source SpotlightKit to consume. */
	void				Consume(SpotlightKit & in_kit);

	/*! Copies the source SpotlightKit into this SpotlightKit.
	 * 	\param in_kit The source SpotlightKit to copy. */
	void				Set(SpotlightKit const & in_kit);

	/*! Copies this SpotlightKit into the given SpotlightKit.
	 * 	\param out_kit The SpotlightKit to populate with the contents of this SpotlightKit. */
	void				Show(SpotlightKit & out_kit) const;

	/*! Copies the source SpotlightKit into this SpotlightKit.
	 * 	\param in_kit The source SpotlightKit to copy.
	 * 	\return A reference to this SpotlightKit. */
	SpotlightKit &		operator=(SpotlightKit const & in_kit);

	/*! Indicates whether this SpotlightKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this SpotlightKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source SpotlightKit is equivalent to this SpotlightKit.
	 *	\param in_kit The source SpotlightKit to compare to this SpotlightKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(SpotlightKit const & in_kit) const;

	/*!	Check if the source SpotlightKit is equivalent to this SpotlightKit.
	 *	\param in_kit The source SpotlightKit to compare to this SpotlightKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(SpotlightKit const & in_kit) const;

	/*!	Check if the source SpotlightKit is not equivalent to this SpotlightKit.
	 *	\param in_kit The source SpotlightKit to compare to this SpotlightKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(SpotlightKit const & in_kit) const;


	/*!	Assigns a specific drawing priority value to the SpotlightKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	SpotlightKit &		SetPriority(int in_priority);

	/*! Sets the position of the light source for this SpotlightKit.
	 *	\param in_position The position of the light source for this SpotlightKit.  The point will either be treated as being in object space or in camera-relative units depending on the setting passed
	 *		to SetCameraRelative.
	 *	\return A reference to this SpotlightKit.
	 *	\sa SetCameraRelative */
	SpotlightKit &		SetPosition(HPS::Point const & in_position);

	/*! Sets the target coordinate towards which the light source points for this SpotlightKit.
	 *	\param in_target The target coordinate towards which the light source points for this SpotlightKit.  The point will either be treated as being in object space or in camera-relative units depending on
	 *		the setting passed to SetCameraRelative.
	 *	\return A reference to this SpotlightKit.
	 *	\sa SetCameraRelative */
	SpotlightKit &		SetTarget(HPS::Point const & in_target);

	/*! Sets the RGBA color to use for this SpotlightKit.
	 *	\param in_rgba_color The RGBA color to use for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		SetColor(RGBAColor const & in_rgba_color);

	/*! Sets the color index to use for this SpotlightKit.
	 *	\param in_index The color index to use for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		SetColorByIndex(float in_index);

	/*! Sets the size of the outer cone for this SpotlightKit.  The outer cone defines the conic region inside of which surfaces will be illuminated by this spotlight.  Any surface outside this conic
	 *	region will not be illuminated by this spotlight.
	 *	\param in_size The size of the outer cone for this SpotlightKit.  The interpretation of the value and its valid range depends on the units argument.
	 *	\param in_units The units for the size of the outer cone for this SpotlightKit.  Defaults to Spotlight::OuterConeUnits::Degrees.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		SetOuterCone(float in_size, HPS::Spotlight::OuterConeUnits in_units = HPS::Spotlight::OuterConeUnits::Degrees);

	/*! Sets the size of the inner cone for this SpotlightKit.  The inner cone defines the conic region inside the conic region defined by the outer cone at which the spotlight intensity will decrease linearly
	 *	to zero at the outer cone's edge.  As such, the size of the inner cone should be no larger than the outer cone.
	 *	\param in_size The size of the inner cone for this SpotlightKit.  The interpretation of the value and its valid range depends on the units argument.
	 *	\param in_units The units for the size of the inner cone for this SpotlightKit.  Defaults to Spotlight::InnerConeUnits::Percent.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		SetInnerCone(float in_size, HPS::Spotlight::InnerConeUnits in_units = HPS::Spotlight::InnerConeUnits::Percent);

	/*! Sets the concentration for this SpotlightKit.  The concentration defines the rate at which light intensity decreases with increasing angular distance from the light direction vector.  This effect
	 *	works in addition to the decrease that occurs between the inner and outer cones.
	 *	\param in_concentration The concentration for the SpotlightKit.  This value must be non-negative.  A value of <span class='code'>0.0f</span> defines no intensity decrease (besides that between the inner
	 *		and outer cone), and larger values will concentrate intensity closer to the light direction vector.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		SetConcentration(float in_concentration);

	/*! Sets the camera-relative setting for this SpotlightKit.  This defines what the implied units of the target and position will be.
	 *	\param in_state Whether the coordinates of the position and target for this SpotlightKit are treated as being in object space or camera-relative space.
	 *	\return A reference to this SpotlightKit.
	 *	\sa SetPosition
	 *	\sa SetTarget */
	SpotlightKit &		SetCameraRelative(bool in_state);


	/*!	Removes the drawing priority setting.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetPriority();

	/*! Removes the light source position for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetPosition();

	/*! Removes the target coordinate towards which the light source points for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetTarget();

	/*! Removes the color (RGBA or material index) for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetColor();

	/*! Removes the outer-cone size specification for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetOuterCone();

	/*! Removes the inner-cone size specification for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetInnerCone();

	/*! Removes the concentration for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetConcentration();

	/*! Removes the camera-relative setting for this SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetCameraRelative();

	/*! Removes all settings from the SpotlightKit.
	 *	\return A reference to this SpotlightKit. */
	SpotlightKit &		UnsetEverything();


	/*! Shows the drawing priority.
	 *	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	 *	\return <span class='code'>true</span> if a drawing priority was specified, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Shows the position of the light source for this SpotlightKit.
	 *	\param out_position The position of the light source for this SpotlightKit.
	 *	\return <span class='code'>true</span> if a light source position was set, <span class='code'>false</span> otherwise. */
	bool				ShowPosition(HPS::Point & out_position) const;

	/*! Shows the target coordinate towards which the light source points for this SpotlightKit.
	 *	\param out_target The target coordinate towards which the light source points for this SpotlightKit.
	 *	\return <span class='code'>true</span> if a target was set, <span class='code'>false</span> otherwise. */
	bool				ShowTarget(HPS::Point & out_target) const;

	/*! Shows the color for this SpotlightKit.
	 *	\param out_type The type of color for the spotlight.
	 *	\param out_rgba_color The RGBA color for the spotlight.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for the spotlight.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_index) const;

	/*! Shows the outer cone for this SpotlightKit.
	 *	\param out_size The size of the outer cone for this SpotlightKit.
	 *	\param out_units The units for the size of the outer cone for this SpotlightKit.
	 *	\return <span class='code'>true</span> if an outer cone was set, <span class='code'>false</span> otherwise. */
	bool				ShowOuterCone(float & out_size, HPS::Spotlight::OuterConeUnits & out_units) const;

	/*! Shows the inner cone for this SpotlightKit.
	 *	\param out_size The size of the inner cone for this SpotlightKit.
	 *	\param out_units The units for the size of the inner cone for this SpotlightKit.
	 *	\return <span class='code'>true</span> if an inner cone was set, <span class='code'>false</span> otherwise. */
	bool				ShowInnerCone(float & out_size, HPS::Spotlight::InnerConeUnits & out_units) const;

	/*! Shows the concentration for this SpotlightKit.
	 *	\param out_concentration The concentration for this SpotlightKit.
	 *	\return <span class='code'>true</span> if a concentration was set, <span class='code'>false</span> otherwise. */
	bool				ShowConcentration(float & out_concentration) const;

	/*! Shows the camera-relative setting for this SpotlightKit.
	 *	\param out_state Whether the coordinates of the position and target for this SpotlightKit are treated as being in object space or camera-relative space.
	 *	\return <span class='code'>true</span> if a camera-relative setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowCameraRelative(bool & out_state) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	SpotlightKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	SpotlightKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	SpotlightKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	SpotlightKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	SpotlightKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	SpotlightKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	SpotlightKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The SpotlightKey class is a smart pointer to a database object.  It is a handle to a spotlight inserted via SegmentKey::InsertSpotlight. */
class HPS_API SpotlightKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized SpotlightKey object.  The Type() function will return Type::None. */
	SpotlightKey();

	/*! This constructor creates a SpotlightKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a Spotlight key.  Otherwise the copy will fail and the resulting SpotlightKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit SpotlightKey(Key const & in_that);

	/*! The copy constructor creates a SpotlightKey object that shares the underlying smart-pointer of the source SpotlightKey.
	 *	\param in_that The source SpotlightKey to copy. */
	SpotlightKey(SpotlightKey const & in_that);

	/*! Associate this SpotlightKey with the same underlying impl as the source SpotlightKey.
	 *	\param in_that The source SpotlightKey for the assignment.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey & operator=(SpotlightKey const & in_that);

	/*! The move constructor creates a SpotlightKey by transferring the underlying impl of the rvalue reference to this SpotlightKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SpotlightKey to take the impl from. */
	SpotlightKey(SpotlightKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SpotlightKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SpotlightKey to take the impl from.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey & operator=(SpotlightKey && in_that);

	~SpotlightKey();

	static const HPS::Type staticType = HPS::Type::SpotlightKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this SpotlightKey with those set on the specified kit and resets the kit.InfiniteLineKey
	 *	\param in_kit The kit from which to get the settings to replace on this SpotlightKey. */
	void				Consume(SpotlightKit & in_kit);

	/*! Replace those settings on this SpotlightKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this SpotlightKey. */
	void				Set(SpotlightKit const & in_kit);

	/*! Copy the contents of this SpotlightKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this SpotlightKey. */
	void				Show(SpotlightKit & out_kit) const;


	/*! Sets the position of the light source for this SpotlightKey.
	 *	\param in_position The position of the light source for this SpotlightKey.  The point will either be treated as being in object space or in camera-relative units depending on the setting passed
	 *		to SetCameraRelative.
	 *	\return A reference to this SpotlightKey.
	 *	\sa SetCameraRelative */
	SpotlightKey &		SetPosition(HPS::Point const & in_position);

	/*! Sets the target coordinate towards which the light source points for this SpotlightKey.
	 *	\param in_target The target coordinate towards which the light source points for this SpotlightKey.  The point will either be treated as being in object space or in camera-relative units depending on
	 *		the setting passed to SetCameraRelative.
	 *	\return A reference to this SpotlightKey.
	 *	\sa SetCameraRelative */
	SpotlightKey &		SetTarget(HPS::Point const & in_target);

	/*! Sets the RGBA color to use for this SpotlightKey.
	 *	\param in_rgba_color The RGBA color to use for this SpotlightKey.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey &		SetColor(RGBAColor const & in_rgba_color);

	/*! Sets the color index to use for this SpotlightKey.
	 *	\param in_index The color index to use for this SpotlightKey.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey &		SetColorByIndex(float in_index);

	/*! Sets the size of the outer cone for this SpotlightKey.  The outer cone defines the conic region inside of which surfaces will be illuminated by this spotlight.  Any surface outside this conic
	 *	region will not be illuminated by this spotlight.
	 *	\param in_size The size of the outer cone for this SpotlightKey.  The interpretation of the value and its valid range depends on the units argument.
	 *	\param in_units The units for the size of the outer cone for this SpotlightKey.  Defaults to Spotlight::OuterConeUnits::Degrees.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey &		SetOuterCone(float in_size, HPS::Spotlight::OuterConeUnits in_units = HPS::Spotlight::OuterConeUnits::Degrees);

	/*! Sets the size of the inner cone for this SpotlightKey.  The inner cone defines the conic region inside the conic region defined by the outer cone at which the spotlight intensity will decrease linearly
	 *	to zero at the outer cone's edge.  As such, the size of the inner cone should be no larger than the outer cone.
	 *	\param in_size The size of the inner cone for this SpotlightKey.  The interpretation of the value and its valid range depends on the units argument.
	 *	\param in_units The units for the size of the inner cone for this SpotlightKey.  Defaults to Spotlight::InnerConeUnits::Degrees.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey &		SetInnerCone(float in_size, HPS::Spotlight::InnerConeUnits in_units = HPS::Spotlight::InnerConeUnits::Percent);

	/*! Sets the concentration for this SpotlightKey.  The concentration defines the rate at which light intensity decreases with increasing angular distance from the light direction vector.  This effect
	 *	works in addition to the decrease that occurs between the inner and outer cones.
	 *	\param in_concentration The concentration for the SpotlightKey.  This value must be non-negative.  A value of <span class='code'>0.0f</span> defines no intensity decrease (besides that between the inner
	 *		and outer cone), and larger values will concentrate intensity closer to the light direction vector.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey &		SetConcentration(float in_concentration);

	/*! Sets whether the coordinates of the position and target for this SpotlightKey are treated as being in object space or camera-relative space.
	 *	\param in_state Whether the coordinates of the position and target for this SpotlightKey are treated as being in object space or camera-relative space.
	 *	\return A reference to this SpotlightKey.
	 *	\sa SetPosition
	 *	\sa SetTarget */
	SpotlightKey &		SetCameraRelative(bool in_state);


	/*! Removes the color (RGBA or material index) set on this SpotlightKey.
	 *	\return A reference to this SpotlightKey. */
	SpotlightKey &		UnsetColor();


	/*! Shows the position of the light source for this SpotlightKey.
	 *	\param out_position The position of the light source for this SpotlightKey.
	 *	\return <span class='code'>true</span> if a light source position was set, <span class='code'>false</span> otherwise. */
	bool				ShowPosition(HPS::Point & out_position) const;

	/*! Shows the target coordinate towards which the light source points for this SpotlightKey.
	 *	\param out_target The target coordinate towards which the light source points for this SpotlightKey.
	 *	\return <span class='code'>true</span> if a target was set, <span class='code'>false</span> otherwise. */
	bool				ShowTarget(HPS::Point & out_target) const;

	/*! Shows the color for this SpotlightKey.
	 *	\param out_type The type of color for the spotlight.
	 *	\param out_rgba_color The RGBA color for the spotlight.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for the spotlight.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_index) const;

	/*! Shows the outer cone for this SpotlightKey.
	 *	\param out_size The size of the outer cone for this SpotlightKey.
	 *	\param out_units The units for the size of the outer cone for this SpotlightKey.
	 *	\return <span class='code'>true</span> if an outer cone was set, <span class='code'>false</span> otherwise. */
	bool				ShowOuterCone(float & out_size, HPS::Spotlight::OuterConeUnits & out_units) const;

	/*! Shows the inner cone for this SpotlightKey.
	 *	\param out_size The size of the inner cone for this SpotlightKey.
	 *	\param out_units The units for the size of the inner cone for this SpotlightKey.
	 *	\return <span class='code'>true</span> if an inner cone was set, <span class='code'>false</span> otherwise. */
	bool				ShowInnerCone(float & out_size, HPS::Spotlight::InnerConeUnits & out_units) const;

	/*! Shows the concentration for this SpotlightKey.
	 *	\param out_concentration The concentration for this SpotlightKey.
	 *	\return <span class='code'>true</span> if a concentration was set, <span class='code'>false</span> otherwise. */
	bool				ShowConcentration(float & out_concentration) const;

	/*! Shows whether the coordinates of the position and target for this SpotlightKey are treated as being in object space or camera-relative space.
	 *	\param out_state Whether the coordinates of the position and target for this SpotlightKey are treated as being in object space or camera-relative space.
	 *	\return <span class='code'>true</span> if a camera-relative setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowCameraRelative(bool & out_state) const;
};



/*! The NURBSCurveKit class is a user space object.  It is a kit analog to a NURBSCurveKey. */
class HPS_API NURBSCurveKit : public Kit
{
public:
	/*! The default constructor creates an empty NURBSCurveKit object. */
	NURBSCurveKit();

	/*! The copy constructor creates a new NURBSCurveKit object that contains the same settings as the source NURBSCurveKit.
	 * 	\param in_kit The source NURBSCurveKit to copy. */
	NURBSCurveKit(NURBSCurveKit const & in_kit);

	/*! The move constructor creates a NURBSCurveKit by transferring the underlying impl of the rvalue reference to this NURBSCurveKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a NURBSCurveKit to take the impl from. */
	NURBSCurveKit(NURBSCurveKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NURBSCurveKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a NURBSCurveKit to take the impl from.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit & operator=(NURBSCurveKit && in_that);

	virtual ~NURBSCurveKit();

	static const HPS::Type staticType = HPS::Type::NURBSCurveKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source NURBSCurveKit into this NURBSCurveKit and resets the source kit.
	 * 	\param in_kit The source NURBSCurveKit to consume. */
	void				Consume(NURBSCurveKit & in_kit);

	/*! Copies the source NURBSCurveKit into this NURBSCurveKit.
	 * 	\param in_kit The source NURBSCurveKit to copy. */
	void				Set(NURBSCurveKit const & in_kit);

	/*! Copies this NURBSCurveKit into the given NURBSCurveKit.
	 * 	\param out_kit The NURBSCurveKit to populate with the contents of this NURBSCurveKit. */
	void				Show(NURBSCurveKit & out_kit) const;

	/*! Copies the source NURBSCurveKit into this NURBSCurveKit.
	 * 	\param in_kit The source NURBSCurveKit to copy.
	 * 	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &	operator=(NURBSCurveKit const & in_kit);

	/*! Indicates whether this NURBSCurveKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this NURBSCurveKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source NURBSCurveKit is equivalent to this NURBSCurveKit.
	 *	\param in_kit The source NURBSCurveKit to compare to this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(NURBSCurveKit const & in_kit) const;

	/*!	Check if the source NURBSCurveKit is equivalent to this NURBSCurveKit.
	 *	\param in_kit The source NURBSCurveKit to compare to this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(NURBSCurveKit const & in_kit) const;

	/*!	Check if the source NURBSCurveKit is not equivalent to this NURBSCurveKit.
	 *	\param in_kit The source NURBSCurveKit to compare to this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(NURBSCurveKit const & in_kit) const;

	/*!	Retrieves the number of points in this NURBS curve.
	 *	\return The number of points in this NURBS curve. */
	size_t				GetPointCount() const;

	/*!	Assigns a specific drawing priority value to the NURBSCurveKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	NURBSCurveKit &		SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	NURBSCurveKit &		UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Sets the degree of the NURBSCurveKit.
	 *	\param in_degree The degree of the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetDegree(size_t in_degree);

	/*! Sets the control points for the NURBSCurveKit.
	 *	\param in_points The control points for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetPoints(PointArray const & in_points);

	/*! Sets the control points for the NURBSCurveKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The control points for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetPoints(size_t in_count, Point const in_points []);

	/*! Sets the control point weights for the NURBSCurveKit.
	 *	\param in_weights The control point weights for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetWeights(FloatArray const & in_weights);

	/*! Sets the control point weights for the NURBSCurveKit.
	 *	\param in_count Size of the following array.
	 *	\param in_weights The control point weights for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetWeights(size_t in_count, float const in_weights []);

	/*! Sets the knots for the NURBSCurveKit.
	 *	\param in_knots The knots for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetKnots(FloatArray const & in_knots);

	/*! Sets the knots for the NURBSCurveKit.
	 *	\param in_count Size of the following array.
	 *	\param in_knots The knots for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetKnots(size_t in_count, float const in_knots []);

	/*! Sets the normalized start and end parameters for the NURBSCurveKit.
	 *	\param in_start The noramlized start parameter for the NURBSCurveKit.
	 *	\param in_end The noramlized end parameter for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		SetParameters(float in_start, float in_end);


	/*! Removes the setting for the degree of the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		UnsetDegree();

	/*! Removes the control points for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		UnsetPoints();

	/*! Removes the control point weights for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		UnsetWeights();

	/*! Removes the knots for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		UnsetKnots();

	/*! Removes the normalized start and end parameters for the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		UnsetParameters();

	/*! Removes all settings from the NURBSCurveKit.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		UnsetEverything();


	/*! Shows the degree of this NURBSCurveKit.
	 *	\param out_degree The degree of this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if a degree was set, <span class='code'>false</span> otherwise. */
	bool				ShowDegree(size_t & out_degree) const;

	/*! Shows the control points for this NURBSCurveKit.
	 *	\param out_points The control points for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if control points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSCurveKit by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSCurveKit by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSCurveKit by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Shows the control point weights for this NURBSCurveKit.
	 *	\param out_weights The control point weights for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if control point weights were set, <span class='code'>false</span> otherwise. */
	bool				ShowWeights(FloatArray & out_weights) const;

	/*! Shows the knots for this NURBSCurveKit.
	 *	\param out_knots The knots for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if knots were set, <span class='code'>false</span> otherwise. */
	bool				ShowKnots(FloatArray & out_knots) const;

	/*! Shows the normalized start and end parameters for this NURBSCurveKit.
	 *	\param out_start The normalized start parameter for this NURBSCurveKit.
	 *	\param out_end The normalized end parameter for this NURBSCurveKit.
	 *	\return <span class='code'>true</span> if start and end parameters were set, <span class='code'>false</span> otherwise. */
	bool				ShowParameters(float & out_start, float & out_end) const;


	/*! Adds points to the control point list for this NURBSCurveKit.
	 *	\param in_offset The offset into the control point list for the NURBSCurveKit at which to insert points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the control point list at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the control point list for this NURBSCurveKit.
	 *	\param in_offset The offset into the control point list for the NURBSCurveKit at which to insert points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_points The points to insert into the control point list at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the control point list for this NURBSCurveKit.
	 *	\param in_offset The offset into the control point list for the NURBSCurveKit at which to start removing points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of points to delete from the control point list for the NURBSCurveKit.  This value must be such that
	 *		<span class='code'>in_offset+in_count&lt;=control_point_count</span> for the deletion to succeed.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces control points for this NURBSCurveKit.
	 *	\param in_offset The offset into the control point list for the NURBSCurveKit at which to replace points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces control points for this NURBSCurveKit.
	 *	\param in_offset The offset into the control point list for the NURBSCurveKit at which to replace points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.  This size of the array must be such that
	 *		<span class='code'>in_offset+in_points.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Adds weights to the control point weight list for this NURBSCurveKit.  This will allow modification of the default control point weights if no explicit weights are set
	 *	if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSCurveKit at which to insert weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_weights The weights to insert into the control point weight list at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditWeightsByInsertion(size_t in_offset, size_t in_count, float const in_weights[]);

	/*! Adds weights to the control point weight list for this NURBSCurveKit.  This will allow modification of the default control point weights if no explicit weights are set
	 *	if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSCurveKit at which to insert weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_weights The weights to insert into the control point weight list at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditWeightsByInsertion(size_t in_offset, FloatArray const & in_weights);

	/*! Removes weights from the control point weight list for this NURBSCurveKit.  This will allow modification of the default control point weights if no explicit weights are set
	 *	if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSCurveKit at which to start removing weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of weights to delete from the control point weight list for the NURBSCurveKit.  This value must be such that
	 *		<span class='code'>in_offset+in_count&lt;=weight_count</span> for the deletion to succeed.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditWeightsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces control point weights for this NURBSCurveKit.  This will allow modification of the default control point weights if no explicit weights are set if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSCurveKit at which to replace weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=weight_count</span> for the replacement to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditWeightsByReplacement(size_t in_offset, size_t in_count, float const in_weights[]);

	/*! Replaces control point weights for this NURBSCurveKit.  This will allow modification of the default control point weights if no explicit weights are set if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSCurveKit at which to replace weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.  This size of the array must be such that
	 *		<span class='code'>in_offset+in_weights.size()&lt;=weight_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditWeightsByReplacement(size_t in_offset, FloatArray const & in_weights);


	/*! Adds knots for this NURBSCurveKit.  This will allow modification of the default knots if no explicit knots are set if possible.
	 *	\param in_offset The offset into the knots the NURBSCurveKit at which to insert knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_knots The knots to insert at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditKnotsByInsertion(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Adds knots for this NURBSCurveKit.  This will allow modification of the default knots if no explicit knots are set if possible.
	 *	\param in_offset The offset into the knots the NURBSCurveKit at which to insert knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span> for insertion to succeed.
	 *	\param in_knots The knots to insert at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditKnotsByInsertion(size_t in_offset, FloatArray const & in_knots);

	/*! Removes knots for this NURBSCurveKit.  This will allow modification of the default knots if no explicit knots are set if possible.
	 *	\param in_offset The offset into the knots for the NURBSCurveKit at which to start removing knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of knots to delete for the NURBSCurveKit.  This value must be such that  <span class='code'>in_offset+in_count&lt;=control_point_count+degree+1</span> for the deletion to succeed.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditKnotsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces knots for this NURBSCurveKit.  This will allow modification of the default knots if no explicit knots are set if possible.
	 *	\param in_offset The offset into the knots for the NURBSCurveKit at which to replace knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span>
	 *		for the replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=control_point_count+degree+1</span> for the replacement to succeed.
	 *	\param in_knots The knots to use to replace those at the specified offset.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditKnotsByReplacement(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Replaces knots for this NURBSCurveKit.  This will allow modification of the default knots if no explicit knots are set if possible.
	 *	\param in_offset The offset into the knots for the NURBSCurveKit at which to replace knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span>
	 *		for the replacement to succeed.
	 *	\param in_knots The knots to use to replace those at the specified offset.  The size of the array must be such that <span class='code'>in_offset+in_knots.size()&lt;=control_point_count+degree+1</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this NURBSCurveKit. */
	NURBSCurveKit &		EditKnotsByReplacement(size_t in_offset, FloatArray const & in_knots);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	NURBSCurveKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The NURBSCurveKey class is a smart pointer to a database object.  It is a handle to a NURBS curve inserted via SegmentKey::InsertNURBSCurve. */
class HPS_API NURBSCurveKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized NURBSCurveKey object.  The Type() function will return Type::None. */
	NURBSCurveKey();

	/*! This constructor creates a NURBSCurveKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a NURBSCurve key.  Otherwise the copy will fail and the resulting NURBSCurveKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit NURBSCurveKey(Key const & in_that);

	/*! The copy constructor creates a NURBSCurveKey object that shares the underlying smart-pointer of the source NURBSCurveKey.
	 *	\param in_that The source NURBSCurveKey to copy. */
	NURBSCurveKey(NURBSCurveKey const & in_that);

	/*! Associate this NURBSCurveKey with the same underlying impl as the source NURBSCurveKey.
	 *	\param in_that The source NURBSCurveKey for the assignment.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey & operator=(NURBSCurveKey const & in_that);

	/*! The move constructor creates a NURBSCurveKey by transferring the underlying impl of the rvalue reference to this NURBSCurveKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a NURBSCurveKey to take the impl from. */
	NURBSCurveKey(NURBSCurveKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NURBSCurveKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a NURBSCurveKey to take the impl from.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey & operator=(NURBSCurveKey && in_that);

	~NURBSCurveKey();

	static const HPS::Type staticType = HPS::Type::NURBSCurveKey;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Completely replaces all settings on this NURBSCurveKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this NURBSCurveKey. */
	void				Consume(NURBSCurveKit & in_kit);

	/*! Replace those settings on this NURBSCurveKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this NURBSCurveKey. */
	void				Set(NURBSCurveKit const & in_kit);

	/*! Copy the contents of this NURBSCurveKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this NURBSCurveKey. */
	void				Show(NURBSCurveKit & out_kit) const;

	/*!	Retrieves the number of points in this NURBS curve.
	 *	\return The number of points in this NURBS curve. */
	size_t				GetPointCount() const;

	/*! Sets the normalized start and end parameters for this NURBSCurveKey.
	 *	\param in_start The start parameter.  This value should be in the range <span class='code'>[0,1]</span> and should be defined such that <span class='code'>in_start&lt;=in_end</span>.
	 *	\param in_end The end parameter.  This value should be in the range <span class='code'>[0,1]</span> and should be defined such that <span class='code'>in_start&lt;=in_end</span>.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		SetParameters(float in_start, float in_end);

	/*! Shows the degree of this NURBSCurveKey.
	 *	\param out_degree The degree of this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if a degree was set, <span class='code'>false</span> otherwise. */
	bool				ShowDegree(size_t & out_degree) const;

	/*! Shows the control points for this NURBSCurveKey.
	 *	\param out_points The control points for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if control points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSCurveKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSCurveKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSCurveKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Shows the control point weights for this NURBSCurveKey.
	 *	\param out_weights The control point weights for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if control point weights were set, <span class='code'>false</span> otherwise. */
	bool				ShowWeights(FloatArray & out_weights) const;

	/*! Shows the knots for this NURBSCurveKey.
	 *	\param out_knots The knots for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if knots were set, <span class='code'>false</span> otherwise. */
	bool				ShowKnots(FloatArray & out_knots) const;

	/*! Shows the normalized start and end parameters for this NURBSCurveKey.
	 *	\param out_start The noramlized start parameter for this NURBSCurveKey.
	 *	\param out_end The noramlized end parameter for this NURBSCurveKey.
	 *	\return <span class='code'>true</span> if start and end parameters were set, <span class='code'>false</span> otherwise. */
	bool				ShowParameters(float & out_start, float & out_end) const;


	/*! Replaces control points for this NURBSCurveKey.
	 *	\param in_offset The offset into the control points for this NURBS curve at which to start replacing points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of control points to replace for the NURBS curve.  This must be such that such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement
	 *		to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces control points for this NURBSCurveKey.
	 *	\param in_offset The offset into the control points for this NURBS curve at which to start replacing points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.  The size of the array must be such that such that
	 *		<span class='code'>in_offset+in_points.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Replaces control point weights for this NURBSCurveKey.  It is possible to edit control point weights even if no weights were specified (i.e., default weights were used) when the NURBS curve
	 *	was inserted.
	 *	\param in_offset The offset into the control point weights for this NURBS curve at which to start replacing weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of control point weights to replace for the NURBS curve.  This must be such that such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement
	 *		to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		EditWeightsByReplacement(size_t in_offset, size_t in_count, float const in_weights[]);

	/*! Replaces control point weights for this NURBSCurveKey.  It is possible to edit control point weights even if no weights were specified (i.e., default weights were used) when the NURBS curve
	 *	was inserted.
	 *	\param in_offset The offset into the control point weights for this NURBS curve at which to start replacing weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.  The size of the array must be such that such that
	 *		<span class='code'>in_offset+in_weights.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		EditWeightsByReplacement(size_t in_offset, FloatArray const & in_weights);


	/*! Replaces knots for this NURBSCurveKey.  It is possible to edit these knots even if no knots were specified (i.e., default knots were used) when the NURBS curve was inserted.
	 *	\param in_offset The offset into the knots for this NURBS curve at which to start replacing knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of knots to replace for this NURBS curve.  This must be such that <span class='code'>in_offset+in_count&lt;=control_point_count+degree+1</span> for the replacement
	 *		to succeed.
	 *	\param in_knots The knots to use to replace those at the specified offset.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		EditKnotsByReplacement(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Replaces knots for this NURBSCurveKey.  It is possible to edit these knots even if no knots were specified (i.e., default knots were used) when the NURBS curve was inserted.
	 *	\param in_offset The offset into the knots for this NURBS curve at which to start replacing knots.  This value must be such that <span class='code'>in_offset&lt;control_point_count+degree+1</span>
	 *		for replacement to succeed.
	 *	\param in_knots The knots to use to replace those at the specified offset.  The size of the array must be such that <span class='code'>in_offset+in_knots.size()&lt;=control_point_count+degree+1</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this NURBSCurveKey. */
	NURBSCurveKey &		EditKnotsByReplacement(size_t in_offset, FloatArray const & in_knots);
};



/*! The NURBSSurfaceKit class is a user space object.  It is a kit analog to a NURBSSurfaceKey. */
class HPS_API NURBSSurfaceKit : public Kit
{
public:
	/*! The default constructor creates an empty NURBSSurfaceKit object. */
	NURBSSurfaceKit();

	/*! The copy constructor creates a new NURBSSurfaceKit object that contains the same settings as the source NURBSSurfaceKit.
	 * 	\param in_kit The source NURBSSurfaceKit to copy. */
	NURBSSurfaceKit(NURBSSurfaceKit const & in_kit);

	/*! The move constructor creates a NURBSSurfaceKit by transferring the underlying impl of the rvalue reference to this NURBSSurfaceKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a NURBSSurfaceKit to take the impl from. */
	NURBSSurfaceKit(NURBSSurfaceKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NURBSSurfaceKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a NURBSSurfaceKit to take the impl from.
	 * 	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit & operator=(NURBSSurfaceKit && in_that);

	virtual ~NURBSSurfaceKit();

	static const HPS::Type staticType = HPS::Type::NURBSSurfaceKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source NURBSSurfaceKit into this NURBSSurfaceKit and resets the source kit.
	 * 	\param in_kit The source NURBSSurfaceKit to consume. */
	void				Consume(NURBSSurfaceKit & in_kit);

	/*! Copies the source NURBSSurfaceKit into this NURBSSurfaceKit.
	 * 	\param in_kit The source NURBSSurfaceKit to copy. */
	void				Set(NURBSSurfaceKit const & in_kit);

	/*! Copies this NURBSSurfaceKit into the given NURBSSurfaceKit.
	 * 	\param out_kit The NURBSSurfaceKit to populate with the contents of this NURBSSurfaceKit. */
	void				Show(NURBSSurfaceKit & out_kit) const;

	/*! Copies the source NURBSSurfaceKit into this NURBSSurfaceKit.
	 * 	\param in_kit The source NURBSSurfaceKit to copy.
	 * 	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	operator=(NURBSSurfaceKit const & in_kit);

	/*! Indicates whether this NURBSSurfaceKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this NURBSSurfaceKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source NURBSSurfaceKit is equivalent to this NURBSSurfaceKit.
	 *	\param in_kit The source NURBSSurfaceKit to compare to this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(NURBSSurfaceKit const & in_kit) const;

	/*!	Check if the source NURBSSurfaceKit is equivalent to this NURBSSurfaceKit.
	 *	\param in_kit The source NURBSSurfaceKit to compare to this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(NURBSSurfaceKit const & in_kit) const;

	/*!	Check if the source NURBSSurfaceKit is not equivalent to this NURBSSurfaceKit.
	 *	\param in_kit The source NURBSSurfaceKit to compare to this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(NURBSSurfaceKit const & in_kit) const;

	/*!	Retrieves the number of points in this NURBS surface.
	 *	\return The number of points in this NURBS surface. */
	size_t				GetPointCount() const;

	/*!	Assigns a specific drawing priority value to the NURBSSurfaceKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	NURBSSurfaceKit &	SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	NURBSSurfaceKit &	UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Sets degree of the NURBSSurfaceKit in the U direction.
	 *	\param in_degree The degree of the NURBSSurfaceKit in the U direction.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetUDegree(size_t in_degree);

	/*! Sets degree of the NURBSSurfaceKit in the V direction.
	 *	\param in_degree The degree of the NURBSSurfaceKit in the V direction.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetVDegree(size_t in_degree);

	/*! Sets the number of control points in the U direction for the NURBSSurfaceKit.
	 *	\param in_count The number of control points in the U direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetUCount(size_t in_count);

	/*! Sets the number of control points in the V direction for the NURBSSurfaceKit.
	 *	\param in_count The number of control points in the V direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetVCount(size_t in_count);

	/*! Sets the control points for the NURBSSurfaceKit.
	 *	\param in_points The control points for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetPoints(PointArray const & in_points);

	/*! Sets the control points for the NURBSSurfaceKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The control points for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetPoints(size_t in_count, Point const in_points []);

	/*! Sets the control point weights for the NURBSSurfaceKit.  If no weights are set when this kit is used to insert a NURBS surface, default weights of <span class='code'>1.0f</span>
	 *	per control point will be used.
	 *	\param in_weights The control point weights for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetWeights(FloatArray const & in_weights);

	/*! Sets the control point weights for the NURBSSurfaceKit.  If no weights are set when this kit is used to insert a NURBS surface, default weights of <span class='code'>1.0f</span>
	 *	per control point will be used.
	 *	\param in_count Size of the following array.
	 *	\param in_weights The control point weights for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetWeights(size_t in_count, float const in_weights []);

	/*! Sets the knots in the U direction for the NURBSSurfaceKit.  If no knots are set when this kit is used to insert a NURBS surface, default knots of increasing value in the range
	 *	<span class='code'>[0,u_count+u_degree+1)</span> will be used.
	 *	\param in_knots The knots in the U direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetUKnots(FloatArray const & in_knots);

	/*! Sets the knots in the U direction for the NURBSSurfaceKit.  If no knots are set when this kit is used to insert a NURBS surface, default knots of increasing value in the range
	 *	<span class='code'>[0,u_count+u_degree+1)</span> will be used.
	 *	\param in_count Size of the following array.
	 *	\param in_knots The knots in the U direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetUKnots(size_t in_count, float const in_knots []);

	/*! Sets the knots in the V direction for the NURBSSurfaceKit.  If no knots are set when this kit is used to insert a NURBS surface, default knots of increasing value in the range
	 *	<span class='code'>[0,v_count+v_degree+1)</span> will be used.
	 *	\param in_knots The knots in the V direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetVKnots(FloatArray const & in_knots);

	/*! Sets the knots in the V direction for the NURBSSurfaceKit.  If no knots are set when this kit is used to insert a NURBS surface, default knots of increasing value in the range
	 *	<span class='code'>[0,v_count+v_degree+1)</span> will be used.
	 *	\param in_count Size of the following array.
	 *	\param in_knots The knots in the V direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetVKnots(size_t in_count, float const in_knots []);

	/*! Sets the trims for the NURBSSurfaceKit.
	 *	\param in_trims The trims for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetTrims(TrimKitArray const & in_trims);

	/*! Sets the trims for the NURBSSurfaceKit.
	 *	\param in_count Size of the following array.
	 *	\param in_trims The trims for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetTrims(size_t in_count, TrimKit const in_trims []);

	/*! Sets the trim for the NURBSSurfaceKit.
	 *	\param in_trim The trim for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	SetTrim(TrimKit const & in_trim);


	/*! Removes the setting for the degree of the NURBSSurfaceKit in the U direction.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetUDegree();

	/*! Removes the setting for the degree of the NURBSSurfaceKit in the V direction.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetVDegree();

	/*! Removes the setting for the number of points in the U direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetUCount();

	/*! Removes the setting for the number of points in the V direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetVCount();

	/*! Removes the control points for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetPoints();

	/*! Removes the control point weights for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetWeights();

	/*! Removes the knots in the U direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetUKnots();

	/*! Removes the knots in the V direction for the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetVKnots();

	/*! Removes the trims from the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetTrims();

	/*! Removes all settings from the NURBSSurfaceKit.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	UnsetEverything();


	/*! Shows the degree of this NURBSSurfaceKit in the U direction.
	 *	\param out_degree The degree of this NURBSSurfaceKit in the U direction.
	 *	\return <span class='code'>true</span> if such a degree was set, <span class='code'>false</span> otherwise. */
	bool				ShowUDegree(size_t & out_degree) const;

	/*! Shows the degree of this NURBSSurfaceKit in the V direction.
	 *	\param out_degree The degree of this NURBSSurfaceKit in the V direction.
	 *	\return <span class='code'>true</span> if such a degree was set, <span class='code'>false</span> otherwise. */
	bool				ShowVDegree(size_t & out_degree) const;

	/*! Shows the number of control points in the U direction for this NURBSSurfaceKit.
	 *	\param out_count The number of control points in the U direction for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if such a count was set, <span class='code'>false</span> otherwise. */
	bool				ShowUCount(size_t & out_count) const;

	/*! Shows the number of control points in the V direction for this NURBSSurfaceKit.
	 *	\param out_count The number of control points in the V direction for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if such a count was set, <span class='code'>false</span> otherwise. */
	bool				ShowVCount(size_t & out_count) const;

	/*! Shows the control points for this NURBSSurfaceKit.
	 *	\param out_points The control points for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if control points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSSurfaceKit by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSSurfaceKit by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSSurfaceKit by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Shows the control point weights for this NURBSSurfaceKit.
	 *	\param out_weights The control point weights for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if control point weights were set, <span class='code'>false</span> otherwise. */
	bool				ShowWeights(FloatArray & out_weights) const;

	/*! Shows the knots in the U direction for this NURBSSurfaceKit.
	 *	\param out_knots The knots in the U direction for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if these knots were set, <span class='code'>false</span> otherwise. */
	bool				ShowUKnots(FloatArray & out_knots) const;

	/*! Shows the knots in the V direction for this NURBSSurfaceKit.
	 *	\param out_knots The knots in the V direction for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if these knots were set, <span class='code'>false</span> otherwise. */
	bool				ShowVKnots(FloatArray & out_knots) const;

	/*! Shows the trims for this NURBSSurfaceKit.
	 *	\param out_trims The trims for this NURBSSurfaceKit.
	 *	\return <span class='code'>true</span> if trims were set, <span class='code'>false</span> otherwise. */
	bool				ShowTrims(TrimKitArray & out_trims) const;


	/*! Adds points to the control point list for this NURBSSurfaceKit.
	 *	\param in_offset The offset into the control point list for the NURBSSurfaceKit at which to insert points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the control point list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the control point list for this NURBSSurfaceKit.
	 *	\param in_offset The offset into the control point list for the NURBSSurfaceKit at which to insert points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_points The points to insert into the control point list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the control point list for this NURBSSurfaceKit.
	 *	\param in_offset The offset into the control point list for the NURBSSurfaceKit at which to start removing points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of points to delete from the control point list for the NURBSSurfaceKit.  This value must be such that
	 *		<span class='code'>in_offset+in_count&lt;=control_point_count</span> for the deletion to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces control points for this NURBSSurfaceKit.
	 *	\param in_offset The offset into the control point list for the NURBSSurfaceKit at which to replace points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces control points for this NURBSSurfaceKit.
	 *	\param in_offset The offset into the control point list for the NURBSSurfaceKit at which to replace points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.  This size of the array must be such that
	 *		<span class='code'>in_offset+in_points.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Adds weights to the control point weight list for this NURBSSurfaceKit.  This will allow modification of the default control point weights if no explicit weights are set
	 *	if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSSurfaceKit at which to insert weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_weights The weights to insert into the control point weight list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditWeightsByInsertion(size_t in_offset, size_t in_count, float const in_weights[]);

	/*! Adds weights to the control point weight list for this NURBSSurfaceKit.  This will allow modification of the default control point weights if no explicit weights are set
	 *	if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSSurfaceKit at which to insert weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_weights The weights to insert into the control point weight list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditWeightsByInsertion(size_t in_offset, FloatArray const & in_weights);

	/*! Removes weights from the control point weight list for this NURBSSurfaceKit.  This will allow modification of the default control point weights if no explicit weights are set
	 *	if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSSurfaceKit at which to start removing weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of weights to delete from the control point weight list for the NURBSSurfaceKit.  This value must be such that
	 *		<span class='code'>in_offset+in_count&lt;=control_point_count</span> for the deletion to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditWeightsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces control point weights for this NURBSSurfaceKit.  This will allow modification of the default control point weights if no explicit weights are set if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSSurfaceKit at which to replace weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditWeightsByReplacement(size_t in_offset, size_t in_count, float const in_weights[]);

	/*! Replaces control point weights for this NURBSSurfaceKit.  This will allow modification of the default control point weights if no explicit weights are set if possible.
	 *	\param in_offset The offset into the control point weight list for the NURBSSurfaceKit at which to replace weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for insertion to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.  This size of the array must be such that
	 *		<span class='code'>in_offset+in_weights.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditWeightsByReplacement(size_t in_offset, FloatArray const & in_weights);


	/*! Adds knots in the U direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the U direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the U direction for the NURBSSurfaceKit at which to insert knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_knots The knots to insert in the U direction at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditUKnotsByInsertion(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Adds knots in the U direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the U direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the U direction for the NURBSSurfaceKit at which to insert knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for insertion to succeed.
	 *	\param in_knots The knots to insert in the U direction at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditUKnotsByInsertion(size_t in_offset, FloatArray const & in_knots);

	/*! Removes knots in the U direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the U direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the U direction for the NURBSSurfaceKit at which to start removing knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of knots in the U direction to delete for the NURBSSurfaceKit.  This value must be such that
	 *		<span class='code'>in_offset+in_count&lt;=u_count+u_degree+1</span> for the deletion to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditUKnotsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces knots in the U direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the U direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the U direction for the NURBSSurfaceKit at which to replace knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for the replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=u_count+u_degree+1</span> for the replacement to succeed.
	 *	\param in_knots The knots to use to replace those in the U direction at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditUKnotsByReplacement(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Replaces knots in the U direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the U direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the U direction for the NURBSSurfaceKit at which to replace knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for the replacement to succeed.
	 *	\param in_knots The knots to use to replace those in the U direction at the specified offset.  The size of the array must be such that
	 *		<span class='code'>in_offset+in_knots.size()&lt;=u_count+u_degree+1</span> for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditUKnotsByReplacement(size_t in_offset, FloatArray const & in_knots);


	/*! Adds knots in the V direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the V direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the V direction for the NURBSSurfaceKit at which to insert knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_knots The knots to insert in the V direction at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditVKnotsByInsertion(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Adds knots in the V direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the V direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the V direction for the NURBSSurfaceKit at which to insert knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for insertion to succeed.
	 *	\param in_knots The knots to insert in the V direction at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditVKnotsByInsertion(size_t in_offset, FloatArray const & in_knots);

	/*! Removes knots in the V direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the V direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the V direction for the NURBSSurfaceKit at which to start removing knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for deletion to succeed.
	 *	\param in_count The number of knots in the V direction to delete for the NURBSSurfaceKit.  This value must be such that
	 *		<span class='code'>in_offset+in_count&lt;=v_count+v_degree+1</span> for the deletion to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditVKnotsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces knots in the V direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the V direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the V direction for the NURBSSurfaceKit at which to replace knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for the replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=v_count+v_degree+1</span> for the replacement to succeed.
	 *	\param in_knots The knots to use to replace those in the V direction at the specified offset.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditVKnotsByReplacement(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Replaces knots in the V direction for this NURBSSurfaceKit.  This will allow modification of the default knots in the V direction if no such explicit knots are set if possible.
	 *	\param in_offset The offset into the knots in the V direction for the NURBSSurfaceKit at which to replace knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for the replacement to succeed.
	 *	\param in_knots The knots to use to replace those in the V direction at the specified offset.  The size of the array must be such that
	 *		<span class='code'>in_offset+in_knots.size()&lt;=v_count+v_degree+1</span> for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKit. */
	NURBSSurfaceKit &	EditVKnotsByReplacement(size_t in_offset, FloatArray const & in_knots);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	NURBSSurfaceKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The NURBSSurfaceKey class is a smart pointer to a database object.  It is a handle to a NURBS surface inserted via SegmentKey::InsertNURBSSurface. */
class HPS_API NURBSSurfaceKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized NURBSSurfaceKey object.  The Type() function will return Type::None. */
	NURBSSurfaceKey();

	/*! This constructor creates a NURBSSurfaceKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of a NURBSSurface key.  Otherwise the copy will fail and the resulting NURBSSurfaceKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit NURBSSurfaceKey(Key const & in_that);

	/*! The copy constructor creates a NURBSSurfaceKey object that shares the underlying smart-pointer of the source NURBSSurfaceKey.
	 *	\param in_that The source NURBSSurfaceKey to copy. */
	NURBSSurfaceKey(NURBSSurfaceKey const & in_that);

	/*! Associate this NURBSSurfaceKey with the same underlying impl as the source NURBSSurfaceKey.
	 *	\param in_that The source NURBSSurfaceKey for the assignment.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey & operator=(NURBSSurfaceKey const & in_that);

	/*! The move constructor creates a NURBSSurfaceKey by transferring the underlying impl of the rvalue reference to this NURBSSurfaceKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a NURBSSurfaceKey to take the impl from. */
	NURBSSurfaceKey(NURBSSurfaceKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NURBSSurfaceKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a NURBSSurfaceKey to take the impl from.
	 * 	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey & operator=(NURBSSurfaceKey && in_that);

	~NURBSSurfaceKey();

	static const HPS::Type staticType = HPS::Type::NURBSSurfaceKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this NURBSSurfaceKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this NURBSSurfaceKey. */
	void				Consume(NURBSSurfaceKit & in_kit);

	/*! Replace those settings on this NURBSSurfaceKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this NURBSSurfaceKey. */
	void				Set(NURBSSurfaceKit const & in_kit);

	/*! Copy the contents of this NURBSSurfaceKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this NURBSSurfaceKey. */
	void				Show(NURBSSurfaceKit & out_kit) const;

	/*!	Retrieves the number of points in this NURBS surface.
	 *	\return The number of points in this NURBS surface. */
	size_t				GetPointCount() const;

	/*! Sets the specified trims on this NURBSSurfaceKey.  These will replace any existing trims.
	 *	\param in_count Size of the following array.
	 *	\param in_trims The array of trims to apply to this NURBSSurfaceKey.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	SetTrims(size_t in_count, TrimKit const in_trims []);

	/*! Sets the specified trim on this NURBSSurfaceKey.  These will replace any existing trims.
	 *	\param in_trim The trim to apply to this NURBSSurfaceKey.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	SetTrim(TrimKit const & in_trim);

	/*! Sets the specified trims on this NURBSSurfaceKey.  These will replace any existing trims.
	 *	\param in_trims The array of trims to apply to this NURBSSurfaceKey.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	SetTrims(TrimKitArray const & in_trims);


	/*! Removes the trims from this NURBSSurfaceKey.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	UnsetTrims();


	/*! Shows the degree of this NURBSSurfaceKey in the U direction.
	 *	\param out_degree The degree of this NURBSSurfaceKey in the U direction.
	 *	\return <span class='code'>true</span> if such a degree was set, <span class='code'>false</span> otherwise. */
	bool				ShowUDegree(size_t & out_degree) const;

	/*! Shows the degree of this NURBSSurfaceKey in the V direction.
	 *	\param out_degree The degree of this NURBSSurfaceKey in the V direction.
	 *	\return <span class='code'>true</span> if such a degree was set, <span class='code'>false</span> otherwise. */
	bool				ShowVDegree(size_t & out_degree) const;

	/*! Shows the number of control points in the U direction for this NURBSSurfaceKey.
	 *	\param out_count The number of control points in the U direction for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if such a count was set, <span class='code'>false</span> otherwise. */
	bool				ShowUCount(size_t & out_count) const;

	/*! Shows the number of control points in the V direction for this NURBSSurfaceKey.
	 *	\param out_count The number of control points in the V direction for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if such a count was set, <span class='code'>false</span> otherwise. */
	bool				ShowVCount(size_t & out_count) const;

	/*! Shows the control points for this NURBSSurfaceKey.
	 *	\param out_points The control points for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if control points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSSurfaceKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSSurfaceKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this NURBSSurfaceKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Shows the control point weights for this NURBSSurfaceKey.
	 *	\param out_weights The control point weights for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if control point weights were set, <span class='code'>false</span> otherwise. */
	bool				ShowWeights(FloatArray & out_weights) const;

	/*! Shows the knot sequence in the U direction for this NURBSSurfaceKey.
	 *	\param out_knots The knot sequence in the U direction for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if these knots were set, <span class='code'>false</span> otherwise. */
	bool				ShowUKnots(FloatArray & out_knots) const;

	/*! Shows the knot sequence in the V direction for this NURBSSurfaceKey.
	 *	\param out_knots The knot sequence in the V direction for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if these knots were set, <span class='code'>false</span> otherwise. */
	bool				ShowVKnots(FloatArray & out_knots) const;

	/*! Shows the trims for this NURBSSurfaceKey.
	 *	\param out_trims The trims for this NURBSSurfaceKey.
	 *	\return <span class='code'>true</span> if trims were set, <span class='code'>false</span> otherwise. */
	bool				ShowTrims(TrimKitArray & out_trims) const;


	/*! Replaces control points for this NURBSSurfaceKey.
	 *	\param in_offset The offset into the control points for this NURBS surface at which to start replacing points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of control points to replace for the NURBS surface.  This must be such that such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement
	 *		to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces control points for this NURBSSurfaceKey.
	 *	\param in_offset The offset into the control points for this NURBS surface at which to start replacing points.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_points The points to use to replace those in the control point list at the specified offset.  The size of the array must be such that such that
	 *		<span class='code'>in_offset+in_points.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Replaces control point weights for this NURBSSurfaceKey.  It is possible to edit control point weights even if no weights were specified (i.e., default weights were used) when the NURBS surface
	 *	was inserted.
	 *	\param in_offset The offset into the control point weights for this NURBS surface at which to start replacing weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of control point weights to replace for the NURBS surface.  This must be such that such that <span class='code'>in_offset+in_count&lt;=control_point_count</span> for the replacement
	 *		to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditWeightsByReplacement(size_t in_offset, size_t in_count, float const in_weights[]);

	/*! Replaces control point weights for this NURBSSurfaceKey.  It is possible to edit control point weights even if no weights were specified (i.e., default weights were used) when the NURBS surface
	 *	was inserted.
	 *	\param in_offset The offset into the control point weights for this NURBS surface at which to start replacing weights.  This value must be such that <span class='code'>in_offset&lt;control_point_count</span>
	 *		for replacement to succeed.
	 *	\param in_weights The weights to use to replace those in the control point weight list at the specified offset.  The size of the array must be such that such that
	 *		<span class='code'>in_offset+in_weights.size()&lt;=control_point_count</span> for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditWeightsByReplacement(size_t in_offset, FloatArray const & in_weights);


	/*! Replaces knots in the U direction for this NURBSSurfaceKey.  It is possible to edit these knots even if no knots were specified (i.e., default knots were used) when the NURBS surface was inserted.
	 *	\param in_offset The offset into the knots in the U direction for this NURBS surface at which to start replacing knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of knots in the U direction to replace for this NURBS surface.  This must be such that <span class='code'>in_offset+in_count&lt;=u_count+u_degree+1</span> for the replacement
	 *		to succeed.
	 *	\param in_knots The knots in the U direction to use to replace those at the specified offset.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditUKnotsByReplacement(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Replaces knots in the U direction for this NURBSSurfaceKey.  It is possible to edit these knots even if no knots were specified (i.e., default knots were used) when the NURBS surface was inserted.
	 *	\param in_offset The offset into the knots in the U direction for this NURBS surface at which to start replacing knots.  This value must be such that <span class='code'>in_offset&lt;u_count+u_degree+1</span>
	 *		for replacement to succeed.
	 *	\param in_knots The knots in the U direction to use to replace those at the specified offset.  The size of the array must be such that <span class='code'>in_offset+in_knots.size()&lt;=u_count+u_degree+1</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditUKnotsByReplacement(size_t in_offset, FloatArray const & in_knots);


	/*! Replaces knots in the V direction for this NURBSSurfaceKey.  It is possible to edit these knots even if no knots were specified (i.e., default knots were used) when the NURBS surface was inserted.
	 *	\param in_offset The offset into the knots in the V direction for this NURBS surface at which to start replacing knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for replacement to succeed.
	 *	\param in_count The number of knots in the V direction to replace for this NURBS surface.  This must be such that <span class='code'>in_offset+in_count&lt;=v_count+v_degree+1</span> for the replacement
	 *		to succeed.
	 *	\param in_knots The knots in the V direction to use to replace those at the specified offset.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditVKnotsByReplacement(size_t in_offset, size_t in_count, float const in_knots[]);

	/*! Replaces knots in the V direction for this NURBSSurfaceKey.  It is possible to edit these knots even if no knots were specified (i.e., default knots were used) when the NURBS surface was inserted.
	 *	\param in_offset The offset into the knots in the V direction for this NURBS surface at which to start replacing knots.  This value must be such that <span class='code'>in_offset&lt;v_count+v_degree+1</span>
	 *		for replacement to succeed.
	 *	\param in_knots The knots in the V direction to use to replace those at the specified offset.  The size of the array must be such that <span class='code'>in_offset+in_knots.size()&lt;=v_count+v_degree+1</span>
	 *		for the replacement to succeed.
	 *	\return A reference to this NURBSSurfaceKey. */
	NURBSSurfaceKey &	EditVKnotsByReplacement(size_t in_offset, FloatArray const & in_knots);
};



/*! The TrimElement class is a user space object.  It is used to specify the curves that are used to define a trim region. */
class HPS_API TrimElement : public Object
{
public:
	/*! The default constructor creates an empty TrimElement object. */
	TrimElement();

	/*! The copy constructor creates a new TrimElement object that contains the same settings as the source TrimElement.
	 * 	\param in_that The source TrimElement to copy. */
	TrimElement(TrimElement const & in_that);

	/*! This constructor creates a TrimElement with a line.
	 *	\param in_line The line for this TrimElement.  Only the X and Y coordinates of the points defining the line will be used when the trim region is applied to a surface.
	 *		The coordinates will be treated as U and V parameter values in the normalized parameter space for the NURBS surface. */
	TrimElement(LineKit const & in_line);

	/*! This constructor creates a TrimElement with a NURBS curve.
	 *	\param in_curve The NURBS curve for this TrimElement.  Only the X and Y coordinates of the control points defining the curve will be used when the trim region is applied to a surface.
	 *		The coordinates will be treated as U and V parameter values in the normalized parameter space for the NURBS surface. */
	TrimElement(NURBSCurveKit const & in_curve);

	/*! The move constructor creates a TrimElement by transferring the underlying impl of the rvalue reference to this TrimElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TrimElement to take the impl from. */
	TrimElement(TrimElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TrimElement thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a TrimElement to take the impl from.
	 *	\return A reference to this TrimElement. */
	TrimElement & operator=(TrimElement && in_that);

	~TrimElement();

	static const HPS::Type staticType = HPS::Type::TrimElement;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source TrimElement into this TrimElement.
	 * 	\param in_that The source TrimElement to copy. */
	void					Set(TrimElement const & in_that);

	/*! Copies the source TrimElement into this TrimElement.
	 * 	\param in_that The source TrimElement to copy.
	 * 	\return A reference to this TrimElement. */
	TrimElement &			operator=(TrimElement const & in_that);

	/*!	Check if the source TrimElement is equivalent to this TrimElement.
	 *	\param in_that The source TrimElement to compare to this TrimElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(TrimElement const & in_that) const;

	/*!	Check if the source TrimElement is equivalent to this TrimElement.
	 *	\param in_that The source TrimElement to compare to this TrimElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(TrimElement const & in_that) const;

	/*!	Check if the source TrimElement is not equivalent to this TrimElement.
	 *	\param in_that The source TrimElement to compare to this TrimElement.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(TrimElement const & in_that) const;


	/*! Sets a line as the curve for this TrimElement.
	 *	\param in_line The line for this TrimElement.  Only the X and Y coordinates of the points defining the line will be used when the trim region is applied to a surface.
	 *		The coordinates will be treated as U and V parameter values in the normalized parameter space for the NURBS surface. */
	void					SetCurve(LineKit const & in_line);

	/*! Sets a NURBS curve as the curve for this TrimElement.
	 *	\param in_curve The NURBS curve for this TrimElement.  Only the X and Y coordinates of the control points defining the curve will be used when the trim region is applied to a surface.
	 *		The coordinates will be treated as U and V parameter values in the normalized parameter space for the NURBS surface. */
	void					SetCurve(NURBSCurveKit const & in_curve);

	/*! Shows the curve for this TrimElement.
	 *	\param out_type The type of curve used for this TrimElement.
	 *	\param out_line The line for the trim curve.  This is only valid if <span class='code'>out_type</type> is NURBSSurface::Line.
	 *	\param out_curve The NURBS curve for the trim curve.  This is only valid if <span class='code'>out_type</type> is NURBSSurface::Curve.
	 *	\return <span class='code'>true</span> if a line or NURBS curve was set, <span class='code'>false</span> otherwise. */
	bool					ShowCurve(Trim::Type & out_type, LineKit & out_line, NURBSCurveKit & out_curve) const;
};



/*! The TrimKit class is a user space object.  It is used to define trim curves (either NURBS curves or lines) that can be used to trim NURBS surfaces. */
class HPS_API TrimKit : public Kit
{
public:
	/*! The default constructor creates an empty TrimKit object. */
	TrimKit();

	/*! The copy constructor creates a new TrimKit object that contains the same settings as the source TrimKit.
	 * 	\param in_kit The source TrimKit to copy. */
	TrimKit(TrimKit const & in_kit);

	/*! The move constructor creates a TrimKit by transferring the underlying impl of the rvalue reference to this TrimKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TrimKit to take the impl from. */
	TrimKit(TrimKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TrimKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a TrimKit to take the impl from.
	 * 	\return A reference to this TrimKit. */
	TrimKit & operator=(TrimKit && in_that);

	virtual ~TrimKit();

	static const HPS::Type staticType = HPS::Type::TrimKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source TrimKit into this TrimKit.
	 * 	\param in_kit The source TrimKit to copy. */
	void				Set(TrimKit const & in_kit);

	/*! Copies this TrimKit into the given TrimKit.
	 * 	\param out_kit The TrimKit to populate with the contents of this TrimKit. */
	void				Show(TrimKit & out_kit) const;

	/*! Copies the source TrimKit into this TrimKit.
	 * 	\param in_kit The source TrimKit to copy.
	 * 	\return A reference to this TrimKit. */
	TrimKit &			operator=(TrimKit const & in_kit);

	/*! Indicates whether this TrimKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this TrimKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source TrimKit is equivalent to this TrimKit.
	 *	\param in_kit The source TrimKit to compare to this TrimKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(TrimKit const & in_kit) const;

	/*!	Check if the source TrimKit is equivalent to this TrimKit.
	 *	\param in_kit The source TrimKit to compare to this TrimKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(TrimKit const & in_kit) const;

	/*!	Check if the source TrimKit is not equivalent to this TrimKit.
	 *	\param in_kit The source TrimKit to compare to this TrimKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(TrimKit const & in_kit) const;


	/*! Sets the shape of the trim region.  The shape is a collection of trim elements.
	 *	\param in_count Size of the following array.
	 *	\param in_shape An array of trim elements defining a trim region.
	 *	\return A reference to this TrimKit. */
	TrimKit &			SetShape(size_t in_count, TrimElement const in_shape[]);

	/*! Sets the shape of the trim region.  The shape is a collection of trim elements.
	 *	\param in_shape An array of trim elements defining a trim region.
	 *	\return A reference to this TrimKit. */
	TrimKit &			SetShape(TrimElementArray const & in_shape);

	/*! Sets the shape of the trim region.
	 *	\param in_shape An trim element defining a trim region.
	 *	\return A reference to this TrimKit. */
	TrimKit &			SetShape(TrimElement const & in_shape);


	/*! Sets the operation for the trim.
	 *	\param in_operation The operation for the trim.
	 *	\return A reference to this TrimKit. */
	TrimKit &			SetOperation(Trim::Operation in_operation);


	/*! Removes the trim elements defining a trim region.
	 *	\return A reference to this TrimKit. */
	TrimKit &			UnsetShape();

	/*! Removes the operation for the trim.
	 *	\return A reference to this TrimKit. */
	TrimKit &			UnsetOperation();

	/*! Removes all settings from this TrimKit.
	 *	\return A reference to this TrimKit. */
	TrimKit &			UnsetEverything();


	/*! Shows the shape of the trim region.
	 *	\param out_shape The array of trim elements defining a trim region.
	 *	\return <span class='code'>true</span> if a shape was set, <span class='code'>false</span> otherwise. */
	bool				ShowShape(TrimElementArray & out_shape) const;

	/*! Shows the operation for the trim.
	 *	\param out_operation The operation for the trim.
	 *	\return <span class='code'>true</span> if an operation was set, <span class='code'>false</span> otherwise. */
	bool				ShowOperation(Trim::Operation & out_operation) const;
};



/*! The EllipseKit class is a user space object.  It is the kit analog to an EllipseKey. */
class HPS_API EllipseKit : public Kit
{
public:
	/*! The default constructor creates an empty EllipseKit object. */
	EllipseKit();

	/*! The copy constructor creates a new EllipseKit object that contains the same settings as the source EllipseKit.
	 * 	\param in_kit The source EllipseKit to copy. */
	EllipseKit(EllipseKit const & in_kit);

	/*! The move constructor creates an EllipseKit by transferring the underlying impl of the rvalue reference to this EllipseKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an EllipseKit to take the impl from. */
	EllipseKit(EllipseKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipseKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an EllipseKit to take the impl from.
	 * 	\return A reference to this EllipseKit. */
	EllipseKit & operator=(EllipseKit && in_that);

	virtual ~EllipseKit();

	static const HPS::Type staticType = HPS::Type::EllipseKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source EllipseKit into this EllipseKit and resets the source kit.
	 * 	\param in_kit The source EllipseKit to consume. */
	void				Consume(EllipseKit & in_kit);

	/*! Copies the source EllipseKit into this EllipseKit.
	 * 	\param in_kit The source EllipseKit to copy. */
	void				Set(EllipseKit const & in_kit);

	/*! Copies this EllipseKit into the given EllipseKit.
	 * 	\param out_kit The EllipseKit to populate with the contents of this EllipseKit. */
	void				Show(EllipseKit & out_kit) const;

	/*! Copies the source EllipseKit into this EllipseKit.
	 * 	\param in_kit The source EllipseKit to copy.
	 * 	\return A reference to this EllipseKit. */
	EllipseKit &		operator=(EllipseKit const & in_kit);

	/*! Indicates whether this EllipseKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this EllipseKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source EllipseKit is equivalent to this EllipseKit.
	 *	\param in_kit The source EllipseKit to compare to this EllipseKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(EllipseKit const & in_kit) const;

	/*!	Check if the source EllipseKit is equivalent to this EllipseKit.
	 *	\param in_kit The source EllipseKit to compare to this EllipseKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(EllipseKit const & in_kit) const;

	/*!	Check if the source EllipseKit is not equivalent to this EllipseKit.
	 *	\param in_kit The source EllipseKit to compare to this EllipseKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(EllipseKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the EllipseKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	EllipseKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	EllipseKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowPriority(int & out_priority) const;


	/*! Sets the center point for the ellipse.
	 *	\param in_center The center point for the ellipse.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		SetCenter(Point const & in_center);

	/*! Sets the intersection point of the major axis and the ellipse.
	 *	\param in_major The intersection point of the major axis and the ellipse.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		SetMajor(Point const & in_major);

	/*! Sets the intersection point of the minor axis and the ellipse.
	 *	\param in_minor The intersection point of the minor axis and the ellipse.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		SetMinor(Point const & in_minor);


	/*! Removes the center point for the ellipse.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		UnsetCenter();

	/*! Removes the intersection point of the major axis and the ellipse.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		UnsetMajor();

	/*! Removes the intersection point of the minor axis and the ellipse.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		UnsetMinor();

	/*! Removes all settings from this EllipseKit.
	 *	\return A reference to this EllipseKit. */
	EllipseKit &		UnsetEverything();


	/*! Shows the center point for the ellipse.
	 *	\param out_center The center point for the ellipse.
	 *	\return <span class='code'>true</span> if a center was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(Point & out_center) const;

	/*! Shows the intersection point of the major axis and the ellipse.
	 *	\param out_major The intersection point of the major axis and the ellipse.
	 *	\return <span class='code'>true</span> if an intersection point with the major axis was set, <span class='code'>false</span> otherwise. */
	bool				ShowMajor(Point & out_major) const;

	/*! Shows the intersection point of the minor axis and the ellipse.
	 *	\param out_minor The intersection point of the minor axis and the ellipse.
	 *	\return <span class='code'>true</span> if an intersection point with the minor axis was set, <span class='code'>false</span> otherwise. */
	bool				ShowMinor(Point & out_minor) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	EllipseKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	EllipseKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	EllipseKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	EllipseKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	EllipseKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	EllipseKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	EllipseKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};



/*! The EllipseKey class is a smart pointer to a database object.  It is a handle to an ellipse inserted via SegmentKey::InsertEllipse. */
class HPS_API EllipseKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized EllipseKey object.  The Type() function will return Type::None. */
	EllipseKey();

	/*! This constructor creates an EllipseKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of an Ellipse key.  Otherwise the copy will fail and the resulting EllipseKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit EllipseKey(Key const & in_that);

	/*! The copy constructor creates an EllipseKey object that shares the underlying smart-pointer of the source EllipseKey.
	 *	\param in_that The source EllipseKey to copy. */
	EllipseKey(EllipseKey const & in_that);

	/*! Associate this EllipseKey with the same underlying impl as the source EllipseKey.
	 *	\param in_that The source EllipseKey for the assignment.
	 *	\return A reference to this EllipseKey. */
	EllipseKey & operator=(EllipseKey const & other);

	/*! The move constructor creates an EllipseKey by transferring the underlying impl of the rvalue reference to this EllipseKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an EllipseKey to take the impl from. */
	EllipseKey(EllipseKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipseKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an EllipseKey to take the impl from.
	 * 	\return A reference to this EllipseKey. */
	EllipseKey & operator=(EllipseKey && in_that);

	~EllipseKey();

	static const HPS::Type staticType = HPS::Type::EllipseKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this EllipseKit with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this EllipseKit. */
	void				Consume(EllipseKit & in_kit);

	/*! Replace those settings on this EllipseKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this EllipseKey. */
	void				Set(EllipseKit const & in_kit);

	/*! Copy the contents of this EllipseKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this EllipseKey. */
	void				Show(EllipseKit & out_kit) const;


	/*! Sets the center point for the ellipse.
	 *	\param in_center The center point for the ellipse.
	 *	\return A reference to this EllipseKey. */
	EllipseKey &		SetCenter(Point const & in_center);

	/*! Sets the intersection point of the major axis and the ellipse.
	 *	\param in_major The intersection point of the major axis and the ellipse.
	 *	\return A reference to this EllipseKey. */
	EllipseKey &		SetMajor(Point const & in_major);

	/*! Sets the intersection point of the minor axis and the ellipse.
	 *	\param in_minor The intersection point of the minor axis and the ellipse.
	 *	\return A reference to this EllipseKey. */
	EllipseKey &		SetMinor(Point const & in_minor);


	/*! Shows the center point for the ellipse.
	 *	\param out_center The center point for the ellipse.
	 *	\return <span class='code'>true</span> if a center was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(Point & out_center) const;

	/*! Shows the intersection point of the major axis and the ellipse.
	 *	\param out_major The intersection point of the major axis and the ellipse.
	 *	\return <span class='code'>true</span> if an intersection point with the major axis was set, <span class='code'>false</span> otherwise. */
	bool				ShowMajor(Point & out_major) const;

	/*! Shows the intersection point of the minor axis and the ellipse.
	 *	\param out_minor The intersection point of the minor axis and the ellipse.
	 *	\return <span class='code'>true</span> if an intersection point with the minor axis was set, <span class='code'>false</span> otherwise. */
	bool				ShowMinor(Point & out_minor) const;
};



/*! The EllipticalArcKit class is a user space object.  It is the kit analog to an EllipticalArcKey. */
class HPS_API EllipticalArcKit : public Kit
{
public:
	/*! The default constructor creates an empty EllipticalArcKit object. */
	EllipticalArcKit();

	/*! The copy constructor creates a new EllipticalArcKit object that contains the same settings as the source EllipticalArcKit.
	 * 	\param in_kit The source EllipticalArcKit to copy. */
	EllipticalArcKit(EllipticalArcKit const & in_kit);

	/*! The move constructor creates an EllipticalArcKit by transferring the underlying impl of the rvalue reference to this EllipticalArcKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an EllipticalArcKit to take the impl from. */
	EllipticalArcKit(EllipticalArcKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipticalArcKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an EllipticalArcKit to take the impl from.
	 * 	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit & operator=(EllipticalArcKit && in_that);

	virtual ~EllipticalArcKit();

	static const HPS::Type staticType = HPS::Type::EllipticalArcKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source EllipticalArcKit into this EllipticalArcKit and resets the source kit.
	 * 	\param in_kit The source EllipticalArcKit to consume. */
	void					Consume(EllipticalArcKit & in_kit);

	/*! Copies the source EllipticalArcKit into this EllipticalArcKit.
	 * 	\param in_kit The source EllipticalArcKit to copy. */
	void					Set(EllipticalArcKit const & in_kit);

	/*! Copies this EllipticalArcKit into the given EllipticalArcKit.
	 * 	\param out_kit The EllipticalArcKit to populate with the contents of this EllipticalArcKit. */
	void					Show(EllipticalArcKit & out_kit) const;

	/*! Copies the source EllipticalArcKit into this EllipticalArcKit.
	 * 	\param in_kit The source EllipticalArcKit to copy.
	 * 	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		operator=(EllipticalArcKit const & in_kit);

	/*! Indicates whether this EllipticalArcKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this EllipticalArcKit, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source EllipticalArcKit is equivalent to this EllipticalArcKit.
	 *	\param in_kit The source EllipticalArcKit to compare to this EllipticalArcKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(EllipticalArcKit const & in_kit) const;

	/*!	Check if the source EllipticalArcKit is equivalent to this EllipticalArcKit.
	 *	\param in_kit The source EllipticalArcKit to compare to this EllipticalArcKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(EllipticalArcKit const & in_kit) const;

	/*!	Check if the source EllipticalArcKit is not equivalent to this EllipticalArcKit.
	 *	\param in_kit The source EllipticalArcKit to compare to this EllipticalArcKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(EllipticalArcKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the EllipticalArcKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	EllipticalArcKit &				SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	EllipticalArcKit &				UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPriority(int & out_priority) const;


	/*! Sets the center point for the ellipse used to define the elliptcal arc.
	 *	\param in_center The center point for the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		SetCenter(Point const & in_center);

	/*! Sets the intersection point of the major axis and the ellipse used to define the elliptcal arc.
	 *	\param in_major The intersection point of the major axis and the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		SetMajor(Point const & in_major);

	/*! Sets the intersection point of the minor axis and the ellipse used to define the elliptcal arc.
	 *	\param in_minor The intersection point of the minor axis and the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		SetMinor(Point const & in_minor);

	/*! Sets the normalized parametric value on the ellipse at which the elliptical arc starts.  The value should be in the range <span class='code'>[0.0f,1.0f]</span> and be smaller than
	 *	the end value.  It is defined such that <span class='code'>0.0f</span> is the point where the major axis intersects the ellipse, and as the value increases it passes
	 *	through the point at which the minor axis intersects the ellipse (<span class='code'>0.25f</span>), and that <span class='code'>1.0f</span> maps to the same point
	 *	as <span class='code'>0.0f</span>.
	 *	\param in_start The noramlized parametric value on the ellipse at which the elliptical arc starts.  This value should be in the range <span class='code'>[0.0f,1.0f]</span>
	 *		and be smaller than the end value.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		SetStart(float in_start);

	/*! Sets the normalized parametric value on the ellipse at which the elliptical arc ends.  The value should be in the range <span class='code'>[0.0f,1.0f]</span> and be larger than
	 *	the start value.  It is defined such that <span class='code'>0.0f</span> is the point where the major axis intersects the ellipse, and as the value increases it passes
	 *	through the point at which the minor axis intersects the ellipse (<span class='code'>0.25f</span>), and that <span class='code'>1.0f</span> maps to the same point
	 *	as <span class='code'>0.0f</span>.
	 *	\param in_end The noramlized parametric value on the ellipse at which the elliptical arc ends.  This value should be in the range <span class='code'>[0.0f,1.0f]</span>
	 *		and be larger than the start value.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		SetEnd(float in_end);


	/*! Removes the center point for the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		UnsetCenter();

	/*! Removes the intersection point of the major axis and the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		UnsetMajor();

	/*! Removes the intersection point of the minor axis and the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		UnsetMinor();

	/*! Removes the normalized parametric value on the ellipse at which the elliptical arc starts.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		UnsetStart();

	/*! Removes the normalized parametric value on the ellipse at which the elliptical arc ends.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		UnsetEnd();

	/*! Removes all settings from this EllipticalArcKit.
	 *	\return A reference to this EllipticalArcKit. */
	EllipticalArcKit &		UnsetEverything();


	/*! Shows the center point for the ellipse used to define the elliptical arc.
	 *	\param out_center The center point for the ellipse used to define the elliptical arc.
	 *	\return <span class='code'>true</span> if a center was set, <span class='code'>false</span> otherwise. */
	bool					ShowCenter(Point & out_center) const;

	/*! Shows the intersection point of the major axis and the ellipse used to define the elliptcal arc.
	 *	\param out_major The intersection point of the major axis and the ellipse used to define the elliptical arc.
	 *	\return <span class='code'>true</span> if an intersection point with the major axis was set, <span class='code'>false</span> otherwise. */
	bool					ShowMajor(Point & out_major) const;

	/*! Shows the intersection point of the minor axis and the ellipse used to define the elliptcal arc.
	 *	\param out_minor The intersection point of the minor axis and the ellipse used to define the elliptical arc.
	 *	\return <span class='code'>true</span> if an intersection point with the minor axis was set, <span class='code'>false</span> otherwise. */
	bool					ShowMinor(Point & out_minor) const;

	/*! Shows the normalized parametric value on the ellipse at which the elliptical arc starts.
	 *	\param out_start The noramlized parametric value on the ellipse at which the elliptical arc starts.
	 *	\return <span class='code'>true</span> if a normalized parametric start value was set, <span class='code'>false</span> otherwise. */
	bool					ShowStart(float & out_start) const;

	/*! Shows the normalized parametric value on the ellipse at which the elliptical arc ends.
	 *	\param out_end The noramlized parametric value on the ellipse at which the elliptical arc ends.
	 *	\return <span class='code'>true</span> if a normalized parametric end value was set, <span class='code'>false</span> otherwise. */
	bool					ShowEnd(float & out_end) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	EllipticalArcKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The EllipticalArcKey class is a smart pointer to a database object.  It is a handle to an elliptical arc inserted via SegmentKey::InsertEllipticalArc. */
class HPS_API EllipticalArcKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized EllipticalArcKey object.  The Type() function will return Type::None. */
	EllipticalArcKey();

	/*! This constructor creates an EllipticalArcKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really
	 *	an upcast of an EllipticalArc key.  Otherwise the copy will fail and the resulting EllipticalArcKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit EllipticalArcKey(Key const & in_that);

	/*! The copy constructor creates an EllipticalArcKey object that shares the underlying smart-pointer of the source EllipticalArcKey.
	 *	\param in_that The source EllipticalArcKey to copy. */
	EllipticalArcKey(EllipticalArcKey const & in_that);

	/*! Associate this EllipticalArcKey with the same underlying impl as the source EllipticalArcKey.
	 *	\param in_that The source EllipticalArcKey for the assignment.
	 *	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey & operator=(EllipticalArcKey const & other);

	/*! The move constructor creates an EllipticalArcKey by transferring the underlying impl of the rvalue reference to this EllipticalArcKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an EllipticalArcKey to take the impl from. */
	EllipticalArcKey(EllipticalArcKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipticalArcKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an EllipticalArcKey to take the impl from.
	 * 	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey & operator=(EllipticalArcKey && in_that);

	~EllipticalArcKey();

	static const HPS::Type staticType = HPS::Type::EllipticalArcKey;
	HPS::Type				ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this EllipticalArcKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this EllipticalArcKey. */
	void					Consume(EllipticalArcKit & in_kit);

	/*! Replace those settings on this EllipticalArcKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this EllipticalArcKey. */
	void					Set(EllipticalArcKit const & in_kit);

	/*! Copy the contents of this EllipticalArcKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this EllipticalArcKey. */
	void					Show(EllipticalArcKit & out_kit) const;


	/*! Sets the center point for the ellipse used to define the elliptcal arc.
	 *	\param in_center The center point for the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey &		SetCenter(Point const & in_center);

	/*! Sets the intersection point of the major axis and the ellipse used to define the elliptcal arc.
	 *	\param in_major The intersection point of the major axis and the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey &		SetMajor(Point const & in_major);

	/*! Sets the intersection point of the minor axis and the ellipse used to define the elliptcal arc.
	 *	\param in_minor The intersection point of the minor axis and the ellipse used to define the elliptical arc.
	 *	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey &		SetMinor(Point const & in_minor);

	/*! Sets the normalized parametric value on the ellipse at which the elliptical arc starts.  The value should be in the range <span class='code'>[0.0f,1.0f]</span> and be smaller than
	 *	the end value.  It is defined such that <span class='code'>0.0f</span> is the point where the major axis intersects the ellipse, and as the value increases it passes
	 *	through the point at which the minor axis intersects the ellipse (<span class='code'>0.25f</span>), and that <span class='code'>1.0f</span> maps to the same point
	 *	as <span class='code'>0.0f</span>.
	 *	\param in_start The noramlized parametric value on the ellipse at which the elliptical arc starts.  This value should be in the range <span class='code'>[0.0f,1.0f]</span>
	 *		and be smaller than the end value.
	 *	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey &		SetStart(float in_start);

	/*! Sets the normalized parametric value on the ellipse at which the elliptical arc ends.  The value should be in the range <span class='code'>[0.0f,1.0f]</span> and be larger than
	 *	the start value.  It is defined such that <span class='code'>0.0f</span> is the point where the major axis intersects the ellipse, and as the value increases it passes
	 *	through the point at which the minor axis intersects the ellipse (<span class='code'>0.25f</span>), and that <span class='code'>1.0f</span> maps to the same point
	 *	as <span class='code'>0.0f</span>.
	 *	\param in_end The noramlized parametric value on the ellipse at which the elliptical arc ends.  This value should be in the range <span class='code'>[0.0f,1.0f]</span>
	 *		and be larger than the start value.
	 *	\return A reference to this EllipticalArcKey. */
	EllipticalArcKey &		SetEnd(float in_end);


	/*! Shows the center point for the ellipse used to define the elliptical arc.
	 *	\param out_center The center point for the ellipse used to define the elliptical arc.
	 *	\return <span class='code'>true</span> if a center was set, <span class='code'>false</span> otherwise. */
	bool					ShowCenter(Point & out_center) const;

	/*! Shows the intersection point of the major axis and the ellipse used to define the elliptcal arc.
	 *	\param out_major The intersection point of the major axis and the ellipse used to define the elliptical arc.
	 *	\return <span class='code'>true</span> if an intersection point with the major axis was set, <span class='code'>false</span> otherwise. */
	bool					ShowMajor(Point & out_major) const;

	/*! Shows the intersection point of the minor axis and the ellipse used to define the elliptcal arc.
	 *	\param out_minor The intersection point of the minor axis and the ellipse used to define the elliptical arc.
	 *	\return <span class='code'>true</span> if an intersection point with the minor axis was set, <span class='code'>false</span> otherwise. */
	bool					ShowMinor(Point & out_minor) const;

	/*! Shows the normalized parametric value on the ellipse at which the elliptical arc starts.
	 *	\param out_start The noramlized parametric value on the ellipse at which the elliptical arc starts.
	 *	\return <span class='code'>true</span> if a normalized parametric start value was set, <span class='code'>false</span> otherwise. */
	bool					ShowStart(float & out_start) const;

	/*! Shows the normalized parametric value on the ellipse at which the elliptical arc ends.
	 *	\param out_end The noramlized parametric value on the ellipse at which the elliptical arc ends.
	 *	\return <span class='code'>true</span> if a normalized parametric end value was set, <span class='code'>false</span> otherwise. */
	bool					ShowEnd(float & out_end) const;
};



/*! The TextKit class is a user space object.  It is the kit analog to a TextKey. */
class HPS_API TextKit : public Kit
{
public:
	/*! The default constructor creates an empty TextKit object. */
	TextKit();

	/*! The copy constructor creates a new TextKit object that contains the same settings as the source TextKit.
	 * 	\param in_kit The source TextKit to copy. */
	TextKit(TextKit const & in_kit);

	/*! The move constructor creates a TextKit by transferring the underlying impl of the rvalue reference to this TextKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextKit to take the impl from. */
	TextKit(TextKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a TextKit to take the impl from.
	 *	\return A reference to this TextKit. */
	TextKit & operator=(TextKit && in_that);

	virtual ~TextKit();

	static const HPS::Type staticType = HPS::Type::TextKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source TextKit into this TextKit and resets the source kit.
	 * 	\param in_kit The source TextKit to consume. */
	void				Consume(TextKit & in_kit);

	/*! Copies the source TextKit into this TextKit.
	 * 	\param in_kit The source TextKit to copy. */
	void				Set(TextKit const & in_kit);

	/*! Copies this TextKit into the given TextKit.
	 * 	\param out_kit The TextKit to populate with the contents of this TextKit. */
	void				Show(TextKit & out_kit) const;

	/*! Copies the source TextKit into this TextKit.
	 * 	\param in_kit The source TextKit to copy.
	 * 	\return A reference to this TextKit. */
	TextKit &			operator=(TextKit const & in_kit);

	/*! Indicates whether this TextKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this TextKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source TextKit is equivalent to this TextKit.
	 *	\param in_kit The source TextKit to compare to this TextKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(TextKit const & in_kit) const;

	/*!	Check if the source TextKit is equivalent to this TextKit.
	 *	\param in_kit The source TextKit to compare to this TextKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(TextKit const & in_kit) const;

	/*!	Check if the source TextKit is not equivalent to this TextKit.
	 *	\param in_kit The source TextKit to compare to this TextKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(TextKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the TextKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	TextKit &			SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	TextKit &			UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Sets the position of the text in object space.
	 *	\in_position The object-space position for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetPosition(Point const & in_position);

	/*! Sets the contents of the string for the text.
	 *	\param in_string UTF8-encoded string for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetText(char const * in_string);

	/*! Sets the RGBA color of the text.
	 *	\param in_rgba_color The RGBA color of the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetColor(RGBAColor const & in_rgba_color);

	/*! Sets the material index color for the text.
	 *	\param in_index The material index color for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetColorByIndex(float in_index);

	/*! Sets the modelling matrix for the text.
	 *	\param in_matrix The modelling matrix for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetModellingMatrix(MatrixKit const & in_matrix);

	/*! Sets the alignment for the text.
	 *	\param in_alignment The alignment for the text.
	 *	\param in_reference_frame The reference frame for the text.  Defaults to Text::ReferenceFrame::WorldAligned.
	 *	\param in_justification The justification for the text.  Defaults to Text::Justification::Left.
	 *	\return A reference to this TextKit. */
	TextKit &			SetAlignment(Text::Alignment in_alignment, Text::ReferenceFrame in_reference_frame = Text::ReferenceFrame::WorldAligned, Text::Justification in_justification = Text::Justification::Left);

	/*! Sets whether the text should be bold.  For fonts which do not have a bold variant, this setting will be ignored.
	 *	\param in_state Whether the text should be bold.
	 *	\return A reference to this TextKit. */
	TextKit &			SetBold(bool in_state);

	/*! Sets whether the text should be italic.  For fonts which do not have an italic variant, this setting will be ignored.
	 *	\param in_state Whether the text should be italic.
	 *	\return A reference to this TextKit. */
	TextKit &			SetItalic(bool in_state);

	/*! Sets whether an overline should be drawn over the text.
	 *	\param in_state Whether an overline should be drawn over the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetOverline(bool in_state);

	/*! Sets whether a strikethrough should be drawn through the text.
	 *	\param in_state Whether a strikethrough should be drawn through the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetStrikethrough(bool in_state);

	/*! Sets whether an underline should be drawn under the text.
	 *	\param in_state Whether an underline should be drawn under the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetUnderline(bool in_state);

	/*! Sets the slant angle for the text.  This determines how far the characters in the string are sheared to the left (negative angle) or right (positive angle) relative
	 *	to the perpendicular.
	 *	\param in_angle The angle in degrees to slant the text.  This value must be in the range <span class='code'>[-75.0f,+75.0f]</span>.
	 *	\return A reference to this TextKit. */
	TextKit &			SetSlant(float in_angle);

	/*! Sets the line spacing multiplier for the text.  This is a multiple of the font size that will be used to determine spacing between lines in multi-line text string.
	 *	\param in_multiplier The line spacing multiplier for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetLineSpacing(float in_multiplier);

	/*! Sets the angle characters should be rotated within the text string.
	 *	\param in_state Whether and how to rotate the characters within the text string.
	 *	\param in_angle The angle in degrees to rotate each character within the text string.  This is only relevant if <span class='code'>in_state</span> is Text::Rotation::Rotate.
	 *		Defaults to <span class='code'>0.0f</span>.
	 *	\return A reference to this TextKit. */
	TextKit &			SetRotation(Text::Rotation in_state, float in_angle = 0.0f);

	/*! Sets the angle characters should be rotated within the text string.  This function implicitly sets a rotation state of Text::Rotation::Rotate.
	 *	\param in_angle The angle in degrees to rotate each character within the text string.
	 *	\return A reference to this TextKit. */
	TextKit &			SetRotation(float in_angle);

	/*! Sets the amount of additional space to add between characters in a text string.
	 *	\param in_state Whether to add addtional space between characters in a text string.
	 *	\param in_size The size of the addtional space to add between characters.  Defaults to <span class='code'>0.0f</span>.
	 *	\param in_units The units of the size of the additional space to add between characters.  Defaults to Text::SizeUnits::ObjectSpace.
	 *	\return A reference to this TextKit. */
	TextKit &			SetExtraSpace(bool in_state, float in_size = 0.0f, Text::SizeUnits in_units = Text::SizeUnits::ObjectSpace);

	/*! Sets the amount of additional space to add between characters in a text string.  This function implicitly enables the addition of extra space.
	 *	\param in_size The size of the addtional space to add between characters.
	 *	\param in_units The units of the size of the additional space to add between characters.
	 *	\return A reference to this TextKit. */
	TextKit &			SetExtraSpace(float in_size, Text::SizeUnits in_units);

	/*! Sets the greeking settings to use for the text.
	 *	\param in_state Whether greeking is enabled for this text.
	 *	\param in_size The size below which to draw a simple symbol in place of a character.  Defaults to <span class='code'>0.0f</span>.
	 *	\param in_units The units of the size below which to draw a simple glyph in place of a character.  Defaults to Text::GreekingUnits::ObjectSpace.
	 *	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.  Defaults to Text::GreekingMode::Lines.
	 *	\return A reference to this TextKit. */
	TextKit &			SetGreeking(bool in_state, float in_size = 0.0f, Text::GreekingUnits in_units = Text::GreekingUnits::ObjectSpace, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the greeking settings to use for the text.  This function implicitly enables text greeking.
	 *	\param in_size The size below which to draw a simple symbol in place of a character.
	 *	\param in_units The units of the size below which to draw a simple glyph in place of a character.
	 *	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.  Defaults to Text::Gree::Lines.
	 *	\return A reference to this TextKit. */
	TextKit &			SetGreeking(float in_size, Text::GreekingUnits in_units, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the size tolerance settings to use for the text.  These settings control how to render text strings which request a size not available for a bitmap font.
	 *	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	 *	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.  This setting has no effect for True Type
	 *	or Open Type fonts.
	 *	\param in_state Whether a size tolerance is enabled for this text.
	 *	\param in_size The size for the tolerance.  Defaults to <span class='code'>50.0f</span>.
	 *	\param in_units The units of the size for the tolerance.  Defaults to Text::SizeToleranceUnits::Percent.
	 *	\return A reference to this TextKit. */
	TextKit &			SetSizeTolerance(bool in_state, float in_size = 50.0f, Text::SizeToleranceUnits in_units = Text::SizeToleranceUnits::Percent);

	/*! Sets the size tolerance settings to use for the text.  These settings control how to render text strings which request a size not available for a bitmap font.
	 *	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	 *	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.  This setting has no effect for True Type
	 *	or Open Type fonts.  This function implicitly enables a size tolerance.
	 *	\param in_size The size for the tolerance.
	 *	\param in_units The units of the size for the tolerance.
	 *	\return A reference to this TextKit. */
	TextKit &			SetSizeTolerance(float in_size, Text::SizeToleranceUnits in_units);

	/*! Sets the font size to use for the text.
	 *	\param in_size The size for the text.
	 *	\param in_units The units of the size for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetSize(float in_size, Text::SizeUnits in_units);

	/*! Sets the font to use for the text.  This must either be a builtin font or a font Visualize can locate in the directories specified by World::SetFontDirectories.
	 *	If the requested font cannot be found, the stroked font will be used.
	 *	\param in_name UTF8-encoded font name to use for the text.
	 *	\return A reference to this TextKit.
	 *	\sa World::SetFontDirectories */
	TextKit &			SetFont(char const * in_name);

	/*! Sets the transform behavior for the text.
	 *	\param in_transform The transform behavior for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetTransform(Text::Transform in_trans);

	/*! Sets the renderer for the text.
	 *	\param in_renderer The renderer for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetRenderer(Text::Renderer in_rend);

	/*! Sets the font type preference for the text.  This function implicitly sets the same font type for all text sizes.
	 *	\param in_preference The font type preference for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetPreference(Text::Preference in_pref);

	/*! Sets the preference for the text.  This setting controls which font type is used for the text for "large" and "small" sizes and the cutoff at which this distinction is made.
	 *	\param in_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param in_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param in_smaller The font type preference for strings below the cutoff size.
	 *	\param in_larger The font type preference for strings above the cutoff size.
	 *	\return A reference to this TextKit. */
	TextKit &			SetPreference(float in_cutoff, Text::SizeUnits in_units, Text::Preference in_smaller, Text::Preference in_larger);

	/*! Sets the path for the text.  This setting controls the vector along which a text string will be displayed.
	 *	\param in_path The path for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetPath(Vector const & in_path);

	/*! Sets the spacing multiplier for the text.  This setting controls the spacing between adjacent characters within a string.  A value of <span class='code'>0.0f</span>
	 *	would result in all characters being drawn on top of each other, a value of <span class='code'>1.0f</span> would be the standard spacing between characters,
	 *	a value of <span class='code'>2.0f</span> would insert twice as much space as would normally be between two characters, and so on.
	 *	\param in_multiplier The spacing multiplier for the text.
	 *	\return A reference to this TextKit. */
	TextKit &			SetSpacing(float in_multiplier);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextKit &		SetBackground(bool in_state, char const * in_name);

	/*! Sets the background to be used with text.
	*	The state is implicitly on.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextKit &		SetBackground(char const * in_name);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\return A reference to this object. */
	TextKit &		SetBackground(bool in_state);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	\param in_size The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextKit &		SetBackgroundMargins(float in_size, Text::MarginUnits in_units = Text::MarginUnits::Percent);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextKit &		SetBackgroundMargins(FloatArray const & in_sizes, TextMarginUnitsArray const & in_units);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_count The number of elements in each array.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextKit &		SetBackgroundMargins(size_t in_count, float const in_sizes [], HPS::Text::MarginUnits const in_units []);

	/*! Allows specifying a named style to be used in the drawing of text backgrounds.
	*	If no style is specified, backgrounds inherit the face and edge attributes from the containing segment.
	*	\param in_name The name of a style, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	TextKit &		SetBackgroundStyle(char const * in_name);

	/*! Inserts a leader line for this text, with one end specified by in_position and the other end calculated automatically.
	* \param in_position the target position of the leader line.
	* \param in_space the coordinate space in which in_position is specified.
	* \return A reference to this object. */
	TextKit &		SetLeaderLine(Point const & in_position, Text::LeaderLineSpace in_space = Text::LeaderLineSpace::Object);

	/*! Inserts leader lines for this text.
	* \param in_positions the target positions of the leader lines.
	* \param in_space the coordinate space in which in_positions is specified.
	* \return A reference to this object. */
	TextKit &		SetLeaderLines(PointArray const & in_positions, Text::LeaderLineSpace in_space = Text::LeaderLineSpace::Object);

	/*! Inserts leader lines for this text.
	* \param in_count the size of in_positions.
	* \param in_positions the target positions of the leader lines.
	* \param in_space the coordinate space in which in_positions is specified.
	* \return A reference to this object. */
	TextKit &		SetLeaderLines(size_t in_count, Point const in_positions [], Text::LeaderLineSpace in_space = Text::LeaderLineSpace::Object);

	/*! Removes the text position.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetPosition();

	/*! Removes the text string.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetText();

	/*! Removes the color (RGBA or material index) from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetColor();

	/*! Removes the modelling matrix from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetModellingMatrix();

	/*! Removes the alignment setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetAlignment();

	/*! Removes the bold setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetBold();

	/*! Removes the italic setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetItalic();

	/*! Removes the overline setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetOverline();

	/*! Removes the strikethrough setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetStrikethrough();

	/*! Removes the underline setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetUnderline();

	/*! Removes the slant setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetSlant();

	/*! Removes the line spacing setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetLineSpacing();

	/*! Removes the rotation setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetRotation();

	/*! Removes the extra space setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetExtraSpace();

	/*! Removes the greeking settings from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetGreeking();

	/*! Removes the size tolerance setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetSizeTolerance();

	/*! Removes the size setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetSize();

	/*! Removes the font setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetFont();

	/*! Removes the transform setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetTransform();

	/*! Removes the renderer setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetRenderer();

	/*! Removes the font type preference from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetPreference();

	/*! Removes the path from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetPath();

	/*! Removes the spacing setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetSpacing();

	/*! Removes the background setting.
	*	\return A reference to this object. */
	TextKit &			UnsetBackground();

	/*! Removes the background margin setting.
	*	\return A reference to this object. */
	TextKit &			UnsetBackgroundMargins();

	/*! Removes the background style setting.
	*	\return A reference to this object. */
	TextKit &			UnsetBackgroundStyle();

	/*! Removes the leader line setting.
	*	\return A reference to this object. */
	TextKit &			UnsetLeaderLines();

	/*! Removes all settings from this TextKit.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetEverything();


	/*! Shows the position for the text.
	 *	\param out_position The object-space position for the text.
	 *	\return <span class='code'>true</span> if a position was set, <span class='code'>false</span> otherwise. */
	bool				ShowPosition(Point & out_position) const;

	/*! Shows the string for the text.
	 *	\param out_string UTF8-encoded string for the text.
	 *	\return <span class='code'>true</span> if a text string was set, <span class='code'>false</span> otherwise. */
	bool				ShowText(UTF8 & out_string) const;

	/*! Shows the color for the text.
	 *	\param out_type The type of color for the text.
	 *	\param out_rgba_color The RGBA color for the text.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for the text.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_index) const;

	/*! Shows the modelling matrix for the text.
	 *	\param out_matrix The modelling matrix for the text.
	 *	\return <span class='code'>true</span> if a modelling matrix was set, <span class='code'>false</span> otherwise. */
	bool				ShowModellingMatrix(MatrixKit & out_matrix) const;

	/*! Shows the aligment for the text.
	 *	\param out_alignment The alignment for the text.
	 *	\param out_reference_frame The reference frame for the text.
	 *	\param out_justification The justification for the text.
	 *	\return <span class='code'>true</span> if an alignment was set, <span class='code'>false</span> otherwise. */
	bool				ShowAlignment(Text::Alignment & out_alignment, Text::ReferenceFrame & out_reference_frame, Text::Justification & out_justification) const;

	/*! Shows whether the text should be bold.
	 *	\param out_state Whether the text should be bold.
	 *	\return <span class='code'>true</span> if a bold setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowBold(bool & out_state) const;

	/*! Shows whether the text should be italic.
	 *	\param out_state Whether the text should be italic.
	 *	\return <span class='code'>true</span> if an italic setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowItalic(bool & out_state) const;

	/*! Shows whether an overline should be drawn over the text.
	 *	\param out_state Whether an overline should be drawn over the text.
	 *	\return <span class='code'>true</span> if an overline setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowOverline(bool & out_state) const;

	/*! Shows whether a strikethrough should be drawn through the text.
	 *	\param out_state Whether a strikethrough should be drawn through the text.
	 *	\return <span class='code'>true</span> if a strikethrough setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowStrikethrough(bool & out_state) const;

	/*! Shows whether an underline should be drawn under the text.
	 *	\param out_state Whether an underline should be drawn under the text.
	 *	\return <span class='code'>true</span> if an underline setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowUnderline(bool & out_state) const;

	/*! Shows the slant angle for the text.
	 *	\param out_angle The angle in degrees to slant the text.
	 *	\return <span class='code'>true</span> if a slang angle was set, <span class='code'>false</span> otherwise. */
	bool				ShowSlant(float & out_angle) const;

	/*! Shows the line spacing multiplier for the text.
	 *	\param out_multiplier The line spacing multiplier for the text.
	 *	\return <span class='code'>true</span> if a line space multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowLineSpacing(float & out_multiplier) const;

	/*! Shows the angle characters should be rotated within the text string.
	 *	\param out_rot Whether to rotate the characters within the text string, and if so, what the angle should be measured with repect to.
	 *	\param out_angle The angle in degrees to rotate each character within the text string.
	 *	\return <span class='code'>true</span> if a rotation setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowRotation(Text::Rotation & out_rot, float & out_angle) const;

	/*! Shows the amount of additional space to add between characters in a text string.
	 *	\param out_state Whether to add addtional space between characters in a text string.
	 *	\param out_size The size of the addtional space to add between characters.
	 *	\param out_units The units of the size of the additional space to add between characters.
	 *	\return <span class='code'>true</span> if an extra space setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowExtraSpace(bool & out_state, float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the greeking settings to use for the text.
	 *	\param out_state Whether greeking is enabled for this text.
	 *	\param out_size The size below which to draw a simple symbol in place of a character.
	 *	\param out_units The units of the size below which to draw a simple glyph in place of a character.
	 *	\param out_mode The type of symbol to draw for characters which are smaller than the greeking size.
	 *	\return <span class='code'>true</span> if greeking settings were set, <span class='code'>false</span> otherwise. */
	bool				ShowGreeking(bool & out_state, float & out_size, Text::GreekingUnits & out_units, Text::GreekingMode & out_mode) const;

	/*! Shows the size tolerance settings to use for the text.
	 *	\param out_state Whether a size tolerance is enabled for this text.
	 *	\param out_size The size for the tolerance.
	 *	\param out_units The units of the size for the tolerance.
	 *	\return <span class='code'>true</span> if a size tolerance was set, <span class='code'>false</span> otherwise. */
	bool				ShowSizeTolerance(bool & out_state, float & out_size, Text::SizeToleranceUnits & out_units) const;

	/*! Shows the font size to use for the text.
	 *	\param out_size The size for the text.
	 *	\param out_units The units of the size for the text.
	 *	\return <span class='code'>true</span> if a size was set, <span class='code'>false</span> otherwise. */
	bool				ShowSize(float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the font to use for the text.
	 *	\param out_name UTF8-encoded font name to use for the text.
	 *	\return <span class='code'>true</span> if a font was set, <span class='code'>false</span> otherwise. */
	bool				ShowFont(UTF8 & out_name) const;

	/*! Shows the transform state for the text.
	 *	\param out_transform The transform state for the text.
	 *	\return <span class='code'>true</span> if a transform state was set, <span class='code'>false</span> otherwise. */
	bool				ShowTransform(Text::Transform & out_trans) const;

	/*! Shows the renderer for the text.
	 *	\param in_renderer The renderer for the text.
	 *	\return <span class='code'>true</span> if a renderer was set, <span class='code'>false</span> otherwise. */
	bool				ShowRenderer(Text::Renderer & out_renderer) const;

	/*! Shows the preference for the text.
	 *	\param out_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param out_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param out_smaller The font type preference for strings below the cutoff size.
	 *	\param out_larger The font type preference for strings above the cutoff size.
	 *	\return <span class='code'>true</span> if a preference was set, <span class='code'>false</span> otherwise. */
	bool				ShowPreference(float & out_cutoff, Text::SizeUnits & out_units, Text::Preference & out_smaller, Text::Preference & out_larger) const;

	/*! Shows the path for the text.
	 *	\param out_path The path for the text.
	 *	\return <span class='code'>true</span> if a path was set, <span class='code'>false</span> otherwise. */
	bool				ShowPath(Vector & out_path) const;

	/*! Shows the spacing multiplier for the text.
	 *	\param out_multiplier The spacing multiplier for the text.
	 *	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowSpacing(float & out_multiplier) const;

	/*! Shows the background to be used with text.
	*	\param out_state Whether a background is drawn for text.
	*	\param out_name The name of a shape definition.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowBackground(bool & out_state, UTF8 & out_name) const;

	/*! Shows the amount of additional padding around text strings when backgrounds are used.
	*	\param out_size The size of the margins.
	*	\param out_units The units of the sizes.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowBackgroundMargins(FloatArray & out_size, TextMarginUnitsArray & out_units) const;

	/*! Shows the named style to be used in the drawing of text backgrounds.
	*	\param out_name The name of a style, defined in a portfolio that is accessible.
	*	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowBackgroundStyle(UTF8 & out_name) const;

	/*! Shows the leader lines to be used with text.
	*	\param out_positions the target positions of the leader lines.
	*   \param out_space the coordinate space in which the points in out_positions are specified
	*	\return <span class='code'>true</span> if leader lines were set, <span class='code'>false</span> otherwise. */
	bool				ShowLeaderLines(PointArray & out_positions, Text::LeaderLineSpace & out_space) const;

	/*! Adds characters to the text at the specified offset.
	 *	\param in_row The row offset into a multiline text string.  This value must be less than the number of lines in the text string.
	 *	\param in_column The column offset in Unicode code points into the specified row in a multiline text string.  This value must be less than the number of Unicode code points
	 *		within the specified row.
	 *	\param in_count The number of Unicode code points within the given text string to insert into the text.
	 *	\param in_text UTF8-encoded text to insert into the text.  This must contain at least <span class='code'>in_count</span> Unicode code points.
	 *	\return A reference to this TextKit. */
	TextKit &			EditTextByInsertion(size_t in_row, size_t in_column, size_t in_count, char const * in_text);

	/*! Removes characters from the text at the specified offset.
	 *	\param in_row The row offset into a multiline text string.  This value must be less than the number of lines in the text string.
	 *	\param in_column The column offset in Unicode code points into the specified row in a multiline text string.  This value must be less than the number of Unicode code points
	 *		within the specified row.
	 *	\param in_count The number of Unicode code points within the given text string to remove.
	 *	\return A reference to this TextKit. */
	TextKit &			EditTextByDeletion(size_t in_row, size_t in_column, size_t in_count);

	/*! Replaces characters from the text at the specified offset.
	 *	\param in_row The row offset into a multiline text string.  This value must be less than the number of lines in the text string.
	 *	\param in_column The column offset in Unicode code points into the specified row in a multiline text string.  This value must be less than the number of Unicode code points
	 *		within the specified row.
	 *	\param in_count The number of Unicode code points within the given text string to remove.
	 * 	\param in_text UTF8-encoded text to perform replacement with. This must contain at least <span class='code'>in_count</span> Unicode code points.
	 *	\return A reference to this TextKit. */
	TextKit &			EditTextByReplacement(size_t in_row, size_t in_column, size_t in_count, char const * in_text);

	/*! Shows the region for the text.
	 *	\param out_region The points defining the region for the text.
	 *	\param out_region_alignment How the text will be positioned relative to the region line.
	 *	\param out_region_fitting How the text will be organized within the region.
	 *	\param out_region_adjust_direction Whether to draw text such that it is readable regardless of camera location.
	 *	\param out_region_relative_coordinates Whether the points defining the region are relative to the insertion point for the text.
	 *	\param out_region_window_space Whether the points defining the region are in window space coordinates.
	 *	\return <span class='code'>true</span> if a region was set, <span class='code'>false</span> otherwise. */
	bool				ShowRegion(PointArray & out_region, Text::RegionAlignment & out_region_alignment, Text::RegionFitting & out_region_fitting, bool & out_region_adjust_direction, bool & out_region_relative_coordinates, bool & out_region_window_space) const;

	/*! Sets the region for the text.  This setting forces the text to be rendererd along the vector defined by two object space points.  A region additionally allows control over
	 *	if text should be evenly spaced between those points, or allowed to grow or shrink to avoid stretching or overlapping characters.  No region is set on the text by default.
	 *	\param in_region The points defining the region for the text.  This array must be of size <span class='code'>2</span> or <span class='code'>3</span>.  A two point region
	 *		defines an implicit up vector which is rotated 90 degrees counter-clockwise from the region line.  A three point region uses the first two points as the region line
	 *		and the third point defines the plane in which a vector perpendicular to the region line will be computed for use as the up vector.
	 *	\param in_region_alignment How the text will be positioned relative to the region line.
	 *	\param in_region_fitting How the text is organized within the region.
	 *	\param in_region_adjust_direction Whether to draw text such that it is readable regardless of camera location.
	 *	\param in_region_relative_coordinates Whether the points defining the region are relative to the insertion point for the text.
	 *	\param in_region_window_space Whether the points defining the region are in window space coordinates.
	 *	\return A reference to this TextKit.
	 *	\sa SetPath */
	TextKit &			SetRegion(PointArray const & in_region, Text::RegionAlignment in_region_alignment, Text::RegionFitting in_region_fitting, bool in_region_adjust_direction, bool in_region_relative_coordinates, bool in_region_window_space);

	/*! Sets the region for the text.  This setting forces the text to be rendererd along the vector defined by two object space points.  A region additionally allows control over
	 *	if text should be evenly spaced between those points, or allowed to grow or shrink to avoid stretching or overlapping characters.  No region is set on the text by default.
	 *	\param in_region_count Size of the following array.  This value must be <span class='code'>2</span> or <span class='code'>3</span>.  A two point region
	 *		defines an implicit up vector which is rotated 90 degrees counter-clockwise from the region line.  A three point region uses the first two points as the region line
	 *		and the third point defines the plane in which a vector perpendicular to the region line will be computed for use as the up vector.
	 *	\param in_region The points defining the region for the text.
	 *	\param in_region_alignment How the text will be positioned relative to the region line.
	 *	\param in_region_fitting How the text is organized within the region.
	 *	\param in_region_adjust_direction Whether to draw text such that it is readable regardless of camera location.
	 *	\param in_region_relative_coordinates Whether the points defining the region are relative to the insertion point for the text.
	 *	\param in_region_window_space Whether the points defining the region are in window space coordinates.
	 *	\return A reference to this TextKit.
	 *	\sa SetPath */
	TextKit &			SetRegion(size_t in_region_count, Point const in_region [], Text::RegionAlignment in_region_alignment, Text::RegionFitting in_region_fitting, bool in_region_adjust_direction, bool in_region_relative_coordinates, bool in_region_window_space);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	TextKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Removes the region setting from the text.
	 *	\return A reference to this TextKit. */
	TextKit &			UnsetRegion();

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	TextKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	TextKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	TextKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	TextKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	TextKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	TextKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The TextKey class is a smart pointer to a database object.  It is a handle to text inserted via SegmentKey::InsertText. */
class HPS_API TextKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized TextKey object.  The Type() function will return Type::None. */
	TextKey();

	/*! This constructor creates an TextKey object that shares the underlying smart-pointer of the source Key.  The copy will only be successful if the source key is really an
	 *	upcast of a text key.  Otherwise the copy will fail and the resulting TextKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit TextKey(Key const & in_that);

	/*! The copy constructor creates a TextKey object that shares the underlying smart-pointer of the source TextKey.
	 *	\param in_that The source TextKey to copy. */
	TextKey(TextKey const & in_that);

	/*! Associate this TextKey with the same underlying impl as the source TextKey.
	 *	\param in_that The source TextKey for the assignment.
	 *	\return A reference to this TextKey. */
	TextKey & operator=(TextKey const & other);

	/*! The move constructor creates a TextKey by transferring the underlying impl of the rvalue reference to this TextKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextKey to take the impl from. */
	TextKey(TextKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a TextKey to take the impl from.
	 * 	\return A reference to this TextKey. */
	TextKey & operator=(TextKey && in_that);

	~TextKey();

	static const HPS::Type staticType = HPS::Type::TextKey;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Completely replaces all settings on this TextKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this TextKey. */
	void				Consume(TextKit & in_kit);

	/*! Replace those settings on this TextKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this TextKey. */
	void				Set(TextKit const & in_kit);

	/*! Copy the contents of this TextKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this TextKey. */
	void				Show(TextKit & out_kit) const;

	/*! Sets the text attributes designated by in_kit on this TextKey.
	 *	\param in_kit The attribute kit from which to get the attributes for this TextKey. */
	TextKey &			SetTextAttribute(TextAttributeKit const & in_kit);

	/*! Sets the text attributes designated by in_kit on this TextKey.
	 *	\param out_kit The attribute kit to populate with the attributes for this TextKey.
	 *	\return <span class='code'>true</span> if the attributes were set, <span class='code'>false</span> otherwise. */
	bool				ShowTextAttribute(TextAttributeKit & out_kit) const;

	/*! Repositions the text in object space.
	 *	\in_position The object-space position for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetPosition(Point const & in_position);

	/*! Replaces the contents of the string for the text.
	 *	\param in_string UTF8-encoded string for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetText(char const * in_string);

	/*! Sets the RGBA color of the text.  No color is set on the text by default.
	 *	\param in_rgba_color The RGBA color of the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetColor(RGBAColor const & in_rgba_color);

	/*! Sets the material index color for the text.  No color is set on the text by default.
	 *	\param in_index The material index color for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetColorByIndex(float in_index);

	/*! Sets the modelling matrix for the text.  No modelling matrix is set on the text by default.
	 *	\param in_matrix The modelling matrix for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetModellingMatrix(MatrixKit const & in_matrix);

	/*! Sets the alignment for the text.  No aligment is set on the text by default.
	 *	\param in_alignment The alignment for the text.
	 *	\param in_reference_frame The reference frame for the text.  Defaults to Text::ReferenceFrame::WorldAligned.
	 *	\param in_justification The justification for the text.  Defaults to Text::Justification::Left.
	 *	\return A reference to this TextKey. */
	TextKey &			SetAlignment(Text::Alignment in_alignment, Text::ReferenceFrame in_reference_frame = Text::ReferenceFrame::WorldAligned, Text::Justification in_justification = Text::Justification::Left);

	/*! Sets whether the text should be bold.  For fonts which do not have a bold variant, this setting will be ignored.  No bold setting is set on the text by default.
	 *	\param in_state Whether the text should be bold.
	 *	\return A reference to this TextKey. */
	TextKey &			SetBold(bool in_state);

	/*! Sets whether the text should be italic.  For fonts which do not have an italic variant, this setting will be ignored.  No italic setting is set on the text by default.
	 *	\param in_state Whether the text should be italic.
	 *	\return A reference to this TextKey. */
	TextKey &			SetItalic(bool in_state);

	/*! Sets whether an overline should be drawn over the text.  No overline setting is set on the text by default.
	 *	\param in_state Whether an overline should be drawn over the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetOverline(bool in_state);

	/*! Sets whether a strikethrough should be drawn through the text.  No strikethrough setting is set on the text by default.
	 *	\param in_state Whether a strikethrough should be drawn through the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetStrikethrough(bool in_state);

	/*! Sets whether an underline should be drawn under the text.  No underline setting is set on the text by default.
	 *	\param in_state Whether an underline should be drawn under the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetUnderline(bool in_state);

	/*! Sets the slant angle for the text.  This determines how far the characters in the string are sheared to the left (negative angle) or right (positive angle) relative
	 *	to the perpendicular.  No slant angle is set on the text by default.
	 *	\param in_angle The angle in degrees to slant the text.  This value must be in the range <span class='code'>[-75.0f,+75.0f]</span>.
	 *	\return A reference to this TextKey. */
	TextKey &			SetSlant(float in_angle);

	/*! Sets the line spacing multiplier for the text.  This is a multiple of the font size that will be used to determine spacing between lines in multi-line text string.
	 *	No line spacing is set on the text by default.
	 *	\param in_multiplier The line spacing multiplier for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetLineSpacing(float in_multiplier);

	/*! Sets the angle characters should be rotated within the text string.  No rotation is set on the text by default.
	 *	\param in_state Whether and how to rotate the characters within the text string.
	 *	\param in_angle The angle in degrees to rotate each character within the text string.  This is only relevant if <span class='code'>in_state</span> is Text::Rotation::Rotate.
	 *		Defaults to <span class='code'>0.0f</span>.
	 *	\return A reference to this TextKey. */
	TextKey &			SetRotation(Text::Rotation in_state, float in_angle = 0.0f);

	/*! Sets the angle characters should be rotated within the text string.  This function implicitly sets a rotation state of Text::Rotation::Rotate.  No rotation is set on the text by default.
	 *	\param in_angle The angle in degrees to rotate each character within the text string.
	 *	\return A reference to this TextKey. */
	TextKey &			SetRotation(float in_angle);

	/*! Sets the amount of additional space to add between characters in a text string.  No extra space is set on the text by default.
	 *	\param in_state Whether to add additional space between characters in a text string.
	 *	\param in_size The size of the additional space to add between characters.  Defaults to <span class='code'>0.0f</span>.
	 *	\param in_units The units of the size of the additional space to add between characters.  Defaults to Text::SizeUnits::ObjectSpace.
	 *	\return A reference to this TextKey. */
	TextKey &			SetExtraSpace(bool in_state, float in_size = 0.0f, Text::SizeUnits in_units = Text::SizeUnits::ObjectSpace);

	/*! Sets the amount of additional space to add between characters in a text string.  This function implicitly enables the addition of extra space.  No extra space is set on the text by default.
	 *	\param in_size The size of the additional space to add between characters.
	 *	\param in_units The units of the size of the additional space to add between characters.
	 *	\return A reference to this TextKey. */
	TextKey &			SetExtraSpace(float in_size, Text::SizeUnits in_units);

	/*! Sets the greeking settings to use for the text.  No greeking settings are set on the text by default.
	 *	\param in_state Whether greeking is enabled for this text.
	 *	\param in_size The size below which to draw a simple symbol in place of a character.  Defaults to <span class='code'>0.0f</span>.
	 *	\param in_units The units of the size below which to draw a simple glyph in place of a character.  Defaults to Text::GreekingUnits::ObjectSpace.
	 *	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.  Defaults to Text::GreekingMode::Lines.
	 *	\return A reference to this TextKey. */
	TextKey &			SetGreeking(bool in_state, float in_size = 0.0f, Text::GreekingUnits in_units = Text::GreekingUnits::ObjectSpace, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the greeking settings to use for the text.  This function implicitly enables text greeking.  No greeking settings are set on the text by default.
	 *	\param in_size The size below which to draw a simple symbol in place of a character.
	 *	\param in_units The units of the size below which to draw a simple glyph in place of a character.
	 *	\param in_mode The type of symbol to draw for characters which are smaller than the greeking size.  Defaults to Text::Gree::Lines.
	 *	\return A reference to this TextKey. */
	TextKey &			SetGreeking(float in_size, Text::GreekingUnits in_units, Text::GreekingMode in_mode = Text::GreekingMode::Lines);

	/*! Sets the size tolerance settings to use for the text.  These settings control how to render text strings which request a size not available for a bitmap font.
	 *	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	 *	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.  This setting has no effect for True Type
	 *	or Open Type fonts.  No size tolerance is set on the text by default.
	 *	\param in_state Whether a size tolerance is enabled for this text.
	 *	\param in_size The size for the tolerance.  Defaults to <span class='code'>50.0f</span>.
	 *	\param in_units The units of the size for the tolerance.  Defaults to Text::SizeToleranceUnits::Percent.
	 *	\return A reference to this TextKey. */
	TextKey &			SetSizeTolerance(bool in_state, float in_size = 50.0f, Text::SizeToleranceUnits in_units = Text::SizeToleranceUnits::Percent);

	/*! Sets the size tolerance settings to use for the text.  These settings control how to render text strings which request a size not available for a bitmap font.
	 *	If a size tolerance is specified and enabled, Visualize will use the nearest smaller size for the bitmap font within the tolerance in place of the requested size.
	 *	If a size tolerance is not enabled, Visualize will attempt to scale up the nearest bitmap font size to the requested size.  This setting has no effect for True Type
	 *	or Open Type fonts.  This function implicitly enables a size tolerance.  No size tolerance is set on the text by default.
	 *	\param in_size The size for the tolerance.
	 *	\param in_units The units of the size for the tolerance.
	 *	\return A reference to this TextKey. */
	TextKey &			SetSizeTolerance(float in_size, Text::SizeToleranceUnits in_units);

	/*! Sets the font size to use for the text.  No size is set on the text by default.
	 *	\param in_size The size for the text.
	 *	\param in_units The units of the size for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetSize(float in_size, Text::SizeUnits in_units);

	/*! Sets the font to use for the text.  This must either be a builtin font or a font Visualize can locate in the directories specified by World::SetFontDirectories.
	 *	If the requested font cannot be found, the stroked font will be used.  No font is set on the text by default.
	 *	\param in_name UTF8-encoded font name to use for the text.
	 *	\return A reference to this TextKey.
	 *	\sa World::SetFontDirectories */
	TextKey &			SetFont(char const * in_name);

	/*! Sets the transform state for the text.  No transform state is set on the text by default.
	 *	\param in_transform The transform state for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetTransform(Text::Transform in_transform);

	/*! Sets the renderer for the text.  No renderer is set on the text by default.
	 *	\param in_renderer The renderer for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetRenderer(Text::Renderer in_renderer);

	/*! Sets the font type preference for the text.  This function implicitly sets the same font type for all text sizes.  No preference is set on the text by default.
	 *	\param in_preference The font type preference for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetPreference(Text::Preference in_preference);

	/*! Sets the preference for the text.  This setting controls which font type is used for the text for "large" and "small" sizes and the cutoff at which this distinction is made.
	 *	No preference is set on the text by default.
	 *	\param in_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param in_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param in_smaller The font type preference for strings below the cutoff size.
	 *	\param in_larger The font type preference for strings above the cutoff size.
	 *	\return A reference to this TextKey. */
	TextKey &			SetPreference(float in_cutoff, Text::SizeUnits in_units, Text::Preference in_smaller, Text::Preference in_larger);

	/*! Sets the path for the text.  This setting controls the vector along which a text string will be displayed.  No path is set on the text by default.
	 *	\param in_path The path for the text.
	 *	\return A reference to this TextKey.
	 *	\sa SetRegion */
	TextKey &			SetPath(Vector const & in_path);

	/*! Sets the spacing multiplier for the text.  This setting controls the spacing between adjacent characters within a string.  A value of <span class='code'>0.0f</span>
	 *	would result in all characters being drawn on top of each other, a value of <span class='code'>1.0f</span> would be the standard spacing between characters,
	 *	a value of <span class='code'>2.0f</span> would insert twice as much space as would normally be between two characters, and so on.
	 *	\param in_multiplier The spacing multiplier for the text.
	 *	\return A reference to this TextKey. */
	TextKey &			SetSpacing(float in_multiplier);

	/*! Sets the region for the text.  This setting forces the text to be rendererd along the vector defined by two object space points.  A region additionally allows control over
	 *	if text should be evenly spaced between those points, or allowed to grow or shrink to avoid stretching or overlapping characters.  No region is set on the text by default.
	 *	\param in_region The points defining the region for the text.  This array must be of size <span class='code'>2</span> or <span class='code'>3</span>.  A two point region
	 *		defines an implicit up vector which is rotated 90 degrees counter-clockwise from the region line.  A three point region uses the first two points as the region line
	 *		and the third point defines the plane in which a vector perpendicular to the region line will be computed for use as the up vector.
	 *	\param in_region_alignment How the text will be positioned relative to the region line.
	 *	\param in_region_fitting How the text is organized within the region.
	 *	\param in_region_adjust_direction Whether to draw text such that it is readable regardless of camera location.
	 *	\param in_region_relative_coordinates Whether the points defining the region are relative to the insertion point for the text.
	 *	\param in_region_window_space Whether the points defining the region are in window space coordinates.
	 *	\return A reference to this TextKey.
	 *	\sa SetPath */
	TextKey &			SetRegion(PointArray const & in_region, Text::RegionAlignment in_region_alignment, Text::RegionFitting in_region_fitting, bool in_region_adjust_direction, bool in_region_relative_coordinates, bool in_region_window_space);

	/*! Sets the region for the text.  This setting forces the text to be rendererd along the vector defined by two object space points.  A region additionally allows control over
	 *	if text should be evenly spaced between those points, or allowed to grow or shrink to avoid stretching or overlapping characters.  No region is set on the text by default.
	 *	\param in_region_count Size of the following array.  This value must be <span class='code'>2</span> or <span class='code'>3</span>.  A two point region
	 *		defines an implicit up vector which is rotated 90 degrees counter-clockwise from the region line.  A three point region uses the first two points as the region line
	 *		and the third point defines the plane in which a vector perpendicular to the region line will be computed for use as the up vector.
	 *	\param in_region The points defining the region for the text.
	 *	\param in_region_alignment How the text will be positioned relative to the region line.
	 *	\param in_region_fitting How the text is organized within the text region.
	 *	\param in_region_adjust_direction Whether to draw text such that it is readable regardless of camera location.
	 *	\param in_region_relative_coordinates Whether the points defining the region are relative to the insertion point for the text.
	 *	\param in_region_window_space Whether the points defining the region are in window space coordinates.
	 *	\return A reference to this TextKey.
	 *	\sa SetPath */
	TextKey &			SetRegion(size_t in_region_count, Point const in_region [], Text::RegionAlignment in_region_alignment, Text::RegionFitting in_region_fitting, bool in_region_adjust_direction, bool in_region_relative_coordinates, bool in_region_window_space);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextKey &			SetBackground(bool in_state, char const * in_name);

	/*! Sets the background to be used with text.
	*	The state is implicitly on.
	*	\param in_name The name of a shape definition.
	*	\return A reference to this object. */
	TextKey &			SetBackground(char const * in_name);

	/*! Sets the background to be used with text.
	*	\param in_state Whether a background is drawn for text.
	*	\return A reference to this object. */
	TextKey &			SetBackground(bool in_state);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	\param in_size The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextKey &			SetBackgroundMargins(float in_size, Text::MarginUnits in_units = Text::MarginUnits::Percent);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextKey &			SetBackgroundMargins(FloatArray const & in_sizes, TextMarginUnitsArray const & in_units);

	/*! Sets the amount of additional padding around text strings when backgrounds are used.
	*	Additional margin values can also be referenced within definitions of background shapes and leader lines.
	*	\param in_count The number of elements in each array.
	*	\param in_sizes The size of the margins.
	*	\param in_units The units of the size.
	*	\return A reference to this object. */
	TextKey &			SetBackgroundMargins(size_t in_count, float const in_sizes [], HPS::Text::MarginUnits const in_units []);

	/*! Allows specifying a named style to be used in the drawing of text backgrounds.
	*	If no style is specified, backgrounds inherit the face and edge attributes from the containing segment.
	*	\param in_name The name of a style, defined in a portfolio that is accessible.
	*	\return A reference to this object. */
	TextKey &			SetBackgroundStyle(char const * in_name);

	/*! Inserts a leader line for this text, with one end specified by in_position and the other end calculated automatically.
	* \param in_position the target position of the leader line.
	* \param in_space the coordinate space in which in_position is specified.
	* \return A reference to this object. */
	TextKey &		SetLeaderLine(Point const & in_position, Text::LeaderLineSpace in_space = Text::LeaderLineSpace::Object);

	/*! Inserts leader lines for this text.
	* \param in_positions the target positions of the leader lines.
	* \param in_space the coordinate space in which in_positions is specified.
	* \return A reference to this object. */
	TextKey &		SetLeaderLines(PointArray const & in_positions, Text::LeaderLineSpace in_space = Text::LeaderLineSpace::Object);

	/*! Inserts leader lines for this text.
	* \param in_count the size of in_positions.
	* \param in_positions the target positions of the leader lines.
	* \param in_space the coordinate space in which in_positions is specified.
	* \return A reference to this object. */
	TextKey &		SetLeaderLines(size_t in_count, Point const in_positions [], Text::LeaderLineSpace in_space = Text::LeaderLineSpace::Object);


	/*! Removes the color (RGBA or material index) from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetColor();

	/*! Removes the modelling matrix from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetModellingMatrix();

	/*! Removes the alignment setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetAlignment();

	/*! Removes the bold setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetBold();

	/*! Removes the italic setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetItalic();

	/*! Removes the overline setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetOverline();

	/*! Removes the strikethrough setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetStrikethrough();

	/*! Removes the underline setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetUnderline();

	/*! Removes the slant setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetSlant();

	/*! Removes the line spacing setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetLineSpacing();

	/*! Removes the rotation setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetRotation();

	/*! Removes the extra space setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetExtraSpace();

	/*! Removes the greeking settings from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetGreeking();

	/*! Removes the size tolerance setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetSizeTolerance();

	/*! Removes the size setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetSize();

	/*! Removes the font setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetFont();

	/*! Removes the transform setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetTransform();

	/*! Removes the renderer setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetRenderer();

	/*! Removes the font type preference from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetPreference();

	/*! Removes the path from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetPath();

	/*! Removes the spacing setting from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetSpacing();

	/*! Removes the region from the text.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetRegion();

	/*! Removes the background setting.
	*	\return A reference to this object. */
	TextKey &		UnsetBackground();

	/*! Removes the background margin setting.
	*	\return A reference to this object. */
	TextKey &		UnsetBackgroundMargins();

	/*! Removes the background style setting.
	*	\return A reference to this object. */
	TextKey &		UnsetBackgroundStyle();

	/*! Removes the leader line setting.
	*	\return A reference to this object. */
	TextKey &			UnsetLeaderLines();

	/*! Removes all settings from this TextKey.
	 *	\return A reference to this TextKey. */
	TextKey &			UnsetEverything();


	/*! Shows the position for the text.
	 *	\param out_position The object-space position for the text.
	 *	\return <span class='code'>true</span> if a position was set, <span class='code'>false</span> otherwise. */
	bool				ShowPosition(Point & out_position) const;

	/*! Shows the string for the text.
	 *	\param out_string UTF8-encoded string for the text.
	 *	\return <span class='code'>true</span> if a text string was set, <span class='code'>false</span> otherwise. */
	bool				ShowText(UTF8 & out_string) const;

	/*! Shows the color for the text.
	 *	\param out_type The type of color for the text.
	 *	\param out_rgba_color The RGBA color for the text.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for the text.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_rgba_color, float & out_index) const;

	/*! Shows the modelling matrix for the text.
	 *	\param out_matrix The modelling matrix for the text.
	 *	\return <span class='code'>true</span> if a modelling matrix was set, <span class='code'>false</span> otherwise. */
	bool				ShowModellingMatrix(MatrixKit & out_matrix) const;

	/*! Shows the alignment for the text.
	*	\param out_alignment The alignment for the text.
	*	\param out_reference_frame The reference frame for the text.
	*	\param out_justification The justification for the text.
	*	\return <span class='code'>true</span> if an alignment was set, <span class='code'>false</span> otherwise. */
	bool				ShowAlignment(Text::Alignment & out_alignment, Text::ReferenceFrame & out_reference_frame, Text::Justification & out_justification) const;

	/*! Shows whether the text should be bold.
	 *	\param out_state Whether the text should be bold.
	 *	\return <span class='code'>true</span> if a bold setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowBold(bool & out_state) const;

	/*! Shows whether the text should be italic.
	 *	\param out_state Whether the text should be italic.
	 *	\return <span class='code'>true</span> if an italic setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowItalic(bool & out_state) const;

	/*! Shows whether an overline should be drawn over the text.
	 *	\param out_state Whether an overline should be drawn over the text.
	 *	\return <span class='code'>true</span> if an overline setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowOverline(bool & out_state) const;

	/*! Shows whether a strikethrough should be drawn through the text.
	 *	\param out_state Whether a strikethrough should be drawn through the text.
	 *	\return <span class='code'>true</span> if a strikethrough setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowStrikethrough(bool & out_state) const;

	/*! Shows whether an underline should be drawn under the text.
	 *	\param out_state Whether an underline should be drawn under the text.
	 *	\return <span class='code'>true</span> if an underline setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowUnderline(bool & out_state) const;

	/*! Shows the slant angle for the text.
	 *	\param out_angle The angle in degrees to slant the text.
	 *	\return <span class='code'>true</span> if a slang angle was set, <span class='code'>false</span> otherwise. */
	bool				ShowSlant(float & out_angle) const;

	/*! Shows the line spacing multiplier for the text.
	 *	\param out_multiplier The line spacing multiplier for the text.
	 *	\return <span class='code'>true</span> if a line space multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowLineSpacing(float & out_multiplier) const;

	/*! Shows the angle characters should be rotated within the text string.
	 *	\param out_rot Whether to rotate the characters within the text string, and if so, what the angle should be measured with repect to.
	 *	\param out_angle The angle in degrees to rotate each character within the text string.
	 *	\return <span class='code'>true</span> if a rotation setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowRotation(Text::Rotation & out_rot, float & out_angle) const;

	/*! Shows the amount of additional space to add between characters in a text string.
	 *	\param out_state Whether to add additional space between characters in a text string.
	 *	\param out_size The size of the additional space to add between characters.
	 *	\param out_units The units of the size of the additional space to add between characters.
	 *	\return <span class='code'>true</span> if an extra space setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowExtraSpace(bool & out_state, float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the greeking settings to use for the text.
	 *	\param out_state Whether greeking is enabled for this text.
	 *	\param out_size The size below which to draw a simple symbol in place of a character.
	 *	\param out_units The units of the size below which to draw a simple glyph in place of a character.
	 *	\param out_mode The type of symbol to draw for characters which are smaller than the greeking size.
	 *	\return <span class='code'>true</span> if greeking settings were set, <span class='code'>false</span> otherwise. */
	bool				ShowGreeking(bool & out_state, float & out_size, Text::GreekingUnits & out_units, Text::GreekingMode & out_mode) const;

	/*! Shows the size tolerance settings to use for the text.
	 *	\param out_state Whether a size tolerance is enabled for this text.
	 *	\param out_size The size for the tolerance.
	 *	\param out_units The units of the size for the tolerance.
	 *	\return <span class='code'>true</span> if a size tolerance was set, <span class='code'>false</span> otherwise. */
	bool				ShowSizeTolerance(bool & out_state, float & out_size, Text::SizeToleranceUnits & out_units) const;

	/*! Shows the font size to use for the text.
	 *	\param out_size The size for the text.
	 *	\param out_units The units of the size for the text.
	 *	\return <span class='code'>true</span> if a size was set, <span class='code'>false</span> otherwise. */
	bool				ShowSize(float & out_size, Text::SizeUnits & out_units) const;

	/*! Shows the font to use for the text.
	 *	\param out_name UTF8-encoded font name to use for the text.
	 *	\return <span class='code'>true</span> if a font was set, <span class='code'>false</span> otherwise. */
	bool				ShowFont(UTF8 & out_name) const;

	/*! Shows the transform state for the text.
	 *	\param out_transform The transform state for the text.
	 *	\return <span class='code'>true</span> if a transform state was set, <span class='code'>false</span> otherwise. */
	bool				ShowTransform(Text::Transform & out_trans) const;

	/*! Shows the renderer for the text.
	 *	\param in_renderer The renderer for the text.
	 *	\return <span class='code'>true</span> if a renderer was set, <span class='code'>false</span> otherwise. */
	bool				ShowRenderer(Text::Renderer & out_renderer) const;

	/*! Shows the preference for the text.
	 *	\param out_cutoff The font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param out_units The units for the font size below which the smaller preference is used and above which the larger preference is used.
	 *	\param out_smaller The font type preference for strings below the cutoff size.
	 *	\param out_larger The font type preference for strings above the cutoff size.
	 *	\return <span class='code'>true</span> if a preference was set, <span class='code'>false</span> otherwise. */
	bool				ShowPreference(float & out_cutoff, Text::SizeUnits & out_units, Text::Preference & out_smaller, Text::Preference & out_larger) const;

	/*! Shows the path for the text.
	 *	\param out_path The path for the text.
	 *	\return <span class='code'>true</span> if a path was set, <span class='code'>false</span> otherwise. */
	bool				ShowPath(Vector & out_path) const;

	/*! Shows the spacing multiplier for the text.
	 *	\param out_multiplier The spacing multiplier for the text.
	 *	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowSpacing(float & out_multiplier) const;

	/*! Shows the region for the text.
	 *	\param out_region The points defining the region for the text.
	 *	\param out_region_alignment How the text will be positioned relative to the region line.
	 *	\param out_region_fitting How the text will be organized within the region.
	 *	\param out_region_adjust_direction Whether to draw text such that it is readable regardless of camera location.
	 *	\param out_region_relative_coordinates Whether the points defining the region are relative to the insertion point for the text.
	 *	\param out_region_window_space Whether the points defining the region are in window space coordinates.
	 *	\return <span class='code'>true</span> if a region was set, <span class='code'>false</span> otherwise. */
	bool				ShowRegion(PointArray & out_region, Text::RegionAlignment & out_region_alignment, Text::RegionFitting & out_region_fitting, bool & out_region_adjust_direction, bool & out_region_relative_coordinates, bool & out_region_window_space) const;

	/*! Shows the background to be used with text.
	 *	\param out_state Whether a background is drawn for text.
	 *	\param out_name The name of a shape definition.
	 *	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowBackground(bool & out_state, UTF8 & out_name) const;

	/*! Shows the amount of additional padding around text strings when backgrounds are used.
	 *	\param out_size The size of the margins.
	 *	\param out_units The units of the sizes.
	 *	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowBackgroundMargins(FloatArray & out_size, TextMarginUnitsArray & out_units) const;

	/*! Shows the named style to be used in the drawing of text backgrounds.
	 *	\param out_name The name of a style, defined in a portfolio that is accessible.
	 *	\return <span class='code'>true</span> if a spacing multiplier was set, <span class='code'>false</span> otherwise. */
	bool				ShowBackgroundStyle(UTF8 & out_name) const;

	/*! Shows the leader lines to be used with text.
	*	\param out_positions the target positions of the leader lines.
	*   \param out_space the coordinate space in which the points in out_positions are specified
	*	\return <span class='code'>true</span> if leader lines were set, <span class='code'>false</span> otherwise. */
	bool				ShowLeaderLines(PointArray & out_positions, Text::LeaderLineSpace & out_space) const;

	/*! Adds characters to the text at the specified offset.
	 *	\param in_row The row offset into a multiline text string.  This value must be less than the number of lines in the text string.
	 *	\param in_column The column offset in Unicode code points into the specified row in a multiline text string.  This value must be less than the number of Unicode code points
	 *		within the specified row.
	 *	\param in_count The number of Unicode code points within the given text string to insert into the text.
	 *	\param in_text UTF8-encoded text to insert into the text.  This must contain at least <span class='code'>in_count</span> Unicode code points.
	 *	\return A reference to this TextKey. */
	TextKey &			EditTextByInsertion(size_t in_row, size_t in_column, size_t in_count, char const * in_text);

	/*! Removes characters from the text at the specified offset.
	 *	\param in_row The row offset into a multiline text string.  This value must be less than the number of lines in the text string.
	 *	\param in_column The column offset in Unicode code points into the specified row in a multiline text string.  This value must be less than the number of Unicode code points
	 *		within the specified row.
	 *	\param in_count The number of Unicode code points within the given text string to remove.
	 *	\return A reference to this TextKey. */
	TextKey &			EditTextByDeletion(size_t in_row, size_t in_column, size_t in_count);

	/*! Replaces characters from the text at the specified offset.
	 *	\param in_row The row offset into a multiline text string.  This value must be less than the number of lines in the text string.
	 *	\param in_column The column offset in Unicode code points into the specified row in a multiline text string.  This value must be less than the number of Unicode code points
	 *		within the specified row.
	 *	\param in_count The number of Unicode code points within the given text string to remove.
	 *  \param in_text UTF8-encoded text to perform replacement with. This must contain at least <span class='code'>in_count</span> Unicode code points.
	 *	\return A reference to this TextKey. */
	TextKey &			EditTextByReplacement(size_t in_row, size_t in_column, size_t in_count, char const * in_text);
};


/*! The ShellOptimizationOptionsKit class is a user space object. It is used for setting options for a shell optimization operation. Calling HPS::ShellOptimizationOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#shell-optimization">this table</a>. */
class HPS_API ShellOptimizationOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty ShellOptimizationOptionsKit object. */
	ShellOptimizationOptionsKit();

	/*! The copy constructor creates a new ShellOptimizationOptionsKit object that contains the same settings as the source ShellOptimizationOptionsKit.
	 * 	\param in_kit The source ShellOptimizationOptionsKit to copy. */
	ShellOptimizationOptionsKit(ShellOptimizationOptionsKit const & in_kit);

	/*! The move constructor creates a ShellOptimizationOptionsKit by transferring the underlying impl of the rvalue reference to this ShellOptimizationOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShellOptimizationOptionsKit to take the impl from. */
	ShellOptimizationOptionsKit(ShellOptimizationOptionsKit && in_that);

	virtual ~ShellOptimizationOptionsKit();

	static const HPS::Type staticType = HPS::Type::ShellOptimizationOptionsKit;
	HPS::Type						ObjectType() const { return staticType; };

	/*! Copies the source ShellOptimizationOptionsKit into this ShellOptimizationOptionsKit and resets the source kit.
	 * 	\param in_kit The source ShellOptimizationOptionsKit to consume. */
	void							Consume(ShellOptimizationOptionsKit & in_kit);

	/*! Copies the source ShellOptimizationOptionsKit into this ShellOptimizationOptionsKit.
	 * 	\param in_kit The source ShellOptimizationOptionsKit to copy. */
	void							Set(ShellOptimizationOptionsKit const & in_kit);

	/*! Copies this ShellOptimizationOptionsKit into the given ShellOptimizationOptionsKit.
	 * 	\param out_kit The ShellOptimizationOptionsKit to populate with the contents of this ShellOptimizationOptionsKit. */
	void							Show(ShellOptimizationOptionsKit & out_kit) const;

	/*! Copies the source ShellOptimizationOptionsKit into this ShellOptimizationOptionsKit.
	 * 	\param in_kit The source ShellOptimizationOptionsKit to copy.
	 * 	\return A reference to this ShellOptimizationOptionsKit. */
	ShellOptimizationOptionsKit &	operator=(ShellOptimizationOptionsKit const & in_kit);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShellOptimizationOptionsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShellOptimizationOptionsKit to take the impl from.
	 * 	\return A reference to this ShellOptimizationOptionsKit. */
	ShellOptimizationOptionsKit &	operator=(ShellOptimizationOptionsKit && in_that);

	/*! Indicates whether this ShellOptimizationOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ShellOptimizationOptionsKit, <span class='code'>false</span> otherwise. */
	bool							Empty() const;

	/*!	Check if the source ShellOptimizationOptionsKit is equivalent to this ShellOptimizationOptionsKit.
	 *	\param in_kit The source ShellOptimizationOptionsKit to compare to this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							Equals(ShellOptimizationOptionsKit const & in_kit) const;

	/*!	Check if the source ShellOptimizationOptionsKit is equivalent to this ShellOptimizationOptionsKit.
	 *	\param in_kit The source ShellOptimizationOptionsKit to compare to this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							operator==(ShellOptimizationOptionsKit const & in_kit) const;

	/*!	Check if the source ShellOptimizationOptionsKit is not equivalent to this ShellOptimizationOptionsKit.
	 *	\param in_kit The source ShellOptimizationOptionsKit to compare to this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool							operator!=(ShellOptimizationOptionsKit const & in_kit) const;

	/*! Creates a ShellOptimizationOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 *	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 *	\return A ShellOptimizationOptionsKit with the default settings. */
	static ShellOptimizationOptionsKit GetDefault();


	/*! Sets the tolerance to use when deciding if two normals can be merged.
	 * \param in_normal_tolerance The tolerance to use during optimization, specified in degrees.
	 * \return A reference to this object. */
	ShellOptimizationOptionsKit &	SetNormalTolerance(float in_normal_tolerance);

	/*! Sets the tolerance to use when deciding if two vertices can be merged.
	 * \param in_tolerance The tolerance to use during optimization.
	 * \param in_tolerance_units The units in_tolerance is specified in.
	 * \return A reference to this object. */
	ShellOptimizationOptionsKit &	SetTolerance(float in_tolerance, Shell::ToleranceUnits in_tolerance_units);

	/*! Sets whether orphan elimination can be used during optimization. Orphan elimination removes
	 *  points that are not referenced by any face.
	 * \param in_orphan_elimination Whether orphaned points can be eliminated during optimization.
	 * \return A reference to this object. */
	ShellOptimizationOptionsKit &	SetOrphanElimination(bool in_orphan_elimination);

	/*! Sets whether the optimization procedure should impact the shell's face handedness, and if so, in which way.
	 * \param in_handedness_optimization Whether handedness should be altered during optimization.
	 * \param in_handedness_option Whether the faces' handedness should be fixed or reversed.
	 * \return A reference to this object. */
	ShellOptimizationOptionsKit &	SetHandednessOptimization(Shell::HandednessOptimization in_handedness_option);


	/*! Removes the normal tolerance value for this ShellOptimizationOptionsKit.
	 *	\return A reference to this object. */
	ShellOptimizationOptionsKit &	UnsetNormalTolerance();

	/*! Removes the tolerance value for this ShellOptimizationOptionsKit.
	 *	\return A reference to this object. */
	ShellOptimizationOptionsKit &	UnsetTolerance();

	/*! Removes the orphan elimination value for this ShellOptimizationOptionsKit.
	 *	\return A reference to this object. */
	ShellOptimizationOptionsKit &	UnsetOrphanElimination();

	/*! Removes the fix handedness value for this ShellOptimizationOptionsKit.
	 *	\return A reference to this object. */
	ShellOptimizationOptionsKit &	UnsetHandednessOptimization();

	/*! Removes all settings from this ShellOptimizationOptionsKit.
	 *	\return A reference to this ShellOptimizationOptionsKit. */
	ShellOptimizationOptionsKit &	UnsetEverything();


	/*! Shows the value of the normal tolerance for this ShellOptimizationOptionsKit.
	 *	\param out_normal_tolerance The normal tolerance for this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if normal tolerance was set, <span class='code'>false</span> otherwise. */
	bool							ShowNormalTolerance(float & out_normal_tolerance) const;

	/*! Shows the value of the tolerance and its units for this ShellOptimizationOptionsKit.
	 *	\param out_tolerance The tolerance for this ShellOptimizationOptionsKit.
	 *	\param out_tolerance_units The units out_tolerance is specified in.
	 *	\return <span class='code'>true</span> if tolerance was set, <span class='code'>false</span> otherwise. */
	bool							ShowTolerance(float & out_tolerance, Shell::ToleranceUnits & out_tolerance_units) const;

	/*! Shows the value of orphan elimination for this ShellOptimizationOptionsKit.
	 *	\param out_orphan_elimination The orphan elimination value for this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if orphan elimination was set, <span class='code'>false</span> otherwise. */
	bool							ShowOrphanElimination(bool & out_orphan_elimination) const;

	/*! Shows the value of the handedness options for this ShellOptimizationOptionsKit.
	 *	\param out_handedness_optimization The handedness optimization value for this ShellOptimizationOptionsKit.
	 *	\param out_handedness_option The handedness option value for this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if fix handedness was set, <span class='code'>false</span> otherwise. */
	bool							ShowHandednessOptimization(Shell::HandednessOptimization & out_handedness_option) const;
};


/*!
<p>The HPS::ShellRelationOptionsKit class is a user space object. It is used for setting options for a shell relation operation. Calling HPS::ShellRelationOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#shell-relation">this table</a>.</p>
*/
class HPS_API ShellRelationOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty ShellRelationOptionsKit object. */
	ShellRelationOptionsKit();

	/*! The copy constructor creates a new ShellRelationOptionsKit object that contains the same settings as the source ShellRelationOptionsKit.
	 * 	\param in_kit The source ShellRelationOptionsKit to copy. */
	ShellRelationOptionsKit(ShellRelationOptionsKit const & in_kit);

	/*! The move constructor creates a ShellRelationOptionsKit by transferring the underlying impl of the rvalue reference to this ShellRelationOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShellRelationOptionsKit to take the impl from. */
	ShellRelationOptionsKit(ShellRelationOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShellRelationOptionsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShellRelationOptionsKit to take the impl from.
	 * 	\return A reference to this ShellRelationOptionsKit. */
	ShellRelationOptionsKit &		operator=(ShellRelationOptionsKit && in_that);

	virtual ~ShellRelationOptionsKit();

	static const HPS::Type staticType = HPS::Type::ShellRelationOptionsKit;
	HPS::Type						ObjectType() const { return staticType; };

	/*! Creates a ShellRelationOptionsKit which contains the default settings.  The returned object will not necessarily have values
	*	set for every option, but it will have settings for those options where it is reasonable to have a default.
	*	\return A ShellRelationOptionsKit with the default settings. */
	static ShellRelationOptionsKit	GetDefault();

	/*! Copies the source ShellRelationOptionsKit into this ShellRelationOptionsKit and resets the source kit.
	 * 	\param in_kit The source ShellRelationOptionsKit to consume. */
	void							Consume(ShellRelationOptionsKit & in_kit);

	/*! Copies the source ShellRelationOptionsKit into this ShellRelationOptionsKit.
	 * 	\param in_kit The source ShellRelationOptionsKit to copy. */
	void							Set(ShellRelationOptionsKit const & in_kit);

	/*! Copies this ShellRelationOptionsKit into the given ShellRelationOptionsKit.
	 * 	\param out_kit The ShellRelationOptionsKit to populate with the contents of this ShellRelationOptionsKit. */
	void							Show(ShellRelationOptionsKit & out_kit) const;

	/*! Copies the source ShellRelationOptionsKit into this ShellRelationOptionsKit.
	 * 	\param in_kit The source ShellRelationOptionsKit to copy.
	 * 	\return A reference to this ShellRelationOptionsKit. */
	ShellRelationOptionsKit &		operator=(ShellRelationOptionsKit const & in_kit);

	/*! Indicates whether this ShellRelationOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ShellRelationOptionsKit, <span class='code'>false</span> otherwise. */
	bool							Empty() const;

	/*!	Check if the source ShellRelationOptionsKit is equivalent to this ShellRelationOptionsKit.
	 *	\param in_kit The source ShellRelationOptionsKit to compare to this ShellRelationOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							Equals(ShellRelationOptionsKit const & in_kit) const;

	/*!	Check if the source ShellRelationOptionsKit is equivalent to this ShellRelationOptionsKit.
	 *	\param in_kit The source ShellRelationOptionsKit to compare to this ShellRelationOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							operator==(ShellRelationOptionsKit const & in_kit) const;

	/*!	Check if the source ShellRelationOptionsKit is not equivalent to this ShellRelationOptionsKit.
	 *	\param in_kit The source ShellRelationOptionsKit to compare to this ShellRelationOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool							operator!=(ShellRelationOptionsKit const & in_kit) const;


	/*! Sets the tolerance within which points will be considered on the shell.
	 * \param in_tolerance The tolerance, in world space units, to use for this relation test.
	 * \return A reference to this object. */
	ShellRelationOptionsKit &		SetTolerance(float in_tolerance);

	/*! Sets the type of relation test that should be performed.  This determines what kind of information is available from the results.
	 * \param in_test The relation test to be performed.
	 * \return A reference to this object. */
	ShellRelationOptionsKit &		SetTest(Shell::RelationTest in_test);

	/*! Sets a TreeContext to be used for this relation test.  If many relation or selections are going to be computed without modifying the segment tree,
	 *	using the same tree context for all of them can be a significant optimization.  If a TreeContext is not specified, a new one is computed each time.
	 * \param in_tree_context The tree context to use for this relation test.
	 * \return A reference to this object. */
	ShellRelationOptionsKit &		SetTreeContext(TreeContext const & in_tree_context);

	/*! Sets whether the nearest face should be calculated in addition to the primary relation test.
	 * \param in_state Whether to perform nearest face calculation.
	 * \return A reference to this object. */
	ShellRelationOptionsKit &		SetNearestFaceCalculation(bool in_state);


	/*! Removes the tolerance value from this ShellRelationOptionsKit.
	 *	\return A reference to this object. */
	ShellRelationOptionsKit &		UnsetTolerance();

	/*! Removes the test value from this ShellRelationOptionsKit.
	 *	\return A reference to this object. */
	ShellRelationOptionsKit &		UnsetTest();

	/*! Removes the tree context from this ShellRelationOptionsKit.
	 *	\return A reference to this object. */
	ShellRelationOptionsKit &		UnsetTreeContext();

	/*! Removes the nearest face calculation setting from this ShellRelationOptionsKit.
	 *	\return A reference to this object. */
	ShellRelationOptionsKit &		UnsetNearestFaceCalculation();

	/*! Removes all settings from this ShellRelationOptionsKit.
	 *	\return A reference to this object. */
	ShellRelationOptionsKit &		UnsetEverything();


	/*! Shows the value of the tolerance for this ShellRelationOptionsKit.
	 *	\param out_tolerance The tolerance, in world units, for this ShellOptimizationOptionsKit.
	 *	\return <span class='code'>true</span> if tolerance was set, <span class='code'>false</span> otherwise. */
	bool							ShowTolerance(float & out_tolerance) const;

	/*! Shows the relation test for this ShellRelationOptionsKit.
	 *	\param out_test The relation test to be performed.
	 *	\return <span class='code'>true</span> if test was set, <span class='code'>false</span> otherwise. */
	bool							ShowTest(Shell::RelationTest & out_test) const;

	/*! Shows the tree context for this ShellRelationOptionsKit.
	 *	\param out_tree_context The tree context to use for this relation test.
	 *	\return <span class='code'>true</span> if a tree context was set, <span class='code'>false</span> otherwise. */
	bool							ShowTreeContext(TreeContext & out_tree_context) const;

	/*! Shows the nearest face calculation setting for this ShellRelationOptionsKit.
	 *	\param out_state Whether to perform nearest face calculation.
	 *	\return <span class='code'>true</span> if nearest face calculation was specified, <span class='code'>false</span> otherwise. */
	bool							ShowNearestFaceCalculation(bool & out_state) const;
};

/*! The ShellKit class is a user space object.  It contains results from a shell relation operation. */
class HPS_API ShellRelationResultsKit : public Kit
{
public:
	/*! The default constructor creates an empty ShellRelationResultsKit object. */
	ShellRelationResultsKit();

	/*! The copy constructor creates a new ShellRelationResultsKit object that contains the same settings as the source ShellRelationResultsKit.
	 * 	\param in_kit The source ShellRelationResultsKit to copy. */
	ShellRelationResultsKit(ShellRelationResultsKit const & in_kit);

	/*! The move constructor creates a ShellRelationResultsKit by transferring the underlying impl of the rvalue reference to this ShellRelationResultsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShellRelationResultsKit to take the impl from. */
	ShellRelationResultsKit(ShellRelationResultsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShellRelationResultsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShellRelationResultsKit to take the impl from.
	 * 	\return A reference to this ShellRelationResultsKit. */
	ShellRelationResultsKit &		operator=(ShellRelationResultsKit && in_that);

	virtual ~ShellRelationResultsKit();

	static const HPS::Type staticType = HPS::Type::ShellRelationResultsKit;
	HPS::Type						ObjectType() const { return staticType; };

	/*! Copies the source ShellRelationResultsKit into this ShellRelationResultsKit and resets the source kit.
	 * 	\param in_kit The source ShellRelationResultsKit to consume. */
	void							Consume(ShellRelationResultsKit & in_kit);

	/*! Copies the source ShellRelationResultsKit into this ShellRelationResultsKit.
	 * 	\param in_kit The source ShellRelationResultsKit to copy. */
	void							Set(ShellRelationResultsKit const & in_kit);

	/*! Copies this ShellRelationResultsKit into the given ShellRelationResultsKit.
	 * 	\param out_kit The ShellRelationResultsKit to populate with the contents of this ShellRelationResultsKit. */
	void							Show(ShellRelationResultsKit & out_kit) const;

	/*! Copies the source ShellRelationResultsKit into this ShellRelationResultsKit.
	 * 	\param in_kit The source ShellRelationResultsKit to copy.
	 * 	\return A reference to this ShellRelationResultsKit. */
	ShellRelationResultsKit &		operator=(ShellRelationResultsKit const & in_kit);

	/*! Indicates whether this ShellRelationResultsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ShellRelationResultsKit, <span class='code'>false</span> otherwise. */
	bool							Empty() const;

	/*!	Check if the source ShellRelationResultsKit is equivalent to this ShellRelationResultsKit.
	 *	\param in_kit The source ShellRelationResultsKit to compare to this ShellRelationResultsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							Equals(ShellRelationResultsKit const & in_kit) const;

	/*!	Check if the source ShellRelationResultsKit is equivalent to this ShellRelationResultsKit.
	 *	\param in_kit The source ShellRelationResultsKit to compare to this ShellRelationResultsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool							operator==(ShellRelationResultsKit const & in_kit) const;

	/*!	Check if the source ShellRelationResultsKit is not equivalent to this ShellRelationResultsKit.
	 *	\param in_kit The source ShellRelationResultsKit to compare to this ShellRelationResultsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool							operator!=(ShellRelationResultsKit const & in_kit) const;


	/*! Shows the relation of each point in a shell relation computation to the target shell.
	 *	\param out_results The relations, one per point, of points to a target shell.
	 *	\return <span class='code'>true</span> if any relations were requested and computed, <span class='code'>false</span> otherwise. */
	bool							ShowRelations(ShellRelationArray & out_results) const;

	/*! Shows the nearest face in the target shell for each of a set of points.
	 *	\param out_faces The nearest faces, one per point, in the target shell to a set of points.
	 *	\return <span class='code'>true</span> if nearest faces were requested and computed, <span class='code'>false</span> otherwise. */
	bool							ShowNearestFaces(SizeTArray & out_faces) const;

	/*! Shows the smallest distance of each point in a shell relation computation to the target shell.
	 *	\param out_distances The smallest distances, one per point, of points to a target shell.
	 *	\return <span class='code'>true</span> if distances were requested and computed, <span class='code'>false</span> otherwise. */
	bool							ShowDistances(FloatArray & out_distances) const;
};


/*! The ShellKit class is a user space object.  It is the kit analog to a ShellKey. */
class HPS_API ShellKit : public Kit
{
public:
	/*! The default constructor creates an empty ShellKit object. */
	ShellKit();

	/*! The copy constructor creates a new ShellKit object that contains the same settings as the source ShellKit.
	 * 	\param in_kit The source ShellKit to copy. */
	ShellKit(ShellKit const & in_kit);

	/*! The move constructor creates a ShellKit by transferring the underlying impl of the rvalue reference to this ShellKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShellKit to take the impl from. */
	ShellKit(ShellKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShellKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShellKit to take the impl from.
	 * 	\return A reference to this ShellKit. */
	ShellKit & operator=(ShellKit && in_that);

	virtual ~ShellKit();

	static const HPS::Type staticType = HPS::Type::ShellKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source ShellKit into this ShellKit and resets the source kit.
	 * 	\param in_kit The source ShellKit to consume. */
	void				Consume(ShellKit & in_kit);

	/*! Copies the source ShellKit into this ShellKit.
	 * 	\param in_kit The source ShellKit to copy. */
	void				Set(ShellKit const & in_kit);

	/*! Copies this ShellKit into the given ShellKit.
	 * 	\param out_kit The ShellKit to populate with the contents of this ShellKit. */
	void				Show(ShellKit & out_kit) const;

	/*!	Retrieves the number of points in this shell.
	 *	\return The number of points in this shell. */
	size_t				GetPointCount() const;

	/*!	Retrieves the number of faces in this shell.  Note that this is different than the length of the face list
	 *	\return The number of faces in this shell. */
	size_t				GetFaceCount() const;

	/*! Copies the source ShellKit into this ShellKit.
	 * 	\param in_kit The source ShellKit to copy.
	 * 	\return A reference to this ShellKit. */
	ShellKit &			operator=(ShellKit const & in_kit);

	/*! Indicates whether this ShellKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ShellKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source ShellKit is equivalent to this ShellKit.
	 *	\param in_kit The source ShellKit to compare to this ShellKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(ShellKit const & in_kit) const;

	/*!	Check if the source ShellKit is equivalent to this ShellKit.
	 *	\param in_kit The source ShellKit to compare to this ShellKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(ShellKit const & in_kit) const;

	/*!	Check if the source ShellKit is not equivalent to this ShellKit.
	 *	\param in_kit The source ShellKit to compare to this ShellKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(ShellKit const & in_kit) const;

	/*!	Assigns a specific drawing priority value to the ShellKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	ShellKit &			SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	ShellKit &			UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;



	/*! Sets the points for this ShellKit.
	 *	\param in_points The points for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetPoints(PointArray const & in_points);

	/*! Sets the points for this ShellKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetPoints(size_t in_count, Point const in_points []);

	/*! Sets the face list for this ShellKit.
	 *	\param in_facelist The face list for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFacelist(IntArray const & in_facelist);

	/*! Sets the face list for this ShellKit.
	 *	\param in_count Size of the following array.
	 *	\param in_facelist The face list for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFacelist(size_t in_count, int const in_facelist []);

	/*! Sets the triangle strips for this ShellKit.
	 *	\param in_tristrips The tristrips list for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetTristrips(IntArray const & in_tristrips);

	/*! Sets the triangle strips for this ShellKit.
	 *	\param in_count Size of the following array.
	 *	\param in_tristrips The tristrips list for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetTristrips(size_t in_count, int const in_tristrips []);

	/*! Removes the points for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetPoints();

	/*! Removes the face list for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFacelist();

	/*! Removes the tristrips list for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetTristrips();

	/*! Removes all settings from this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetEverything();

	/*! Show the points for this ShellKit.
	 *	\param out_points The points for this ShellKit.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this ShellKit by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this ShellKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this ShellKit by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this ShellKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this ShellKit by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this ShellKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Show the face list for this ShellKit.
	 *	\param out_facelist The face list for this ShellKit.
	 *	\return <span class='code'>true</span> if face list was set, <span class='code'>false</span> otherwise. */
	bool				ShowFacelist(IntArray & out_facelist) const;

	/*! Show the tristrips list for this ShellKit.
	 *	\param out_tristrips The face list for this ShellKit.
	 *	\return <span class='code'>true</span> if tristrips list was set, <span class='code'>false</span> otherwise. */
	bool				ShowTristrips(IntArray & out_tristrips) const;

	/*! Sets the specified material mappings on this ShellKit.  If this kit is used to insert a shell, only face, back face, cut edge, cut face, edge, and vertex materials will be set on the inserted shell.
	 *	These material settings will be "global" for the shell, i.e., all types will get the material for that type.  To get different materials for the same types, e.g., faces with different colors, it is
	 *	necessary to use the per-vertex or per-face functions.
	 *	\param in_kit The material mappings to set on this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetMaterialMapping(MaterialMappingKit const & in_kit);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool const in_visibilities[]);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray const & in_visibilities);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_indices The material indices to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, FloatArray const & in_indices);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, float in_index);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_indices The material indices to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float const in_indices[]);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float in_index);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColorArray const & in_rgb_colors);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColor const & in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_colors[]);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this ShellKit. */
	ShellKit &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param out_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.
	*	\param out_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is MaterialIndex.
	*	\return A reference to this ShellKit. */
	bool				ShowEdgeColors(SizeTArray & out_vertices1, SizeTArray & out_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this ShellKit. */
	bool				ShowEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Unsets edge colors on all edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeColors();

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);

	/*! Removes all vertex visibilities.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeVisibilities();

	/*! Removes all edge settings (edge colors and edge visibilities) from this ShellKit.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeEverything();

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);


	/*! Shows all the edge visibilities on this ShellKit.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_validities The validities of the visibilities for each edge.  If an edge has a visibility set on it, the entry in this array will be
	*		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	*	\param out_visibilities The edge visibilities for each edge.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	*		is <span class='code'>true</span>.
	*	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGB color on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const in_rgb_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified shell component.  If the sizes of the vertex index array and the color array different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColorArray const & in_rgb_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const & in_rgb_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColor const & in_rgb_color, Shell::Component in_apply_to = Shell::Component::Faces);


	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const in_rgba_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByRange(size_t in_start, RGBAColorArray const & in_rgba_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGBA color on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const & in_rgba_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const in_rgba_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified shell component.  If the sizes of the vertex index array and color array are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColorArray const & in_rgba_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const & in_rgba_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColor const & in_rgba_color, Shell::Component in_apply_to = Shell::Component::Faces);


	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_indices The material indices to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting colors.
	 *	\param in_indices The material indices to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByRange(size_t in_start, FloatArray const & in_indices, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single material index on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices for this ShellKit.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float in_index, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float const in_indices[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified shell component.  If the sizes of the vertex index and material index arrays are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, FloatArray const & in_indices, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float in_index, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, float in_index, Shell::Component in_apply_to = Shell::Component::Faces);


	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting normals.
	 *	\param in_count Size of the following array.
	 *	\param in_normals The normals to set on the vertices for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting normals.
	 *	\param in_normals The normals to set on the vertices for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting the normal.
	 *	\param in_count The number of vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets vertex normals on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the normals.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const in_normals[]);

	/*! Sets vertex normals on a selection of arbitrary vertices.  If the sizes of the vertex index and normal arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the normals.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByList(SizeTArray const & in_vertices, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexNormalsByList(SizeTArray const & in_vertices, Vector const & in_normal);


	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting texture parameters.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKit.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexParametersByRange(size_t in_start, size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting texture parameters.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKit.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexParametersByRange(size_t in_start, FloatArray const & in_params, size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertex_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKit.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexParametersByList(size_t in_vertex_count, size_t const in_vertices[], size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKit.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexParametersByList(SizeTArray const & in_vertices, FloatArray const & in_params, size_t in_param_width=2);


	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting visibilities.
	 *	\param in_count Size of the following array.
	 *	\param in_visibilities The visibilities to set on the vertices for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start setting the visibility.
	 *	\param in_count The number of vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool const in_visibilities[]);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.  If the sizes of the vertex index and visibility arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, bool in_visibility);


	/*! Removes all material mappings on this ShellKit.  This removes the "global" material settings and does not affect per-vertex or per-face materials.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetMaterialMapping();


	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for all shell components.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColors();

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this ShellKit.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this ShellKit.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this ShellKit.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[], Shell::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for all shell components starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start removing colors.
	 *	\param in_count The number of vertex colors to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for all shell components on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColorsByList(SizeTArray const & in_vertices);


	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for the specified shell component.
	 *	\param in_apply_to The shell component for which to remove the colors.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColors(Shell::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for the specified shell component starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start removing colors.
	 *	\param in_count The number of vertex colors to remove for this ShellKit.
	 *	\param in_apply_to The shell component for which to remove the colors.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColorsByRange(size_t in_start, size_t in_count, Shell::Component in_apply_to);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for the specified shell component on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\param in_apply_to The shell component for which to remove the colors.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexColorsByList(SizeTArray const & in_vertices, Shell::Component in_apply_to);


	/*! Removes all vertex normals.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexNormals();

	/*! Removes the specified range of vertex normals starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start removing normals.
	 *	\param in_count The number of vertex normals to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex normals on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the normals.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all texture parameters.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexParameters();

	/*! Removes the specified range of texture parameters starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start removing texture parameters.
	 *	\param in_count The number of texture parameters to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexParametersByRange(size_t in_start, size_t in_count);

	/*! Removes the texture parameters on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the texture parameters.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexParametersByList(SizeTArray const & in_vertices);


	/*! Removes all vertex visibilities.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexVisibilities();

	/*! Removes the specified range of vertex visibilities starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start removing visibilities.
	 *	\param in_count The number of vertex visibilities to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the visibilities.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexVisibilitiesByList(SizeTArray const & in_vertices);


	/*! Removes all vertex settings (vertex colors, vertex normals, texture parameters, and vertex visibilities) from this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetVertexEverything();


	/*! Shows the material mappings set on this ShellKit.  These are the "global" material settings, not the per-vertex and per-face material settings.
	 *	\param out_kit The material mappings set on this ShellKit.
	 *	\return <span class='code'>true</span> if material mappings were set, <span class='code'>false</span> otherwise. */
	bool				ShowMaterialMapping(MaterialMappingKit & out_kit) const;


	/*! Shows all the vertex colors on the specified shell component.
	 *	\param in_apply_to The shell component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex.  If a vertex does not have a vertex color set for the specified shell component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex colors were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColors(Shell::Component in_apply_to, MaterialTypeArray & out_types,
										 RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start showing colors.
	 *	\param in_count The number of colors to show.
	 *	\param in_apply_to The shell component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex in the specified range.  If a vertex in the specified range does not have a vertex color set for the specified shell component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex in the specified range.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByRange(size_t in_start, size_t in_count, Shell::Component in_apply_to, MaterialTypeArray & out_types,
							RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a selection of arbitrary vertices which apply to the specified shell component.  The order of the values in the ouput arrays is the same as the input vertex
	 *	index array, i.e., the values of <span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, <span class='code'>out_rgba_colors[i]</span>,
	 *	and <span class='code'>out_indices[i]</span>, correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the colors.
	 *	\param in_apply_to The shell component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex at the specified index.  If a vertex at a specified index does not have a vertex color set for the specified component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex at the specified index.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByList(SizeTArray const & in_vertices, Shell::Component in_apply_to, MaterialTypeArray & out_types,
							RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows all the vertex normals on this ShellKit.
	 *	\param out_validities The validities of the normals for each vertex.  If a vertex had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex normals were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start showing normals.
	 *	\param in_count The number of normals to show.
	 *	\param out_validities The validities of the normals for each vertex in the specified range.  If a vertex in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByList(SizeTArray const & in_vertices, BoolArray & out_validities, VectorArray & out_normals) const;


	/*! Shows the texture parameters on all of the vertices in this ShellKit.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on all of the vertices in this ShellKit.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start showing texture parameters.
	 *	\param in_count The number of vertices for which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start showing texture parameters.
	 *	\param in_count The number of vertices for which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_vertices.size()</span>.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;


	/*! Shows all the vertex visibilities on this ShellKit
	 *	\param out_validities The validities of the visibilities for each vertex.  If a vertex had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKit at which to start showing visibilities.
	 *	\param in_count The number of visibilities to show.
	 *	\param out_validities The validities of the visibilities for each vertex in the specified range.  If a vertex in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray & out_validities, BoolArray & out_visibilities) const;



	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting the color.
	 *	\param in_count The number of faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color);

	/*! Sets face RGB colors on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a selection of arbitrary faces.  If the sizes of the face index array and the color array different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const & in_rgb_color);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColor const & in_rgb_color);


	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_indices The material indices to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[]);

	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting colors.
	 *	\param in_indices The material indices to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByRange(size_t in_start, FloatArray const & in_indices);

	/*! Sets a single material index on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting the color.
	 *	\param in_count The number of faces on which to set the color.
	 *	\param in_index The material index to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float in_index);

	/*! Sets face material indices on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float const in_indices[]);

	/*! Sets face material indices on a selection of arbitrary faces.  If the sizes of the face index and material index arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByList(SizeTArray const & in_faces, FloatArray const & in_indices);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float in_index);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceIndexColorsByList(SizeTArray const & in_faces, float in_index);


	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting normals.
	 *	\param in_count Size of the following array.
	 *	\param in_normals The normals to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting normals.
	 *	\param in_normals The normals to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting the normal.
	 *	\param in_count The number of faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets face normals on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the normals.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const in_normals[]);

	/*! Sets face normals on a selection of arbitrary faces.  If the sizes of the face index and normal arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the normals.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByList(SizeTArray const & in_faces, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceNormalsByList(SizeTArray const & in_faces, Vector const & in_normal);


	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting visibilities.
	 *	\param in_count Size of the following array.
	 *	\param in_visibilities The visibilities to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting visibilities.
	 *	\param in_visibilities The visibilities to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start setting the visibility.
	 *	\param in_count The number of faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets face visibilities on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool const in_visibilities[]);

	/*! Sets face visibilities on a selection of arbitrary faces.  If the sizes of the face index and visibility arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this ShellKit. */
	ShellKit &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, bool in_visibility);


	/*! Removes all face colors (RGB colors or material indices).
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceColors();

	/*! Removes the specified range of face colors (RGB colors or material indices) starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start removing colors.
	 *	\param in_count The number of face colors to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the face colors (RGB colors or material indices) on a selection of arbitrary vertices.
	 *	\param in_faces The indices of the faces on which to remove the colors.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceColorsByList(SizeTArray const & in_faces);


	/*! Removes all face normals.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceNormals();

	/*! Removes the specified range of face normals starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start removing normals.
	 *	\param in_count The number of face normals to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the face normals on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to remove the normals.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all face visibilities.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceVisibilities();

	/*! Removes the specified range of face visibilities starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start removing visibilities.
	 *	\param in_count The number of face visibilities to remove for this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to remove the visibilities.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceVisibilitiesByList(SizeTArray const & in_vertices);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	 *	\param in_count The number of face visibilities to remove for this ShellKit.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[]);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this ShellKit.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceColorsByList(size_t in_count, size_t const in_faces[]);

	/*! Removes all face settings (face colors, face normals, and face visibilities) from this ShellKit.
	 *	\return A reference to this ShellKit. */
	ShellKit &			UnsetFaceEverything();

	/*! Shows all the face colors on this ShellKit.
	 *	\param out_types The types of face colors for each face.  If a face does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColors(MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start showing colors.
	 *	\param in_count The number of colors to show.
	 *	\param out_types The types of face colors for each face in the specified range.  If a face in the specified range does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByRange(size_t in_start, size_t in_count, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a selection of arbitrary faces.  The order of the values in the ouput arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, and <span class='code'>out_indices[i]</span>, correspond to the face at
	 *	index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the colors.
	 *	\param out_types The types of face colors for each face at the specified index.  If a face at a specified index does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByList(SizeTArray const & in_faces, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;


	/*! Shows the all face normals on this ShellKit.
	 *	\param out_validities The validities of the normals for each face.  If a face had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start showing normals.
	 *	\param in_count The number of normals to show.
	 *	\param out_validities The validities of the normals for each face in the specified range.  If a face in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByList(SizeTArray const & in_faces, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows all the face visibilities on this ShellKit.
	 *	\param out_validities The validities of the visibilities for each face.  If a face had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKit at which to start showing visibilities.
	 *	\param in_count The number of visibilities to show.
	 *	\param out_validities The validities of the visibilities for each face in the specified range.  If a face in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray & out_validities, BoolArray & out_visibilities) const;


	/*! Adds points to the point list for this ShellKit.  No existing faces will reference these points, i.e., the face list will be updated to reference the original vertices in their new positions.
	 *	Addtionally, no vertex attributes will apply to these points, i.e., the vertex attributes will only be set on those points which had them prior to the insertion.
	 *	\param in_offset The offset into the point list for the shell at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the point list for this ShellKit.  No existing faces will reference these points, i.e., the face list will be updated to reference the original vertices in their new positions.
	 *	Addtionally, no vertex attributes will apply to these points, i.e., the vertex attributes will only be set on those points which had them prior to the insertion.
	 *	\param in_offset The offset into the point list for the shell at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the point list for this ShellKit.  Any existing faces which reference points which are being deleted will be removed.  Additionally, any vertex attributes on the deleted vertices,
	 *	i.e., colors, normals, parameters, and visibilities, will be removed.  The face list will also be updated to reflect the new vertex offsets caused by removing elements from the point list.
	 *	\param in_offset The offset into the point list for the shell at which to start removing points.  This value must be such that <span class='code'>in_offset<point_count</span> for deletion to succeed.
	 *	\param in_count The number of points to delete from the point list for the shell.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the deletion to succeed.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces points in the point list for this ShellKit.  These points will replace those already referenced by any faces and will inherit any attributes the points being replaced had.
	 *	\param in_offset The offset into the point list for the shell at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces points in the point list for this ShellKit.  These points will replace those already referenced by any faces and will inherit any attributes the points being replaced had.
	 *	\param in_offset The offset into the point list for the shell at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.  This size of the array must be such that <span class='code'>in_offset+in_points.size()&lt;=point_count</span> for
	 *		the replacement to succeed.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Adds faces to the face list for this ShellKit.
	 *	\param in_offset The offset into the faces for the shell at which to insert faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for insertion to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_count Size of the following array.
	 *	\param in_facelist The faces (using the standard face-list encoding) to insert into the face list at the specified offset.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditFacelistByInsertion(size_t in_offset, size_t in_count, int const in_facelist[]);

	/*! Adds faces to the face list for this ShellKit.
	 *	\param in_offset The offset into the faces for the shell at which to insert faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for insertion to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_facelist The faces (using the standard face-list encoding) to insert into the face list at the specified offset.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditFacelistByInsertion(size_t in_offset, IntArray const & in_facelist);

	/*! Removes faces from the face list for this ShellKit.  This will not affect the points referenced by the removed faces, however any face attributes on the removed faces will be lost.
	 *	\param in_offset The offset into the faces for the shell at which to start removing faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for deletion to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_count The number of faces to remove from the face list for the shell.  This value must be such that <span class='code'>in_offset+in_count&lt;=face_count</span> for the deletion to succeed.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditFacelistByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces faces in the face list for this ShellKit.
	 *	\param in_offset The offset into the faces for the shell at which to start replacing faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for replacement to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_count Size of the following array.
	 *	\param in_facelist The faces (using the standard face-list encoding) to use to replace those in the face list at the specified offset.  The number of replacement faces must be such that
	 *		<span class='code'>in_offset+replacement_face_count&lt;=face_count</span>.  This does not mean that the face list length must be the same, i.e., faces can use different numbers of vertices than previously,
	 *		but rather is a limit on the number of faces encoded in the face list.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditFacelistByReplacement(size_t in_offset, size_t in_count, int const in_facelist[]);

	/*! Replaces faces in the face list for this ShellKit.
	 *	\param in_offset The offset into the faces for the shell at which to start replacing faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for replacement to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_facelist The faces (using the standard face-list encoding) to use to replace those in the face list at the specified offset.  The number of replacement faces must be such that
	 *		<span class='code'>in_offset+replacement_face_count&lt;=face_count</span>.  This does not mean that the face list length must be the same, i.e., faces can use different numbers of vertices than previously,
	 *		but rather is a limit on the number of faces encoded in the face list.
	 *	\return A reference to this ShellKit. */
	ShellKit &			EditFacelistByReplacement(size_t in_offset, IntArray const & in_facelist);

	/*! Optimizes the shell using the parameters set in a ShellOptimizationOptionsKit
	 * \param in_shell_optimization_options_kit The kit containing the optimization options to use. */
	void				Optimize(ShellOptimizationOptionsKit const & in_shell_optimization_kit);

	/*! Computes the relation of a collection of points to this shell, subject to the specified options.
	 * \param in_points An array of points to test against this shell.
	 * \param in_options The options to use when performing the relation test.
	 * \param out_results The results of the relation test. */
	void				ComputeRelation(PointArray const & in_points, ShellRelationOptionsKit const & in_options, ShellRelationResultsKit & out_results) const;

	/*! Computes the relation of a collection of points to this shell, subject to the specified options.
	 * \param in_points_source A shell whose points should be tested against this shell.
	 * \param in_options The options to use when performing the relation test.
	 * \param out_results The results of the relation test. */
	void				ComputeRelation(ShellKey const & in_points_source, ShellRelationOptionsKit const & in_options, ShellRelationResultsKit & out_results) const;

	/*! Computes the relation of a collection of points to this shell, subject to the specified options.
	 * \param in_points_source A shell whose points should be tested against this shell.
	 * \param in_options The options to use when performing the relation test.
	 * \param out_results The results of the relation test. */
	void				ComputeRelation(ShellKit const & in_points_source, ShellRelationOptionsKit const & in_options, ShellRelationResultsKit & out_results) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	ShellKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	ShellKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	ShellKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	ShellKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	ShellKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	ShellKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	ShellKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};



/*! The ShellKey class is a smart pointer to a database object.  It is a handle to a shell created by SegmentKey::InsertShell. */
class HPS_API ShellKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized ShellKey object.  The Type() function will return Type::None. */
	ShellKey();

	/*! This constructor creates an ShellKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of a shell key.  Otherwise the copy
	 * 	will fail and the resulting ShellKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit ShellKey(Key const & in_that);

	/*! The copy constructor creates a ShellKey object that shares the underlying smart-pointer of the source ShellKey.
	 *	\param in_that The source ShellKey to copy. */
	ShellKey(ShellKey const & in_that);

	/*! Associate this ShellKey with the same underlying impl as the source ShellKey.
	 *	\param in_that The source ShellKey for the assignment.
	 *	\return A reference to this ShellKey. */
	ShellKey & operator=(ShellKey const & other);

	/*! The move constructor creates a ShellKey by transferring the underlying impl of the rvalue reference to this ShellKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShellKey to take the impl from. */
	ShellKey(ShellKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShellKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShellKey to take the impl from.
	 * 	\return A reference to this ShellKey. */
	ShellKey & operator=(ShellKey && in_that);

	~ShellKey();

	static const HPS::Type staticType = HPS::Type::ShellKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this ShellKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this ShellKey. */
	void				Consume(ShellKit & in_kit);

	/*! Replace those settings on this ShellKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this ShellKey. */
	void				Set(ShellKit const & in_kit);

	/*! Copy the contents of this ShellKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this ShellKey. */
	void				Show(ShellKit & out_kit) const;

	/*!	Retrieves the number of points in this shell.
	 *	\return The number of points in this shell. */
	size_t				GetPointCount() const;

	/*!	Retrieves the number of faces in this shell.  Note that this is different than the length of the face list
	 *	\return The number of faces in this shell. */
	size_t				GetFaceCount() const;


	/*! Replace the points on this ShellKey with the specified points.
	 *	\param in_points The points to use to replace those for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetPoints(PointArray const & in_points);

	/*! Replace the points on this ShellKey with the specified points.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to use to replace those for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetPoints(size_t in_count, Point const in_points []);

	/*! Replace the face list on this ShellKey with the specified face list.
	 *	\param in_facelist The face list to use to replace the one for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFacelist(IntArray const & in_facelist);

	/*! Replace the face list on this ShellKey with the specified face list.
	 *	\param in_count Size of the following array.
	 *	\param in_facelist The face list to use to replace the one for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFacelist(size_t in_count, int const in_facelist []);

	/*! Replace the face list on this ShellKey with the specified face list.
	 *	\param in_tristrips The tristrips list to use to replace the one for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetTristrips(IntArray const & in_tristrips);

	/*! Replace the face list on this ShellKey with the specified face list.
	 *	\param in_count Size of the following array.
	 *	\param in_tristrips The tristrips list to use to replace the one for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetTristrips(size_t in_count, int const in_tristrips []);

	/*! Sets the specified material mappings on this ShellKey.  Only face, back face, cut edge, cut face, edge, and vertex materials will be set on the shell.  These material settings will be "global" for the shell, i.e.,
	 *	all types will get the material for that type.  To get different materials for the same types, e.g., faces with different colors, it is necessary to use the per-vertex or per-face functions.
	 *	\param in_kit The material mappings to set on this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetMaterialMapping(MaterialMappingKit const & in_kit);

	/*! Removes the points for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetPoints();

	/*! Removes the face list for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFacelist();

	/*! Removes the tristrips list for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetTristrips();

	/*! Removes all material mappings on this ShellKey.  This removes the "global" material settings and does not affect per-vertex or per-face materials.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetMaterialMapping();

	/*! Removes all settings from this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetEverything();

	/*! Show the points for this ShellKey.
	 *	\param out_points The points for this ShellKey.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this ShellKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this ShellKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this ShellKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this ShellKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this ShellKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this ShellKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Show the face list for this ShellKey.
	 *	\param out_facelist The face list for this ShellKey.
	 *	\return <span class='code'>true</span> if face list was set, <span class='code'>false</span> otherwise. */
	bool				ShowFacelist(IntArray & out_facelist) const;

	/*! Show the tristrips list for this ShellKey.
	 *	\param out_tristrips The tristrip list for this ShellKey.
	 *	\return <span class='code'>true</span> if tristrips list was set, <span class='code'>false</span> otherwise. */
	bool				ShowTristrips(IntArray & out_tristrips) const;

	/*! Show the tristrips list for this ShellKey.
	*	\param out_tristrips The tristrip list for this ShellKey.
	*	\param out_face_indices The corresponding face indices for each triangle in the tristrip list.
	*	\return <span class='code'>true</span> if tristrips list was set, <span class='code'>false</span> otherwise. */
	bool				ShowTristrips(IntArray & out_tristrips, IntArray & out_face_indices) const;

	/*! Shows the material mappings set on this ShellKey.  These are the "global" material settings, not the per-vertex and per-face material settings.
	 *	\param out_kit The material mappings set on this ShellKey.
	 *	\return <span class='code'>true</span> if material mappings were set, <span class='code'>false</span> otherwise. */
	bool				ShowMaterialMapping(MaterialMappingKit & out_kit) const;

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool const in_visibilities[]);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray const & in_visibilities);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_indices The material indices to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, FloatArray const & in_indices);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, float in_index);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_indices The material indices to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float const in_indices[]);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float in_index);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColorArray const & in_rgb_colors);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColor const & in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_colors[]);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this ShellKey. */
	ShellKey &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param out_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.
	*	\param out_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is MaterialIndex.
	*	\return A reference to this ShellKey. */
	bool				ShowEdgeColors(SizeTArray & out_vertices1, SizeTArray & out_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this ShellKey. */
	bool				ShowEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Unsets edge colors on all edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeColors();

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);

	/*! Removes all vertex visibilities.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeVisibilities();

	/*! Removes all edge settings (edge colors and edge visibilities) from this ShellKey.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeEverything();

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);


	/*! Shows all the edge visibilities on this ShellKey.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_validities The validities of the visibilities for each edge.  If an edge has a visibility set on it, the entry in this array will be
	*		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	*	\param out_visibilities The edge visibilities for each edge.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	*		is <span class='code'>true</span>.
	*	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this ShellKey.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_rgb_colors.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGB color on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the vertices for this ShellKey.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const in_rgb_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified shell component.  If the sizes of the vertex index array and the color array different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColorArray const & in_rgb_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const & in_rgb_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_vertices The indices of the vertices on which to set the color.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColor const & in_rgb_color, Shell::Component in_apply_to = Shell::Component::Faces);


	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this ShellKey.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const in_rgba_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_rgba_colors.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByRange(size_t in_start, RGBAColorArray const & in_rgba_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGBA color on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_rgba_color The RGBA color to set on the vertices for this ShellKey.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const & in_rgba_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const in_rgba_colors[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified shell component.  If the sizes of the vertex index array and color array are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColorArray const & in_rgba_colors, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const & in_rgba_color, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_vertices The indices of the vertices on which to set the color.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColor const & in_rgba_color, Shell::Component in_apply_to = Shell::Component::Faces);


	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_indices The material indices to set on the vertices for this ShellKey.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the vertices for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_indices.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByRange(size_t in_start, FloatArray const & in_indices, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single material index on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_index The material index to set on the vertices for this ShellKey.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float in_index, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float const in_indices[], Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified shell component.  If the sizes of the vertex index and material index arrays are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, FloatArray const & in_indices, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float in_index, Shell::Component in_apply_to = Shell::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified shell component.
	 *	\param in_vertices The indices of the vertices on which to set the color.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The shell component the colors should apply to.  Defaults to Shell::Component::Faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, float in_index, Shell::Component in_apply_to = Shell::Component::Faces);


	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting normals.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_normals The normals to set on the vertices for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting normals.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the vertices for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_normals.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting the normal.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the normal.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_normal The normal to set on the vertices for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets vertex normals on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the normals.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const in_normals[]);

	/*! Sets vertex normals on a selection of arbitrary vertices.  If the sizes of the vertex index and normal arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the normals.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByList(SizeTArray const & in_vertices, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the normal.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the normal.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexNormalsByList(SizeTArray const & in_vertices, Vector const & in_normal);


	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.  This value must be such that
	 *		<span class='code'>in_start+in_param_count/in_param_width&lt;=point_count</span> for the setting to succeed.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKey.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexParametersByRange(size_t in_start, size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKey.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.  The size of the array must be such that <span class='code'>in_start+in_params.size()/in_param_width&lt;=point_count</span> for the setting to succeed.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexParametersByRange(size_t in_start, FloatArray const & in_params, size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertex_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKey.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexParametersByList(size_t in_vertex_count, size_t const in_vertices[], size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_params The texture parameters to set on the vertices for this ShellKey.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexParametersByList(SizeTArray const & in_vertices, FloatArray const & in_params, size_t in_param_width=2);


	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_visibilities The visibilities to set on the vertices for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the vertices for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_visibilities.size()&lt;=point_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start setting the visibility.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the visibility.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the setting to succeed.
	 *	\param in_visibility The visibility to set on the vertices for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool const in_visibilities[]);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.  If the sizes of the vertex index and visibility arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, bool in_visibility);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this ShellKey.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this ShellKey.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this ShellKey.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The shell component the colors should apply to.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[], Shell::Component in_apply_to);

	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for all shell components.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColors();

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for all shell components starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start removing colors.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex colors to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for all shell components on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColorsByList(SizeTArray const & in_vertices);


	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for the specified shell component.
	 *	\param in_apply_to The shell component for which to remove the colors.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColors(Shell::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for the specified shell component starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start removing colors.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex colors to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the removal to succeed.
	 *	\param in_apply_to The shell component for which to remove the colors.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColorsByRange(size_t in_start, size_t in_count, Shell::Component in_apply_to);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for the specified shell component on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for removal to succeed.
	 *	\param in_apply_to The shell component for which to remove the colors.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexColorsByList(SizeTArray const & in_vertices, Shell::Component in_apply_to);


	/*! Removes all vertex normals.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexNormals();

	/*! Removes the specified range of vertex normals starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start removing normals.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex normals to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex normals on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the normals.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all texture parameters.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexParameters();

	/*! Removes the specified range of texture parameters starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start removing texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of texture parameters to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexParametersByRange(size_t in_start, size_t in_count);

	/*! Removes the texture parameters on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the texture parameters.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexParametersByList(SizeTArray const & in_vertices);


	/*! Removes all vertex visibilities.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexVisibilities();

	/*! Removes the specified range of vertex visibilities starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start removing visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex visibilities to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the visibilities.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexVisibilitiesByList(SizeTArray const & in_vertices);


	/*! Removes all vertex settings (vertex colors, vertex normals, texture parameters, and vertex visibilities) from this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetVertexEverything();


	/*! Shows all the vertex colors on the specified shell component.
	 *	\param in_apply_to The shell component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex.  If a vertex does not have a vertex color set for the specified shell component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex colors were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColors(Shell::Component in_apply_to, MaterialTypeArray & out_types,
										 RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a range of vertices starting at the specified offset which apply to the specified shell component.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start showing colors.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of colors to show.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param in_apply_to The shell component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex in the specified range.  If a vertex in the specified range does not have a vertex color set for the specified shell component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex in the specified range.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByRange(size_t in_start, size_t in_count, Shell::Component in_apply_to, MaterialTypeArray & out_types,
							RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a selection of arbitrary vertices which apply to the specified shell component.  The order of the values in the ouput arrays is the same as the input vertex
	 *	index array, i.e., the values of <span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, <span class='code'>out_rgba_colors[i]</span>,
	 *	and <span class='code'>out_indices[i]</span>, correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the colors.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for showing to succeed.
	 *	\param in_apply_to The shell component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex at the specified index.  If a vertex at a specified index does not have a vertex color set for the specified component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex at the specified index.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByList(SizeTArray const & in_vertices, Shell::Component in_apply_to, MaterialTypeArray & out_types,
							RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;


	/*! Shows all the vertex normals on this ShellKey.
	 *	\param out_validities The validities of the normals for each vertex.  If a vertex had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex normals were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start showing normals.  This value must be such that <span class='code'>in_start&lt;point_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param out_validities The validities of the normals for each vertex in the specified range.  If a vertex in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for showing to succeed.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByList(SizeTArray const & in_vertices, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the all net vertex normals on this ShellKey.
	 *	\param out_normals The vertex normals for each vertex.
	 *	\param in_polygon_handedness The polygon handedness to assume when returning normals. Defaults to None.
	 *	Specifying no handedness when requesting net normals, will return the normals using the handedness used internally by Visualize for this particular shell.
	 *	When specifying a handedness, only normals which were implicitly calculated by Visualize will be flipped to conform to the requested handedness.
	 *	User specified normals will be left untouched.
	 *	\return <span class='code'>true</span> if no errors were encountered, <span class='code'>false</span> otherwise. */
	bool				ShowNetVertexNormals(VectorArray & out_normals, Drawing::Handedness in_polygon_handedness = Drawing::Handedness::None) const;

	/*! Shows the net vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start showing normals.  This value must be such that <span class='code'>in_start&lt;point_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param out_normals The vertex normals for each vertex in the specified range.
	 *	\param in_polygon_handedness The polygon handedness to assume when returning normals. Defaults to None.
	 *	Specifying no handedness when requesting net normals, will return the normals using the handedness used internally by Visualize for this particular shell.
	 *	When specifying a handedness, only normals which were implicitly calculated by Visualize will be flipped to conform to the requested handedness.
	 *	User specified normals will be left untouched.
	 *	\return <span class='code'>true</span> if no errors were encountered, <span class='code'>false</span> otherwise. */
	bool				ShowNetVertexNormalsByRange(size_t in_start, size_t in_count, VectorArray & out_normals, Drawing::Handedness in_polygon_handedness = Drawing::Handedness::None) const;

	/*! Shows the texture parameters for all of the vertices on this ShellKey.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters for all of the vertices on this ShellKey.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start showing texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of vertices for which to show the texture parameters.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start showing texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of vertices for which to show the texture parameters.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_vertices.size()</span>.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for showing to succeed.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for showing to succeed.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;


	/*! Shows all the vertex visibilities on this ShellKey.
	 *	\param out_validities The validities of the visibilities for each vertex.  If a vertex had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this ShellKey at which to start showing visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of visibilities to show.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param out_validities The validities of the visibilities for each vertex in the specified range.  If a vertex in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for showing to succeed.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray & out_validities, BoolArray & out_visibilities) const;


	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_rgb_colors.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting the color.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color);

	/*! Sets face RGB colors on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a selection of arbitrary faces.  If the sizes of the face index array and the color array different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const & in_rgb_color);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColor const & in_rgb_color);


	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_indices The material indices to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[]);

	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the faces for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_indices.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByRange(size_t in_start, FloatArray const & in_indices);

	/*! Sets a single material index on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting the color.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_index The material index to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float in_index);

	/*! Sets face material indices on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float const in_indices[]);

	/*! Sets face material indices on a selection of arbitrary faces.  If the sizes of the face index and material index arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByList(SizeTArray const & in_faces, FloatArray const & in_indices);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float in_index);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceIndexColorsByList(SizeTArray const & in_faces, float in_index);


	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_normals The normals to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the faces for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_normals.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting the normal.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the normal.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_normal The normal to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets face normals on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the normals.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const in_normals[]);

	/*! Sets face normals on a selection of arbitrary faces.  If the sizes of the face index and normal arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the normals.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByList(SizeTArray const & in_faces, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the normal.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the normal.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceNormalsByList(SizeTArray const & in_faces, Vector const & in_normal);


	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_visibilities The visibilities to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the faces for this ShellKey.  The size of the array must be such that <span class='code'>in_start+in_visibilities.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start setting the visibility.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the visibility.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_visibility The visibility to set on the faces for this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets face visibilities on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the visibilities.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool const in_visibilities[]);

	/*! Sets face visibilities on a selection of arbitrary faces.  If the sizes of the face index and visibility arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the visibilities.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the visibility.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the visibility.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for setting to succeed.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this ShellKey. */
	ShellKey &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, bool in_visibility);


	/*! Removes all face colors (RGB colors or material indices).
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceColors();

	/*! Removes the specified range of face colors (RGB colors or material indices) starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start removing colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for removal to succeed.
	 *	\param in_count The number of face colors to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the face colors (RGB colors or material indices) on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the faces on which to remove the colors.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceColorsByList(SizeTArray const & in_vertices);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this ShellKey.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[]);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this ShellKey.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceColorsByList(size_t in_count, size_t const in_faces[]);

	/*! Removes all face normals.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceNormals();

	/*! Removes the specified range of face normals starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start removing normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for removal to succeed.
	 *	\param in_count The number of face normals to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the face normals on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to remove the normals.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all face visibilities.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceVisibilities();

	/*! Removes the specified range of face visibilities starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start removing visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for removal to succeed.
	 *	\param in_count The number of face visibilities to remove for this ShellKey.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to remove the visibilities.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for removal to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceVisibilitiesByList(SizeTArray const & in_vertices);


	/*! Removes all face settings (face colors, face normals, and face visibilities) from this ShellKey.
	 *	\return A reference to this ShellKey. */
	ShellKey &			UnsetFaceEverything();

	/*! Shows the face colors on ShellKey.
	 *	\param out_types The types of face colors for each face.  If a face does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColors(MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start showing colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of colors to show.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the showing to succeed.
	 *	\param out_types The types of face colors for each face in the specified range.  If a face in the specified range does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByRange(size_t in_start, size_t in_count, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a selection of arbitrary faces.  The order of the values in the ouput arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, and <span class='code'>out_indices[i]</span>, correspond to the face at
	 *	index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the colors.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for showing to succeed.
	 *	\param out_types The types of face colors for each face at the specified index.  If a face at a specified index does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByList(SizeTArray const & in_faces, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows all the face normals for this ShellKey.
	 *	\param out_validities The validities of the normals for each face.  If a face had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start showing normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the showing to succeed.
	 *	\param out_validities The validities of the normals for each face in the specified range.  If a face in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for showing to succeed.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByList(SizeTArray const & in_faces, BoolArray & out_validities, VectorArray & out_normals) const;


	/*! Shows the effective face normals on a range of faces starting at the specified offset.  If a normal for a given face is unspecified, this will retrieve the effective normal.
	 *	\param in_start The offset into the faces for this ShellKey at which to start showing normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the showing to succeed.
	 *	\param out_normals The face normals for each face in the specified range.
	 *	\return <span class='code'>true</span> if no errors were encountered, <span class='code'>false</span> otherwise. */
	bool				ShowNetFaceNormalsByRange(size_t in_start, size_t in_count, VectorArray & out_normals) const;

	/*! Shows the effective face normals on a selection of arbitrary faces.  If a normal for a given face is unspecified, this will retrieve the effective normal.
	 *	The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for showing to succeed.
	 *	\param out_normals The face normals for each face at the specified index.
	 *	\return <span class='code'>true</span> if no errors were encountered, <span class='code'>false</span> otherwise. */
	bool				ShowNetFaceNormalsByList(SizeTArray const & in_faces, VectorArray & out_normals) const;


	/*! Shows all the face visibilities on this ShellKey.
	 *	\param out_validities The validities of the visibilities for each face.  If a face had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this ShellKey at which to start showing visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of visibilities to show.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the showing to succeed.
	 *	\param out_validities The validities of the visibilities for each face in the specified range.  If a face in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.  Each index in the array must be such that <span class='code'>in_faces[i]&lt;face_count</span> for showing to succeed.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray & out_validities, BoolArray & out_visibilities) const;


	/*! Adds points to the point list for this ShellKey.  No existing faces will reference these points, i.e., the face list will be updated to reference the original vertices in their new positions.
	 *	Addtionally, no vertex attributes will apply to these points, i.e., the vertex attributes will only be set on those points which had them prior to the insertion.
	 *	\param in_offset The offset into the point list for the shell at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Adds points to the point list for this ShellKey.  No existing faces will reference these points, i.e., the face list will be updated to reference the original vertices in their new positions.
	 *	Addtionally, no vertex attributes will apply to these points, i.e., the vertex attributes will only be set on those points which had them prior to the insertion.
	 *	\param in_offset The offset into the point list for the shell at which to insert points.  This value must be such that <span class='code'>in_offset<point_count</span> for insertion to succeed.
	 *	\param in_points The points to insert into the point list at the specified offset.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Removes points from the point list for this ShellKey.  Any existing faces which reference points which are being deleted will be removed.  Additionally, any vertex settings on the deleted vertices,
	 *	i.e., colors, normals, parameters, and visibilities, will be removed.  The face list will also be updated to reflect the new vertex offsets caused by removing elements from the point list.
	 *	\param in_offset The offset into the point list for the shell at which to start removing points.  This value must be such that <span class='code'>in_offset<point_count</span> for deletion to succeed.
	 *	\param in_count The number of points to delete from the point list for the shell.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the deletion to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces points in the point list for this ShellKey.  These points will replace those already referenced by any faces and will inherit any attributes the points being replaced had.
	 *	\param in_offset The offset into the point list for the shell at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_offset+in_count&lt;=point_count</span> for the replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replaces points in the point list for this ShellKey.  These points will replace those already referenced by any faces and will inherit any attributes the points being replaced had.
	 *	\param in_offset The offset into the point list for the shell at which to start replacing points.  This value must be such that <span class='code'>in_offset<point_count</span> for replacement to succeed.
	 *	\param in_points The points to use to replace those in the point list at the specified offset.  This size of the array must be such that <span class='code'>in_offset+in_points.size()&lt;=point_count</span> for
	 *		the replacement to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditPointsByReplacement(size_t in_offset, PointArray const & in_points);


	/*! Adds faces to the face list for this ShellKey.
	 *	\param in_offset The offset into the faces for the shell at which to insert faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for insertion to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_count Size of the following array.
	 *	\param in_facelist The faces (using the standard face-list encoding) to insert into the face list at the specified offset.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditFacelistByInsertion(size_t in_offset, size_t in_count, int const in_facelist[]);

	/*! Adds faces to the face list for this ShellKey.
	 *	\param in_offset The offset into the faces for the shell at which to insert faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for insertion to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_facelist The faces (using the standard face-list encoding) to insert into the face list at the specified offset.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditFacelistByInsertion(size_t in_offset, IntArray const & in_facelist);

	/*! Removes faces from the face list for this ShellKey.  This will not affect the points referenced by the removed faces, however any face attributes on the removed faces will be lost.
	 *	\param in_offset The offset into the faces for the shell at which to start removing faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for deletion to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_count The number of faces to remove from the face list for the shell.  This value must be such that <span class='code'>in_offset+in_count&lt;=face_count</span> for the deletion to succeed.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditFacelistByDeletion(size_t in_offset, size_t in_count);

	/*! Replaces faces in the face list for this ShellKey.
	 *	\param in_offset The offset into the faces for the shell at which to start replacing faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for replacement to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_count Size of the following array.
	 *	\param in_facelist The faces (using the standard face-list encoding) to use to replace those in the face list at the specified offset.  The number of replacement faces must be such that
	 *		<span class='code'>in_offset+replacement_face_count&lt;=face_count</span>.  This does not mean that the face list length must be the same, i.e., faces can use different numbers of vertices than previously,
	 *		but rather is a limit on the number of faces encoded in the face list.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditFacelistByReplacement(size_t in_offset, size_t in_count, int const in_facelist[]);

	/*! Replaces faces in the face list for this ShellKey.
	 *	\param in_offset The offset into the faces for the shell at which to start replacing faces.  This value must be such that <span class='code'>in_offset&lt;face_count</span> for replacement to succeed.  This is not an
	 *		offset into the raw face list, but is relative to the actual face count for the shell.
	 *	\param in_facelist The faces (using the standard face-list encoding) to use to replace those in the face list at the specified offset.  The number of replacement faces must be such that
	 *		<span class='code'>in_offset+replacement_face_count&lt;=face_count</span>.  This does not mean that the face list length must be the same, i.e., faces can use different numbers of vertices than previously,
	 *		but rather is a limit on the number of faces encoded in the face list.
	 *	\return A reference to this ShellKey. */
	ShellKey &			EditFacelistByReplacement(size_t in_offset, IntArray const & in_facelist);

	/*! Optimizes the shell using the parameters set in a ShellOptimizationOptionsKit
	 * \param in_shell_optimization_options_kit The kit containing the optimization options to use. */
	void				Optimize(ShellOptimizationOptionsKit const & in_shell_optimization_kit);

	/*! Computes the relation of a collection of points to this shell, subject to the specified options.
	 * \param in_points An array of points to test against this shell.
	 * \param in_options The options to use when performing the relation test.
	 * \param out_results The results of the relation test. */
	void				ComputeRelation(PointArray const & in_points, ShellRelationOptionsKit const & in_options, ShellRelationResultsKit & out_results) const;

	/*! Computes the relation of a collection of points to this shell, subject to the specified options.
	 * \param in_points_source A shell whose points should be tested against this shell.
	 * \param in_options The options to use when performing the relation test.
	 * \param out_results The results of the relation test. */
	void				ComputeRelation(ShellKey const & in_points_source, ShellRelationOptionsKit const & in_options, ShellRelationResultsKit & out_results) const;

	/*! Computes the relation of a collection of points to this shell, subject to the specified options.
	 * \param in_points_source A shell whose points should be tested against this shell.
	 * \param in_options The options to use when performing the relation test.
	 * \param out_results The results of the relation test. */
	void				ComputeRelation(ShellKit const & in_points_source, ShellRelationOptionsKit const & in_options, ShellRelationResultsKit & out_results) const;
};



/*! The MeshKit class is a user space object. It is a kit analog to a MeshKey. */
class HPS_API MeshKit : public Kit
{
public:
	/*! The default constructor creates an empty MeshKit object. */
	MeshKit();

	/*! The copy constructor creates a new MeshKit object that contains the same settings as the source MeshKit.
	 * 	\param in_kit The source MeshKit to copy. */
	MeshKit(MeshKit const & in_kit);

	/*! The move constructor creates a MeshKit by transferring the underlying impl of the rvalue reference to this MeshKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MeshKit to take the impl from. */
	MeshKit(MeshKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MeshKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a MeshKit to take the impl from.
	 * 	\return A reference to this MeshKit. */
	MeshKit & operator=(MeshKit && in_that);

	virtual ~MeshKit();

	static const HPS::Type staticType = HPS::Type::MeshKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source MeshKit into this MeshKit and resets the source kit.
	 * 	\param in_kit The source MeshKit to consume. */
	void				Consume(MeshKit & in_kit);

	/*! Copies the source MeshKit into this MeshKit.
	 * 	\param in_kit The source MeshKit to copy. */
	void				Set(MeshKit const & in_kit);

	/*! Copies this MeshKit into the given MeshKit.
	 * 	\param out_kit The MeshKit to populate with the contents of this MeshKit. */
	void				Show(MeshKit & out_kit) const;

	/*! Copies the source MeshKit into this MeshKit.
	 * 	\param in_kit The source MeshKit to copy.
	 * 	\return A reference to this MeshKit. */
	MeshKit &			operator=(MeshKit const & in_kit);

	/*! Indicates whether this MeshKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this MeshKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source MeshKit is equivalent to this MeshKit.
	 *	\param in_kit The source MeshKit to compare to this MeshKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(MeshKit const & in_kit) const;

	/*!	Check if the source MeshKit is equivalent to this MeshKit.
	 *	\param in_kit The source MeshKit to compare to this MeshKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(MeshKit const & in_kit) const;

	/*!	Check if the source MeshKit is not equivalent to this MeshKit.
	 *	\param in_kit The source MeshKit to compare to this MeshKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(MeshKit const & in_kit) const;

	/*!	Retrieves the number of points in this mesh.
	 *	\return The number of points in this mesh. */
	size_t				GetPointCount() const;

	/*!	Assigns a specific drawing priority value to the MeshKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	MeshKit &			SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	MeshKit &			UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Sets the points for this MeshKit.
	 *	\param in_points The points for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetPoints(PointArray const & in_points);

	/*! Sets the points for this MeshKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetPoints(size_t in_count, Point const in_points []);

	/*! Sets the points, rows and columns for this MeshKit.
	 *	\param in_rows The number of rows for this MeshKit.
	 *	\param in_columns The number of columns for this MeshKit.
	 *	\param in_points The points to use to replace those on this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetPoints(size_t in_rows, size_t in_columns, HPS::PointArray const & in_points);

	/*! Sets the points, rows and columns for this MeshKit.
	 *	\param in_rows The number of rows for this MeshKit.
	 *	\param in_columns The number of columns for this MeshKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to use to replace those on this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetPoints(size_t in_rows, size_t in_columns, size_t in_count, Point const in_points []);

	/*! Sets the number of rows for this MeshKit.
	 *	\param in_rows The number of rows for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetRows(size_t in_rows);

	/*! Sets the number of columns for this MeshKit.
	 *	\param in_columns The number of columns for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetColumns(size_t in_columns);

	/*! Removes the points for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetPoints();

	/*! Removes the number of rows for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetRows();

	/*! Removes the number of columns for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetColumns();

	/*! Removes all settings from this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetEverything();

	/*! Shows the points for this MeshKit.
	 *	\param out_points The points for this MeshKit.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this MeshKit by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this MeshKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this MeshKit by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this MeshKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this MeshKit by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this MeshKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Shows the number of rows, number of columns, and points for this MeshKit.
	 *	\param out_rows The number of rows for this MeshKit.
	 *	\param out_columns The number of columns for this MeshKit.
	 *	\param out_points The points for this MeshKit.
	 *	\return <span class='code'>true</span> if a number of rows, a number of columns, and points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(size_t & out_rows, size_t & out_columns, PointArray & out_points) const;

	/*! Shows the number of rows for this MeshKit.
	 *	\param out_rows The number of rows for this MeshKit.
	 *	\return <span class='code'>true</span> if a number of rows was set, <span class='code'>false</span> otherwise. */
	bool				ShowRows(size_t & out_rows) const;

	/*! Shows the number of columns for this MeshKit.
	 *	\param out_columns The number of columns for this MeshKit.
	 *	\return <span class='code'>true</span> if a number of columns was set, <span class='code'>false</span> otherwise. */
	bool				ShowColumns(size_t & out_columns) const;

	/*! Sets the specified material mappings on this MeshKit.  If this kit is used to insert a mesh, only face, back face, cut edge, cut face, edge, and vertex materials will be set on the inserted mesh.
	 *	These material settings will be "global" for the mesh, i.e., all types will get the material for that type.  To get different materials for the same types, e.g., faces with different colors,
	 *	it is necessary to use the per-vertex or per-face functions.
	 *	\param in_kit The material mappings to set on this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKit &			SetMaterialMapping(MaterialMappingKit const & in_kit);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool const in_visibilities[]);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray const & in_visibilities);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, FloatArray const & in_indices);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, float in_index);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float const in_indices[]);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float in_index);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColorArray const & in_rgb_colors);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColor const & in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_colors[]);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this MeshKit. */
	MeshKit &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param out_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.
	*	\param out_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.
	 *	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is MaterialIndex.
	*	\return A reference to this MeshKit. */
	bool				ShowEdgeColors(SizeTArray & out_vertices1, SizeTArray & out_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this MeshKit. */
	bool				ShowEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Unsets edge colors on all edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeColors();

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);

	/*! Removes all vertex visibilities.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeVisibilities();

	/*! Removes all edge settings (edge colors and edge visibilities) from this MeshKit.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeEverything();

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);


	/*! Shows all the edge visibilities on this ShellKey.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_validities The validities of the visibilities for each edge.  If an edge has a visibility set on it, the entry in this array will be
	*		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	*	\param out_visibilities The edge visibilities for each edge.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	*		is <span class='code'>true</span>.
	*	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGB color on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const in_rgb_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified mesh component.  If the sizes of the vertex index array and the color array different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColorArray const & in_rgb_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const & in_rgb_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColor const & in_rgb_color, Mesh::Component in_apply_to = Mesh::Component::Faces);


	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const in_rgba_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByRange(size_t in_start, RGBAColorArray const & in_rgba_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGBA color on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const & in_rgba_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const in_rgba_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified mesh component.  If the sizes of the vertex index array and color array are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColorArray const & in_rgba_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const & in_rgba_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColor const & in_rgba_color, Mesh::Component in_apply_to = Mesh::Component::Faces);


	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_indices The material indices to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting colors.
	 *	\param in_indices The material indices to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByRange(size_t in_start, FloatArray const & in_indices, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single material index on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting the color.
	 *	\param in_count The number of vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices for this MeshKit.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float in_index, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float const in_indices[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified mesh component.  If the sizes of the vertex index and material index arrays are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, FloatArray const & in_indices, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float in_index, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, float in_index, Mesh::Component in_apply_to = Mesh::Component::Faces);


	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting normals.
	 *	\param in_count Size of the following array.
	 *	\param in_normals The normals to set on the vertices for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting normals.
	 *	\param in_normals The normals to set on the vertices for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting the normal.
	 *	\param in_count The number of vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets vertex normals on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the normals.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const in_normals[]);

	/*! Sets vertex normals on a selection of arbitrary vertices.  If the sizes of the vertex index and normal arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the normals.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByList(SizeTArray const & in_vertices, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexNormalsByList(SizeTArray const & in_vertices, Vector const & in_normal);


	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting texture parameters.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKit.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexParametersByRange(size_t in_start, size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting texture parameters.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKit.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexParametersByRange(size_t in_start, FloatArray const & in_params, size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertex_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKit.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexParametersByList(size_t in_vertex_count, size_t const in_vertices[], size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKit.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexParametersByList(SizeTArray const & in_vertices, FloatArray const & in_params, size_t in_param_width=2);


	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting visibilities.
	 *	\param in_count Size of the following array.
	 *	\param in_visibilities The visibilities to set on the vertices for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start setting the visibility.
	 *	\param in_count The number of vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool const in_visibilities[]);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.  If the sizes of the vertex index and visibility arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, bool in_visibility);


	/*! Removes all material mappings on this MeshKey.  This removes the "global" material settings and does not affect per-vertex or per-face materials.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetMaterialMapping();

	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for all mesh components.
	 *	\return A reference to this MeshKey. */
	MeshKit &			UnsetVertexColors();

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this MeshKit.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this MeshKit.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this MeshKit.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The shell component the colors should apply to.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[], Mesh::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for all mesh components starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start removing colors.
	 *	\param in_count The number of vertex colors to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for all mesh components on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColorsByList(SizeTArray const & in_vertices);


	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for the specified mesh component.
	 *	\param in_apply_to The mesh component for which to remove the colors.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColors(Mesh::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for the specified mesh component starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start removing colors.
	 *	\param in_count The number of vertex colors to unset for this MeshKit.
	 *	\param in_apply_to The mesh component for which to remove the colors.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColorsByRange(size_t in_start, size_t in_count, Mesh::Component in_apply_to);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for the specificed mesh component on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\param in_apply_to The mesh component for which to remove the colors.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexColorsByList(SizeTArray const & in_vertices, Mesh::Component in_apply_to);


	/*! Removes all vertex normals.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexNormals();

	/*! Removes the specified range of vertex normals starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start removing normals.
	 *	\param in_count The number of vertex normals to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex normals on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the normals.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all texture parameters.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexParameters();

	/*! Removes the specified range of texture parameters starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start removing texture parameters.
	 *	\param in_count The number of texture parameters to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexParametersByRange(size_t in_start, size_t in_count);

	/*! Removes the texture parameters on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the texture parameters.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexParametersByList(SizeTArray const & in_vertices);


	/*! Removes all vertex visibilities.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexVisibilities();

	/*! Removes the specified range of vertex visibilities starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start removing visibilities.
	 *	\param in_count The number of vertex visibilities to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the visibilities.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexVisibilitiesByList(SizeTArray const & in_vertices);


	/*! Removes all vertex settings (vertex colors, vertex normals, texture parameters, and vertex visibilities) from this MeshKey.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetVertexEverything();


	/*! Shows the material mappings set on this MeshKit.  These are the "global" material settings, not the per-vertex and per-face material settings.
	 *	\param out_kit The material mappings set on this MeshKit.
	 *	\return <span class='code'>true</span> if material mappings were set, <span class='code'>false</span> otherwise. */
	bool				ShowMaterialMapping(MaterialMappingKit & out_kit) const;

	/*! Shows all the vertex colors on the specified mesh component.
	 *	\param in_apply_to The mesh component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex.  If a vertex does not have a vertex color set for the specified mesh component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex colors were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColors(Mesh::Component in_apply_to, MaterialTypeArray & out_types,
										 RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start showing colors.
	 *	\param in_count The number of colors to show.
	 *	\param in_apply_to The mesh component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex in the specified range.  If a vertex in the specified range does not have a vertex color set for the specified mesh component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex in the specified range.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByRange(size_t in_start, size_t in_count, Mesh::Component in_apply_to, MaterialTypeArray & out_types,
										RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a selection of arbitrary vertices which apply to the specified mesh component.  The order of the values in the ouput arrays is the same as the input vertex
	 *	index array, i.e., the values of <span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, <span class='code'>out_rgba_colors[i]</span>,
	 *	and <span class='code'>out_indices[i]</span>, correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the colors.
	 *	\param in_apply_to The mesh component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex at the specified index.  If a vertex at a specified index does not have a vertex color set for the specified component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex at the specified index.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByList(SizeTArray const & in_vertices, Mesh::Component in_apply_to, MaterialTypeArray & out_types,
										RGBColorArray & out_rgb_colors,  RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;


	/*! Shows all the vertex normals on this MeshKit.
	 *	\param out_validities The validities of the normals for each vertex.  If a vertex had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex normals were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start showing normals.
	 *	\param in_count The number of normals to show.
	 *	\param out_validities The validities of the normals for each vertex in the specified range.  If a vertex in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByList(SizeTArray const & in_vertices, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the texture parameters for all of the vertices starting in this MeshKit.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters for all of the vertices starting in this MeshKit.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start showing texture parameters.
	 *	\param in_count The number of vertices for which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start showing texture parameters.
	 *	\param in_count The number of vertices for which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_vertices.size()</span>.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows all the vertex visibilities on this MeshKit.
	 *	\param out_validities The validities of the visibilities for each vertex.  If a vertex had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKit at which to start showing visibilities.
	 *	\param in_count The number of visibilities to show.
	 *	\param out_validities The validities of the visibilities for each vertex in the specified range.  If a vertex in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray & out_validities, BoolArray & out_visibilities) const;


	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting the color.
	 *	\param in_count The number of faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color);

	/*! Sets face RGB colors on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a selection of arbitrary faces.  If the sizes of the face index array and the color array different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const & in_rgb_color);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColor const & in_rgb_color);


	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting colors.
	 *	\param in_count Size of the following array.
	 *	\param in_indices The material indices to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[]);

	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting colors.
	 *	\param in_indices The material indices to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByRange(size_t in_start, FloatArray const & in_indices);

	/*! Sets a single material index on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting the color.
	 *	\param in_count The number of faces on which to set the color.
	 *	\param in_index The material index to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float in_index);

	/*! Sets face material indices on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float const in_indices[]);

	/*! Sets face material indices on a selection of arbitrary faces.  If the sizes of the face index and material index arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByList(SizeTArray const & in_faces, FloatArray const & in_indices);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float in_index);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceIndexColorsByList(SizeTArray const & in_faces, float in_index);


	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting normals.
	 *	\param in_count Size of the following array.
	 *	\param in_normals The normals to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting normals.
	 *	\param in_normals The normals to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting the normal.
	 *	\param in_count The number of faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets face normals on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the normals.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const in_normals[]);

	/*! Sets face normals on a selection of arbitrary faces.  If the sizes of the face index and normal arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the normals.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByList(SizeTArray const & in_faces, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceNormalsByList(SizeTArray const & in_faces, Vector const & in_normal);


	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting visibilities.
	 *	\param in_count Size of the following array.
	 *	\param in_visibilities The visibilities to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting visibilities.
	 *	\param in_visibilities The visibilities to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start setting the visibility.
	 *	\param in_count The number of faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets face visibilities on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool const in_visibilities[]);

	/*! Sets face visibilities on a selection of arbitrary faces.  If the sizes of the face index and visibility arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this MeshKit. */
	MeshKit &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, bool in_visibility);


	/*! Removes all face colors (RGB colors or material indices).
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceColors();

	/*! Removes the specified range of face colors (RGB colors or material indices) starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start removing colors.
	 *	\param in_count The number of face colors to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the face colors (RGB colors or material indices) on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the faces on which to remove the colors.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceColorsByList(SizeTArray const & in_vertices);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this MeshKit.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[]);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this MeshKit.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceColorsByList(size_t in_count, size_t const in_faces[]);

	/*! Removes all face normals.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceNormals();

	/*! Removes the specified range of face normals starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start removing normals.
	 *	\param in_count The number of face normals to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the face normals on a selection of arbitrary faces.
	 *	\param in_vertices The indices of the faces on which to remove the normals.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all face visibilities.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceVisibilities();

	/*! Removes the specified range of face visibilities starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start removing visibilities.
	 *	\param in_count The number of face visibilities to unset for this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	 *	\param in_vertices The indices of the faces on which to remove the visibilities.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceVisibilitiesByList(SizeTArray const & in_vertices);


	/*! Removes all face settings (face colors, face normals, and face visibilities) from this MeshKit.
	 *	\return A reference to this MeshKit. */
	MeshKit &			UnsetFaceEverything();

	/*! Shows all the face colors on this MeshKit.
	 *	\param out_types The types of face colors for each face.  If a face does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColors(MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start showing colors.
	 *	\param in_count The number of colors to show.
	 *	\param out_types The types of face colors for each face in the specified range.  If a face in the specified range does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByRange(size_t in_start, size_t in_count, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a selection of arbitrary faces.  The order of the values in the ouput arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, and <span class='code'>out_indices[i]</span>, correspond to the face at
	 *	index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the colors.
	 *	\param out_types The types of face colors for each face at the specified index.  If a face at a specified index does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByList(SizeTArray const & in_faces, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;


	/*! Shows the all face normals on this MeshKit.
	 *	\param out_validities The validities of the normals for each face.  If a face had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start showing normals.
	 *	\param in_count The number of normals to show.
	 *	\param out_validities The validities of the normals for each face in the specified range.  If a face in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByList(SizeTArray const & in_faces, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows all the face visibilities on this MeshKit.
	 *	\param out_validities The validities of the visibilities for each face.  If a face had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKit at which to start showing visibilities.
	 *	\param in_count The number of visibilities to show.
	 *	\param out_validities The validities of the visibilities for each face in the specified range.  If a face in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	MeshKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	MeshKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	MeshKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	MeshKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	MeshKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	MeshKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	MeshKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;

};



/*! The MeshKey class is a smart pointer to a database object.  It is a handle to a mesh created by SegmentKey::InsertMesh. */
class HPS_API MeshKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized MeshKey object.  The Type() function will return Type::None. */
	MeshKey();

	/*! This constructor creates an MeshKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of a mesh key.  Otherwise the copy
	 * 	will fail and the resulting MeshKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit MeshKey(Key const & in_that);

	/*! The copy constructor creates a MeshKey object that shares the underlying smart-pointer of the source MeshKey.
	 *	\param in_that The source MeshKey to copy. */
	MeshKey(MeshKey const & in_that);

	/*! Associate this MeshKey with the same underlying impl as the source MeshKey.
	 *	\param in_that The source MeshKey for the assignment.
	 *	\return A reference to this MeshKey. */
	MeshKey & operator=(MeshKey const & in_that);

	/*! The move constructor creates a MeshKey by transferring the underlying impl of the rvalue reference to this MeshKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MeshKey to take the impl from. */
	MeshKey(MeshKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MeshKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a MeshKey to take the impl from.
	 * 	\return A reference to this MeshKey. */
	MeshKey & operator=(MeshKey && in_that);

	~MeshKey();

	static const HPS::Type staticType = HPS::Type::MeshKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this MeshKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this MeshKey. */
	void				Consume(MeshKit & in_kit);

	/*! Replace those settings on this MeshKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this MeshKey. */
	void				Set(MeshKit const & in_kit);

	/*! Copy the contents of this MeshKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this MeshKey. */
	void				Show(MeshKit & out_kit) const;

	/*!	Retrieves the number of points in this mesh.
	 *	\return The number of points in this mesh. */
	size_t				GetPointCount() const;

	/*! Replace the points on this MeshKey with the specified points.
	 *	\param in_rows The number of rows for this MeshKey.
	 *	\param in_columns The number of columns for this MeshKey.
	 *	\param in_points The points to use to replace those on this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetPoints(size_t in_rows, size_t in_columns, PointArray const & in_points);

	/*! Replace the points on this MeshKey with the specified points.
	 *	\param in_rows The number of rows for this MeshKey.
	 *	\param in_columns The number of columns for this MeshKey.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to use to replace those on this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetPoints(size_t in_rows, size_t in_columns, size_t in_count, Point const in_points []);

	/*! Show the points for this MeshKey.
	 *	\param out_points The points for this MeshKey.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this MeshKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this MeshKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this MeshKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this MeshKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this MeshKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this MeshKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Show the number of rows, number of columns, and points for this MeshKey.
	 *	\param out_rows The number of rows for this MeshKey.
	 *	\param out_columns The number of columns for this MeshKey.
	 *	\param out_points The points for this MeshKey.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(size_t & out_rows, size_t & out_columns, PointArray & out_points) const;

	/*! Show the number of rows for this MeshKey.
	 *	\param out_rows The number of rows for this MeshKey.
	 *	\return <span class='code'>true</span> if rows were set, <span class='code'>false</span> otherwise. */
	bool				ShowRows(size_t & out_rows) const;

	/*! Show the number of columns for this MeshKey.
	 *	\param out_columns The number of columns for this MeshKey.
	 *	\return <span class='code'>true</span> if columns were set, <span class='code'>false</span> otherwise. */
	bool				ShowColumns(size_t & out_columns) const;


	/*! Sets the specified material mappings on this MeshKey.  Only face, back face, cut edge, cut face, edge, and vertex materials will be set on the mesh.  These material settings will be "global" for the mesh, i.e.,
	 *	all types will get the material for that type.  To get different materials for the same types, e.g., faces with different colors, it is necessary to use the per-vertex or per-face functions.
	 *	\param in_kit The material mappings to set on this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetMaterialMapping(MaterialMappingKit const & in_kit);

	/*! Removes all material mappings on this MeshKey.  This removes the "global" material settings and does not affect per-vertex or per-face materials.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetMaterialMapping();

	/*! Shows the material mappings set on this MeshKey.  These are the "global" material settings, not the per-vertex and per-face material settings.
	 *	\param out_kit The material mappings set on this MeshKey.
	 *	\return <span class='code'>true</span> if material mappings were set, <span class='code'>false</span> otherwise. */
	bool				ShowMaterialMapping(MaterialMappingKit & out_kit) const;

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool const in_visibilities[]);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibility The visibility to apply to each edge specified.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, bool in_visibility);

	/*! Sets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_visibilities The visibilities that should be set for each edge specified.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray const & in_visibilities);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_indices The material indices to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, FloatArray const & in_indices);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeIndexColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, float in_index);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_indices The material indices to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float const in_indices[]);

	/*! Sets edge material indices on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_index The material index to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeIndexColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], float in_index);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColorArray const & in_rgb_colors);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeRGBColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, RGBColor const & in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_colors The colors to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_colors[]);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_rgb_color The color to set on the edges.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetEdgeRGBColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[], RGBColor const in_rgb_color);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param out_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.
	*	\param out_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is MaterialIndex.
	*	\return A reference to this MeshKey. */
	bool				ShowEdgeColors(SizeTArray & out_vertices1, SizeTArray & out_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Sets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this MeshKey. */
	bool				ShowEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, HPS::MaterialTypeArray & out_types, HPS::RGBColorArray & out_rgb_colors, HPS::FloatArray & out_indices);

	/*! Unsets edge colors on all edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_types The types of edge colors for each edge.
	*	\param out_rgb_colors The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::RGBColor.
	*	\param out_indices The colors that have been set on each edge. A given element of this array is valid only if the equivalent element of out_types is Material::Type::MaterialIndex.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeColors();

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeColorsByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge colors on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being changed.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeColorsByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);

	/*! Removes all vertex visibilities.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeVisibilities();

	/*! Removes all edge settings (edge colors and edge visibilities) from this MeshKey.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeEverything();

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2);

	/*! Unsets edge visibilities on a selection of arbitrary edges.
	*	\param in_count Size of the following arrays.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being unset.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetEdgeVisibilitiesByList(size_t in_count, size_t const in_vertices1[], size_t const in_vertices2[]);


	/*! Shows all the edge visibilities on this ShellKey.
	*	\param in_vertices1 The vertex indices that correspond to the start position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param in_vertices2 The vertex indices that correspond to the end position of each edge for which the visibilities are being shown.  Each index in the array must be such that <span class='code'>in_vertices[i]<point_count</span> for setting to succeed.
	*	\param out_validities The validities of the visibilities for each edge.  If an edge has a visibility set on it, the entry in this array will be
	*		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	*	\param out_visibilities The edge visibilities for each edge.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	*		is <span class='code'>true</span>.
	*	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowEdgeVisibilitiesByList(SizeTArray const & in_vertices1, SizeTArray const & in_vertices2, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this MeshKey.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGB colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the vertices for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_rgb_colors.size()&lt;=vertex_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGB color on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the vertices for this MeshKey.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const in_rgb_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGB colors on a selection of arbitrary vertices which apply to the specified mesh component.  If the sizes of the vertex index array and the color array different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColorArray const & in_rgb_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByList(size_t in_count, size_t const in_vertices[], RGBColor const & in_rgb_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGB color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBColorsByList(SizeTArray const & in_vertices, RGBColor const & in_rgb_color, Mesh::Component in_apply_to = Mesh::Component::Faces);


	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this MeshKey.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const in_rgba_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGBA colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_rgba_colors.size()&lt;=vertex_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByRange(size_t in_start, RGBAColorArray const & in_rgba_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGBA color on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_rgba_color The RGBA color to set on the vertices for this MeshKey.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByRange(size_t in_start, size_t in_count, RGBAColor const & in_rgba_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const in_rgba_colors[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex RGBA colors on a selection of arbitrary vertices which apply to the specified mesh component.  If the sizes of the vertex index array and color array are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_rgba_colors The RGBA colors to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColorArray const & in_rgba_colors, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByList(size_t in_count, size_t const in_vertices[], RGBAColor const & in_rgba_color, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single RGBA color on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_rgba_color The RGBA color to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexRGBAColorsByList(SizeTArray const & in_vertices, RGBAColor const & in_rgba_color, Mesh::Component in_apply_to = Mesh::Component::Faces);


	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_indices The material indices to set on the vertices for this MeshKey.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex material indices on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the vertices for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_indices.size()&lt;=vertex_count</span>
	 *		for the setting to succeed.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByRange(size_t in_start, FloatArray const & in_indices, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single material index on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting the color.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_index The material index to set on the vertices for this MeshKey.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByRange(size_t in_start, size_t in_count, float in_index, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float const in_indices[], Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex material indices on a selection of arbitrary vertices which apply to the specified mesh component.  If the sizes of the vertex index and material index arrays are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the colors.
	 *	\param in_indices The material indices to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, FloatArray const & in_indices, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByList(size_t in_count, size_t const in_vertices[], float in_index, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets a single material index on a selection of arbitrary vertices which apply to the specified mesh component.
	 *	\param in_vertices The indices of the vertices on which to set the color.
	 *	\param in_index The material index to set on the vertices.
	 *	\param in_apply_to The mesh component the colors should apply to.  Defaults to Mesh::Component::Faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexIndexColorsByList(SizeTArray const & in_vertices, float in_index, Mesh::Component in_apply_to = Mesh::Component::Faces);

	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	*	\param in_start The offset into the vertices for this MeshKey at which to start setting normals.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	*	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	*	\param in_normals The normals to set on the vertices for this MeshKey.
	*	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting normals.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the vertices for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_normals.size()&lt;=vertex_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting the normal.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the normal.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_normal The normal to set on the vertices for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets vertex normals on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the normals.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const in_normals[]);

	/*! Sets vertex normals on a selection of arbitrary vertices.  If the sizes of the vertex index and normal arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the normals.
	 *	\param in_normals The normals to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByList(SizeTArray const & in_vertices, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByList(size_t in_count, size_t const in_vertices[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the normal.
	 *	\param in_normal The normal to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexNormalsByList(SizeTArray const & in_vertices, Vector const & in_normal);


	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.  This value must be such that
	 *		<span class='code'>in_start+in_param_count/in_param_width&lt;=point_count</span> for the setting to succeed.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKey.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexParametersByRange(size_t in_start, size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKey.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.  This value must be such that <span class='code'>in_start+in_params.size()/in_param_width&lt;=point_count</span> for the setting to succeed.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexParametersByRange(size_t in_start, FloatArray const & in_params, size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertex_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.
	 *	\param in_param_count Size of the following array.  This should be divisible by the parameter width, if it is not, some parameters will get ignored.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKey.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexParametersByList(size_t in_vertex_count, size_t const in_vertices[], size_t in_param_count, float const in_params[], size_t in_param_width=2);

	/*! Sets texture parameters on a selection of arbitrary vertices.  If the sizes of the vertex index array and the texture paramter array (divided by the parameter width) are different,
	 *	the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the texture parameters.
	 *	\param in_params The texture parameters to set on the vertices for this MeshKey.  The size of the array should be divisible by the parameter width, if it is not,
	 *		some parameters will get ignored.
	 *	\param in_param_width The number of texture parameters per vertex.  Defaults to <span class='code'>2</span>.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexParametersByList(SizeTArray const & in_vertices, FloatArray const & in_params, size_t in_param_width=2);


	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_visibilities The visibilities to set on the vertices for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the vertices for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_visibilities.size()&lt;=vertex_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start setting the visibility.  This value must be such that <span class='code'>in_start<point_count</span> for setting to succeed.
	 *	\param in_count The number of vertices on which to set the visibility.  This value must be such that <span class='code'>in_start+in_count&lt;=vertex_count</span> for the setting to succeed.
	 *	\param in_visibility The visibility to set on the vertices for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_count Size of the following arrays.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool const in_visibilities[]);

	/*! Sets vertex visibilities on a selection of arbitrary vertices.  If the sizes of the vertex index and visibility arrays are different, the smaller size will be used.
	 *	\param in_vertices The indices of the vertices on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_count Size of the following array.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to set the visibility.
	 *	\param in_visibility The visibility to set on the vertices.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetVertexVisibilitiesByList(SizeTArray const & in_vertices, bool in_visibility);


	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for all mesh components.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColors();

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this MeshKey.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexVisibilitiesByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this MeshKey.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[]);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	*	\param in_count The number of vertex visibilities to remove for this MeshKey.
	*	\param in_faces The indices of the vertices on which to remove the visibilities.
	*	\param in_apply_to The shell component the colors should apply to.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColorsByList(size_t in_count, size_t const in_vertices[], Mesh::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for all mesh components starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start removing colors.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex colors to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for all mesh components on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColorsByList(SizeTArray const & in_vertices);


	/*! Removes all vertex colors (RGB colors, RGBA colors, or material indices) for the specified mesh component.
	 *	\param in_apply_to The mesh component for which to remove the colors.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColors(Mesh::Component in_apply_to);

	/*! Removes the specified range of vertex colors (RGB colors, RGBA colors, or material indices) for the specified mesh component starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start removing colors.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex colors to unset for this MeshKey.
	 *	\param in_apply_to The mesh component for which to remove the colors.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColorsByRange(size_t in_start, size_t in_count, Mesh::Component in_apply_to);

	/*! Removes the vertex colors (RGB colors, RGBA colors, or material indices) for the specificed mesh component on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the colors.
	 *	\param in_apply_to The mesh component for which to remove the colors.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexColorsByList(SizeTArray const & in_vertices, Mesh::Component in_apply_to);


	/*! Removes all vertex normals.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexNormals();

	/*! Removes the specified range of vertex normals starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start removing normals.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex normals to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex normals on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the normals.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexNormalsByList(SizeTArray const & in_vertices);


	/*! Removes all texture parameters.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexParameters();

	/*! Removes the specified range of texture parameters starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start removing texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of texture parameters to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexParametersByRange(size_t in_start, size_t in_count);

	/*! Removes the texture parameters on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the texture parameters.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexParametersByList(SizeTArray const & in_vertices);


	/*! Removes all vertex visibilities.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexVisibilities();

	/*! Removes the specified range of vertex visibilities starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start removing visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of vertex visibilities to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the vertex visibilities on a selection of arbitrary vertices.
	 *	\param in_vertices The indices of the vertices on which to remove the visibilities.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexVisibilitiesByList(SizeTArray const & in_vertices);


	/*! Removes all vertex settings (vertex colors, vertex normals, texture parameters, and vertex visibilities) from this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetVertexEverything();

	/*! Removes all settings from this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetEverything();


	/*! Shows all the vertex colors on the specified mesh component.
	 *	\param in_apply_to The mesh component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex.  If a vertex does not have a vertex color set for the specified mesh component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex colors were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColors(Mesh::Component in_apply_to, MaterialTypeArray & out_types,
										 RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a range of vertices starting at the specified offset which apply to the specified mesh component.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start showing colors.  This value must be such that <span class='code'>in_start<point_count</span> for removal to succeed.
	 *	\param in_count The number of colors to show.
	 *	\param in_apply_to The mesh component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex in the specified range.  If a vertex in the specified range does not have a vertex color set for the specified mesh component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex in the specified range.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByRange(size_t in_start, size_t in_count, Mesh::Component in_apply_to, MaterialTypeArray & out_types,
										RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;

	/*! Shows the vertex colors on a selection of arbitrary vertices which apply to the specified mesh component.  The order of the values in the ouput arrays is the same as the input vertex
	 *	index array, i.e., the values of <span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, <span class='code'>out_rgba_colors[i]</span>,
	 *	and <span class='code'>out_indices[i]</span>, correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the colors.
	 *	\param in_apply_to The mesh component the colors should apply to.
	 *	\param out_types The types of vertex colors for each vertex at the specified index.  If a vertex at a specified index does not have a vertex color set for the specified component,
	 *		the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each vertex at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_rgba_colors The RGBA colors for each vertex at the specified index.  <span class='code'>out_rgba_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBAColor.
	 *	\param out_indices The material indices for each vertex at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex color on the specified component set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexColorsByList(SizeTArray const & in_vertices, Mesh::Component in_apply_to, MaterialTypeArray & out_types,
										RGBColorArray & out_rgb_colors, RGBAColorArray & out_rgba_colors, FloatArray & out_indices) const;


	/*! Shows all the vertex normals on this MeshKey.
	 *	\param out_validities The validities of the normals for each vertex.  If a vertex had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex normals were shown, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start showing normals.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.
	 *	\param out_validities The validities of the normals for each vertex in the specified range.  If a vertex in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the vertex normals on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The vertex normals for each vertex at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex normal set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexNormalsByList(SizeTArray const & in_vertices, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the all net vertex normals on this MeshKey.
	 *	\param out_normals The vertex normals for each vertex.
	 *	\param in_polygon_handedness The polygon handedness to assume when returning normals. Defaults to None.
	 *	Specifying no handedness when requesting net normals, will return the normals using the handedness used internally by Visualize for this particular shell.
	 *	When specifying a handedness, only normals which were implicitly calculated by Visualize will be flipped to conform to the requested handedness.
	 *	User specified normals will be left untouched.
	 *	\return <span class='code'>true</span> if no errors were encountered, <span class='code'>false</span> otherwise. */
	bool				ShowNetVertexNormals(VectorArray & out_normals, Drawing::Handedness in_polygon_handedness = Drawing::Handedness::None) const;

	/*! Shows the net vertex normals on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start showing normals.  This value must be such that <span class='code'>in_start&lt;point_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.  This value must be such that <span class='code'>in_start+in_count&lt;=point_count</span> for the showing to succeed.
	 *	\param out_normals The vertex normals for each vertex in the specified range.
	 *	\param in_polygon_handedness The polygon handedness to assume when returning normals. Defaults to None.
	 *	Specifying no handedness when requesting net normals, will return the normals using the handedness used internally by Visualize for this particular shell.
	 *	When specifying a handedness, only normals which were implicitly calculated by Visualize will be flipped to conform to the requested handedness.
	 *	User specified normals will be left untouched.
	 *	\return <span class='code'>true</span> if no errors were encountered, <span class='code'>false</span> otherwise. */
	bool				ShowNetVertexNormalsByRange(size_t in_start, size_t in_count, VectorArray & out_normals, Drawing::Handedness in_polygon_handedness = Drawing::Handedness::None) const;

	/*! Shows the texture parameters for all the vertices in this MeshKey.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params) const;

	/*!  Shows the texture parameters for all the vertices in this MeshKey.
	 *	\param out_validities The validities of the texture parameters for each vertex.  If a vertex had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParameters(BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_count</span>.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start showing texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of vertices for which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start showing texture parameters.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of vertices for which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex in the specified range.  If a vertex in the specified range had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex in the specified range.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByRange(size_t in_start, size_t in_count, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  For this particular show function, the parameter width is returned implicitly and could be determined
	 *	by <span class='code'>out_params.size()/in_vertices.size()</span>.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params) const;

	/*! Shows the texture parameters on a selection of arbitrary vertices.  The order of the output arrays is the same as the input vertex index array, i.e., <span class='code'>out_validities[i]</span>
	 *	and <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the texture parameters.
	 *	\param out_validities The validities of the texture parameters for each vertex at the specified index.  If a vertex at a specified index had a texture parameter set on it, the entry in
	 *		this array will be <span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_params The texture parameters for each vertex at the specified index.  <span class='code'>(out_params[i],...,out_params[i+param_width-1])</span> are only valid if
	 *		<span class='code'>out_validities[i]</span> is <span class='code'>true</span>.
	 *	\param out_param_width The number of texture parameters per vertex.
	 *	\return <span class='code'>true</span> if any specified vertex had a texture parameter set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexParametersByList(SizeTArray const & in_vertices, BoolArray & out_validities, FloatArray & out_params, size_t & out_param_width) const;


	/*! Shows all the vertex visibilities on this MeshKey.
	 *	\param out_validities The validities of the visibilities for each vertex.  If a vertex had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a range of vertices starting at the specified offset.
	 *	\param in_start The offset into the vertices for this MeshKey at which to start showing visibilities.  This value must be such that <span class='code'>in_start<point_count</span> for showing to succeed.
	 *	\param in_count The number of visibilities to show.
	 *	\param out_validities The validities of the visibilities for each vertex in the specified range.  If a vertex in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any vertex in the specified range had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the vertex visibilities on a selection of arbitrary vertices.  The order of the values in the output arrays is the same as the input vertex index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the vertex at index <span class='code'>in_vertices[i]</span>.
	 *	\param in_vertices The indices of the vertices on which to show the normals.
	 *	\param out_validities The validities of the normals for each vertex at the specified index.  If a vertex at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The vertex visibilities for each vertex at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified vertex had a vertex visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowVertexVisibilitiesByList(SizeTArray const & in_vertices, BoolArray & out_validities, BoolArray & out_visibilities) const;


	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_rgb_colors The RGB colors to set on the faces for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_rgb_colors.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByRange(size_t in_start, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting the color.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_rgb_color The RGB color to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByRange(size_t in_start, size_t in_count, RGBColor const & in_rgb_color);

	/*! Sets face RGB colors on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const in_rgb_colors[]);

	/*! Sets face RGB colors on a selection of arbitrary faces.  If the sizes of the face index array and the color array different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_rgb_colors The RGB colors to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColorArray const & in_rgb_colors);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByList(size_t in_count, size_t const in_faces[], RGBColor const & in_rgb_color);

	/*! Sets a single RGB color on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_rgb_color The RGB color to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceRGBColorsByList(SizeTArray const & in_faces, RGBColor const & in_rgb_color);


	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_indices The material indices to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float const in_indices[]);

	/*! Sets face material indices on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_indices The material indices to set on the faces for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_indices.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByRange(size_t in_start, FloatArray const & in_indices);

	/*! Sets a single material index on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting the color.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the color.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_index The material index to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByRange(size_t in_start, size_t in_count, float in_index);

	/*! Sets face material indices on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float const in_indices[]);

	/*! Sets face material indices on a selection of arbitrary faces.  If the sizes of the face index and material index arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the colors.
	 *	\param in_indices The material indices to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByList(SizeTArray const & in_faces, FloatArray const & in_indices);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByList(size_t in_count, size_t const in_faces[], float in_index);

	/*! Sets a single material index on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the color.
	 *	\param in_index The material index to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceIndexColorsByList(SizeTArray const & in_faces, float in_index);


	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_normals The normals to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const in_normals[]);

	/*! Sets face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_normals The normals to set on the faces for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_normals.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByRange(size_t in_start, VectorArray const & in_normals);

	/*! Sets a single normal on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting the normal.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the normal.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_normal The normal to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByRange(size_t in_start, size_t in_count, Vector const & in_normal);

	/*! Sets face normals on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the normals.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const in_normals[]);

	/*! Sets face normals on a selection of arbitrary faces.  If the sizes of the face index and normal arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the normals.
	 *	\param in_normals The normals to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByList(SizeTArray const & in_faces, VectorArray const & in_normals);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByList(size_t in_count, size_t const in_faces[], Vector const & in_normal);

	/*! Sets a single normal on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the normal.
	 *	\param in_normal The normal to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceNormalsByList(SizeTArray const & in_faces, Vector const & in_normal);


	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count Size of the following array.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_visibilities The visibilities to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool const in_visibilities[]);

	/*! Sets face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_visibilities The visibilities to set on the faces for this MeshKey.  The size of the array must be such that <span class='code'>in_start+in_visibilities.size()&lt;=face_count</span>
	 *		for the setting to succeed.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByRange(size_t in_start, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start setting the visibility.  This value must be such that <span class='code'>in_start&lt;face_count</span> for setting to succeed.
	 *	\param in_count The number of faces on which to set the visibility.  This value must be such that <span class='code'>in_start+in_count&lt;=face_count</span> for the setting to succeed.
	 *	\param in_visibility The visibility to set on the faces for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByRange(size_t in_start, size_t in_count, bool in_visibility);

	/*! Sets face visibilities on a selection of arbitrary faces.
	 *	\param in_count Size of the following arrays.
	 *	\param in_faces The indices of the faces on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool const in_visibilities[]);

	/*! Sets face visibilities on a selection of arbitrary faces.  If the sizes of the face index and visibility arrays are different, the smaller size will be used.
	 *	\param in_faces The indices of the faces on which to set the visibilities.
	 *	\param in_visibilities The visibilities to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray const & in_visibilities);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_count Size of the following array.
	 *	\param in_faces The indices of the faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[], bool in_visibility);

	/*! Sets a single visibility on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to set the visibility.
	 *	\param in_visibility The visibility to set on the faces.
	 *	\return A reference to this MeshKey. */
	MeshKey &			SetFaceVisibilitiesByList(SizeTArray const & in_faces, bool in_visibility);


	/*! Removes all face colors (RGB colors or material indices).
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceColors();

	/*! Removes the specified range of face colors (RGB colors or material indices) starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start removing colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for removal to succeed.
	 *	\param in_count The number of face colors to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceColorsByRange(size_t in_start, size_t in_count);

	/*! Removes the face colors (RGB colors or material indices) on a selection of arbitrary vertices.
	 *	\param in_faces The indices of the faces on which to remove the colors.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceColorsByList(SizeTArray const & in_faces);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this MeshKey.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceVisibilitiesByList(size_t in_count, size_t const in_faces[]);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	*	\param in_count The number of face visibilities to remove for this MeshKey.
	*	\param in_faces The indices of the faces on which to remove the visibilities.
	*	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceColorsByList(size_t in_count, size_t const in_faces[]);

	/*! Removes all face normals.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceNormals();

	/*! Removes the specified range of face normals starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start removing normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for removal to succeed.
	 *	\param in_count The number of face normals to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceNormalsByRange(size_t in_start, size_t in_count);

	/*! Removes the face normals on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to remove the normals.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceNormalsByList(SizeTArray const & in_faces);


	/*! Removes all face visibilities.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceVisibilities();

	/*! Removes the specified range of face visibilities starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start removing visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for removal to succeed.
	 *	\param in_count The number of face visibilities to unset for this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceVisibilitiesByRange(size_t in_start, size_t in_count);

	/*! Removes the face visibilities on a selection of arbitrary faces.
	 *	\param in_faces The indices of the faces on which to remove the visibilities.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceVisibilitiesByList(SizeTArray const & in_faces);


	/*! Removes all face settings (face colors, face normals, and face visibilities) from this MeshKey.
	 *	\return A reference to this MeshKey. */
	MeshKey &			UnsetFaceEverything();

	/*! Shows the face colors on MeshKey.
	 *	\param out_types The types of face colors for each face.  If a face does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColors(MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start showing colors.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of colors to show.
	 *	\param out_types The types of face colors for each face in the specified range.  If a face in the specified range does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face in the specified range.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face in the specified range.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByRange(size_t in_start, size_t in_count, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows the face colors on a selection of arbitrary faces.  The order of the values in the ouput arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_types[i], </span><span class='code'>out_rgb_colors[i]</span>, and <span class='code'>out_indices[i]</span>, correspond to the face at
	 *	index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the colors.
	 *	\param out_types The types of face colors for each face at the specified index.  If a face at a specified index does not have a face color set, the entry in this array will be Material::Type::None.
	 *	\param out_rgb_colors The RGB colors for each face at the specified index.  <span class='code'>out_rgb_colors[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::RGBColor.
	 *	\param out_indices The material indices for each face at the specified index.  The <span class='code'>out_indices[i]</span> is only valid if <span class='code'>out_types[i]</span>
	 *		is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if any specified face had a face color set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceColorsByList(SizeTArray const & in_faces, MaterialTypeArray & out_types, RGBColorArray & out_rgb_colors, FloatArray & out_indices) const;

	/*! Shows all the face normals for this MeshKey.
	 *	\param out_validities The validities of the normals for each face.  If a face had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormals(BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start showing normals.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of normals to show.
	 *	\param out_validities The validities of the normals for each face in the specified range.  If a face in the specified range had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face in the specified range.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByRange(size_t in_start, size_t in_count, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows the face normals on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_normals[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a normal set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_normals The face normals for each face at the specified index.  <span class='code'>out_normals[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face normal set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceNormalsByList(SizeTArray const & in_faces, BoolArray & out_validities, VectorArray & out_normals) const;

	/*! Shows all the face visibilities on this MeshKey.
	 *	\param out_validities The validities of the visibilities for each face.  If a face had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities or each face.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilities(BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a range of faces starting at the specified offset.
	 *	\param in_start The offset into the faces for this MeshKey at which to start showing visibilities.  This value must be such that <span class='code'>in_start&lt;face_count</span> for showing to succeed.
	 *	\param in_count The number of visibilities to show.
	 *	\param out_validities The validities of the visibilities for each face in the specified range.  If a face in the specified range had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face in the specified range.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any face in the specified range had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByRange(size_t in_start, size_t in_count, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Shows the face visibilities on a selection of arbitrary faces.  The order of the values in the output arrays is the same as the input face index array, i.e., the values of
	 *	<span class='code'>out_validities[i]</span> and <span class='code'>out_visibilities[i]</span> correspond to the face at index <span class='code'>in_faces[i]</span>.
	 *	\param in_faces The indices of the faces on which to show the normals.
	 *	\param out_validities The validities of the normals for each face at the specified index.  If a face at a specified index had a visibility set on it, the entry in this array will be
	 *		<span class='code'>true</span>, otherwise it will be <span class='code'>false</span>.
	 *	\param out_visibilities The face visibilities for each face at the specified index.  <span class='code'>out_visibilities[i]</span> is only valid if <span class='code'>out_validities[i]</span>
	 *		is <span class='code'>true</span>.
	 *	\return <span class='code'>true</span> if any specified face had a face visibility set, <span class='code'>false</span> otherwise. */
	bool				ShowFaceVisibilitiesByList(SizeTArray const & in_faces, BoolArray & out_validities, BoolArray & out_visibilities) const;

	/*! Replaces a range of points for this MeshKey.
	 *	\param in_row_offset The row offset into the MeshKey at which to start replacing points.  This value must be such that <span class='code'>in_row_offset&lt;row_count</span> for replacement to succeed.
	 *	\param in_column_offset The column offset into the MeshKey at which to start replacing points.  This value must be such that <span class='code'>in_column_offset&lt;column_count</span> for replacement to succeed.
	 *	\param in_row_count The number of rows to replace.  This value must be such that <span class='code'>in_row_offset+in_row_count&lt;=row_count</span> for replacement to succeed.
	 *	\param in_column_count The number of columns to replace.  This value must be such that <span class='code'>in_column_offset+in_column_count&lt;=column_count</span> for replacement to succeed.
	 *	\param in_point_count The size of the <span class='code'>in_points</span> array.  The size of the array should be <span class='code'>in_row_count*in_column_count</span>.
	 *	\param in_points The points to use to replace those in the specified range.
	 *	\return A reference to this MeshKey. */
	MeshKey &			EditMeshByReplacement(size_t in_row_offset, size_t in_column_offset, size_t in_row_count, size_t in_column_count, size_t in_point_count, Point const in_points[]);

	/*! Replaces a range of points for this MeshKey.
	 *	\param in_row_offset The row offset into the MeshKey at which to start replacing points.  This value must be such that <span class='code'>in_row_offset&lt;row_count</span> for replacement to succeed.
	 *	\param in_column_offset The column offset into the MeshKey at which to start replacing points.  This value must be such that <span class='code'>in_column_offset&lt;column_count</span> for replacement to succeed.
	 *	\param in_row_count The number of rows to replace.  This value must be such that <span class='code'>in_row_offset+in_row_count&lt;=row_count</span> for replacement to succeed.
	 *	\param in_column_count The number of columns to replace.  This value must be such that <span class='code'>in_column_offset+in_column_count&lt;=column_count</span> for replacement to succeed.
	 *	\param in_points The points to use to replace those in the specified range.  The size of the array should be <span class='code'>in_row_count*in_column_count</span>.
	 *	\return A reference to this MeshKey. */
	MeshKey &			EditMeshByReplacement(size_t in_row_offset, size_t in_column_offset, size_t in_row_count, size_t in_column_count, PointArray const & in_points);
};




/*! The PolygonKit class is a user space object.  It is a kit analog to a PolygonKey. */
class HPS_API PolygonKit : public Kit
{
public:
	/*! The default constructor creates an empty PolygonKit object. */
	PolygonKit();

	/*! The copy constructor creates a new PolygonKit object that contains the same settings as the source PolygonKit.
	 * 	\param in_kit The source PolygonKit to copy. */
	PolygonKit(PolygonKit const & in_kit);

	/*! The move constructor creates a PolygonKit by transferring the underlying impl of the rvalue reference to this PolygonKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PolygonKit to take the impl from. */
	PolygonKit(PolygonKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PolygonKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a PolygonKit to take the impl from.
	 * 	\return A reference to this PolygonKit. */
	PolygonKit & operator=(PolygonKit && in_that);

	virtual ~PolygonKit();

	static const HPS::Type staticType = HPS::Type::PolygonKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source PolygonKit into this LineKit and resets the source kit.
	 * 	\param in_kit The source PolygonKit to consume. */
	void				Consume(PolygonKit & in_kit);

	/*! Copies the source PolygonKit into this PolygonKit.
	 * 	\param in_kit The source PolygonKit to copy. */
	void				Set(PolygonKit const & in_kit);

	/*! Copies this PolygonKit into the given PolygonKit.
	 * 	\param out_kit The PolygonKit to populate with the contents of this PolygonKit. */
	void				Show(PolygonKit & out_kit) const;

	/*! Copies the source PolygonKit into this PolygonKit.
	 * 	\param in_kit The source PolygonKit to copy.
	 * 	\return A reference to this PolygonKit. */
	PolygonKit &		operator=(PolygonKit const & in_kit);

	/*! Indicates whether this PolygonKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this PolygonKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source PolygonKit is equivalent to this PolygonKit.
	 *	\param in_kit The source PolygonKit to compare to this PolygonKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(PolygonKit const & in_kit) const;

	/*!	Check if the source PolygonKit is equivalent to this PolygonKit.
	 *	\param in_kit The source PolygonKit to compare to this PolygonKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(PolygonKit const & in_kit) const;

	/*!	Check if the source PolygonKit is not equivalent to this PolygonKit.
	 *	\param in_kit The source PolygonKit to compare to this PolygonKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(PolygonKit const & in_kit) const;

	/*!	Retrieves the number of points in this polygon.
	 *	\return The number of points in this polygon. */
	size_t				GetPointCount() const;

	/*!	Assigns a specific drawing priority value to the PolygonKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	PolygonKit &		SetPriority(int in_priority);

	/*!	Removes a drawing priority setting.
	*	\return A reference to this object. */
	PolygonKit &		UnsetPriority();

	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;


	/*! Sets the points for this PolygonKit.
	 *	\param in_points The points for this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		SetPoints(PointArray const & in_points);

	/*! Sets the points for this PolygonKit.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points for this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		SetPoints(size_t in_count, Point const in_points []);

	/*! Removes the points for this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		UnsetPoints();

	/*! Removes all settings from this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		UnsetEverything();

	/*! Shows the points for this PolygonKit.
	 *	\param out_points The points for this PolygonKit.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this PolygonKit by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this PolygonKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this PolygonKit by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this PolygonKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this PolygonKit by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this PolygonKit.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Add points to this PolygonKit at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKit at which to add points.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to add to this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Add points to this PolygonKit at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKit at which to add points.
	 *	\param in_points The points to add to this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Remove the specified number of points from this PolygonKit at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKit at which to remove points.
	 *	\param in_count The number of points to remove.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replace the specified number of points for this PolygonKit at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKit at which to start replacing points.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to use to replace those on this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replace the specified number of points for this PolygonKit at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKit at which to start replacing points.
	 *	\param in_points The points to use to replace those on this PolygonKit.
	 *	\return A reference to this PolygonKit. */
	PolygonKit &		EditPointsByReplacement(size_t in_offset, PointArray const & in_points);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	PolygonKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	PolygonKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	PolygonKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	PolygonKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	PolygonKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	PolygonKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	PolygonKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The PolygonKey class is a smart pointer to a database object.  It is a handle to a polygon created by SegmentKey::InsertPolygon. */
class HPS_API PolygonKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized PolygonKey object.  The Type() function will return Type::None. */
	PolygonKey();

	/*! This constructor creates an PolygonKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of a polygon key.  Otherwise the copy
	 * 	will fail and the resulting PolygonKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit PolygonKey(Key const & in_that);

	/*! The copy constructor creates a PolygonKey object that shares the underlying smart-pointer of the source PolygonKey.
	 *	\param in_that The source PolygonKey to copy. */
	PolygonKey(PolygonKey const & in_that);

	/*! Associate this PolygonKey with the same underlying impl as the source PolygonKey.
	 *	\param in_that The source PolygonKey for the assignment.
	 *	\return A reference to this PolygonKey. */
	PolygonKey & operator=(PolygonKey const & in_that);

	/*! The move constructor creates a PolygonKey by transferring the underlying impl of the rvalue reference to this PolygonKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PolygonKey to take the impl from. */
	PolygonKey(PolygonKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PolygonKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a PolygonKey to take the impl from.
	 * 	\return A reference to this PolygonKey. */
	PolygonKey & operator=(PolygonKey && in_that);

	~PolygonKey();

	static const HPS::Type staticType = HPS::Type::PolygonKey;
	HPS::Type			ObjectType() const { return staticType; };


	/*! Completely replaces all settings on this PolygonKit with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this PolygonKit. */
	void				Consume(PolygonKit & in_kit);

	/*! Replace those settings on this PolygonKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this PolygonKey. */
	void				Set(PolygonKit const & in_kit);

	/*! Copy the contents of this PolygonKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this PolygonKey. */
	void				Show(PolygonKit & out_kit) const;

	/*!	Retrieves the number of points in this polygon.
	 *	\return The number of points in this polygon. */
	size_t				GetPointCount() const;

	/*! Replace the points on this PolygonKey with the specified points.
	 *	\param in_points The points to use to replace those on this PolygonKey.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		SetPoints(PointArray const & in_points);

	/*! Replace the points on this PolygonKey with the specified points.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to use to replace those on this PolygonKey.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		SetPoints(size_t in_count, Point const in_points []);

	/*! Show the points for this PolygonKey.
	 *	\param out_points The points for this PolygonKey.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(PointArray & out_points) const;

	/*! Show a subset of the points for this PolygonKey by range.
	 *	\param in_start_index The first point to show.
	 *	\param in_count The number of points to show.
	 *	\param out_points The requested points for this PolygonKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByRange(size_t in_start_index, size_t in_count, PointArray & out_points) const;

	/*! Show a subset of the points for this PolygonKey by list.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this PolygonKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(SizeTArray const & in_indices, PointArray & out_points) const;

	/*! Show a subset of the points for this PolygonKey by list.
	 *	\param in_count The number of points to show.
	 *	\param in_indices The list of point indices to show.
	 *	\param out_points The requested points for this PolygonKey.
	 *	\return <span class='code'>true</span> if all requested points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPointsByList(size_t in_count, size_t const in_indices[], PointArray & out_points) const;

	/*! Add points to this PolygonKey at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKey at which to add points.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to add to this PolygonKey.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		EditPointsByInsertion(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Add points to this PolygonKey at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKey at which to add points.
	 *	\param in_points The points to add to this PolygonKey.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		EditPointsByInsertion(size_t in_offset, PointArray const & in_points);

	/*! Remove the specified number of points from this PolygonKey at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKey at which to remove points.
	 *	\param in_count The number of points to remove.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		EditPointsByDeletion(size_t in_offset, size_t in_count);

	/*! Replace the specified number of points for this PolygonKey at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKey at which to start replacing points.
	 *	\param in_count Size of the following array.
	 *	\param in_points The points to use to replace those on this PolygonKey.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		EditPointsByReplacement(size_t in_offset, size_t in_count, Point const in_points[]);

	/*! Replace the specified number of points for this PolygonKey at the specified offset.
	 *	\param in_offset The offset into the points for PolygonKey at which to start replacing points.
	 *	\param in_points The points to use to replace those on this PolygonKey.
	 *	\return A reference to this PolygonKey. */
	PolygonKey &		EditPointsByReplacement(size_t in_offset, PointArray const & in_points);
};




/*! The GridKit class is a user space object.  It is a kit analog to a GridKey. */
class HPS_API GridKit : public Kit
{
public:
	/*! The default constructor creates an empty GridKit object. */
	GridKit();

	/*! The copy constructor creates a new GridKit object that contains the same settings as the source GridKit.
	 * 	\param in_kit The source GridKit to copy. */
	GridKit(GridKit const & in_kit);

	/*! The move constructor creates a GridKit by transferring the underlying object of the rvalue reference to this GridKit.
	 * 	\param in_that An rvalue reference to a GridKit to take the underlying object from. */
	GridKit(GridKit && in_that);

	virtual ~GridKit();

	static const HPS::Type staticType = HPS::Type::GridKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source GridKit into this GridKit and resets the source kit.
	 * 	\param in_kit The source GridKit to consume. */
	void				Consume(GridKit & in_kit);

	/*! Copies the source GridKit into this GridKit.
	 * 	\param in_kit The source GridKit to copy. */
	void				Set(GridKit const & in_kit);

	/*! Copies this GridKit into the given GridKit.
	 * 	\param out_kit The GridKit to populate with the contents of this GridKit. */
	void				Show(GridKit & out_kit) const;

	/*! Copies the source GridKit into this GridKit.
	 * 	\param in_kit The source GridKit to copy.
	 * 	\return A reference to this GridKit. */
	GridKit &			operator=(GridKit const & in_kit);

	/*! The move assignment operator transfers the underlying object of the rvalue reference to this GridKit.
	 * 	\param in_that An rvalue reference to a GridKit to take the underlying object from.
	 * 	\return A reference to this GridKit. */
	GridKit &			operator=(GridKit && in_that);

	/*! Indicates whether this GridKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this GridKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source GridKit is equivalent to this GridKit.
	 *	\param in_kit The source GridKit to compare to this GridKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(GridKit const & in_kit) const;

	/*!	Check if the source GridKit is equivalent to this GridKit.
	 *	\param in_kit The source GridKit to compare to this GridKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(GridKit const & in_kit) const;

	/*!	Check if the source GridKit is not equivalent to this GridKit.
	 *	\param in_kit The source GridKit to compare to this GridKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(GridKit const & in_kit) const;


	/*!	Assigns a specific drawing priority value to the GridKit.  It affects the order in which the contents of this segment
	*	are drawn if and only if the rendering algorithm is set to Priority.
	*	\param in_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return A reference to this object.
	*	\sa SubwindowKit::SetPriority()
	*	\sa SubwindowKit::SetRenderingAlgorithm() */
	GridKit &			SetPriority(int in_priority);

	/*! Sets the type of this GridKit.
	 *	\param in_type The type of this GridKit.
	 *	\return A reference to this GridKit. */
	GridKit &			SetType(Grid::Type in_type);

	/*! Sets the origin for this GridKit.
	 *	\param in_origin The origin for this GridKit.
	 *	\return A reference to this GridKit. */
	GridKit &			SetOrigin(Point const & in_origin);

	/*! Sets the first reference point for this GridKit.  If the type of the grid is Grid::Type::Quadrilateral, this defines the first
	 *	point along one of the vectors defining the grid (the other vector is determined by the second point).  It also determines the
	 *	spacing between the grid lines along the vector.  If the type of the grid is Grid::Type::Radial, this defines the first point
	 *	along the radius vector which will intersect with the circular grid arcs.
	 *	\param in_first_point The first reference point for this GridKit.
	 *	\return A reference to this GridKit. */
	GridKit &			SetFirstPoint(Point const & in_first_point);

	/*! Sets the second reference point for this GridKit.  If the type of the grid Grid::Type::Quadrilateral, this defines the first
	 *	point along the second vector defining the grid (the other vector is determined by the first point).  It also determines the
	 *	spacing between the grid lines along the vector.  If the type of the grid is Grid::Type::Radial, this defines the first point
	 *	on the first circular arc which intersects with the radial vectors, and determines the spacing of the arcs along the radial
	 *	vectors.
	 *	\param in_second_point The second reference point for this GridKit.
	 *	\return A reference to this GridKit. */
	GridKit &			SetSecondPoint(Point const & in_second_point);

	/*! Sets the first reference count for this GridKit, i.e., the number of grid elements along the vector determined by the first
	 *	reference point.  If the type of the grid is Grid::Type::Quadrilateral, there are three type of behavior depending on if the
	 *	count is greater than zero, less than zero, or equal to zero.  If the count is greater than zero, the count determines the
	 *	finite number of grid lines which will intersect with the vector determined by the first reference point.  If the count is less
	 *	than zero, the count determines the finite number of grid lines which will intersect with the vector determined by the first
	 *	reference point and additionally that same number of intersections along the negation of that vector.  Lastly, if the count is
	 *	zero, the grid will extend infinitely along the vector determined by the first reference point and its negation.  If the type of
	 *	the grid is Grid::Type::Radial, there are two types of behavior depending on if the count is greater than zero or equal to zero.
	 *  If the count is greater than zero, it determines the finite number of circular arcs which will intersect with the radial vectors.
	 *	If the count is equal to zero, there will be an infinite number of intersections along the radial arcs.  Negative counts are
	 *	invalid in this case.
	 *	\param in_first_count The count of the number of grid elements along the vector determined by the first reference point.
	 *	\return A reference to this GridKit. */
	GridKit &			SetFirstCount(int in_first_count);

	/*! Sets the second reference count for this GridKit, i.e., the number of grid elements along the vector determined by the second
	 *	reference point.  If the type of the grid is Grid::Type::Quadrilateral, there are three type of behavior depending on if the
	 *	count is greater than zero, less than zero, or equal to zero.  If the count is greater than zero, the count determines the finite
	 *	number of grid lines which will intersect with the vector determined by the second reference point.  If the count is less than zero,
	 *	the count determines the finite number of grid lines which will intersect with the vector determined by the second reference point
	 *	and additionally that same number of intersections along the negation of that vector.  Lastly, if the count is zero, the grid will
	 *	extend infinitely along the vector determined by the second reference point and its negation.  If the type of the grid is
	 *	Grid::Type::Radial, the count determines the number of radial vectors for the grid.
	 *	\param in_second_count The count of the number of grid elements along the vector determined by the second reference point.
	 *	\return A reference to this GridKit. */
	GridKit &			SetSecondCount(int in_second_count);


	/*!	Removes a drawing priority setting.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetPriority();

	/*!	Removes the type from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetType();

	/*!	Removes the origin from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetOrigin();

	/*!	Removes the first reference point from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetFirstPoint();

	/*!	Removes the second reference point from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetSecondPoint();

	/*! Removes the first reference count from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetFirstCount();

	/*! Removes the second reference count from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetSecondCount();

	/*!	Removes the all settings from this GridKit.
	*	\return A reference to this GridKit. */
	GridKit &			UnsetEverything();


	/*! Shows the drawing priority.
	*	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Shows the type for this GridKit.
	 *	\param out_type The type for this GridKit.
	 *	\return <span class='code'>true</span> if a type was set, <span class='code'>false</span> otherwise. */
	bool				ShowType(Grid::Type & out_type) const;

	/*! Shows the origin for this GridKit.
	 *	\param out_origin The origin for this GridKit.
	 *	\return <span class='code'>true</span> if an origin was set, <span class='code'>false</span> otherwise. */
	bool				ShowOrigin(Point & out_origin) const;

	/*! Shows the first reference point for this GridKit.
	 *	\param out_first_point The first reference point for this GridKit.
	 *	\return <span class='code'>true</span> if a first reference point was set, <span class='code'>false</span> otherwise. */
	bool				ShowFirstPoint(Point & out_first_point) const;

	/*! Shows the second reference point for this GridKit.
	 *	\param out_second_point The second reference point for this GridKit.
	 *	\return <span class='code'>true</span> if a second reference point was set, <span class='code'>false</span> otherwise. */
	bool				ShowSecondPoint(Point & out_second_point) const;

	/*! Shows the first reference count for this GridKit.
	 *	\param out_first_count The first reference count for this GridKit.
	 *	\return <span class='code'>true</span> if a first reference count was set, <span class='code'>false</span> otherwise. */
	bool				ShowFirstCount(int & out_first_count) const;

	/*! Shows the second reference count for this GridKit.
	 *	\param out_second_count The second reference count for this GridKit.
	 *	\return <span class='code'>true</span> if a second reference count was set, <span class='code'>false</span> otherwise. */
	bool				ShowSecondCount(int & out_second_count) const;

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_bytes The number of bytes of user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	GridKit &			SetUserData(intptr_t in_index, size_t in_bytes, byte const in_data[]);

	/*! Sets user data on this kit.
	 *	\param in_index The index of the user data to set.
	 *	\param in_data The bytes of user data to set.
	 *	\return A reference to this kit. */
	GridKit &			SetUserData(intptr_t in_index, ByteArray const & in_data);

	/*! Sets user data on this kit.
	 *	\param in_indices An array of user data indices to set.
	 *	\param in_data An array of bytes of user data to set.
	 *	\return A reference to this kit. */
	GridKit &			SetUserData(IntPtrTArray const & in_indices, ByteArrayArray const & in_data);

	/*! Removes the user data at the given index from this kit.
	 *	\param in_index The index of the user data to remove.
	 *	\return A reference to this kit. */
	GridKit &			UnsetUserData(intptr_t in_index);

	/*! Removes the user data at the given indices from this kit.
	 *  \param in_count The size of the following array.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	GridKit &			UnsetUserData(size_t in_count, intptr_t const in_indices[]);

	/*! Removes the user data at the given indices from this kit.
	 *	\param in_indices The indices of the user data to remove.
	 *	\return A reference to this kit. */
	GridKit &			UnsetUserData(IntPtrTArray const & in_indices);

	/*! Removes all user data from this kit.
	 *	\return A reference to this kit. */
	GridKit &			UnsetAllUserData();

	/*! Get the number of user data indices set on this kit. */
	size_t				ShowUserDataCount() const;

	/*! Shows the indices of all user data set on this kit.
	 *	\param out_indices The user data indices set on this kit.
	 *	\return The number of user data indices set on this kit. */
	bool				ShowUserDataIndices(IntPtrTArray & out_indices) const;

	/*! Shows the user data at a given index for this kit.
	 *	\param in_index The index of the user data to show.
	 *	\param out_data The user data at the given index.
	 *	\return <span class='code'>true</span> if there is user data at the given index, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(intptr_t in_index, ByteArray & out_data) const;

	/*! Shows all user data for this kit.
	 *	\param out_indices An array of all user data indices set on this kit.
	 *	\param out_data An array of all user data set on this kit.
	 *	\return <span class='code'>true</span> if there is user data on this kit, <span class='code'>false</span> otherwise. */
	bool				ShowUserData(IntPtrTArray & out_indices, ByteArrayArray & out_data) const;
};


/*! The GridKey class is a smart pointer to a database object.  It is a handle to a grid created by SegmentKey::InsertGrid. */
class HPS_API GridKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized GridKey object.  The Type() function will return Type::None. */
	GridKey();

	/*! This constructor creates an GridKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of a grid key.  Otherwise the copy
	 * 	will fail and the resulting GridKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit GridKey(Key const & in_that);

	/*! The copy constructor creates a GridKey object that shares the underlying smart-pointer of the source GridKey.
	 *	\param in_that The source GridKey to copy. */
	GridKey(GridKey const & in_that);

	/*! The move constructor creates a GridKey by transferring the underlying object of the rvalue reference to this GridKey.
	 * 	\param in_that An rvalue reference to a GridKey to take the underlying object from. */
	GridKey(GridKey && in_that);

	/*! Associate this GridKey with the same underlying object as the source GridKey.
	 *	\param in_that The source GridKey for the assignment.
	 *	\return A reference to this GridKey. */
	GridKey & operator=(GridKey const & in_that);

	/*! The move assignment operator transfers the underlying object of the rvalue reference to this GridKey.
	 * 	\param in_that An rvalue reference to a GridKey to take the underlying object from.
	 * 	\return A reference to this GridKey. */
	GridKey & operator=(GridKey && in_that);

	~GridKey();

	static const HPS::Type staticType = HPS::Type::GridKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Completely replaces all settings on this GridKey with those set on the specified kit and resets the kit.
	 *	\param in_kit The kit from which to get the settings to replace on this GridKey. */
	void				Consume(GridKit & in_kit);

	/*! Replace those settings on this GridKey with those set on the specified kit.
	 *	\param in_kit The kit from which to get the settings to replace on this GridKey. */
	void				Set(GridKit const & in_kit);

	/*! Copy the contents of this GridKey into the specified kit.
	 *	\param out_kit The kit to populate with the contents of this GridKey. */
	void				Show(GridKit & out_kit) const;


	/*! Sets the type of this GridKey.
	 *	\param in_type The type of this GridKey.
	 *	\return A reference to this GridKey. */
	GridKey &			SetType(Grid::Type in_type);

	/*! Sets the origin for this GridKey.
	 *	\param in_origin The origin for this GridKey.
	 *	\return A reference to this GridKey. */
	GridKey &			SetOrigin(Point const & in_origin);

	/*! Sets the first reference point for this GridKey.  If the type of the grid is Grid::Type::Quadrilateral, this defines the first
	 *	point along one of the vectors defining the grid (the other vector is determined by the second point).  It also determines the
	 *	spacing between the grid lines along the vector.  If the type of the grid is Grid::Type::Radial, this defines the first point
	 *	along the radius vector which will intersect with the circular grid arcs.
	 *	\param in_first_point The first reference point for this GridKey.
	 *	\return A reference to this GridKey. */
	GridKey &			SetFirstPoint(Point const & in_first_point);

	/*! Sets the second reference point for this GridKey.  If the type of the grid Grid::Type::Quadrilateral, this defines the first
	 *	point along the second vector defining the grid (the other vector is determined by the first point).  It also determines the
	 *	spacing between the grid lines along the vector.  If the type of the grid is Grid::Type::Radial, this defines the first point
	 *	on the first circular arc which intersects with the radial vectors, and determines the spacing of the arcs along the radial
	 *	vectors.
	 *	\param in_second_point The second reference point for this GridKey.
	 *	\return A reference to this GridKey. */
	GridKey &			SetSecondPoint(Point const & in_second_point);

	/*! Sets the first reference count for this GridKey, i.e., the number of grid elements along the vector determined by the first
	 *	reference point.  If the type of the grid is Grid::Type::Quadrilateral, there are three type of behavior depending on if the
	 *	count is greater than zero, less than zero, or equal to zero.  If the count is greater than zero, the count determines the
	 *	finite number of grid lines which will intersect with the vector determined by the first reference point.  If the count is less
	 *	than zero, the count determines the finite number of grid lines which will intersect with the vector determined by the first
	 *	reference point and additionally that same number of intersections along the negation of that vector.  Lastly, if the count is
	 *	zero, the grid will extend infinitely along the vector determined by the first reference point and its negation.  If the type of
	 *	the grid is Grid::Type::Radial, there are two types of behavior depending on if the count is greater than zero or equal to zero.
	 *  If the count is greater than zero, it determines the finite number of circular arcs which will intersect with the radial vectors.
	 *	If the count is equal to zero, there will be an infinite number of intersections along the radial arcs.  Negative counts are
	 *	invalid in this case.
	 *	\param in_first_count The count of the number of grid elements along the vector determined by the first reference point.
	 *	\return A reference to this GridKey. */
	GridKey &			SetFirstCount(int in_first_count);

	/*! Sets the second reference count for this GridKey, i.e., the number of grid elements along the vector determined by the second
	 *	reference point.  If the type of the grid is Grid::Type::Quadrilateral, there are three type of behavior depending on if the
	 *	count is greater than zero, less than zero, or equal to zero.  If the count is greater than zero, the count determines the finite
	 *	number of grid lines which will intersect with the vector determined by the second reference point.  If the count is less than zero,
	 *	the count determines the finite number of grid lines which will intersect with the vector determined by the second reference point
	 *	and additionally that same number of intersections along the negation of that vector.  Lastly, if the count is zero, the grid will
	 *	extend infinitely along the vector determined by the second reference point and its negation.  If the type of the grid is
	 *	Grid::Type::Radial, the count determines the number of radial vectors for the grid.
	 *	\param in_second_count The count of the number of grid elements along the vector determined by the second reference point.
	 *	\return A reference to this GridKey. */
	GridKey &			SetSecondCount(int in_second_count);



	/*! Shows the type for this GridKey.
	 *	\param out_type The type for this GridKey.
	 *	\return <span class='code'>true</span> if a type was set, <span class='code'>false</span> otherwise. */
	bool				ShowType(Grid::Type & out_type) const;

	/*! Shows the origin for this GridKey.
	 *	\param out_origin The origin for this GridKey.
	 *	\return <span class='code'>true</span> if an origin was set, <span class='code'>false</span> otherwise. */
	bool				ShowOrigin(Point & out_origin) const;

	/*! Shows the first reference point for this GridKey.
	 *	\param out_first_point The first reference point for this GridKey.
	 *	\return <span class='code'>true</span> if a first reference point was set, <span class='code'>false</span> otherwise. */
	bool				ShowFirstPoint(Point & out_first_point) const;

	/*! Shows the second reference point for this GridKey.
	 *	\param out_second_point The second reference point for this GridKey.
	 *	\return <span class='code'>true</span> if a second reference point was set, <span class='code'>false</span> otherwise. */
	bool				ShowSecondPoint(Point & out_second_point) const;

	/*! Shows the first reference count for this GridKey.
	 *	\param out_first_count The first reference count for this GridKey.
	 *	\return <span class='code'>true</span> if a first reference count was set, <span class='code'>false</span> otherwise. */
	bool				ShowFirstCount(int & out_first_count) const;

	/*! Shows the second reference count for this GridKey.
	 *	\param out_second_count The second reference count for this GridKey.
	 *	\return <span class='code'>true</span> if a second reference count was set, <span class='code'>false</span> otherwise. */
	bool				ShowSecondCount(int & out_second_count) const;
};




/*! The IncludeKey class is a smart pointer to a database object.  It is a handle to an include key created by SegmentKey::IncludeSegment. */
class HPS_API IncludeKey : public Key
{
public:
	/*! The default constructor creates an uninitialized IncludeKey object.  The Type() function will return Type::None. */
	IncludeKey();

	/*! This constructor creates an IncludeKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of an include key.  Otherwise the copy
	 * 	will fail and the resulting IncludeKey will be invalid.
	 *	\param in_that The source Key to copy. */
	explicit IncludeKey(Key const & in_that);

	/*! The copy constructor creates a IncludeKey object that shares the underlying smart-pointer of the source IncludeKey.
	 *	\param in_that The source IncludeKey to copy. */
	IncludeKey(IncludeKey const & in_that);

	/*! Associate this IncludeKey with the same underlying impl as the source IncludeKey.
	 *	\param in_that The source IncludeKey for the assignment.
	 *	\return A reference to this IncludeKey. */
	IncludeKey & operator=(IncludeKey const & in_that);

	/*! The move constructor creates an IncludeKey by transferring the underlying impl of the rvalue reference to this IncludeKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an IncludeKey to take the impl from. */
	IncludeKey(IncludeKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this IncludeKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an IncludeKey to take the impl from.
	 * 	\return A reference to this IncludeKey. */
	IncludeKey & operator=(IncludeKey && in_that);

	~IncludeKey();


	static const HPS::Type staticType = HPS::Type::IncludeKey;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Gets the target, i.e., the segment to be included, for this IncludeKey.
	 *	\return The target, i.e., the segment to be included, for this IncludeKey. */
	SegmentKey			GetTarget() const;


	/*!	Assigns a specific drawing priority value of an include.  It affects the order in which the include is visited, if and only if the rendering algorithm is set to Priority.
	 *	\param in_priority The drawing priority, higher priority items are visited before lower priority items.
	 *	\return A reference to this object.
	 *	\sa SubwindowKit::SetRenderingAlgorithm() */
	IncludeKey &		SetPriority(int in_priority);

	/*! Sets a conditional expression on this IncludeKey.  This will either make an unconditional include into a conditional include, or modify the condition for an existing conditional include.
	 *	The target segment referenced by this include will only be included if a condition satisfying the given conditional expression is set above this include in the tree.
	 *	\param in_conditional The conditional expression for this IncludeKey.
	 *	\return A reference to this IncludeKey.
	 *	\sa SegmentKey::SetCondition
	 *	\sa ConditionControl::SetCondition
	 *	\sa ConditionControl::AddCondition */
	IncludeKey &		SetConditionalExpression(ConditionalExpression const & in_conditional);


	/*!	Removes a drawing priority setting.
	 *	\return A reference to this object. */
	IncludeKey &		UnsetPriority();

	/*! Removes the conditional expression on this IncludeKey.  This will turn a conditional include into an unconditional include.
	 *	\return A reference to this IncludeKey. */
	IncludeKey &		UnsetConditionalExpression();


	/*! Shows the drawing priority.
	 *	\param out_priority The drawing priority, higher priority items are drawn on top of lower priority items.
	 *	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool				ShowPriority(int & out_priority) const;

	/*! Shows the conditional expression for this IncludeKey.
	 *	\param out_conditional The conditional expression for this IncludeKey.
	 *	\return <span class='code'>true</span> if a conditional expression is set on this IncludeKey, <span class='code'>false</span> otherwise. */
	bool				ShowConditionalExpression(ConditionalExpression & out_conditional) const;

	/*! Sets an attribute filter on this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_type The attribute filter to set for this IncludeKey.
	*	\return A reference to this IncludeKey.
	*	\sa IncludeKey::UnsetFilter
	*	\sa IncludeKey::ShowFilter */
	IncludeKey & SetFilter(AttributeLock::Type in_type);

	/*! Sets an array of attribute filters on this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_count The size of the attribute filter array.
	*	\param in_types The array of attribute filters to set for this IncludeKey.
	*	\return A reference to this IncludeKey.
	*	\sa IncludeKey::UnsetFilter
	*	\sa IncludeKey::ShowFilter */
	IncludeKey & SetFilter(size_t in_count, AttributeLock::Type const in_types[]);

	/*! Sets an array of attribute filters on this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_types The array of attribute filters to set for this IncludeKey.
	*	\return A reference to this IncludeKey.
	*	\sa IncludeKey::UnsetFilter
	*	\sa IncludeKey::ShowFilter */
	IncludeKey & SetFilter(AttributeLockTypeArray const & in_types);

	/*! Removes an attribute filter from this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_type The attribute filter to remove from this IncludeKey.
	*	\return A reference to this IncludeKey.
	*	\sa IncludeKey::SetFilter
	*	\sa IncludeKey::ShowFilter */
	IncludeKey & UnsetFilter(AttributeLock::Type in_type);

	/*! Removes an array of attribute filters from this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_count The size of the attribute filter array.
	*	\param in_types The array of attribute filters to remove from this IncludeKey.
	*	\return A reference to this IncludeKey.
	*	\sa IncludeKey::SetFilter
	*	\sa IncludeKey::ShowFilter */
	IncludeKey & UnsetFilter(size_t in_count, AttributeLock::Type const in_types[]);

	/*! Removes an array of attribute filters from this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_types The array of attribute filters to remove from this IncludeKey.
	*	\return A reference to this IncludeKey.
	*	\sa IncludeKey::SetFilter
	*	\sa IncludeKey::ShowFilter */
	IncludeKey & UnsetFilter(AttributeLockTypeArray const & in_types);

	/*! Shows an array of the current attribute filters on this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param out_types The array of attribute filters currently set on this IncludeKey.
	*	\return <span class='code'>true</span> if there are attribute filters, <span class='code'>false</span> otherwise.
	*	\sa IncludeKey::SetFilter
	*	\sa IncludeKey::UnsetFilter */
	bool ShowFilter(AttributeLockTypeArray & out_types) const;

	/*! Tests if a specific attribute filter is set on this IncludeKey.  Attribute filters block the specified attributes set in the tree rooted at the target segment from taking effect for this IncludeKey.
	*	\param in_type The attribute filter to test on this IncludeKey.
	*	\return <span class='code'>true</span> if the specified atribute filter is active on this IncludeKey, <span class='code'>false</span> otherwise.
	*	\sa IncludeKey::SetFilter
	*	\sa IncludeKey::UnsetFilter */
	bool ShowFilter(HPS::AttributeLock::Type in_type) const;
};



/*! The StyleKey class is a smart pointer to a database object.  It is a handle to a style key created by StyleControl::PushSegment. */
class HPS_API StyleKey : public Key
{
public:
	/*! The default constructor creates an uninitialized StyleKey object.  The Type() function will return Type::None. */
	StyleKey();

	/*! This constructor creates an StyleKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of a style key.  Otherwise the copy
	 * 	will fail and the resulting StyleKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit StyleKey(Key const & in_that);

	/*! The copy constructor creates a StyleKey object that shares the underlying smart-pointer of the source StyleKey.
	 *	\param in_that The source StyleKey to copy. */
	StyleKey(StyleKey const & in_that);

	/*! Associate this StyleKey with the same underlying impl as the source StyleKey.
	 *	\param in_that The source StyleKey for the assignment.
	 *	\return A reference to this StyleKey. */
	StyleKey & operator=(StyleKey const & other);

	/*! The move constructor creates a StyleKey by transferring the underlying impl of the rvalue reference to this StyleKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a StyleKey to take the impl from. */
	StyleKey(StyleKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this StyleKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a StyleKey to take the impl from.
	 * 	\return A reference to this StyleKey. */
	StyleKey & operator=(StyleKey && in_that);

	~StyleKey();

	static const HPS::Type staticType = HPS::Type::StyleKey;
	HPS::Type			ObjectType() const { return staticType; };


	/*!	Shows the source for this StyleKey.
	 *	\param out_type The type of source for this StyleKey.  This field indicates which of the following arguments are valid.
	 *	\param out_segment The segment source for this StyleKey.  This is only valid if <span class='code'>out_type</span> is Style::Type::Segment.
	 *	\param out_name The name source for this StyleKey.  This is only valid if <span class='code'>out_type</span> is Style::Type::Named.
	 *	\return <span class='code'>true</span> if there is a source for this StyleKey, <span class='code'>false</span> otherwise. */
	bool				ShowSource(Style::Type & out_type, SegmentKey & out_segment, UTF8 & out_name) const;


	/*! Sets a conditional expression on this StyleKey.  This will either make an unconditional style into a conditional style, or modify the condition for an existing conditional style.
	 *	The target segment referenced by this style will only be styled in if a condition satisfying the given conditional expression is set above this style in the tree.
	 *	\param in_conditional The conditional expression for this StyleKey.
	 *	\return A reference to this StyleKey.
	 *	\sa SegmentKey::SetCondition
	 *	\sa ConditionControl::SetCondition
	 *	\sa ConditionControl::AddCondition */
	StyleKey &			SetConditionalExpression(ConditionalExpression const & in_conditional);


	/*! Removes the conditional expression on this StyleKey.  This will turn a conditional style into an unconditional style.
	 *	\return A reference to this StyleKey. */
	StyleKey &			UnsetConditionalExpression();


	/*! Shows the conditional expression for this StyleKey.
	 *	\param out_conditional The conditional expression for this StyleKey.
	 *	\return <span class='code'>true</span> if a conditional expression is set on this StyleKey, <span class='code'>false</span> otherwise. */
	bool				ShowConditionalExpression(ConditionalExpression & out_conditional) const;


	/*! Sets an attribute filter on this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_type The attribute filter to set for this StyleKey.
	*	\return A reference to this StyleKey.
	*	\sa StyleKey::UnsetFilter
	*	\sa StyleKey::ShowFilter */
	StyleKey & SetFilter(AttributeLock::Type in_type);

	/*! Sets an array of attribute filters on this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_count The size of the attribute filter array.
	*	\param in_types The array of attribute filters to set for this StyleKey.
	*	\return A reference to this StyleKey.
	*	\sa StyleKey::UnsetFilter
	*	\sa StyleKey::ShowFilter */
	StyleKey & SetFilter(size_t in_count, AttributeLock::Type const in_types[]);

	/*! Sets an array of attribute filters on this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_types The array of attribute filters to set for this StyleKey.
	*	\return A reference to this StyleKey.
	*	\sa StyleKey::UnsetFilter
	*	\sa StyleKey::ShowFilter */
	StyleKey & SetFilter(AttributeLockTypeArray const & in_types);

	/*! Removes an attribute filter from this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_type The attribute filter to remove from this StyleKey.
	*	\return A reference to this StyleKey.
	*	\sa StyleKey::SetFilter
	*	\sa StyleKey::ShowFilter */
	StyleKey & UnsetFilter(AttributeLock::Type in_type);

	/*! Removes an array of attribute filters from this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_count The size of the attribute filter array.
	*	\param in_types The array of attribute filters to remove from this StyleKey.
	*	\return A reference to this StyleKey.
	*	\sa StyleKey::SetFilter
	*	\sa StyleKey::ShowFilter */
	StyleKey & UnsetFilter(size_t in_count, AttributeLock::Type const in_types[]);

	/*! Removes an array of attribute filters from this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_types The array of attribute filters to remove from this StyleKey.
	*	\return A reference to this StyleKey.
	*	\sa StyleKey::SetFilter
	*	\sa StyleKey::ShowFilter */
	StyleKey & UnsetFilter(AttributeLockTypeArray const & in_types);

	/*! Shows an array of the current attribute filters on this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param out_types The array of attribute filters currently set on this StyleKey.
	*	\return <span class='code'>true</span> if there are attribute filters, <span class='code'>false</span> otherwise.
	*	\sa StyleKey::SetFilter
	*	\sa StyleKey::UnsetFilter */
	bool ShowFilter(AttributeLockTypeArray & out_types) const;

	/*! Tests if a specific attribute filter is set on this StyleKey.  Attribute filters block the specified attributes set on the source style segment from taking effect for this StyleKey.
	*	\param in_type The attribute filter to test on this StyleKey.
	*	\return <span class='code'>true</span> if the specified atribute filter is active on this StyleKey, <span class='code'>false</span> otherwise.
	*	\sa StyleKey::SetFilter
	*	\sa StyleKey::UnsetFilter */
	bool ShowFilter(HPS::AttributeLock::Type in_type) const;
};



/*! The ReferenceKey class is a smart pointer to a database object.  It is a handle to a geometry reference returned by SegmentKey::ReferenceGeometry. */
class HPS_API ReferenceKey : public GeometryKey
{
public:
	/*! The default constructor creates an uninitialized ReferenceKey object.  The Type() function will return Type::None. */
	ReferenceKey();

	/*! This constructor creates an ReferenceKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of a reference key.  Otherwise the copy
	 * 	will fail and the resulting ReferenceKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit ReferenceKey(Key const & in_that);

	/*! The copy constructor creates a ReferenceKey object that shares the underlying smart-pointer of the source ReferenceKey.
	 *	\param in_that The source ReferenceKey to copy. */
	ReferenceKey(ReferenceKey const & in_that);

	/*! Associate this ReferenceKey with the same underlying impl as the source ReferenceKey.
	 *	\param in_that The source ReferenceKey for the assignment.
	 *	\return A reference to this ReferenceKey. */
	ReferenceKey & operator=(ReferenceKey const & in_that);

	/*! The move constructor creates a ReferenceKey by transferring the underlying impl of the rvalue reference to this ReferenceKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ReferenceKey to take the impl from. */
	ReferenceKey(ReferenceKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ReferenceKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ReferenceKey to take the impl from.
	 * 	\return A reference to this ReferenceKey. */
	ReferenceKey & operator=(ReferenceKey && in_that);

	~ReferenceKey();

	static const HPS::Type staticType = HPS::Type::ReferenceKey;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Gets the geometry or segment key that was used to create this ReferenceKey.
	 * If multiple geometry are referenced only the first is returned.
	 *	\return The geometry or segment key that was used to create this ReferenceKey. */
	Key									GetTarget() const;

	/*! Gets the count of geometry keys or a segment key targeted by this ReferenceKey.
	 * 	\param masked If true a geometry mask if present will be applied to the results.
	 * 	\return A count of targeted geometries or a segment from this reference. */
	size_t								ShowTargets(bool masked=true) const;

	/*! Gets the geometries keys or a segment key targeted by this ReferenceKey.
	 * 	\param out_keys The keys targeted by this reference.
	 * 	\param masked If true a geometry mask if present will be applied to the results.
	 * 	\return A count of targeted geometries or segment from this reference and populates out_keys with their keys. */
	size_t								ShowTargets(KeyArray & out_keys, bool masked=true) const;

	/*! Gets the count of masked geometry types.  Only the geometry types included in the mask will be processed by this ReferenceKey.
	 *	If no mask was explicitly set the mask size is one and the value is HPS::Search::Type::Geometry.
	 * 	\return A count of masked geometry types from this reference. */
	size_t								ShowGeometryMask() const;

	/*! Gets the masked geometry types.  Only the geometry types included in the mask will be processed by this ReferenceKey.
	 *	If no mask was explicitly set the mask size is one and the value is HPS::Search::Type::Geometry.
	 * 	\param out_geometry_types The geometry types processed by this reference.
	 * 	\return A count of masked geometry types from this reference. */
	size_t								ShowGeometryMask(SearchTypeArray & out_geometry_types) const;

	/*! Sets the specified material mappings on this ReferenceKey. This function will not override colors set directly on the original geometry. Light colors and Window colors are not valid on a ReferenceKey.
	*	\param in_kit The material mappings to set on this ReferenceKey.
	*	\return A reference to this ReferenceKey. */
	ReferenceKey &						SetMaterialMapping(MaterialMappingKit const & in_kit);

	/*! Removes all material mapping settings from this ReferenceKey. */
	ReferenceKey &						UnsetMaterialMapping();

	/*! Shows the material mapping settings on this segment.  Returns <span class='code'>false</span> if no material mapping settings exist on this ReferenceKey. */
	bool								ShowMaterialMapping(MaterialMappingKit & out_kit) const;

	/*! Sets the masked geometry types.  Only the geometry types included in the mask will be processed by this ReferenceKey.
	 *	Set HPS::Search::Type::Geometry to process all geometry types.
	 * 	\param in_geometry_types The geometry types to be processed by this reference. */
	ReferenceKey &						SetGeometryMask(SearchTypeArray const & in_geometry_types);

	/*! Resets the masked geometry types on this ReferenceKey to HPS::Search::Type::Geometry.
	 *	\return A reference to this ReferenceKey. */
	ReferenceKey &						UnsetGeometryMask();

	/*! Sets the specified modelling matrix on this reference.
	 *	\param in_kit The modelling matrix to set on this reference. */
	void								SetModellingMatrix(MatrixKit const & in_kit);

	/*! Sets a conditional expression on this ReferenceKey.  This will either make an unconditional reference into a conditional reference, or modify the condition for an existing
	 *	conditional reference.  The target geometry or segment referenced by this reference will only be drawn in the owning segment if a condition satisfying the given conditional expression is set above this
	 *	reference in the tree.
	 *	\param in_conditional The conditional expression for this ReferenceKey.
	 *	\return A reference to this ReferenceKey.
	 *	\sa SegmentKey::SetCondition
	 *	\sa ConditionControl::SetCondition
	 *	\sa ConditionControl::AddCondition */
	ReferenceKey &						SetConditionalExpression(ConditionalExpression const & in_conditional);


	/*! Removes the modelling matrix on this geometry reference. */
	void								UnsetModellingMatrix();

	/*! Removes the conditional expression on this ReferenceKey.  This will turn a conditional reference into an unconditional reference.
	 *	\return A reference to this ReferenceKey. */
	ReferenceKey &						UnsetConditionalExpression();


	/*! Shows the modelling matrix on this reference.
	 *	\param out_kit The modelling matrix set on this reference.
	 *	\return <span class='code'>true</span> if a modelling matrix was set, <span class='code'>false</span> otherwise. */
	bool								ShowModellingMatrix(MatrixKit & out_kit) const;

	/*! Shows the conditional expression for this ReferenceKey.
	 *	\param out_conditional The conditional expression for this ReferenceKey.
	 *	\return <span class='code'>true</span> if a conditional expression is set on this ReferenceKey, <span class='code'>false</span> otherwise. */
	bool								ShowConditionalExpression(ConditionalExpression & out_conditional) const;


	/*! Gets a control that allows querying and modifying modelling matrices set on this reference.
	 * 	\return A control that allows querying and modifying modelling matrices set on this reference. */
	ModellingMatrixControl				GetModellingMatrixControl();

	/*! Gets a control that allows querying modelling matrices set on this reference.
	 * 	\return A control that allows querying modelling matrices set on this reference. */
	ModellingMatrixControl const		GetModellingMatrixControl() const;
};


#if TARGET_OS_ANDROID == 0 && !defined(__APPLE__)
/*!

<p>The StandAloneWindowOptionsKit class is a user space object. It is used to specify stand-alone-window-specific options Calling HPS::StandAloneWindowOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#window-options">this table</a>.</p>
<p>Standalone windows are not supported on Android, iOS, or macOS as all GUI / windowing is controlled at the application level.</p>
*/
class HPS_API StandAloneWindowOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty StandAloneWindowOptionsKit object. */
	StandAloneWindowOptionsKit();

	/*! The copy constructor creates a new StandAloneWindowOptionsKit object that contains the same settings as the source StandAloneWindowOptionsKit.
	 * 	\param in_kit The source StandAloneWindowOptionsKit to copy. */
	StandAloneWindowOptionsKit(StandAloneWindowOptionsKit const & in_kit);

	/*! The move constructor creates a StandAloneWindowOptionsKit by transferring the underlying impl of the rvalue reference to this StandAloneWindowOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a StandAloneWindowOptionsKit to take the impl from. */
	StandAloneWindowOptionsKit(StandAloneWindowOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this StandAloneWindowOptionsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a StandAloneWindowOptionsKit to take the impl from.
	 * 	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit & operator=(StandAloneWindowOptionsKit && in_that);

	virtual ~StandAloneWindowOptionsKit();

	static const HPS::Type staticType = HPS::Type::StandAloneWindowOptionsKit;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Creates an StandAloneWindowOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return An StandAloneWindowOptionsKit with the default settings. */
	static StandAloneWindowOptionsKit 	GetDefault();

	/*! Copies the source StandAloneWindowOptionsKit into this StandAloneWindowOptionsKit.
	 * 	\param in_kit The source StandAloneWindowOptionsKit to copy. */
	void								Set(StandAloneWindowOptionsKit const & in_kit);

	/*! Copies this StandAloneWindowOptionsKit into the given StandAloneWindowOptionsKit.
	 * 	\param out_kit The StandAloneWindowOptionsKit to populate with the contents of this StandAloneWindowOptionsKit. */
	void								Show(StandAloneWindowOptionsKit & out_kit) const;

	/*! Copies the source StandAloneWindowOptionsKit into this StandAloneWindowOptionsKit.
	 * 	\param in_kit The source StandAloneWindowOptionsKit to copy.
	 * 	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		operator=(StandAloneWindowOptionsKit const & in_kit);

	/*! Indicates whether this StandAloneWindowOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this StandAloneWindowOptionsKit, <span class='code'>false</span> otherwise. */
	bool								Empty() const;

	/*!	Check if the source StandAloneWindowOptionsKit is equivalent to this StandAloneWindowOptionsKit.
	 *	\param in_kit The source StandAloneWindowOptionsKit to compare to this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								Equals(StandAloneWindowOptionsKit const & in_kit) const;

	/*!	Check if the source StandAloneWindowOptionsKit is equivalent to this StandAloneWindowOptionsKit.
	 *	\param in_kit The source StandAloneWindowOptionsKit to compare to this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								operator==(StandAloneWindowOptionsKit const & in_kit) const;

	/*!	Check if the source StandAloneWindowOptionsKit is not equivalent to this StandAloneWindowOptionsKit.
	 *	\param in_kit The source StandAloneWindowOptionsKit to compare to this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool								operator!=(StandAloneWindowOptionsKit const & in_kit) const;

	/*! Sets the driver for this StandAloneWindowOptionsKit.
	 * 	\param in_driver The driver for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		SetDriver(Window::Driver in_driver);

	/*! Sets the anti-alias options for this StandAloneWindowOptionsKit.
	 * 	\param in_state Whether the associated application window should be anti-alias capable.
	 * 	\param in_samples The number of anti-alias samples to use for the associated stand-alone window.  Defaults to <span class='code'>4</span>.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		SetAntiAliasCapable(bool in_state, unsigned int in_samples = 4);

	/*!	Manipulates the state of screen anti-aliasing.
	*	\param in_state Whether screen anti-aliasing should be used.
	*	\return A reference to this object. */
	StandAloneWindowOptionsKit &		SetScreenAntiAliasing(bool in_state);

	/*! Sets the title for this StandAloneWindowOptionsKit.
	 * 	\param in_window_name UTF8-encoded title for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		SetTitle(char const * in_window_name);

	/*! Sets the subscreen to render into for this StandAloneWindowOptionsKit.
	 *	\param in_subscreen The subscreen to render into for this StandAloneWindowOptionsKit.  The units of the Rectangle are in window space, so <span class='code'>-1.0f</span> corresponds to the
	 *		left (or bottom) of the window and <span class='code'>1.0f</span> corresponds to the right (or top) of the window.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		SetSubscreen(Rectangle const & in_subscreen);

	/*! Sets the mobility for this StandAloneWindowOptionsKit.
	 *	\param in_mobility The mobility for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		SetMobility(Window::Mobility in_mobility);

	/*! Sets whether the associated stand-alone window should fill the screen.
	 *	\param in_state Whether the associated stand-alone window should fill the screen.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		SetFullScreen(bool in_state);

	/*! Sets which GPU to use when there are multiple available GPUs on a system. This method is only available when using the DirectX11 driver. Other drivers will ignore this request. \n\n `in_gpu_name` needs to be specified when `in_gpu_preference` is set to `GPU::Preference::Specific`. The value passed for `in_gpu_name` needs to match one of those returned by `Database::ShowAvailableGPUs()`. If you select something other than default GPU, and Visualize cannot find a GPU which satisfies the requirement, the default GPU will be used. \n\n All Visualize windows using DirectX11 will use the same GPU. The user should select the preferred GPU before creating a DirectX11 window. The default is for DirectX11 windows to use HighPerformance GPUs. The Microsoft Basic Software Render Driver is always returned as one of the available GPUs by DirectX11. By selecting it (which users can do by calling `SetPreferredGPU(GPU::Preference::Specific, "Microsoft Basic Render Driver")`), DirectX11 will run in software mode.
	*	\param in_gpu_preference Which GPU to choose. If `GPU::Preference::Specific` is chosen, the next argument is required.
	*	\param in_gpu_name The name of the specific GPU to use. Required when `in_gpu_preference` is `GPU::Preference::Specific`, ignored otherwise.
	*	\return A reference to this `StandAloneWindowOptionsKit`. */
	StandAloneWindowOptionsKit &		SetPreferredGPU(GPU::Preference in_gpu_preference, char const * in_gpu_name = "");

	/*! Removes the driver for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetDriver();

	/*! Removes the anti-alias options for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetAntiAliasCapable();

	/*! Removes the screen anti-alias options for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetScreenAntiAliasing();

	/*! Removes the title for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetTitle();

	/*! Removes the subscreen for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetSubscreen();

	/*! Removes the mobility for this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetMobility();

	/*! Removes whether the associated stand-alone window should fill the screen.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetFullScreen();

	/*! Removes the setting for which GPU should be used when multiple GPUs are available.
	*	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetPreferredGPU();

	/*! Removes all settings from this StandAloneWindowOptionsKit.
	 *	\return A reference to this StandAloneWindowOptionsKit. */
	StandAloneWindowOptionsKit &		UnsetEverything();

	/*! Shows the driver for this StandAloneWindowOptionsKit.
	 *	\param out_driver The driver for this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if a driver was set, <span class='code'>false</span> otherwise. */
	bool								ShowDriver(Window::Driver & out_driver) const;

	/*! Shows the anti-alias options for this StandAloneWindowOptionsKit.
	 * 	\param out_state Whether the associated stand-alone window should be anti-alias capable.
	 * 	\param out_samples The number of anti-alias samples to use for the stand-alone application window.
	 *	\return <span class='code'>true</span> if anti-alias options were set, <span class='code'>false</span> otherwise. */
	bool								ShowAntiAliasCapable(bool & out_state, unsigned int & out_samples) const;

	/*! Shows the title for this StandAloneWindowOptionsKit.
	 *	\param out_window_name UTF8-encoded title for this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if a title was set, <span class='code'>false</span> otherwise. */
	bool								ShowTitle(UTF8 & out_window_name) const;

	/*! Shows the subscreen for this StandAloneWindowOptionsKit.
	 *	\param out_subscreen The subscreen for this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if a subscreen was set, <span class='code'>false</span> otherwise. */
	bool								ShowSubscreen(Rectangle & out_subscreen) const;

	/*! Shows the mobility for this StandAloneWindowOptionsKit.
	 *	\param out_mobility The mobility for this StandAloneWindowOptionsKit.
	 *	\return <span class='code'>true</span> if a mobility was set, <span class='code'>false</span> otherwise. */
	bool								ShowMobility(Window::Mobility & out_mobility) const;

	/*! Shows whether the associated stand-alone window should fill the screen.
	 *	\param out_state Whether the associated stand-alone window should fill the screen.
	 *	\return <span class='code'>true</span> if a full screen flag was set, <span class='code'>false</span> otherwise. */
	bool								ShowFullScreen(bool & out_state) const;

	/*! Shows the preference settings for picking a GPU when multiple GPUs are available.
	*	\param out_gpu_preference The preference for picking a GPU when multiple GPUs are available.
	*	\param out_gpu_name The name of the GPU to use. Only valid when out_gpu_preference is GPU::Preference::Specific
	*	\return <span class='code'>true</span> if a GPU preference was set, <span class='code'>false</span> otherwise. */
	bool								ShowPreferredGPU(GPU::Preference & out_gpu_preference, HPS::UTF8 & out_gpu_name) const;
};
#endif


#if TARGET_OS_ANDROID == 0 && !defined(__APPLE__)
/*!
<p>The HPS::StandAloneWindowOptionsControl class is a smart pointer that is tied to a database object.  It is used to set and query stand-alone-window-specific options on a HPS::StandAloneWindowKey. </p>

<p>Default values for the various fields of HPS::StandAloneWindowOptionsControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#window-options">here</a>.</p>

<p>Standalone windows are not supported on Android, iOS, or macOS as all GUI / windowing is controlled at the application level.</p>
*/
class HPS_API StandAloneWindowOptionsControl : public Control
{
public:
	/*! This constructor creates a StandAloneWindowOptionsControl object which is tied to the specified offscreen window.
	 * 	\param in_window The application window which this StandAloneWindowOptionsControl should operate on. */
	explicit StandAloneWindowOptionsControl(StandAloneWindowKey & in_seg);

	/*! The copy constructor creates a StandAloneWindowOptionsControl object that shares the underlying smart-pointer of the source StandAloneWindowOptionsControl.
	 *	\param in_that The source StandAloneWindowOptionsControl to copy. */
	StandAloneWindowOptionsControl(StandAloneWindowOptionsControl const & in_that);

	/*! The move constructor creates a StandAloneWindowOptionsControl by transferring the underlying impl of the rvalue reference to this StandAloneWindowOptionsControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a StandAloneWindowOptionsControl to take the impl from. */
	StandAloneWindowOptionsControl(StandAloneWindowOptionsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this StandAloneWindowOptionsControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an StandAloneWindowOptionsControl to take the impl from.
	 * 	\return A reference to this StandAloneWindowOptionsControl. */
	StandAloneWindowOptionsControl & operator=(StandAloneWindowOptionsControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~StandAloneWindowOptionsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::StandAloneWindowOptionsControl;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the StandAloneWindowOptionsControl source.
	 *	\param in_that The StandAloneWindowOptionsControl source of the assignment.
	 *	\return A reference to this StandAloneWindowOptionsControl. */
	StandAloneWindowOptionsControl &	operator=(StandAloneWindowOptionsControl const & in_that);

	/*! Sets the subscreen to render into for this stand-alone window.
	 *	\param in_subscreen The subscreen to render into for this stand-alone window.  The units of the Rectangle are in window space, so <span class='code'>-1.0f</span> corresponds to the
	 *		left (or bottom) of the window and <span class='code'>1.0f</span> corresponds to the right (or top) of the window.
	 *	\return A reference to this StandAloneWindowOptionsControl. */
	StandAloneWindowOptionsControl &	SetSubscreen(Rectangle const & in_subscreen);

	/*! Sets the mobility for this stand-alone window. Mobility refers to the resizing and positioning behaviors of a window.
	 *	\param in_mobility The mobility for this stand-alone window.
	 *	\return A reference to this StandAloneWindowOptionsControl. */
	StandAloneWindowOptionsControl &	SetMobility(Window::Mobility in_mobility);

	/*! Sets whether this stand-alone window should fill the screen.
	 *	\param in_state Whether this stand-alone window should fill the screen.
	 *	\return A reference to this StandAloneWindowOptionsControl. */
	StandAloneWindowOptionsControl &	SetFullScreen(bool in_state);

    /*! Supplies an array of fonts to be used as fallbacks for when a character can not be found in the active font.
	    \param in_fonts An array of UTF8 encoded strings that correspond to the fallback fonts being used.*/
    StandAloneWindowOptionsControl &    SetFallbackFonts(UTF8Array const & in_fonts);

    /*! Unsets any fonts currently used as fallback fonts.*/
    StandAloneWindowOptionsControl &    UnsetFallbackFonts();

    /*! Returns an array of fonts set to be used as fallbacks for when a character can not be found in the active font.
	    \param out_fonts An array of UTF8 encoded strings that correspond to the fallback fonts being used.*/
    size_t                              ShowFallbackFonts(UTF8Array & out_fonts) const;

	/*! Shows the driver for this stand-alone window.
	 *	\param out_driver The driver for this stand-alone window.
	 *	\return <span class='code'>true</span> if a driver was set, <span class='code'>false</span> otherwise. */
	bool								ShowDriver(Window::Driver & out_driver) const;

	/*! Sets the anti-alias options for this StandAloneWindowOptionsControl.
	* 	\param in_state Whether the associated stand-alone window should be anti-alias capable.
	* 	\param in_samples The number of anti-alias samples to use for the associated stand-alone window.  Defaults to <span class='code'>4</span>.
	*	\return A reference to this StandAloneWindowOptionsControl. */
	StandAloneWindowOptionsControl &		SetAntiAliasCapable(bool in_state, unsigned int in_samples = 4);

	/*!	Manipulates the state of screen anti-aliasing.
	*	\param in_state Whether screen anti-aliasing should be used.
	*	\return A reference to this object. */
	StandAloneWindowOptionsControl &		SetScreenAntiAliasing(bool in_state);

	/*! Shows the whether this stand-alone window is anti-alias capable, and if so, how many samples it uses for anti-aliasing.
	 *	\param out_state Whether this stand-alone window is anti-alias capable.
	 *	\param out_samples The number of anti-alias samples supported by this stand-alone window.
	 *	\return <span class='code'>true</span> if any anti-alias options were set, <span class='code'>false</span> otherwise. */
	bool								ShowAntiAliasCapable(bool & out_state, unsigned int & out_samples) const;

	/*! Shows the title for this stand-alone window.
	 *	\param out_window_name UTF8-encoded title for this stand-alone window.
	 *	\return <span class='code'>true</span> if a title was set, <span class='code'>false</span> otherwise. */
	bool								ShowTitle(UTF8 & out_window_name) const;

	/*! Shows the subscreen for this stand-alone window.
	 *	\param out_subscreen The subscreen for this stand-alone window.
	 *	\return <span class='code'>true</span> if a subscreen was set, <span class='code'>false</span> otherwise. */
	bool								ShowSubscreen(Rectangle & out_subscreen) const;

	/*! Shows the mobility for this stand-alone window.
	 *	\param out_mobility The mobility for this stand-alone window.
	 *	\return <span class='code'>true</span> if a mobility was set, <span class='code'>false</span> otherwise. */
	bool								ShowMobility(Window::Mobility & out_mobility) const;

	/*! Shows whether this stand-alone window should fill the screen.
	 *	\param out_state Whether this stand-alone window should fill the screen.
	 *	\return <span class='code'>true</span> if a full screen flag was set, <span class='code'>false</span> otherwise. */
	bool								ShowFullScreen(bool & out_state) const;

	/*! Shows the window handle for the associated standalone window.
	*	\param out_window_handle The window handle for the associated standalone window.
	*	\return <span class='code'>true</span> if a window handle is available, <span class='code'>false</span> otherwise. */
	bool								ShowWindowHandle(WindowHandle & out_window_handle) const;
private:
	//! Private default constructor to prevent instantiation without an offscreen window.
	StandAloneWindowOptionsControl();
};
#endif


/*!
<p>The HPS::OffScreenWindowOptionsKit class is a user space object.  It is used to specify off-screen-window-specific options. Calling HPS::OffScreenWindowOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#window-options">this table</a>.</p>
*/
class HPS_API OffScreenWindowOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty OffScreenWindowOptionsKit object. */
	OffScreenWindowOptionsKit();

	/*! The copy constructor creates a new OffScreenWindowOptionsKit object that contains the same settings as the source OffScreenWindowOptionsKit.
	 * 	\param in_kit The source OffScreenWindowOptionsKit to copy. */
	OffScreenWindowOptionsKit(OffScreenWindowOptionsKit const & in_kit);

	/*! The move constructor creates an OffScreenWindowOptionsKit by transferring the underlying impl of the rvalue reference to this OffScreenWindowOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an OffScreenWindowOptionsKit to take the impl from. */
	OffScreenWindowOptionsKit(OffScreenWindowOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this OffScreenWindowOptionsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an OffScreenWindowOptionsKit to take the impl from.
	 * 	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit & operator=(OffScreenWindowOptionsKit && in_that);

	virtual ~OffScreenWindowOptionsKit();

	static const HPS::Type staticType = HPS::Type::OffScreenWindowOptionsKit;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Creates an OffScreenWindowOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return An OffScreenWindowOptionsKit with the default settings. */
	static OffScreenWindowOptionsKit 	GetDefault();

	/*! Copies the source OffScreenWindowOptionsKit into this OffScreenWindowOptionsKit.
	 * 	\param in_kit The source OffScreenWindowOptionsKit to copy. */
	void								Set(OffScreenWindowOptionsKit const & in_kit);

	/*! Copies this OffScreenWindowOptionsKit into the given OffScreenWindowOptionsKit.
	 * 	\param out_kit The OffScreenWindowOptionsKit to populate with the contents of this OffScreenWindowOptionsKit. */
	void								Show(OffScreenWindowOptionsKit & out_kit) const;

	/*! Copies the source OffScreenWindowOptionsKit into this OffScreenWindowOptionsKit.
	 * 	\param in_kit The source OffScreenWindowOptionsKit to copy.
	 * 	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			operator=(OffScreenWindowOptionsKit const & in_kit);

	/*! Indicates whether this OffScreenWindowOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this OffScreenWindowOptionsKit, <span class='code'>false</span> otherwise. */
	bool								Empty() const;

	/*!	Check if the source OffScreenWindowOptionsKit is equivalent to this OffScreenWindowOptionsKit.
	 *	\param in_kit The source OffScreenWindowOptionsKit to compare to this OffScreenWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								Equals(OffScreenWindowOptionsKit const & in_kit) const;

	/*!	Check if the source OffScreenWindowOptionsKit is equivalent to this OffScreenWindowOptionsKit.
	 *	\param in_kit The source OffScreenWindowOptionsKit to compare to this OffScreenWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								operator==(OffScreenWindowOptionsKit const & in_kit) const;

	/*!	Check if the source OffScreenWindowOptionsKit is not equivalent to this OffScreenWindowOptionsKit.
	 *	\param in_kit The source OffScreenWindowOptionsKit to compare to this OffScreenWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool								operator!=(OffScreenWindowOptionsKit const & in_kit) const;

	/*! Sets the driver for this OffScreenWindowOptionsKit.
	 * 	\param in_driver The driver for this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			SetDriver(Window::Driver in_driver);

	/*! Sets the anti-alias options for this OffScreenWindowOptionsKit.
	 * 	\param in_state Whether the associated application window should be anti-alias capable.
	 * 	\param in_samples The number of anti-alias samples to use for the associated off-screen window.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			SetAntiAliasCapable(bool in_state, unsigned int in_samples = 4);

	/*!	Manipulates the state of screen anti-aliasing.
	*	\param in_state Whether screen anti-aliasing should be used.
	*	\return A reference to this object. */
	OffScreenWindowOptionsKit &			SetScreenAntiAliasing(bool in_state);

	/*! Sets whether the image data for this offscreen window should be stored exclusively in video memory.
		Storing the image in video memory improves the update time but may make the image data inaccessible directly.
	 * 	\param in_state Whether the image data for this offscreen window should be stored exclusively in video memory.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			SetHardwareResident(bool in_state);

	/*! Sets the native image format to store data in.
	 *  \param in_format Format image data will be stored in.
	 * 	\param in_quality The compression quality for the image data (when applicable).
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			SetNativeFormat(Window::ImageFormat in_format, float in_quality = 1.0f);

	/*! Sets whether this offscreen window supports opacity in the window background and the opacity value that should be applied when rendering the window background.
	* 	\param in_state Whether this offscreen window should support opacity in the window background.
	* 	\param in_opacity The opacity value that will be applied when rendering the window background. The value is clamped if the opacity is outside the range 0 to 1.
	*	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			SetOpacity(bool in_state, float in_opacity = 1.0f);

	/*! Enables support for opacity in the window background and applies the specified opacity value when rendering the window background.
	* 	\param in_opacity The opacity value that will be applied when rendering the window background.
	*	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			SetOpacity(float in_opacity);

	/*! Sets the framebuffer retention option for this OffScreenWindowOptionsKit.
	* 	\param in_retain Whether the associated offscreen window retains the image from the previous frame.
	*	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &		SetFramebufferRetention(bool in_retain);

	/*! Sets which GPU to use when there are multiple available GPUs on a system. This method is only available when using the DirectX11 driver. Other drivers will ignore this request. \n\n `in_gpu_name` needs to be specified when `in_gpu_preference` is set to `GPU::Preference::Specific`. The value passed for `in_gpu_name` needs to match one of those returned by `Database::ShowAvailableGPUs()`. If you select something other than default GPU, and Visualize cannot find a GPU which satisfies the requirement, the default GPU will be used. \n\n All Visualize windows using DirectX11 will use the same GPU. The user should select the preferred GPU before creating a DirectX11 window. The default is for DirectX11 windows to use HighPerformance GPUs. The Microsoft Basic Software Render Driver is always returned as one of the available GPUs by DirectX11. By selecting it (which users can do by calling `SetPreferredGPU(GPU::Preference::Specific, "Microsoft Basic Render Driver")`), DirectX11 will run in software mode.
	*	\param in_gpu_preference Which GPU to choose. If `GPU::Preference::Specific` is chosen, the next argument is required.
	*	\param in_gpu_name The name of the specific GPU to use. Required when `in_gpu_preference` is `GPU::Preference::Specific`, ignored otherwise.
	*	\return A reference to this `OffScreenWindowOptionsKit`. */
	OffScreenWindowOptionsKit &		SetPreferredGPU(GPU::Preference in_gpu_preference, char const * in_gpu_name = "");

	/*! Removes the driver for this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			UnsetDriver();

	/*! Removes the anti-alias options for this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			UnsetAntiAliasCapable();

	/*! Removes the screen anti-alias options for this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			UnsetScreenAntiAliasing();

	/*! Removes the hardware resident option for this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			UnsetHardwareResident();

	/*! Removes the native format option for this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			UnsetNativeFormat();

	/*! Removes the opacity option for this OffScreenWindowOptionsKit.
	*	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &			UnsetOpacity();

	/*! Removes the framebuffer retention setting for this OffScreenWindowOptionsKit.
	*	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &		UnsetFramebufferRetention();

	/*! Removes the setting for which GPU should be used when multiple GPUs are available.
	*	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &		UnsetPreferredGPU();

	/*! Removes all settings from this OffScreenWindowOptionsKit.
	 *	\return A reference to this OffScreenWindowOptionsKit. */
	OffScreenWindowOptionsKit &		UnsetEverything();

	/*! Shows the driver for this OffScreenWindowOptionsKit.
	 *	\param out_driver The driver for this OffScreenWindowOptionsKit.
	 *	\return <span class='code'>true</span> if a driver was set, <span class='code'>false</span> otherwise. */
	bool								ShowDriver(Window::Driver & out_driver) const;

	/*! Shows the anti-alias options for this OffScreenWindowOptionsKit.
	 * 	\param out_state Whether the associated application window should be anti-alias capable.
	 * 	\param out_samples The number of anti-alias samples to use for the associated application window.
	 *	\return <span class='code'>true</span> if anti-alias options were set, <span class='code'>false</span> otherwise. */
	bool								ShowAntiAliasCapable(bool & out_state, unsigned int & out_samples) const;

	/*! Shows the hardware resident option for this OffScreenWindowOptionsKit.
	 * 	\param out_state Whether the image data for this offscreen window should be stored exclusively in video memory.
	 *	\return <span class='code'>true</span> if a hardware resident option was set, <span class='code'>false</span> otherwise. */
	bool								ShowHardwareResident(bool & out_state) const;

	/*! Shows the native format option for this OffScreenWindowOptionsKit.
	 *  \param out_format Format image data will be stored in.
	 * 	\param out_quality The compression quality for the image data (when applicable).
	 *	\return <span class='code'>true</span> if a native format option was set, <span class='code'>false</span> otherwise. */
	bool								ShowNativeFormat(Window::ImageFormat & out_format, float & out_quality) const;

	/*! Shows the opacity option for this offscreen window
	* 	\param out_state Whether this offscreen window supports opacity in the window background.
	* 	\param out_opacity The opacity value that will be applied when rendering the window background.
	*	\return <span class='code'>true</span> if an opacity option was set, <span class='code'>false</span> otherwise. */
	bool								ShowOpacity(bool & out_state, float & out_opacity) const;

	/*! Shows the framebuffer retention setting for this OffScreenWindowOptionsKit.
	*	\param out_retain The framebuffer retention setting for this OffScreenWindowOptionsKit.
	*	\return <span class='code'>true</span> if platform specific data was set, <span class='code'>false</span> otherwise. */
	bool								ShowFramebufferRetention(bool & out_retain) const;

	/*! Shows the preference settings for picking a GPU when multiple GPUs are available.
	*	\param out_gpu_preference The preference for picking a GPU when multiple GPUs are available.
	*	\param out_gpu_name The name of the GPU to use. Only valid when out_gpu_preference is GPU::Preference::Specific
	*	\return <span class='code'>true</span> if a GPU preference was set, <span class='code'>false</span> otherwise. */
	bool								ShowPreferredGPU(GPU::Preference & out_gpu_preference, HPS::UTF8 & out_gpu_name) const;
};

/*!
<p>The ApplicationWindowOptionsKit class is a user space object. It is used to specify application-window-specific options. Calling HPS::ApplicationWindowOptionsKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#window-options">this table</a>.</p>
*/
class HPS_API ApplicationWindowOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty ApplicationWindowOptionsKit object. */
	ApplicationWindowOptionsKit();

	/*! The copy constructor creates a new ApplicationWindowOptionsKit object that contains the same settings as the source ApplicationWindowOptionsKit.
	 * 	\param in_kit The source ApplicationWindowOptionsKit to copy. */
	ApplicationWindowOptionsKit(ApplicationWindowOptionsKit const & in_kit);

	/*! The move constructor creates an ApplicationWindowOptionsKit by transferring the underlying impl of the rvalue reference to this ApplicationWindowOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an ApplicationWindowOptionsKit to take the impl from. */
	ApplicationWindowOptionsKit(ApplicationWindowOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ApplicationWindowOptionsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an ApplicationWindowOptionsKit to take the impl from.
	 * 	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit & operator=(ApplicationWindowOptionsKit && in_that);

	virtual ~ApplicationWindowOptionsKit();

	static const HPS::Type staticType = HPS::Type::ApplicationWindowOptionsKit;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Creates an ApplicationWindowOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return An ApplicationWindowOptionsKit with the default settings. */
	static ApplicationWindowOptionsKit 	GetDefault();

	/*! Copies the source ApplicationWindowOptionsKit into this ApplicationWindowOptionsKit.
	 * 	\param in_kit The source ApplicationWindowOptionsKit to copy. */
	void								Set(ApplicationWindowOptionsKit const & in_kit);

	/*! Copies this ApplicationWindowOptionsKit into the given ApplicationWindowOptionsKit.
	 * 	\param out_kit The ApplicationWindowOptionsKit to populate with the contents of this ApplicationWindowOptionsKit. */
	void								Show(ApplicationWindowOptionsKit & out_kit) const;

	/*! Copies the source ApplicationWindowOptionsKit into this ApplicationWindowOptionsKit.
	 * 	\param in_kit The source ApplicationWindowOptionsKit to copy.
	 * 	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		operator=(ApplicationWindowOptionsKit const & in_kit);

	/*! Indicates whether this ApplicationWindowOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ApplicationWindowOptionsKit, <span class='code'>false</span> otherwise. */
	bool								Empty() const;

	/*!	Check if the source ApplicationWindowOptionsKit is equivalent to this ApplicationWindowOptionsKit.
	 *	\param in_kit The source ApplicationWindowOptionsKit to compare to this ApplicationWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								Equals(ApplicationWindowOptionsKit const & in_kit) const;

	/*!	Check if the source ApplicationWindowOptionsKit is equivalent to this ApplicationWindowOptionsKit.
	 *	\param in_kit The source ApplicationWindowOptionsKit to compare to this ApplicationWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool								operator==(ApplicationWindowOptionsKit const & in_kit) const;

	/*!	Check if the source ApplicationWindowOptionsKit is not equivalent to this ApplicationWindowOptionsKit.
	 *	\param in_kit The source ApplicationWindowOptionsKit to compare to this ApplicationWindowOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool								operator!=(ApplicationWindowOptionsKit const & in_kit) const;

	/*! Sets the driver for this ApplicationWindowOptionsKit.
	 * 	\param in_driver The driver for this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		SetDriver(Window::Driver in_driver);

	/*! Sets the anti-alias options for this ApplicationWindowOptionsKit.
	 * 	\param in_state Whether the associated application window should be anti-alias capable.
	 * 	\param in_samples The number of anti-alias samples to use for the associated application window.  Defaults to <span class='code'>4</span>.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		SetAntiAliasCapable(bool in_state, unsigned int in_samples = 4);

	/*!	Manipulates the state of screen anti-aliasing.
	*	\param in_state Whether screen anti-aliasing should be used.
	*	\return A reference to this object. */
	ApplicationWindowOptionsKit &		SetScreenAntiAliasing(bool in_state);

	/*! Sets the platform specific data for this ApplicationWindowOptionsKit.
	 *	\param in_platform_data Platform specific data for this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		SetPlatformData(PlatformData in_platform_data);

	/*! Sets the framebuffer retention option for this ApplicationWindowOptionsKit.
	* 	\param in_retain Whether the associated application window retains the image from the previous frame.
	*	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		SetFramebufferRetention(bool in_retain);

	/*! Sets which GPU to use when there are multiple available GPUs on a system. This method is only available when using the DirectX11 driver. Other drivers will ignore this request. \n\n `in_gpu_name` needs to be specified when `in_gpu_preference` is set to `GPU::Preference::Specific`. The value passed for `in_gpu_name` needs to match one of those returned by `Database::ShowAvailableGPUs()`. If you select something other than default GPU, and Visualize cannot find a GPU which satisfies the requirement, the default GPU will be used. \n\n All Visualize windows using DirectX11 will use the same GPU. The user should select the preferred GPU before creating a DirectX11 window. The default is for DirectX11 windows to use HighPerformance GPUs. The Microsoft Basic Software Render Driver is always returned as one of the available GPUs by DirectX11. By selecting it (which users can do by calling `SetPreferredGPU(GPU::Preference::Specific, "Microsoft Basic Render Driver")`), DirectX11 will run in software mode.
	*	\param in_gpu_preference Which GPU to choose. If `GPU::Preference::Specific` is chosen, the next argument is required.
	*	\param in_gpu_name The name of the specific GPU to use. Required when in_gpu_preference is `GPU::Preference::Specific`, ignored otherwise.
	*	\return A reference to this `ApplicationWindowOptionsKit`. */
	ApplicationWindowOptionsKit &		SetPreferredGPU(GPU::Preference in_gpu_preference, char const * in_gpu_name = "");

	/*! Removes the driver for this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetDriver();

	/*! Removes the anti-alias options for this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetAntiAliasCapable();

	/*! Removes the screen anti-alias options for this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetScreenAntiAliasing();

	/*! Removes the platform specific data for this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetPlatformData();

	/*! Removes the framebuffer retention setting for this ApplicationWindowOptionsKit.
	*	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetFramebufferRetention();

	/*! Removes the setting for which GPU should be used when multiple GPUs are available.
	*	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetPreferredGPU();

	/*! Removes all settings from this ApplicationWindowOptionsKit.
	 *	\return A reference to this ApplicationWindowOptionsKit. */
	ApplicationWindowOptionsKit &		UnsetEverything();

	/*! Shows the driver for this ApplicationWindowOptionsKit.
	 *	\param out_driver The driver for this ApplicationWindowOptionsKit.
	 *	\return <span class='code'>true</span> if a driver was set, <span class='code'>false</span> otherwise. */
	bool								ShowDriver(Window::Driver & out_driver) const;

	/*! Shows the anti-alias options for this ApplicationWindowOptionsKit.
	 * 	\param out_state Whether the associated application window should be anti-alias capable.
	 * 	\param out_samples The number of anti-alias samples to use for the associated application window.
	 *	\return <span class='code'>true</span> if anti-alias options were set, <span class='code'>false</span> otherwise. */
	bool								ShowAntiAliasCapable(bool & out_state, unsigned int & out_samples) const;

	/*! Shows the platform specific data for this ApplicationWindowOptionsKit.
	 *	\param out_platform_data The platform specific data for this ApplicationWindowOptionsKit.
	 *	\return <span class='code'>true</span> if platform specific data was set, <span class='code'>false</span> otherwise. */
	bool								ShowPlatformData(PlatformData & out_platform_data) const;

	/*! Shows the framebuffer retention setting for this ApplicationWindowOptionsKit.
	*	\param out_retain The framebuffer retention setting for this ApplicationWindowOptionsKit.
	*	\return <span class='code'>true</span> if platform specific data was set, <span class='code'>false</span> otherwise. */
	bool								ShowFramebufferRetention(bool & out_retain) const;

	/*! Shows the preference settings for picking a GPU when multiple GPUs are available.
	*	\param out_gpu_preference The preference for picking a GPU when multiple GPUs are available.
	*	\param out_gpu_name The name of the GPU to use. Only valid when out_gpu_preference is GPU::Preference::Specific
	*	\return <span class='code'>true</span> if a GPU preference was set, <span class='code'>false</span> otherwise. */
	bool								ShowPreferredGPU(GPU::Preference & out_gpu_preference, HPS::UTF8 & out_gpu_name) const;

};



/*! The HPS::ApplicationWindowOptionsControl class is a smart pointer that is tied to a database object. It is used to query and manipulate options pertaining to an HPS::ApplicationWindowKey. Default values for the various fields of HPS::ApplicationWindowOptionsControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#window-options">here</a>. */
class HPS_API ApplicationWindowOptionsControl : public Control
{
public:
	/*! This constructor creates a ApplicationWindowOptionsControl object which is tied to the specified offscreen window.
	 * 	\param in_window The application window which this ApplicationWindowOptionsControl should operate on. */
	explicit ApplicationWindowOptionsControl(ApplicationWindowKey & in_seg);

	/*! The copy constructor creates a ApplicationWindowOptionsControl object that shares the underlying smart-pointer of the source ApplicationWindowOptionsControl.
	 *	\param in_that The source ApplicationWindowOptionsControl to copy. */
	ApplicationWindowOptionsControl(ApplicationWindowOptionsControl const & in_that);

	/*! The move constructor creates an ApplicationWindowOptionsControl by transferring the underlying impl of the rvalue reference to this ApplicationWindowOptionsControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an ApplicationWindowOptionsControl to take the impl from. */
	ApplicationWindowOptionsControl(ApplicationWindowOptionsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ApplicationWindowOptionsControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an ApplicationWindowOptionsControl to take the impl from.
	 * 	\return A reference to this ApplicationWindowOptionsControl. */
	ApplicationWindowOptionsControl & operator=(ApplicationWindowOptionsControl && in_that);

	/*! Releases a reference to the database object this control is tied to. */
	~ApplicationWindowOptionsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::ApplicationWindowOptionsControl;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the ApplicationWindowOptionsControl source.
	 *	\param in_that The ApplicationWindowOptionsControl source of the assignment.
	 *	\return A reference to this ApplicationWindowOptionsControl. */
	ApplicationWindowOptionsControl &	operator=(ApplicationWindowOptionsControl const & in_that);

    /*! Returns an array of fonts set to be used as fallbacks for when a character can not be found in the active font.
	    \param out_fonts An array of UTF8 encoded strings that correspond to the fallback fonts being used.*/
    size_t                              ShowFallbackFonts(UTF8Array & out_fonts) const;

	/*! Sets the anti-alias options for this ApplicationWindowOptionsControl.
	* 	\param in_state Whether the associated application window should be anti-alias capable.
	* 	\param in_samples The number of anti-alias samples to use for the associated application window.  Defaults to <span class='code'>4</span>.
	*	\return A reference to this StandAloneWindowOptionsKit. */
	ApplicationWindowOptionsControl &		SetAntiAliasCapable(bool in_state, unsigned int in_samples = 4);

	/*!	Manipulates the state of screen anti-aliasing.
	*	\param in_state Whether screen anti-aliasing should be used.
	*	\return A reference to this object. */
	ApplicationWindowOptionsControl &		SetScreenAntiAliasing(bool in_state);

	/*! Shows the whether this application window is anti-alias capable, and if so, how many samples it uses for anti-aliasing.
	 *	\param out_state Whether this application window is anti-alias capable.
	 *	\param out_samples The number of anti-alias samples supported by this application window.
	 *	\return <span class='code'>true</span> if any anti-alias options were set, <span class='code'>false</span> otherwise. */
	bool								ShowAntiAliasCapable(bool & out_state, unsigned int & out_samples) const;

	/*! Shows the driver for the associated application window.
	 *	\param out_driver The driver for the associated application window.
	 *	\return <span class='code'>true</span> if a driver was set, <span class='code'>false</span> otherwise. */
	bool								ShowDriver(Window::Driver & out_driver) const;

	/*! Shows the window handle for the associated application window.
	 *	\param out_window_handle The window handle for the associated application window.
	 *	\return <span class='code'>true</span> if a window handle was set, <span class='code'>false</span> otherwise. */
	bool								ShowWindowHandle(WindowHandle & out_window_handle) const;

	/*! Shows the platform specific data for the associated application window.
	 *	\param out_platform_data The platform specific data for the associated application window.
	 *	\return <span class='code'>true</span> if platform specific data was set, <span class='code'>false</span> otherwise. */
	bool								ShowPlatformData(PlatformData & out_platform_data) const;

	/*! Shows the framebuffer retention setting for the associated application window.
	*	\param out_retain The framebuffer retention setting for the associated application window.
	*	\return <span class='code'>true</span> if framebuffer retention option was set, <span class='code'>false</span> otherwise. */
	bool								ShowFramebufferRetention(bool & out_retain) const;

	/*! Sets the window handle for the associated application window.  Used to rebind the application window to a new window handle.
	 *  \param in_window_handle Handle to the new WindowHandle that Visualize will draw into.
	 *	\return A reference to this ApplicationWindowOptionsControl. */
	ApplicationWindowOptionsControl &	SetWindowHandle(WindowHandle in_window_handle);

	/*! Sets the platform specific data for the associated application window.
	 *	\param in_platform_data Platform specific data for the associated application window.
	 *	\return A reference to this ApplicationWindowOptionsControl.*/
	ApplicationWindowOptionsControl &	SetPlatformData(PlatformData in_platform_data);

    /*! Supplies an array of fonts to be used as fallbacks for when a character can not be found in the active font.
	    \param in_fonts An array of UTF8 encoded strings that correspond to the fallback fonts being used.*/
    ApplicationWindowOptionsControl &   SetFallbackFonts(UTF8Array const & in_fonts);

    /*! Unsets any fonts currently used as fallback fonts.*/
    ApplicationWindowOptionsControl &   UnsetFallbackFonts();

private:
	//! Private default constructor to prevent instantiation without an offscreen window.
	ApplicationWindowOptionsControl();
};


#if TARGET_OS_ANDROID == 0 && !defined(__APPLE__)
/*! The StandAloneWindowKey object is a handle to a stand-alone window that Visualize can draw into.
	Standalone windows are always directly created by Visualize. The Visualize rendering context will
	use the entire window for rendering. Standalone windows are only supported on
	Microsoft Windows and Linux platforms. */
class HPS_API StandAloneWindowKey : public WindowKey
{
public:
	/*! The default constructor creates an uninitialized StandAloneWindowKey object.  The Type() function will return Type::None. */
	StandAloneWindowKey();

	/*! This constructor creates an StandAloneWindowKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of an application window.  Otherwise the copy
	 * 	will fail and the resulting StandAloneWindowKey will be invalid.
	 *	\param in_key The source Key to copy. */
	StandAloneWindowKey(Key const & in_key);

	/*! The copy constructor creates a StandAloneWindowKey object that shares the underlying smart-pointer of the source StandAloneWindowKey.
	 *	\param in_that The source StandAloneWindowKey to copy. */
	StandAloneWindowKey(StandAloneWindowKey const & in_that);

	/*! The move constructor creates a StandAloneWindowKey by transferring the underlying impl of the rvalue reference to this StandAloneWindowKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a StandAloneWindowKey to take the impl from. */
	StandAloneWindowKey(StandAloneWindowKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this StandAloneWindowKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an StandAloneWindowKey to take the impl from.
	 * 	\return A reference to this StandAloneWindowKey. */
	StandAloneWindowKey & operator=(StandAloneWindowKey && in_that);

	~StandAloneWindowKey();

	static const HPS::Type staticType = HPS::Type::StandAloneWindowKey;
	HPS::Type								ObjectType() const { return staticType; };

	/*! Gets a control that allows querying options specific to stand-alone windows.
	 * 	\return A control that allows querying options specific to stand-alone windows. */
	StandAloneWindowOptionsControl const	GetWindowOptionsControl() const;

	/*! Gets a control that allows querying options specific to stand-alone windows.
	 * 	\return A control that allows querying options specific to stand-alone windows. */
	StandAloneWindowOptionsControl			GetWindowOptionsControl();

	/*! Shows the stand-alone-window-specific options for this StandAloneWindowKey.
	 * 	\param out_kit The stand-alone-window-specific options for this StandAloneWindowKey.
	 *	\return <span class='code'>true</span> if any options are set, <span class='code'>false</span> otherwise. */
	bool									ShowWindowOptions(StandAloneWindowOptionsKit & out_kit) const;

	/*! Triggers an update and puts the calling thread into a wait loop which will only be exited when a mouse, touch, or keyboard event occurs.
	 *	\return The status of the triggered update. */
	Window::UpdateStatus					Pause();
};
#endif

/*! The ApplicationWindowKey class is a smart pointer to a database object.  It is a handle to an application window Visualize can draw into. */
class HPS_API ApplicationWindowKey : public WindowKey
{
public:
	/*! The default constructor creates an uninitialized ApplicationWindowKey object.  The Type() function will return Type::None. */
	ApplicationWindowKey();

	/*! The copy constructor creates an ApplicationWindowKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of an application window.  Otherwise the copy
	 * 	will fail and the resulting ApplicationWindowKey will be invalid.
	 *	\param in_key The source Key to copy. */
	ApplicationWindowKey(Key const & in_key);

	/*! The copy constructor creates a ApplicationWindowKey object that shares the underlying smart-pointer of the source ApplicationWindowKey.
	 *	\param in_that The source ApplicationWindowKey to copy. */
	ApplicationWindowKey(ApplicationWindowKey const & in_that);

	/*! The move constructor creates a ApplicationWindowKey by transferring the underlying impl of the rvalue reference to this ApplicationWindowKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ApplicationWindowKey to take the impl from. */
	ApplicationWindowKey(ApplicationWindowKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ApplicationWindowKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an ApplicationWindowKey to take the impl from.
	 * 	\return A reference to this ApplicationWindowKey. */
	ApplicationWindowKey & operator=(ApplicationWindowKey && in_that);

	~ApplicationWindowKey();

	static const HPS::Type staticType = HPS::Type::ApplicationWindowKey;
	HPS::Type								ObjectType() const { return staticType; };

	/*! Gets a control that allows querying options specific to application windows.
	 * 	\return A control that allows querying options specific to application windows. */
	ApplicationWindowOptionsControl const	GetWindowOptionsControl() const;

	/*! Gets a control that allows querying options specific to application windows.
	 * 	\return A control that allows querying options specific to application windows. */
	ApplicationWindowOptionsControl			GetWindowOptionsControl();

	/*! Shows the application-window-specific options for this ApplicationWindowKey.
	 * 	\param out_kit The application-window-specific options for this ApplicationWindowKey.
	 *	\return <span class='code'>true</span> if any options are set, <span class='code'>false</span> otherwise. */
	bool									ShowWindowOptions(ApplicationWindowOptionsKit & out_kit) const;
};

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// Glyphs //////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////



/*! The GlyphElement class is a user space object.  It is the base class for all glyph elements. */
class HPS_API GlyphElement : public Object
{
public:
	/*! The default constructor creates an empty GlyphElement object. */
	GlyphElement();

	/*! The copy constructor creates a new GlyphElement object that contains the same settings as the source GlyphElement.
	 * 	\param in_that The source GlyphElement to copy. */
	GlyphElement(GlyphElement const & in_that);

	/*! The move constructor creates a GlyphElement by transferring the underlying impl of the rvalue reference to this GlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a GlyphElement to take the impl from. */
	GlyphElement(GlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this GlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a GlyphElement to take the impl from.
	 * 	\return A reference to this GlyphElement. */
	GlyphElement & operator=(GlyphElement && in_that);

	virtual ~GlyphElement();

	static const HPS::Type staticType = HPS::Type::GlyphElement;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source GlyphElement into this GlyphElement.
	 * 	\param in_that The source GlyphElement to copy. */
	void 					Set(GlyphElement const & in_that);

	/*! Copies the source GlyphElement into this GlyphElement.
	 * 	\param in_that The source GlyphElement to copy.
	 * 	\return A reference to this GlyphElement. */
	GlyphElement &			operator=(GlyphElement const & in_that);

	/*!	Check if the source GlyphElement is equivalent to this GlyphElement.
	 *	\param in_that The source GlyphElement to compare to this GlyphElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool 					Equals(GlyphElement const & in_that) const;

	/*!	Check if the source GlyphElement is equivalent to this GlyphElement.
	 *	\param in_that The source GlyphElement to compare to this GlyphElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool 					operator==(GlyphElement const & in_that) const;

	/*!	Check if the source GlyphElement is not equivalent to this GlyphElement.
	 *	\param in_that The source GlyphElement to compare to this GlyphElement.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool 					operator!=(GlyphElement const & in_that) const;

	/*! Sets the fill mode for this GlyphElement.
	 * 	\param in_fill The fill mode for this GlyphElement. */
	void 					SetFill(Glyph::Fill in_fill);

	/*! Sets the color index for this GlyphElement.
	 * 	\param in_index The color index for this GlyphElement. */
	void 					SetIndexedColor(byte in_index);

	/*! Sets that this GlyphElement should inherit the color of the owning geometry which uses the glyph. */
	void 					SetNormalColor();

	/*! Sets the RGBA color for this GlyphElement.
	 * 	\param in_color The color for this GlyphElement. */
	void 					SetExplicitColor(RGBAColor const & in_color);

	/*! Shows the fill mode for this GlyphElement.
	 * 	\param out_fill The fill mode for this GlyphElement.
	 * 	\return <span class='code'>true</span> if a fill mode was set, <span class='code'>false</span> otherwise. */
	bool 					ShowFill(Glyph::Fill & out_fill) const;

	/*! Shows the color for this GlyphElement.
	 * 	\param out_source The color source for this GlyphElement.
	 * 	\param out_index The color index for this GlyphElement.  This is only valid if <span class='code'>out_source</span> is Glyph::ColorSource::Indexed.
	 * 	\param out_color The color for this GlyphElement.  This is only valid if <span class='code'>out_source</span> is Glyph::ColorSource::Explicit.
	 * 	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool					ShowColor(Glyph::ColorSource & out_source, byte & out_index, RGBAColor & out_color) const;
};


/*! The LineGlyphElement class is a user space object. */
class HPS_API LineGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty LineGlyphElement object. */
	LineGlyphElement();

	/*! This constructor creates a LineGlyphElement object that contains the same settings as the source GlyphElement.
	 * 	The copy will only be successful if the source glyph element is really an upcast of a line glyph element.  Otherwise the copy
	 * 	will fail and the resulting LineGlyphElement will be invalid.
	 *	\param in_that The source GlyphElement to copy. */
	LineGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new LineGlyphElement object that contains the same settings as the source LineGlyphElement.
	 * 	\param in_that The source LineGlyphElement to copy. */
	LineGlyphElement(LineGlyphElement const & in_that);

	/*! This constructor creates a LineGlyphElement with the specified point array.
	 *	\param in_points The points for the line. */
	explicit LineGlyphElement(GlyphPointArray const & in_points);

	/*! This constructor creates a LineGlyphElement with the specified point array.
	 * 	\param in_count Size of the following array.
	 *	\param in_points The points for the line. */
	LineGlyphElement(size_t in_count, GlyphPoint const in_points[]);

	/*! The move constructor creates a LineGlyphElement by transferring the underlying impl of the rvalue reference to this LineGlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LineGlyphElement to take the impl from. */
	LineGlyphElement(LineGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LineGlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a LineGlyphElement to take the impl from.
	 * 	\return A reference to this LineGlyphElement. */
	LineGlyphElement & operator=(LineGlyphElement && in_that);

	~LineGlyphElement();

	static const HPS::Type staticType = HPS::Type::LineGlyphElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the points for this LineGlyphElement.
	 * 	\param in_points The points for the line. */
	void 				SetPoints(GlyphPointArray const & in_points);

	/*! Sets the points for this LineGlyphElement.
	 * 	\param in_count Size of the following array.
	 * 	\param in_points The points for the line. */
	void 				SetPoints(size_t in_count, GlyphPoint const in_points[]);

	/*! Shows the points for this LineGlyphElement.
	 * 	\param out_points The points for the line.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(GlyphPointArray & out_points) const;
};


/*! The ImageGlyphElement class is a user space object. */
class HPS_API ImageGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty ImageGlyphElement object. */
	ImageGlyphElement();

	/*! This constructor creates a ImageGlyphElement object that contains the same settings as the source GlyphElement.
	 * 	The copy will only be successful if the source glyph element is really an upcast of a line glyph element.  Otherwise the copy
	 * 	will fail and the resulting LineGlyphElement will be invalid.
	 *	\param in_that The source GlyphElement to copy. */
	ImageGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new ImageGlyphElement object that contains the same settings as the source ImageGlyphElement.
	 * 	\param in_that The source ImageGlyphElement to copy. */
	ImageGlyphElement(ImageGlyphElement const & in_that);

	/*! The move constructor creates an ImageGlyphElement by transferring the underlying impl of the rvalue reference to this ImageGlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ImageGlyphElement to take the impl from. */
	ImageGlyphElement(ImageGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImageGlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ImageGlyphElement to take the impl from.
	 * 	\return A reference to this LineGlyphElement. */
	ImageGlyphElement & operator=(ImageGlyphElement && in_that);

	~ImageGlyphElement();

	static const HPS::Type staticType = HPS::Type::ImageGlyphElement;
	HPS::Type			ObjectType() const { return staticType; };


	/*! Sets the source image by name for this ImageGlyphElement.
	 * 	\param in_name The name of the source image.
	 */
	void				SetSource(char const * in_name);

	/*! Sets extra scaling for this ImageGlyphElement.
	 * 	\param in_x_scale The x scaling of the source image.  The default is 1.0.
	 * 	\param in_y_scale The y scaling of the source image.  The default is 1.0.
	 */
	void				SetScaling(float in_x_scale, float in_y_scale);

	/*! Sets an offset for the center of this ImageGlyphElement. The expected range of offset 
     *  values is [0, 1]. This locates the origin of the glyph coordinate system relative to 
     *  the center of the glyph. 
	 * 	\param in_x_offset The x offset of the source image.  The default is 0.5.
	 * 	\param in_y_offset The y offset of the source image.  The default is 0.5.
	 */
	void				SetOffset(float in_x_offset, float in_y_offset);

	/*! Sets a rotation this ImageGlyphElement.
	 * 	\param in_rotation The rotation in degrees for the source image.  The default is 0.0.
	 */
	void				SetRotation(float in_rotation);

	/*! Sets if decimation filtering is use for this ImageGlyphElement.
	 * \param in_filter If the glyph should use decimation filtering.  The default is true.
	 */
	void				SetDecimationFilter(bool in_filter);

	/*! Sets if interpolation filtering is use for this ImageGlyphElement.
	 * \param in_filter If the glyph should use interpolation filtering.  The default is true.
	 */
	void				SetInterpolationFilter(bool in_filter);

	/*! Sets if fixed scaling is used for this ImageGlyphElement.
	 * \param in_fixed_scale If the glyph should use the image size for scaling or the effective marker size.  The default is true.
	 */
	void				SetFixedScaling(bool in_fixed_scale);

	/*! Sets if fixed color is used for this ImageGlyphElement.
	 * \param in_fixed_color If the glyph should use the image colors or the effective marker color.  The default is true.
	 */
	void				SetFixedColoring(bool in_fixed_color);

	/*! Shows the source image by name for this ImageGlyphElement.
	 * 	\param out_name UTF8-encoded name of the source image.
	 *	\return <span class='code'>true</span> if a source image name was set, <span class='code'>false</span> otherwise. */
	bool				ShowSource(UTF8 & out_name) const;

	/*! Shows extra scaling for this ImageGlyphElement.
	 * \param out_x_scale The x scaling of the source image.
	 * \param out_y_scale The y scaling of the source image.
	 * \return <span class='code'>true</span> if a scaling was set, <span class='code'>false</span> otherwise. */
	bool				ShowScaling(float & out_x_scale, float & out_y_scale) const;

	/*! Shows an offset for the center of this ImageGlyphElement.
	 * \param out_x_offset The x offset of the source image.
	 * \param out_y_offset The y offset of the source image.
	 * \return <span class='code'>true</span> if an offset was set, <span class='code'>false</span> otherwise. */
	bool				ShowOffset(float & out_x_offset, float & out_y_offset) const;

	/*! Shows a rotation this ImageGlyphElement.
	 * \param out_rotation The rotation in degrees for the source image.
	 * \return <span class='code'>true</span> if a rotation was set, <span class='code'>false</span> otherwise. */
	bool				ShowRotation(float & out_rotation) const;

	/*! Shows if decimation filtering is use for this ImageGlyphElement.
	 * \param out_filter If the glyph should use decimation filtering.
	 * \return <span class='code'>true</span> if a decimation filtering was set, <span class='code'>false</span> otherwise. */
	bool				ShowDecimationFilter(bool & out_filter) const;

	/*! Shows if interpolation filtering is use for this ImageGlyphElement.
	 * \param out_filter If the glyph should use interpolation filtering.
	 * \return <span class='code'>true</span> if a interpolation filtering was set, <span class='code'>false</span> otherwise. */
	bool				ShowInterpolationFilter(bool & out_filter) const;

	/*! Shows if fixed scaling is used for this ImageGlyphElement.
	 * \param out_fixed_scale If the glyph should use the image size for scaling or the effective marker size.
	 * \return <span class='code'>true</span> if a fixed scaling was set, <span class='code'>false</span> otherwise. */
	bool				ShowFixedScaling(bool & out_fixed_scale) const;

	/*! Shows if fixed color is used for this ImageGlyphElement.
	 * \param out_fixed_color If the glyph should use the image colors or the effective marker color.
	 * \return <span class='code'>true</span> if a fixed color was set, <span class='code'>false</span> otherwise. */
	bool				ShowFixedColoring(bool & out_fixed_color) const;

};


/*! The DotGlyphElement class is a user space object.  It is used to dot elements to glyphs. */
class HPS_API DotGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty DotGlyphElement object. */
	DotGlyphElement();

	/*! This constructor creates a DotGlyphElement object that contains the same settings as the source GlyphElement.
	 * 	The copy will only be successful if the source glyph element is really an upcast of a dot glyph element.  Otherwise the copy
	 * 	will fail and the resulting DotGlyphElement will be invalid.
	 *	\param in_that The source GlyphElement to copy. */
	DotGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new DotGlyphElement object that contains the same settings as the source DotGlyphElement.
	 * 	\param in_that The source DotGlyphElement to copy. */
	DotGlyphElement(DotGlyphElement const & in_that);

	/*! This constructor creates a DotGlyphElement with the specified point.
	 *	\param in_point The point for the dot. */
	explicit DotGlyphElement(GlyphPoint const & in_point);

	/*! The move constructor creates a DotGlyphElement by transferring the underlying impl of the rvalue reference to this DotGlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a DotGlyphElement to take the impl from. */
	DotGlyphElement(DotGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this DotGlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a DotGlyphElement to take the impl from.
	 * 	\return A reference to this DotGlyphElement. */
	DotGlyphElement & operator=(DotGlyphElement && in_that);

	~DotGlyphElement();

	static const HPS::Type staticType = HPS::Type::DotGlyphElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the point for this DotGlyphElement.
	 * 	\param in_point The point for the dot. */
	void 				SetPoint(GlyphPoint const & in_point);

	/*! Shows the point for this DotGlyphElement.
	 * 	\param out_point The point for the dot.
	 *	\return <span class='code'>true</span> if a point was set, <span class='code'>false</span> otherwise. */
	bool 				ShowPoint(GlyphPoint & out_point) const;
};


/*! The EllipseGlyphElement class is a user space object.  It is used to add ellipse elements to glyphs. */
class HPS_API EllipseGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty EllipseGlyphElement object. */
	EllipseGlyphElement();

	/*! This constructor creates a EllipseGlyphElement object that contains the same settings as the source GlyphElement.
	 * 	The copy will only be successful if the source glyph element is really an upcast of an ellipse glyph element.  Otherwise the copy
	 * 	will fail and the resulting EllipseGlyphElement will be invalid.
	 *	\param in_that The source GlyphElement to copy. */
	EllipseGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new EllipseGlyphElement object that contains the same settings as the source EllipseGlyphElement.
	 * 	\param in_that The source EllipseGlyphElement to copy. */
	EllipseGlyphElement(EllipseGlyphElement const & in_that);

	/*! This constructor creates a EllipseGlyphElement with the lower left and upper right points for the bounding box which circumscribes the ellipse.
	 *	\param in_lower_left The lower left point for the bounding box which circumscribes the ellipse.
	 *	\param in_upper_right The upper right point for the bounding box which circumscribes the ellipse. */
	EllipseGlyphElement(GlyphPoint const & in_lower_left, GlyphPoint const & in_upper_right);

	/*! The move constructor creates an EllipseGlyphElement by transferring the underlying impl of the rvalue reference to this EllipseGlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an EllipseGlyphElement to take the impl from. */
	EllipseGlyphElement(EllipseGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipseGlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an EllipseGlyphElement to take the impl from.
	 * 	\return A reference to this EllipseGlyphElement. */
	EllipseGlyphElement & operator=(EllipseGlyphElement && in_that);

	~EllipseGlyphElement();

	static const HPS::Type staticType = HPS::Type::EllipseGlyphElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the lower left point for the bounding box which circumscribes the ellipse for this EllipseGlyphElement.
	 * 	\param in_point The lower left point for the bounding box which circumscribes the ellipse. */
	void				SetLowerLeft(GlyphPoint const & in_point);

	/*! Sets the upper right point for the bounding box which circumscribes the ellipse for this EllipseGlyphElement.
	 * 	\param in_point The upper right point for the bounding box which circumscribes the ellipse. */
	void				SetUpperRight(GlyphPoint const & in_point);

	/*! Sets the lower left and upper right points for the bounding box which circumscribes the ellipse for this EllipseGlyphElement.
	 *	\param in_lower_left The lower left point for the bounding box which circumscribes the ellipse.
	 *	\param in_upper_right The upper right point for the bounding box which circumscribes the ellipse. */
	void				SetPoints(GlyphPoint const & in_lower_left, GlyphPoint const & in_upper_right);

	/*! Shows the lower left point for the bounding box which circumscribes the ellipse for this EllipseGlyphElement.
	 * 	\param out_point The lower left point for the bounding box which circumscribes the ellipse.
	 *	\return <span class='code'>true</span> if a lower left point was set, <span class='code'>false</span> otherwise. */
	bool				ShowLowerLeft(GlyphPoint & out_point) const;

	/*! Shows the upper right point for the bounding box which circumscribes the ellipse for this EllipseGlyphElement.
	 * 	\param out_point The upper right point for the bounding box which circumscribes the ellipse.
	 *	\return <span class='code'>true</span> if an upper right point was set, <span class='code'>false</span> otherwise. */
	bool				ShowUpperRight(GlyphPoint & out_point) const;
};

/*! The SphereGlyphElement class is a user space object.  It is used to add ellipse elements to glyphs. */
class HPS_API SphereGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty SphereGlyphElement object. */
	SphereGlyphElement();

	/*! This constructor creates a SphereGlyphElement object that contains the same settings as the source GlyphElement.
	* 	The copy will only be successful if the source glyph element is really an upcast of an ellipse glyph element.  Otherwise the copy
	* 	will fail and the resulting SphereGlyphElement will be invalid.
	*	\param in_that The source GlyphElement to copy. */
	SphereGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new SphereGlyphElement object that contains the same settings as the source SphereGlyphElement.
	* 	\param in_that The source SphereGlyphElement to copy. */
	SphereGlyphElement(SphereGlyphElement const & in_that);

	/*! The move constructor creates an EllipseGlyphElement by transferring the underlying impl of the rvalue reference to this SphereGlyphElement
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to an SphereGlyphElement to take the impl from. */
	SphereGlyphElement(SphereGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SphereGlyphElement thereby avoiding a copy.
	* 	\param in_that An rvalue reference to an SphereGlyphElement to take the impl from.
	* 	\return A reference to this SphereGlyphElement. */
	SphereGlyphElement & operator=(SphereGlyphElement && in_that);

	~SphereGlyphElement();

	static const HPS::Type staticType = HPS::Type::SphereGlyphElement;
	HPS::Type			ObjectType() const { return staticType; };
};


/*! The CircularArcGlyphElement class is a user space object.  It is used to add circular arc elements to a glyph. */
class HPS_API CircularArcGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty CircularArcGlyphElement object. */
	CircularArcGlyphElement();

	/*! This constructor creates a CircularArcGlyphElement object that contains the same settings as the source GlyphElement.
	 * 	The copy will only be successful if the source glyph element is really an upcast of a circular arc glyph element.  Otherwise the copy
	 * 	will fail and the resulting CircularArcGlyphElement will be invalid.
	 *	\param in_that The source GlyphElement to copy. */
	CircularArcGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new CircularArcGlyphElement object that contains the same settings as the source CircularArcGlyphElement.
	 * 	\param in_that The source CircularArcGlyphElement to copy. */
	CircularArcGlyphElement(CircularArcGlyphElement const & in_that);

	/*! This constructor creates a CircularArcGlyphElement with the specified start, intermediate, and end points.
	 *	\param in_start The start point for the circular arc.
	 *	\param in_intermediate The intermediate point for the circular arc.
	 *	\param in_end The end point for the circular arc. */
	CircularArcGlyphElement(GlyphPoint const & in_start, GlyphPoint const & in_intermediate, GlyphPoint const & in_end);

	/*! The move constructor creates a CircularArcGlyphElement by transferring the underlying impl of the rvalue reference to this CircularArcGlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircularArcGlyphElement to take the impl from. */
	CircularArcGlyphElement(CircularArcGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircularArcGlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a CircularArcGlyphElement to take the impl from.
	 * 	\return A reference to this CircularArcGlyphElement. */
	CircularArcGlyphElement & operator=(CircularArcGlyphElement && in_that);

	~CircularArcGlyphElement();

	static const HPS::Type staticType = HPS::Type::CircularArcGlyphElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the start point for the circular arc for this CircularArcGlyphElement.
	 * 	\param in_point The start point for the circular arc. */
	void				SetStartPoint(GlyphPoint const & in_point);

	/*! Sets the intermediate point for the circular arc for this CircularArcGlyphElement.
	 * 	\param in_point The intermediate point for the circular arc. */
	void				SetIntermediatePoint(GlyphPoint const & in_point);

	/*! Sets the end point for the circular arc for this CircularArcGlyphElement.
	 * 	\param in_point The end point for the circular arc. */
	void				SetEndPoint(GlyphPoint const & in_point);

	/*! Sets the start, intermediate, and end points for the circular arc for this CircularArcGlyphElement.
	 * 	\param in_point The start point for the circular arc.
	 * 	\param in_point The intermediate point for the circular arc.
	 * 	\param in_point The end point for the circular arc. */
	void				SetPoints(GlyphPoint const & in_start, GlyphPoint const & in_intermediate, GlyphPoint const & in_end);

	/*! Shows the start point for the circular arc for this CircularArcGlyphElement.
	 * 	\param out_point The start point for the circular arc.
	 *	\return <span class='code'>true</span> if a start point was set, <span class='code'>false</span> otherwise. */
	bool				ShowStartPoint(GlyphPoint & out_point) const;

	/*! Shows the intermediate point for the circular arc for this CircularArcGlyphElement.
	 * 	\param out_point The intermediate point for the circular arc.
	 *	\return <span class='code'>true</span> if an intermediate point was set, <span class='code'>false</span> otherwise. */
	bool				ShowIntermediatePoint(GlyphPoint & out_point) const;

	/*! Shows the end point for the circular arc for this CircularArcGlyphElement.
	 * 	\param out_point The end point for the circular arc.
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool				ShowEndPoint(GlyphPoint & out_point) const;
};



/*! The InfiniteLineGlyphElement class is a user space object.  It is used to add infinite line and ray elements to a glyph. */
class HPS_API InfiniteLineGlyphElement : public GlyphElement
{
public:
	/*! The default constructor creates an empty InfiniteLineGlyphElement object. */
	InfiniteLineGlyphElement();

	/*! This constructor creates a InfiniteLineGlyphElement object that contains the same settings as the source GlyphElement.
	 * 	The copy will only be successful if the source glyph element is really an upcast of an infinite line glyph element.  Otherwise the copy
	 * 	will fail and the resulting InfiniteLineGlyphElement will be invalid.
	 *	\param in_that The source GlyphElement to copy. */
	InfiniteLineGlyphElement(GlyphElement const & in_that);

	/*! The copy constructor creates a new InfiniteLineGlyphElement object that contains the same settings as the source InfiniteLineGlyphElement.
	 * 	\param in_that The source InfiniteLineGlyphElement to copy. */
	InfiniteLineGlyphElement(InfiniteLineGlyphElement const & in_that);

	/*! This constructor creates a InfiniteLineGlyphElement with the specified vector and type.
	 *	\param in_first The first point along the InfiniteLineGlyphElement
	 *	\param in_second The second point along the InfiniteLineGlyphElement
	 *	\param in_type The type of infinite line - either Ray or Line */
	InfiniteLineGlyphElement(GlyphPoint const & in_first, GlyphPoint const & in_second, InfiniteLine::Type in_type = InfiniteLine::Type::Line);

	/*! The move constructor creates an InfiniteLineGlyphElement by transferring the underlying impl of the rvalue reference to this InfiniteLineGlyphElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an InfiniteLineGlyphElement to take the impl from. */
	InfiniteLineGlyphElement(InfiniteLineGlyphElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this InfiniteLineGlyphElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an InfiniteLineGlyphElement to take the impl from.
	 * 	\return A reference to this InfiniteLineGlyphElement. */
	InfiniteLineGlyphElement & operator=(InfiniteLineGlyphElement && in_that);

	~InfiniteLineGlyphElement();

	static const HPS::Type staticType = HPS::Type::InfiniteLineGlyphElement;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Sets the first point for the vector defining the infinite line or ray for this InfiniteLineGlyphElement.
	 * 	\param in_point The first point for the vector defining the infinite line or ray. */
	void					SetFirstPoint(GlyphPoint const & in_point);

	/*! Sets the second point for the vector defining the infinite line or ray for this InfiniteLineGlyphElement.
	 * 	\param in_point The second point for the vector defining the infinite line or ray. */
	void					SetSecondPoint(GlyphPoint const & in_point);

	/*! Sets the points for the vector defining the infinite line or ray for this InfiniteLineGlyphElement.
	 * 	\param in_first The first point for the vector defining the infinite line or ray.
	 * 	\param in_second The second point for the vector defining the infinite line or ray. */
	void					SetPoints(GlyphPoint const & in_first, GlyphPoint const & in_second);

	/*! Sets the type of this InfiniteLineGlyphElement, i.e., whether it represents an infinite line or ray.
	 * 	\param in_type The type of this InfiniteLineGlyphElement. */
	void					SetInfiniteType(InfiniteLine::Type in_type);

	/*! Shows the first point for the vector defining the infinite line or ray for this InfiniteLineGlyphElement.
	 * 	\param out_point The first point for the vector defining the infinite line or ray.
	 *	\return <span class='code'>true</span> if a first point was set, <span class='code'>false</span> otherwise. */
	bool					ShowFirstPoint(GlyphPoint & out_point) const;

	/*! Shows the second point for the vector defining the infinite line or ray for this InfiniteLineGlyphElement.
	 * 	\param out_point The second point for the vector defining the infinite line or ray.
	 *	\return <span class='code'>true</span> if a second point was set, <span class='code'>false</span> otherwise. */
	bool					ShowSecondPoint(GlyphPoint & out_point) const;

	/*! Shows the type of this InfiniteLineGlyphElement.
	 * 	\param out_type The type of this InfiniteLineGlyphElement.
	 *	\return <span class='code'>true</span> if a type was set, <span class='code'>false</span> otherwise. */
	bool					ShowInfiniteType(InfiniteLine::Type & out_type) const;
};



/*! The GlyphKit class is a user space object.  It is used when defining a glyph. */
class HPS_API GlyphKit : public Kit
{
public:
	/*! The default constructor creates an empty GlyphKit object. */
	GlyphKit();

	/*! The copy constructor creates a new GlyphKit object that contains the same settings as the source GlyphKit.
	 * 	\param in_kit The source GlyphKit to copy. */
	GlyphKit(GlyphKit const & in_kit);

	/*! The move constructor creates a GlyphKit by transferring the underlying impl of the rvalue reference to this GlyphKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a GlyphKit to take the impl from. */
	GlyphKit(GlyphKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this GlyphKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a GlyphKit to take the impl from.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit & operator=(GlyphKit && in_that);

	virtual ~GlyphKit();

	static const HPS::Type staticType = HPS::Type::GlyphKit;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Creates a GlyphKit which contains the definition of the specified default glyph.
	 * 	\param in_default_glyph The default glyph for which to get the corresponding GlyphKit.
	 * 	\return A GlyphKit which contains the definition of the specified default glyph. */
	static HPS::GlyphKit 	GetDefault(Glyph::Default in_default_glyph);

	/*! Copies the source GlyphKit into this GlyphKit.
	 * 	\param in_kit The source GlyphKit to copy. */
	void					Set(GlyphKit const & in_kit);

	/*! Copies this GlyphKit into the given GlyphKit.
	 * 	\param out_kit The GlyphKit to populate with the contents of this GlyphKit. */
	void					Show(GlyphKit & out_kit) const;

	/*! Copies the source GlyphKit into this GlyphKit.
	 * 	\param in_kit The source GlyphKit to copy.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				operator=(GlyphKit const & in_kit);

	/*! Indicates whether this GlyphKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this GlyphKit, <span class='code'>false</span> otherwise. */
	bool					Empty() const;

	/*!	Check if the source GlyphKit is equivalent to this GlyphKit.
	 *	\param in_kit The source GlyphKit to compare to this GlyphKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(GlyphKit const & in_kit) const;

	/*!	Check if the source GlyphKit is equivalent to this GlyphKit.
	 *	\param in_kit The source GlyphKit to compare to this GlyphKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(GlyphKit const & in_kit) const;

	/*!	Check if the source GlyphKit is not equivalent to this GlyphKit.
	 *	\param in_kit The source GlyphKit to compare to this GlyphKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(GlyphKit const & in_kit) const;

	/*! Sets the radius of this GlyphKit.  This must be specified when defining a glyph.
	 * 	\param in_radius The radius of the glyph.  The value must be in the range <span class='code'>[0,127]</span>.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit & 				SetRadius(sbyte in_radius);

	/*! Sets the offset for this GlyphKit.  This will determine how the glyph gets shifted relative to the insertion point when the glyph is use.
	 * 	This must be specified when defining a glyph.
	 * 	\param in_point The offset for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				SetOffset(GlyphPoint const & in_point);

	/*! Sets ordering for this GlyphKit.  This will determine whether the glyphs elements are drawn in the order specified.
	 *  This setting is optional.  The default is that glyph elements may be regrouped for faster drawing.
	 * 	\param in_ordered The ordering requirement for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				SetOrdered(bool in_ordered);

	/*! Sets the elements for this GlyphKit.  This must be specified when defining a glyph.
	 * 	\param in_def The array of elements for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				SetElements(GlyphElementArray const & in_def);

	/*! Sets the elements for this GlyphKit.  This must be specified when defining a glyph.
	 * 	\param in_count Size of the following array.
	 * 	\param in_def The array of elements for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				SetElements(size_t in_count, GlyphElement const in_def []);

	/*! Set a single element for this GlyphKit.  This must be specified when defining a glyph.
	 * 	\param in_element A reference to the GlyphElement to set on this kit.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				SetElement(GlyphElement const & in_element);

	/*! Removes the radius for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit & 				UnsetRadius();

	/*! Removes the offset for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				UnsetOffset();

	/*! Removes the ordering requirement for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				UnsetOrdered();

	/*! Removes the elements for the glyph.
	 * 	\return A reference to this GlyphKit. */
	GlyphKit &				UnsetElements();

	/*! Removes all settings from this GlyphKit.
	 *	\return A reference to this GlyphKit. */
	GlyphKit &				UnsetEverything();

	/*! Shows the radius for this GlyphKit.
	 * 	\param out_radius The radius for the glyph.
	 *	\return <span class='code'>true</span> if a radius was set, <span class='code'>false</span> otherwise. */
	bool					ShowRadius(sbyte & out_radius) const;

	/*! Shows the offset for this GlyphKit.
	 * 	\param out_point The offset for the glyph.
	 *	\return <span class='code'>true</span> if an offset was set, <span class='code'>false</span> otherwise. */
	bool					ShowOffset(GlyphPoint & out_point) const;

	/*! Shows the ordering requirement for this GlyphKit.
	 * 	\param out_point The offset for the glyph.
	 *	\return <span class='code'>true</span> if an offset was set, <span class='code'>false</span> otherwise. */
	bool					ShowOrdered(bool & out_ordered) const;

	/*! Shows the elements for this GlyphKit.
	 * 	\param out_def The elements for the glyph.
	 *	\return <span class='code'>true</span> if elements were set, <span class='code'>false</span> otherwise. */
	bool					ShowElements(GlyphElementArray & out_def) const;
};

//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// Line Patterns ////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////


/*! The LinePatternOptionsKit class is a user space object.  It is used for specifying (or overriding) some line pattern options when setting a line pattern
 * 	on a segment. */
class HPS_API LinePatternOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty LinePatternOptionsKit object. */
	LinePatternOptionsKit();

	/*! The copy constructor creates a new LinePatternOptionsKit object that contains the same settings as the source LinePatternOptionsKit.
	 * 	\param in_kit The source LinePatternOptionsKit to copy. */
	LinePatternOptionsKit(LinePatternOptionsKit const & in_kit);

	/*! The move constructor creates a LinePatternOptionsKit by transferring the underlying impl of the rvalue reference to this LinePatternOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LinePatternOptionsKit to take the impl from. */
	LinePatternOptionsKit(LinePatternOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LinePatternOptionsKit thereby avoiding a copy.
	 * \param in_that An rvalue reference to a LinePatternOptionsKit to take the impl from.
	 * \return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit & operator=(LinePatternOptionsKit && in_that);

	virtual ~LinePatternOptionsKit();

	static const HPS::Type staticType = HPS::Type::LinePatternOptionsKit;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Copies the source LinePatternOptionsKit into this LinePatternOptionsKit.
	 * 	\param in_kit The source LinePatternOptionsKit to copy. */
	void						Set(LinePatternOptionsKit const & in_kit);

	/*! Copies this LinePatternOptionsKit into the given LinePatternOptionsKit.
	 * 	\param out_kit The LinePatternOptionsKit to populate with the contents of this LinePatternOptionsKit. */
	void						Show(LinePatternOptionsKit & out_kit) const;

	/*! Copies the source LinePatternOptionsKit into this LinePatternOptionsKit.
	 * 	\param in_kit The source LinePatternOptionsKit to copy.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		operator=(LinePatternOptionsKit const & in_kit);

	/*! Indicates whether this LinePatternOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this LinePatternOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source LinePatternOptionsKit is equivalent to this LinePatternOptionsKit.
	 *	\param in_kit The source LinePatternOptionsKit to compare to this LinePatternOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(LinePatternOptionsKit const & in_kit) const;

	/*!	Check if the source LinePatternOptionsKit is equivalent to this LinePatternOptionsKit.
	 *	\param in_kit The source LinePatternOptionsKit to compare to this LinePatternOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(LinePatternOptionsKit const & in_kit) const;

	/*!	Check if the source LinePatternOptionsKit is not equivalent to this LinePatternOptionsKit.
	 *	\param in_kit The source LinePatternOptionsKit to compare to this LinePatternOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(LinePatternOptionsKit const & in_kit) const;

	/*! Sets the glyph to use as the start cap for the associated line pattern.
	 * 	\param in_glyph UTF8-encoded name of the glyph to use as the start cap for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetStartCap(char const * in_glyph);

	/*! Sets the cap to use as the start cap for the associated line pattern.
	 * 	\param in_type The type of cap to use as the start cap for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetStartCap(LinePattern::Cap in_type);

	/*! Sets the glyph to use as the end cap for the associated line pattern.
	 * 	\param in_glyph UTF8-encoded name of the glyph to use as the end cap for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetEndCap(char const * in_glyph);

	/*! Sets the cap to use as the end cap for the associated line pattern.
	 * 	\param in_type The type of cap to use as the end cap for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetEndCap(LinePattern::Cap in_type);

	/*! Sets the cap to use as the inner cap for the associated line pattern.
	 * 	\param in_type The type of cap to use as the inner cap for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetInnerCap(LinePattern::Cap in_type);

	/*! Sets the glyph to use as the join for the associated line pattern.
	 * 	\param in_glyph UTF8-encoded name of the glyph to use as the join for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetJoin(char const * in_glyph);

	/*! Sets the join to use for the associated line pattern.
	 * 	\param in_type The type of join to use for the associated line pattern.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		SetJoin(LinePattern::Join in_type);

	/*! Removes the start cap for this LinePatternOptionsKit.  This will result in the start cap defined on the associated line pattern (if any) getting used when
	 * 	set with this LinePatternOptionsKit.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		UnsetStartCap();

	/*! Removes the end cap for this LinePatternOptionsKit.  This will result in the end cap defined on the associated line pattern (if any) getting used when
	 * 	set with this LinePatternOptionsKit.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		UnsetEndCap();

	/*! Removes the inner cap for this LinePatternOptionsKit.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		UnsetInnerCap();

	/*! Removes the join for this LinePatternOptionsKit.  This will result in the join defined on the associated line pattern (if any) getting used when
	 * 	set with this LinePatternOptionsKit.
	 * 	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		UnsetJoin();

	/*! Removes all settings from this LinePatternOptionsKit.
	 *	\return A reference to this LinePatternOptionsKit. */
	LinePatternOptionsKit &		UnsetEverything();

	/*! Shows the start cap for this LinePatternOptionsKit.
	 *	\param out_modifier Indicates which of the following arguments is valid.
	 *	\param out_glyph UTF8-encoded name of the glyph to use as the start cap.  This is only valid if <span class='code'>out_modifier</span> is LinePattern::Modifier::GlyphName.
	 *	\param out_type The predefined type of cap to use as the start cap.  This is only valid if <span class='code'>out_modifier</span> is LinePattern::Modifier::Enumerated.
	 *	\return <span class='code'>true</span> if a start cap was set, <span class='code'>false</span> otherwise. */
	bool						ShowStartCap(LinePattern::Modifier & out_modifier, UTF8 & out_glyph, LinePattern::Cap & out_type) const;

	/*! Shows the end cap for this LinePatternOptionsKit.
	 *	\param out_modifier Indicates which of the following arguments is valid.
	 *	\param out_glyph UTF8-encoded name of the glyph to use as the end cap.  This is only valid if <span class='code'>out_modifier</span> is LinePattern::Modifier::GlyphName.
	 *	\param out_type The predefined type of cap to use as the end cap.  This is only valid if <span class='code'>out_modifier</span> is LinePattern::Modifier::Enumerated.
	 *	\return <span class='code'>true</span> if an end cap was set, <span class='code'>false</span> otherwise. */
	bool						ShowEndCap(LinePattern::Modifier & out_modifier, UTF8 & out_glyph, LinePattern::Cap & out_type) const;

	/*! Shows the inner cap for this LinePatternOptionsKit.
	 *	\param out_type The predefined type of cap to use as the inner cap.
	 *	\return <span class='code'>true</span> if an inner cap was set, <span class='code'>false</span> otherwise. */
	bool						ShowInnerCap(LinePattern::Cap & out_type) const;

	/*! Shows the join for this LinePatternOptionsKit.
	 *	\param out_modifier Indicates which of the following arguments is valid.
	 *	\param out_glyph UTF8-encoded name of the glyph to use as the join.  This is only valid if <span class='code'>out_modifier</span> is LinePattern::Modifier::GlyphName.
	 *	\param out_type The predefined type of join to use.  This is only valid if <span class='code'>out_modifier</span> is LinePattern::Modifier::Enumerated.
	 *	\return <span class='code'>true</span> if a join was set, <span class='code'>false</span> otherwise. */
	bool						ShowJoin(LinePattern::Modifier & out_modifier, UTF8 & out_glyph, LinePattern::Join & out_type) const;
};

/*! The LinePatternElement class is a user space object.  It is the base class for other line pattern element types.  Line pattern elements are used
 * 	to define a pattern that can be assigned lines or edges. */
class HPS_API LinePatternElement : public Object
{
public:
	/*! The default constructor creates an empty LinePatternElement object. */
	LinePatternElement();

	/*! The copy constructor creates a new LinePatternElement object that contains the same settings as the source LinePatternElement.
	 * 	\param in_that The source LinePatternElement to copy. */
	LinePatternElement(LinePatternElement const & in_that);

	/*! The move constructor creates a LinePatternElement by transferring the underlying impl of the rvalue reference to this LinePatternElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LinePatternElement to take the impl from. */
	LinePatternElement(LinePatternElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LinePatternElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an LinePatternElement to take the impl from.
	 * 	\return A reference to this LinePatternElement. */
	LinePatternElement & operator=(LinePatternElement && in_that);

	~LinePatternElement();

	static const HPS::Type staticType = HPS::Type::LinePatternElement;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source LinePatternElement into this LinePatternElement.
	 * 	\param in_that The source LinePatternElement to copy. */
	void					Set(LinePatternElement const & in_that);

	/*! Copies the source LinePatternElement into this LinePatternElement.
	 * 	\param in_that The source LinePatternElement to copy.
	 * 	\return A reference to this LinePatternElement. */
	LinePatternElement &	operator=(LinePatternElement const & in_that);

	/*!	Check if the source LinePatternElement is equivalent to this LinePatternElement.
	 *	\param in_that The source LinePatternElement to compare to this LinePatternElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(LinePatternElement const & in_that) const;

	/*!	Check if the source LinePatternElement is equivalent to this LinePatternElement.
	 *	\param in_that The source LinePatternElement to compare to this LinePatternElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(LinePatternElement const & in_that) const;

	/*!	Check if the source LinePatternElement is not equivalent to this LinePatternElement.
	 *	\param in_that The source LinePatternElement to compare to this LinePatternElement.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(LinePatternElement const & in_that) const;

	/*! Sets the size of this LinePatternElement.
	 * 	\param in_size The size of this LinePatternElement.
	 * 	\param in_units The units for the size of this LinePatternElement. */
	void					SetSize(float in_size, LinePattern::SizeUnits in_units);

	/*! Shows the size of this LinePatternElement.
	 * 	\param out_size The size of this LinePatternElement.
	 * 	\param out_units The units for the size of this LinePatternElement.
	 * 	\return <span class='code'>true</span> if a size was set, <span class='code'>false</span> otherwise. */
	bool					ShowSize(float & out_size, LinePattern::SizeUnits & out_units) const;
};

/*! The SolidLinePatternElement class is a user space object.  It is used for specifying solid elements within a line pattern. */
class HPS_API SolidLinePatternElement : public LinePatternElement
{
public:
	/*! The default constructor creates an empty SolidLinePatternElement object. */
	SolidLinePatternElement();

	/*! This constructor creates a SolidLinePatternElement object that contains the same settings as the source LinePatternElement.
	 * 	The copy will only be successful if the source line pattern element is really an upcast of a solid line pattern element.  Otherwise the copy
	 * 	will fail and the resulting SolidLinePatternElement will be invalid.
	 *	\param in_that The source LinePatternElement to copy. */
	SolidLinePatternElement(LinePatternElement const & in_that);

	/*! The copy constructor creates a new SolidLinePatternElement object that contains the same settings as the source SolidLinePatternElement.
	 * 	\param in_that The source SolidLinePatternElement to copy. */
	SolidLinePatternElement(SolidLinePatternElement const & in_that);

	/*! This constructor creates a SolidLinePatternElement with a given size.
	 *	\param in_size The length of the SolidLinePatternElement.
	 *	\param in_units The units for the length of the SolidLinePatternElement. */
	SolidLinePatternElement(float in_size, LinePattern::SizeUnits in_units);

	/*! The move constructor creates a SolidLinePatternElement by transferring the underlying impl of the rvalue reference to this SolidLinePatternElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SolidLinePatternElement to take the impl from. */
	SolidLinePatternElement(SolidLinePatternElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SolidLinePatternElement thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SolidLinePatternElement to take the impl from.
	 *	\return A reference to this SolidLinePatternElement. */
	SolidLinePatternElement & operator=(SolidLinePatternElement && in_that);

	~SolidLinePatternElement();

	static const HPS::Type staticType = HPS::Type::SolidLinePatternElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the color for this SolidLinePatternElement.  If this is not set, this SolidLinePatternElement will take the effective line (or edge) color
	 * 	in the segment where the line (or edge) pattern is used.
	 *  \param in_color The color for this SolidLinePatternElement. */
	void				SetColor(RGBAColor const & in_color);

	/*! Sets the color (by material index) for this SolidLinePatternElement.  If this is not set, this SolidLinePatternElement will take the effective line (or edge)
	 * 	color in the segment where the line (or edge) pattern is used.
	 *  \param in_color The color for this SolidLinePatternElement. */
	void				SetMaterialByIndex(float in_material_index);

	/*! Shows the color for this SolidLinePatternElement.
	 *	\param out_type Indicates which of the following arguments is valid.
	 *	\param out_color The color of this SolidLinePatternElement.  This is only valid if <span class='code'>out_type</span> is Material::Type::RGBAColor.
	 *	\param out_index The material index for this SolidLinePatternElement.  This is only valid if <span class='code'>out_type</span> is Material::Type::MaterialIndex.
	 *	\return <span class='code'>true</span> if a color was set, <span class='code'>false</span> otherwise. */
	bool				ShowColor(Material::Type & out_type, RGBAColor & out_color, float & out_index) const;
};


/*! The BlankLinePatternElement class is a user space object.  It is used for specifying blank elements within a line pattern. */
class HPS_API BlankLinePatternElement : public LinePatternElement
{
public:
	/*! The default constructor creates an empty BlankLinePatternElement object. */
	BlankLinePatternElement();

	/*! This constructor creates a BlankLinePatternElement object that contains the same settings as the source LinePatternElement.
	 * 	The copy will only be successful if the source line pattern element is really an upcast of a blank line pattern element.  Otherwise the copy
	 * 	will fail and the resulting BlankLinePatternElement will be invalid.
	 *	\param in_that The source LinePatternElement to copy. */
	BlankLinePatternElement(LinePatternElement const & in_that);

	/*! The copy constructor creates a new BlankLinePatternElement object that contains the same settings as the source BlankLinePatternElement.
	 * 	\param in_that The source BlankLinePatternElement to copy. */
	BlankLinePatternElement(BlankLinePatternElement const & in_that);

	/*! This constructor creates a BlankLinePatternElement with a given size.
	 *	\param in_size The length of the BlankLinePatternElement.
	 *	\param in_units The units for the length of the BlankLinePatternElement. */
	BlankLinePatternElement(float in_size, LinePattern::SizeUnits in_units);

	/*! The move constructor creates a BlankLinePatternElement by transferring the underlying impl of the rvalue reference to this BlankLinePatternElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a BlankLinePatternElement to take the impl from. */
	BlankLinePatternElement(BlankLinePatternElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this BlankLinePatternElement thereby avoiding a copy.
	 *	\param in_that An rvalue reference to an BlankLinePatternElement to take the impl from.
	 *	\return A reference to this BlankLinePatternElement. */
	BlankLinePatternElement & operator=(BlankLinePatternElement && in_that);

	~BlankLinePatternElement();

	static const HPS::Type staticType = HPS::Type::BlankLinePatternElement;
	HPS::Type		ObjectType() const { return staticType; };
};


/*! The GlyphLinePatternElement class is a user space object.  It is used for specifying glyphs elements within a line pattern. */
class HPS_API GlyphLinePatternElement : public LinePatternElement
{
public:
	/*! The default constructor creates an empty GlyphLinePatternElement object. */
	GlyphLinePatternElement();

	/*! This constructor creates a GlyphLinePatternElement object that contains the same settings as the source LinePatternElement.
	 * 	The copy will only be successful if the source line pattern element is really an upcast of a glyph line pattern element.  Otherwise the copy
	 * 	will fail and the resulting GlyphLinePatternElement will be invalid.
	 *	\param in_that The source LinePatternElement to copy. */
	GlyphLinePatternElement(LinePatternElement const & in_that);

	/*! The copy constructor creates a new GlyphLinePatternElement object that contains the same settings as the source GlyphLinePatternElement.
	 * 	\param in_that The source GlyphLinePatternElement to copy. */
	GlyphLinePatternElement(GlyphLinePatternElement const & in_that);

	/*! Copies the source GlyphLinePatternElement into this GlyphLinePatternElement.
	 * 	\param in_that The source GlyphLinePatternElement to copy.
	 * 	\return A reference to this GlyphLinePatternElement. */
	GlyphLinePatternElement & operator=(GlyphLinePatternElement const & in_that);

	/*! The move constructor creates a GlyphLinePatternElement by transferring the underlying impl of the rvalue reference to this GlyphLinePatternElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a GlyphLinePatternElement to take the impl from. */
	GlyphLinePatternElement(GlyphLinePatternElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this GlyphLinePatternElement thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a GlyphLinePatternElement to take the impl from.
	 *	\return A reference to this GlyphLinePatternElement. */
	GlyphLinePatternElement & operator=(GlyphLinePatternElement && in_that);

	~GlyphLinePatternElement();

	static const HPS::Type staticType = HPS::Type::GlyphLinePatternElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the name of the source for this GlyphLinePatternElement.
	 *	\param in_source UTF8-encoded name of the source for this GlyphLinePatternElement. */
	void				SetSource(char const * in_source);

	/*! Sets the weight for this GlyphLinePatternElement.
	 *	\param in_weight The weight for this GlyphLinePatternElement.
	 *	\param in_units The units of the weight for this GlyphLinePatternElement. */
	void				SetWeight(float in_weight, LinePattern::SizeUnits in_units);

	/*! Sets the inset behavior for this GlyphLinePatternElement.
	 *	\param in_behavior The inset behavior for this GlyphLinePatternElement. */
	void				SetInsetBehavior(LinePattern::InsetBehavior in_behavior);

	/*! Sets whether to flip this GlyphLinePatternElement about the x-axis prior to applying any rotation.
	 *	\param in_state Whether to flip this GlyphLinePatternElement about the x-axis prior to applying any rotation. */
	void				SetMirror(bool in_state);

	/*! Sets whether the angle of the GlyphLinePatternElement should be fixed relative to the line vector.
	 *	\param in_state Whether the angle of the GlyphLinePatternElement should be fixed relative to the line vector. */
	void				SetFixed(bool in_state);

	/*! Sets the angle in degrees the GlyphLinePatternElement is rotated relative to the line vector.
	 *	\param in_degrees The angle in degrees the GlyphLinePatternElement is rotated relative to the line vector. */
	void				SetRotation(float in_degrees);

	/*! Shows the name of the source for this GlyphLinePatternElement.
	 *	\param out_source UTF8-encoded name of the source for this GlyphLinePatternElement.
	 *	\return <span class='code'>true</span> if a source was set, <span class='code'>false</span> otherwise. */
	bool				ShowSource(UTF8 & out_source) const;

	/*! Shows the weight for this GlyphLinePatternElement.
	 *	\param out_weight The weight for this GlyphLinePatternElement.
	 *	\param out_units The units for the weight for this GlyphLinePatternElement.
	 *	\return <span class='code'>true</span> if a weight was set, <span class='code'>false</span> otherwise. */
	bool				ShowWeight(float & out_weight, LinePattern::SizeUnits & out_units) const;

	/*! Shows the inset behavior for this GlyphLinePatternElement.
	 *	\param out_behavior The inset behavior for this GlyphLinePatternElement.
	 *	\return <span class='code'>true</span> if an inset behavior was set, <span class='code'>false</span> otherwise. */
	bool				ShowInsetBehavior(LinePattern::InsetBehavior & out_behavior) const;

	/*! Shows whether to flip this GlyphLinePatternElement about the x-axis prior to applying any rotation.
	 *	\param out_state Whether to flip this GlyphLinePatternElement about the x-axis prior to applying any rotation.
	 *	\return <span class='code'>true</span> if a mirror flag was set, <span class='code'>false</span> otherwise. */
	bool				ShowMirror(bool & out_state) const;

	/*! Shows whether the angle of the GlyphLinePatternElement should be fixed relative to the line vector.
	 *	\param out_state Whether the angle of the GlyphLinePatternElement should be fixed relative to the line vector.
	 *	\return <span class='code'>true</span> if a fixed flag was set, <span class='code'>false</span> otherwise. */
	bool				ShowFixed(bool & out_state) const;

	/*! Shows the angle in degrees the GlyphLinePatternElement is rotated relative to the line vector.
	 *	\param out_degrees The angle in degrees the GlyphLinePatternElement is rotated relative to the line vector.
	 *	\return <span class='code'>true</span> if an angle was set, <span class='code'>false</span> otherwise. */
	bool				ShowRotation(float & out_degrees) const;
};

/*! The LinePatternParallelKit class is a user space object.  It is used to define a single parallel within a line pattern. */
class HPS_API LinePatternParallelKit : public Kit
{
public:
	/*! The default constructor creates an empty LinePatternParallelKit object. */
	LinePatternParallelKit();

	/*! The copy constructor creates a new LinePatternParallelKit object that contains the same settings as the source LinePatternParallelKit.
	 * 	\param in_kit The source LinePatternParallelKit to copy. */
	LinePatternParallelKit(LinePatternParallelKit const & in_kit);

	/*! The move constructor creates a LinePatternParallelKit by transferring the underlying impl of the rvalue reference to this LinePatternParallelKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LinePatternParallelKit to take the impl from. */
	LinePatternParallelKit(LinePatternParallelKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LinePatternParallelKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a LinePatternParallelKit to take the impl from.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit & operator=(LinePatternParallelKit && in_that);

	virtual ~LinePatternParallelKit();

	static const HPS::Type staticType = HPS::Type::LinePatternParallelKit;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Copies the source LinePatternParallelKit into this LinePatternParallelKit.
	 * 	\param in_kit The source LinePatternParallelKit to copy. */
	void						Set(LinePatternParallelKit const & in_kit);

	/*! Copies this LinePatternParallelKit into the given LinePatternParallelKit.
	 * 	\param out_kit The LinePatternParallelKit to populate with the contents of this LinePatternParallelKit. */
	void						Show(LinePatternParallelKit & out_kit) const;

	/*! Copies the source LinePatternParallelKit into this LinePatternParallelKit.
	 * 	\param in_kit The source LinePatternParallelKit to copy.
	 * 	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	operator=(LinePatternParallelKit const & in_kit);

	/*! Indicates whether this LinePatternParallelKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this LinePatternParallelKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source LinePatternParallelKit is equivalent to this LinePatternParallelKit.
	 *	\param in_kit The source LinePatternParallelKit to compare to this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(LinePatternParallelKit const & in_kit) const;

	/*!	Check if the source LinePatternParallelKit is equivalent to this LinePatternParallelKit.
	 *	\param in_kit The source LinePatternParallelKit to compare to this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(LinePatternParallelKit const & in_kit) const;

	/*!	Check if the source LinePatternParallelKit is not equivalent to this LinePatternParallelKit.
	 *	\param in_kit The source LinePatternParallelKit to compare to this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(LinePatternParallelKit const & in_kit) const;

	/*! Sets the glyph to draw at the start point for this LinePatternParallelKit.
	 *	\param in_start The glyph to draw at the start point for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetStartCap(GlyphLinePatternElement const & in_start);

	/*! Sets the glyph to draw at the end point for this LinePatternParallelKit.
	 *	\param in_end The glyph to draw at the end point for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetEndCap(GlyphLinePatternElement const & in_end);

	/*! Sets the glyph to draw at all joins for this LinePatternParallelKit.
	 *	\param in_join The glyph to draw at all joins for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetJoin(GlyphLinePatternElement const & in_join);

	/*! Sets the line pattern element array for this LinePatternParallelKit.
	 *	\param in_elements The line pattern element array for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetBody(LinePatternElementArray const & in_elements);

	/*! Sets the line pattern element body for this LinePatternParallelKit.
	 *	\param in_count Size of the following array.
	 *	\param in_elements The line pattern element body for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetBody(size_t in_count, LinePatternElement const in_elements []);

	/*! Sets the line pattern element body for this LinePatternParallelKit.
	 *	\param in_element The line pattern element body for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetBody(LinePatternElement const & in_element);

	/*! Sets a flag indicating whether to prevent scaling line pattern elements whose size is specified in pixels for this LinePatternParallelKit.
	 *	\param in_state Whether to prevent scaling line pattern elements whose size is specified in pixels for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetAbsoluteLength(bool in_state);

	/*! Sets a flag indicating whether to prevent scaling line pattern elements whose weight is specified in pixels for this LinePatternParallelKit.
	 *	\param in_state Whether to prevent scaling line pattern elements whose weight is specified in pixels for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetAbsoluteWeight(bool in_state);

	/*! Sets how the pattern will fit between the end points for this LinePatternParallelKit.
	 *	\param in_type How the pattern will fit between the end points for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetJustification(LinePattern::Justification in_type);

	/*! Sets the offset above or below the line connecting two points defining a segment for this LinePatternParallelKit.
	 *	\param in_offset The offset above (positive) or below (negative) the line connecting two points defining a segment for this LinePatternParallelKit.
	 *	\param in_units The units for the offset for this LinePatternParallelKit.
	 *	\param in_fixed Whether to prevent scaling the offset based on the effective line weight in the segment where this pattern is used.
	 *		Defaults to <span class='code'>false</span>.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetOffset(float in_offset, LinePattern::SizeUnits in_units, bool in_fixed = false);

	/*! Sets the line weight for this LinePatternParallelKit.
	 *	\param in_weight The line weight for this LinePatternParallelKit.
	 *	\param in_units The units for the weight for this LinePatternParallelKit.
	 *	\param in_fixed Whether to override the effective line weight in the segment where this pattern is used.  Defaults to <span class='code'>false</span>.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetWeight(float in_weight, LinePattern::SizeUnits in_units, bool in_fixed = false);

	/*! Sets whether to reset the line pattern in each segment for this LinePatternParallelKit.
	 *	\param in_state Whether to reset the line pattern in each segment for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	SetContinuous(bool in_state);

	/*! Removes the glyph to draw at the start point for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetStartCap();

	/*! Removes the glyph to draw at the end point for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetEndCap();

	/*! Removes the glyph to draw at all joins for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetJoin();

	/*! Removes the line pattern element body for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetBody();

	/*! Removes whether to prevent scaling line pattern elements whose size is specified in pixels for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetAbsoluteLength();

	/*! Removes whether to prevent scaling line pattern elements whose weight is specified in pixels for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetAbsoluteWeight();

	/*! Removes how the pattern will fit between the end points for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetJustification();

	/*! Removes the offset above or below the line connecting two points defining a segment for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetOffset();

	/*! Removes the line weight for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetWeight();

	/*! Removes whether to reset the line pattern in each segment for this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetContinuous();

	/*! Removes all settings from this LinePatternParallelKit.
	 *	\return A reference to this LinePatternParallelKit. */
	LinePatternParallelKit &	UnsetEverything();

	/*! Shows the glyph to draw at the start point for this LinePatternParallelKit.
	 *	\param out_start The glyph to draw at the start point for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if a start cap was set, <span class='code'>false</span> otherwise. */
	bool						ShowStartCap(GlyphLinePatternElement & out_start) const;

	/*! Shows the glyph to draw at the end point for this LinePatternParallelKit.
	 *	\param out_end The glyph to draw at the end point for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if an end cap was set, <span class='code'>false</span> otherwise. */
	bool						ShowEndCap(GlyphLinePatternElement & out_end) const;

	/*! Shows the glyph to draw at all joins for this LinePatternParallelKit.
	 *	\param out_join The glyph to draw at all joins for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if a join was set, <span class='code'>false</span> otherwise. */
	bool						ShowJoin(GlyphLinePatternElement & out_join) const;

	/*! Shows the line pattern element body for this LinePatternParallelKit.
	 *	\param out_elements The line pattern element body for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if a body was set, <span class='code'>false</span> otherwise. */
	bool						ShowBody(LinePatternElementArray & out_elements) const;

	/*! Shows whether to prevent scaling line pattern elements whose size is specified in pixels for this LinePatternParallelKit.
	 *	\param out_state Whether to prevent scaling line pattern elements whose size is specified in pixels for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if an absolute length was set, <span class='code'>false</span> otherwise. */
	bool						ShowAbsoluteLength(bool & out_state) const;

	/*! Shows whether to prevent scaling line pattern elements whose weight is specified in pixels for this LinePatternParallelKit.
	 *	\param out_state Whether to prevent scaling line pattern elements whose weight is specified in pixels for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if an absolute weight was set, <span class='code'>false</span> otherwise. */
	bool						ShowAbsoluteWeight(bool & out_state) const;

	/*! Shows how the pattern will fit between the end points for this LinePatternParallelKit.
	 *	\param out_type How the pattern will fit between the end points for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if a justficiation was set, <span class='code'>false</span> otherwise. */
	bool						ShowJustification(LinePattern::Justification & out_type) const;

	/*! Shows the offset above or below the line connecting two points defining a segment for this LinePatternParallelKit.
	 *	\param out_offset The offset above (positive) or below (negative) the line connecting two points defining a segment for this LinePatternParallelKit.
	 *	\param out_units The units for the offset for this LinePatternParallelKit.
	 *	\param out_fixed Whether to prevent scaling the offset based on the effective line weight in the segment where this pattern is used.
	 *	\return <span class='code'>true</span> if an offset is set, <span class='code'>false</span> otherwise. */
	bool						ShowOffset(float & out_offset, LinePattern::SizeUnits & out_units, bool & out_fixed) const;

	/*! Shows the line weight for this LinePatternParallelKit.
	 *	\param out_weight The line weight for this LinePatternParallelKit.
	 *	\param out_units The units for the weight for this LinePatternParallelKit.
	 *	\param out_fixed Whether to override the effective line weight in the segment where this pattern is used.
	 *	\return <span class='code'>true</span> if a weight was set, <span class='code'>false</span> otherwise. */
	bool						ShowWeight(float & out_weight, LinePattern::SizeUnits & out_units, bool & out_fixed) const;

	/*! Shows whether to reset the line pattern in each segment for this LinePatternParallelKit.
	 *	\param out_state Whether to reset the line pattern in each segment for this LinePatternParallelKit.
	 *	\return <span class='code'>true</span> if a continuous flag was set, <span class='code'>false</span> otherwise. */
	bool						ShowContinuous(bool & out_state) const;
};


/*! The LinePatternKit class is a user space object.  It is used when defining a line pattern. */
class HPS_API LinePatternKit : public Kit
{
public:
	/*! The default constructor creates an empty LinePatternKit object. */
	LinePatternKit();

	/*! The copy constructor creates a new LinePatternKit object that contains the same settings as the source LinePatternKit.
	 * 	\param in_kit The source LinePatternKit to copy. */
	LinePatternKit(LinePatternKit const & in_kit);

	/*! The move constructor creates a LinePatternKit by transferring the underlying impl of the rvalue reference to this LinePatternKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LinePatternKit to take the impl from. */
	LinePatternKit(LinePatternKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LinePatternKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a LinePatternKit to take the impl from.
	 * 	\return A reference to this LinePatternKit. */
	LinePatternKit & operator=(LinePatternKit && in_that);

	virtual ~LinePatternKit();

	static const HPS::Type staticType = HPS::Type::LinePatternKit;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Creates a LinePatternKit which contains the definition of the specified default line pattern.
	 * 	\param in_default_line_pattern The default line pattern for which to get the corresponding LinePatternKit.
	 * 	\return A LinePatternKit which contains the definition of the specified default line pattern. */
	static HPS::LinePatternKit 	GetDefault(LinePattern::Default in_default_line_pattern);

	/*! Copies the source LinePatternKit into this LinePatternKit.
	 * 	\param in_kit The source LinePatternKit to copy. */
	void						Set(LinePatternKit const & in_kit);

	/*! Copies this LinePatternKit into the given LinePatternKit.
	 * 	\param out_kit The LinePatternKit to populate with the contents of this LinePatternKit. */
	void						Show(LinePatternKit & out_kit) const;

	/*! Copies the source LinePatternKit into this LinePatternKit.
	 * 	\param in_kit The source LinePatternKit to copy.
	 * 	\return A reference to this LinePatternKit. */
	LinePatternKit &			operator=(LinePatternKit const & in_kit);

	/*! Indicates whether this LinePatternKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this LinePatternKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source LinePatternKit is equivalent to this LinePatternKit.
	 *	\param in_kit The source LinePatternKit to compare to this LinePatternKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(LinePatternKit const & in_kit) const;

	/*!	Check if the source LinePatternKit is equivalent to this LinePatternKit.
	 *	\param in_kit The source LinePatternKit to compare to this LinePatternKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(LinePatternKit const & in_kit) const;

	/*!	Check if the source LinePatternKit is not equivalent to this LinePatternKit.
	 *	\param in_kit The source LinePatternKit to compare to this LinePatternKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(LinePatternKit const & in_kit) const;

	/*! Sets the line pattern parallel array for this LinePatternKit.
	 *  \param in_parallels The line pattern parallel array for this LinePatternKit.
	 *  \return A reference to this LinePatternKit. */
	LinePatternKit &			SetParallels(LinePatternParallelKitArray const & in_parallels);

	/*! Sets the line pattern parallel array for this LinePatternKit.
	 * 	\param in_count Size of the following array.
	 *  \param in_parallels The line pattern parallel array for this LinePatternKit.
	 *  \return A reference to this LinePatternKit. */
	LinePatternKit &			SetParallels(size_t in_count, LinePatternParallelKit const in_parallels []);

	/*! Sets the line pattern parallel for this LinePatternKit.
	 *  \param in_parallel The line pattern parallel for this LinePatternKit.
	 *  \return A reference to this LinePatternKit. */
	LinePatternKit &			SetParallel(LinePatternParallelKit const & in_parallel);

	/*! Sets the type of join to use for this LinePatternKit.
	 *  \param in_type The type of join to use for this LinePatternKit.
	 *  \return A reference to this LinePatternKit. */
	LinePatternKit &			SetJoin(LinePattern::Join in_type);

	/*! Removes the line pattern parallel array for this LinePatternKit.
	 *  \return A reference to this LinePatternKit. */
	LinePatternKit &			UnsetParallels();

	/*! Removes the type of join to use for this LinePatternKit.
	 *  \return A reference to this LinePatternKit. */
	LinePatternKit &			UnsetJoin();

	/*! Removes all settings from this LinePatternKit.
	 *	\return A reference to this LinePatternKit. */
	LinePatternKit &			UnsetEverything();

	/*! Shows the line pattern parallel array for this LinePatternKit.
	 *	\param out_parallels The line pattern parallel array for this LinePatternKit.
	 *	\return <span class='code'>true</span> if a line pattern parallel array was set, <span class='code'>false</span> otherwise. */
	bool						ShowParallels(LinePatternParallelKitArray & out_parallels) const;

	/*! Shows the type of join to use for this LinePatternKit.
	 *	\param out_type The type of join to use for this LinePatternKit.
	 *	\return <span class='code'>true</span> if a join was set, <span class='code'>false</span> otherwise. */
	bool						ShowJoin(LinePattern::Join & out_type) const;
};


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// Shapes //////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

/*! The ShapeElement class is a user space object.  It is the base class for all shape elements. */
class HPS_API ShapeElement : public Object
{
public:
	/*! The default constructor creates an empty ShapeElement object. */
	ShapeElement();

	/*! The copy constructor creates a new ShapeElement object that contains the same settings as the source ShapeElement.
	 * 	\param in_that The source ShapeElement to copy. */
	ShapeElement(ShapeElement const & in_that);

	/*! The move constructor creates a ShapeElement by transferring the underlying impl of the rvalue reference to this ShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShapeElement to take the impl from. */
	ShapeElement(ShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShapeElement to take the impl from.
	 * 	\return A reference to this ShapeElement. */
	ShapeElement & operator=(ShapeElement && in_that);

	virtual ~ShapeElement();

	static const HPS::Type staticType = HPS::Type::ShapeElement;
	HPS::Type				ObjectType() const { return staticType; };

	/*! Copies the source ShapeElement into this ShapeElement.
	 * 	\param in_that The source ShapeElement to copy. */
	void 					Set(ShapeElement const & in_that);

	/*! Copies the source ShapeElement into this ShapeElement.
	 * 	\param in_that The source ShapeElement to copy.
	 * 	\return A reference to this ShapeElement. */
	ShapeElement &			operator=(ShapeElement const & in_that);

	/*!	Check if the source ShapeElement is equivalent to this ShapeElement.
	 *	\param in_that The source ShapeElement to compare to this ShapeElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool 					Equals(ShapeElement const & in_that) const;

	/*!	Check if the source ShapeElement is equivalent to this ShapeElement.
	 *	\param in_that The source ShapeElement to compare to this ShapeElement.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool 					operator==(ShapeElement const & in_that) const;

	/*!	Check if the source ShapeElement is not equivalent to this ShapeElement.
	 *	\param in_that The source ShapeElement to compare to this ShapeElement.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool 					operator!=(ShapeElement const & in_that) const;

	/*! Sets the disjointed state for this ShapeElement.
	* 	Two shape elements of the same type are automatically joined together if they appear consecutively in the shape element array.
	*   LineShapeElement objects are always disjointed.
	* 	\param in_state The disjointed state for this ShapeElement. */
	ShapeElement &			SetDisjointed(bool in_state);

	/*! Shows the disjointed state for this ShapeElement.
	 * 	Two shape elements of the same type are automatically joined together if they appear consecutively in the shape element array.
	 *  LineShapeElement objects are always disjointed.
	 * 	\param out_state Whether this shape element will be disjointed from the previous one.
	 * 	\return <span class='code'>true</span> if a disjointed state was set, <span class='code'>false</span> otherwise. */
	bool					ShowDisjointed(bool & out_state) const;

	/*! Sets the fill mode for this ShapeElement.
	* 	All shape elements default to being filled, except for Lines which cannot be filled.
	 * 	\param in_state The fill mode for this ShapeElement. */
	ShapeElement &			SetFill(bool in_state);

	/*! Shows the fill mode for this ShapeElement.
	 * 	All shape elements default to being filled, except for Lines which cannot be filled.
	 * 	\param out_state Whether faces are drawn for this shape element.
	 * 	\return <span class='code'>true</span> if a fill mode was set, <span class='code'>false</span> otherwise. */
	bool					ShowFill(bool & out_state) const;
};

/*! The PolygonShapeElement class is a user space object.  It is used to define polygon elements to make up shapes for text backgrounds. */
class HPS_API PolygonShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty PolygonShapeElement object. */
	PolygonShapeElement();

	/*! This constructor creates a PolygonShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of a polygon shape element.  Otherwise the copy
	 * 	will fail and the resulting PolygonShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	PolygonShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a new PolygonShapeElement object that contains the same settings as the source PolygonShapeElement.
	 * 	\param in_that The source PolygonShapeElement to copy. */
	PolygonShapeElement(PolygonShapeElement const & in_that);

	/*! This constructor creates a PolygonShapeElement with the specified point array.
	 *	\param in_points The points for the polygon. */
	explicit PolygonShapeElement(ShapePointArray const & in_points);

	/*! This constructor creates a PolygonShapeElement with the specified point array.
	 * 	\param in_count Size of the following array.
	 *	\param in_points The points for the line. */
	PolygonShapeElement(size_t in_count, ShapePoint const in_points[]);

	/*! The move constructor creates a PolygonShapeElement by transferring the underlying impl of the rvalue reference to this PolygonShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PolygonShapeElement to take the impl from. */
	PolygonShapeElement(PolygonShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PolygonShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a PolygonShapeElement to take the impl from.
	 * 	\return A reference to this PolygonShapeElement. */
	PolygonShapeElement & operator=(PolygonShapeElement && in_that);

	~PolygonShapeElement();

	static const HPS::Type staticType = HPS::Type::PolygonShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the points for this PolygonShapeElement.
	 * 	\param in_points The points for the polygon. */
	PolygonShapeElement & SetPoints(ShapePointArray const & in_points);

	/*! Sets the points for this PolygonShapeElement.
	 * 	\param in_count Size of the following array.
	 * 	\param in_points The points for the polygon. */
	PolygonShapeElement & SetPoints(size_t in_count, ShapePoint const in_points[]);

	/*! Shows the points for this PolygonShapeElement.
	 * 	\param out_points The points for the polygon.
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(ShapePointArray & out_points) const;
};

/*! The EllipseShapeElement class is a user space object.  It is used to define ellipse elements to make up shapes for text backgrounds. */
class HPS_API EllipseShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty EllipseShapeElement object. */
	EllipseShapeElement();

	/*! This constructor creates a EllipseShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of an ellipse shape element.  Otherwise the copy
	 * 	will fail and the resulting EllipseShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	EllipseShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a new EllipseShapeElement object that contains the same settings as the source EllipseShapeElement.
	 * 	\param in_that The source EllipseShapeElement to copy. */
	EllipseShapeElement(EllipseShapeElement const & in_that);

	/*! This constructor creates a EllipseShapeElement with the specified point array.
	 *	\param in_center The center of the ellipse.
	 *	\param in_major_axis_point A point defining the major axis of the ellipse
	 *	\param in_minor_axis_point A point defining the minor axis of the ellipse. */
	explicit EllipseShapeElement(ShapePoint const & in_center, ShapePoint const & in_major_axis_point, ShapePoint const & in_minor_axis_point);

	/*! The move constructor creates a EllipseShapeElement by transferring the underlying impl of the rvalue reference to this EllipseShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a EllipseShapeElement to take the impl from. */
	EllipseShapeElement(EllipseShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipseShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a EllipseShapeElement to take the impl from.
	 * 	\return A reference to this EllipseShapeElement. */
	EllipseShapeElement & operator=(EllipseShapeElement && in_that);

	~EllipseShapeElement();

	static const HPS::Type staticType = HPS::Type::EllipseShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the points for this EllipseShapeElement.
	 * 	\param in_center The center point of the ellipse. */
	EllipseShapeElement & SetCenter(ShapePoint const & in_center);

	/*! Shows the center point for this EllipseShapeElement.
	 * 	\param out_center The center point for the ellipse.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(ShapePoint & out_center) const;

	/*! Sets a point on the minor axis for this EllipseShapeElement.
	 * 	\param in_minor_axis_point The point on the minor axis of the ellipse. */
	EllipseShapeElement & SetMinorAxisPoint(ShapePoint const & in_minor_axis_point);

	/*! Shows the minor axis point for this EllipseShapeElement.
	 * 	\param out_minor_axis_point The minor axis point for the ellipse.
	 *	\return <span class='code'>true</span> if a minor axis point was set, <span class='code'>false</span> otherwise. */
	bool				ShowMinorAxisPoint(ShapePoint & out_minor_axis_point) const;

	/*! Sets a point on the major axis for this EllipseShapeElement.
	 * 	\param in_major_axis_point The point on the major axis of the ellipse. */
	EllipseShapeElement & SetMajorAxisPoint(ShapePoint const & in_major_axis_point);

	/*! Shows the major axis point for this EllipseShapeElement.
	 * 	\param out_major_axis_point The major axis point for the ellipse.
	 *	\return <span class='code'>true</span> if a major axis point was set, <span class='code'>false</span> otherwise. */
	bool				ShowMajorAxisPoint(ShapePoint & out_major_axis_point) const;
};

/*! The CircleShapeElement class is a user space object.  It is used to define circle elements to make up shapes for text backgrounds. */
class HPS_API CircleShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty CircleShapeElement object. */
	CircleShapeElement();

	/*! This constructor creates a CircleShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of a circle shape element.  Otherwise the copy
	 * 	will fail and the resulting CircleShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	CircleShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a new CircleShapeElement object that contains the same settings as the source CircleShapeElement.
	 * 	\param in_that The source CircleShapeElement to copy. */
	CircleShapeElement(CircleShapeElement const & in_that);

	/*! This constructor creates a CircleShapeElement with the specified center and radius points.
	 *	\param in_center The center point of the circle.
	 *	\param in_radius The radius of the circle. */
	explicit CircleShapeElement(ShapePoint const & in_center, ShapePoint const & in_radius);

	/*! The move constructor creates a CircleShapeElement by transferring the underlying impl of the rvalue reference to this CircleShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircleShapeElement to take the impl from. */
	CircleShapeElement(CircleShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircleShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a CircleShapeElement to take the impl from.
	 * 	\return A reference to this CircleShapeElement. */
	CircleShapeElement & operator=(CircleShapeElement && in_that);

	~CircleShapeElement();

	static const HPS::Type staticType = HPS::Type::CircleShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the center point for this CircleShapeElement.
	 * 	\param in_center The center point of the circle. */
	CircleShapeElement & SetCenter(ShapePoint const & in_center);

	/*! Shows the center point for this CircleShapeElement.
	 * 	\param out_center The center point for the circle.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(ShapePoint & out_center) const;

	/*! Sets the radius point for this CircleShapeElement.
	 * 	\param in_radius The radius point of the circle. */
	CircleShapeElement & SetRadius(ShapePoint const & in_radius);

	/*! Shows the radius point for this CircleShapeElement.
	 * 	\param out_radius The radius point for the circle.
	 *	\return <span class='code'>true</span> if a radius was set, <span class='code'>false</span> otherwise. */
	bool				ShowRadius(ShapePoint & out_radius) const;
};

/*! The EllipticalArcShapeElement class is a user space object.  It is used to define elliptical arc elements to make up shapes for text backgrounds. */
class HPS_API EllipticalArcShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty EllipticalArcShapeElement object. */
	EllipticalArcShapeElement();

	/*! This constructor creates a EllipticalArcShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of an elliptical arc shape element.  Otherwise the copy
	 * 	will fail and the resulting EllipticalArcShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	EllipticalArcShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a new EllipticalArcShapeElement object that contains the same settings as the source EllipticalArcShapeElement.
	 * 	\param in_that The source EllipticalArcShapeElement to copy. */
	EllipticalArcShapeElement(EllipticalArcShapeElement const & in_that);

	/*! This constructor creates a EllipticalArcShapeElement with the specified parameters.
	 *	\param in_center The center point of the arc.
	 *	\param in_major_axis_point A point defining the major axis of the arc.
	 *	\param in_minor_axis_point A point defining the minor axis of the arc.
	 *	\param in_start The start of the arc, in degrees.
	 *	\param in_end The end of the arc, in degrees. */
	explicit EllipticalArcShapeElement(ShapePoint const & in_center, ShapePoint const & in_major_axis_point, ShapePoint const & in_minor_axis_point, float in_start = 0.0f, float in_end = 360.0f);

	/*! The move constructor creates a EllipticalArcShapeElement by transferring the underlying impl of the rvalue reference to this EllipticalArcShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a EllipticalArcShapeElement to take the impl from. */
	EllipticalArcShapeElement(EllipticalArcShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EllipticalArcShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a EllipticalArcShapeElement to take the impl from.
	 * 	\return A reference to this EllipticalArcShapeElement. */
	EllipticalArcShapeElement & operator=(EllipticalArcShapeElement && in_that);

	~EllipticalArcShapeElement();

	static const HPS::Type staticType = HPS::Type::EllipticalArcShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the center point for this EllipticalArcShapeElement.
	 * 	\param in_center The center point of the arc. */
	EllipticalArcShapeElement &	SetCenter(ShapePoint const & in_center);

	/*! Shows the center point for this EllipticalArcShapeElement.
	 * 	\param out_center The center point for the arc.
	 *	\return <span class='code'>true</span> if a center point was set, <span class='code'>false</span> otherwise. */
	bool				ShowCenter(ShapePoint & out_center) const;

	/*! Sets the minor axis point for this EllipticalArcShapeElement.
	 * 	\param in_minor_axis_point A point defining the minor axis of the arc. */
	EllipticalArcShapeElement &	SetMinorAxisPoint(ShapePoint const & in_minor_axis_point);

	/*! Shows the minor axis point for this EllipticalArcShapeElement.
	 * 	\param out_minor_axis_point A point defining the minor axis of the arc.
	 *	\return <span class='code'>true</span> if a minor axis point was set, <span class='code'>false</span> otherwise. */
	bool				ShowMinorAxisPoint(ShapePoint & out_minor_axis_point) const;

	/*! Sets the major axis point for this EllipticalArcShapeElement.
	 * 	\param in_major_axis_point A point defining the major axis of the arc. */
	EllipticalArcShapeElement &	SetMajorAxisPoint(ShapePoint const & in_major_axis_point);

	/*! Shows the major axis point for this EllipticalArcShapeElement.
	 * 	\param out_major_axis_point A point defining the major axis of the arc.
	 *	\return <span class='code'>true</span> if a major axis point was set, <span class='code'>false</span> otherwise. */
	bool				ShowMajorAxisPoint(ShapePoint & out_major_axis_point) const;

	/*! Sets the start for this EllipticalArcShapeElement.
	 * 	\param in_start The starting point of this arc, expressed in degrees */
	EllipticalArcShapeElement &	SetStart(float in_start);

	/*! Shows the start point for this EllipticalArcShapeElement.
	 * 	\param out_start The starting point of this arc, expressed in degrees
	 *	\return <span class='code'>true</span> if a start point was set, <span class='code'>false</span> otherwise. */
	bool				ShowStart(float & out_start) const;

	/*! Sets the end for this EllipticalArcShapeElement.
	 * 	\param in_end The ending point of this arc, expressed in degrees */
	EllipticalArcShapeElement &	SetEnd(float in_end);

	/*! Shows the end point for this EllipticalArcShapeElement.
	 * 	\param out_end The ending point of this arc, expressed in degrees
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool				ShowEnd(float & out_end) const;
};

/*! The CircularArcShapeElement class is a user space object.  It is used to define circular arc elements to make up shapes for text backgrounds. */
class HPS_API CircularArcShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty CircularArcShapeElement object. */
	CircularArcShapeElement();

	/*! This constructor creates a CircularArcShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of a circular arc shape element.  Otherwise the copy
	 * 	will fail and the resulting CircularArcShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	CircularArcShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a new CircularArcShapeElement object that contains the same settings as the source CircularArcShapeElement.
	 * 	\param in_that The source CircularArcShapeElement to copy. */
	CircularArcShapeElement(CircularArcShapeElement const & in_that);

	/*! This constructor creates a CircularArcShapeElement with the specified parameters.
	 *	\param in_start_point The start of the arc.
	 *	\param in_middle_point A point between the start and the end point, where the arc passes through
	 *	\param in_end_point The end of the arc. */
	explicit CircularArcShapeElement(ShapePoint const & in_start_point, ShapePoint const & in_middle_point, ShapePoint const & in_end_point);

	/*! The move constructor creates a CircularArcShapeElement by transferring the underlying impl of the rvalue reference to this CircularArcShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CircularArcShapeElement to take the impl from. */
	CircularArcShapeElement(CircularArcShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CircularArcShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a CircularArcShapeElement to take the impl from.
	 * 	\return A reference to this CircularArcShapeElement. */
	CircularArcShapeElement & operator=(CircularArcShapeElement && in_that);

	~CircularArcShapeElement();

	static const HPS::Type staticType = HPS::Type::CircularArcShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the center point for this CircularArcShapeElement.
	 * 	\param in_start The start of the arc. */
	CircularArcShapeElement &	SetStartPoint(ShapePoint const & in_start);

	/*! Shows the center point for this CircularArcShapeElement.
	 * 	\param out_start The start for the arc.
	 *	\return <span class='code'>true</span> if a star point was set, <span class='code'>false</span> otherwise. */
	bool				ShowStartPoint(ShapePoint & out_start) const;

	/*! Sets the minor axis point for this CircularArcShapeElement.
	 * 	\param in_middle A point between the start and the end point. The arc passes through this point. */
	CircularArcShapeElement &	SetMiddlePoint(ShapePoint const & in_middle);

	/*! Shows the middle point for this CircularArcShapeElement.
	 * 	\param out_middle A point between the start and the end point. The arc passes through this point.
	 *	\return <span class='code'>true</span> if a middle point was set, <span class='code'>false</span> otherwise. */
	bool				ShowMiddlePoint(ShapePoint & out_middle) const;

	/*! Sets the end point for this CircularArcShapeElement.
	 * 	\param in_end The end point of the arc. */
	CircularArcShapeElement &	SetEndPoint(ShapePoint const & in_end);

	/*! Shows the end point for this CircularArcShapeElement.
	 * 	\param out_end The end point of the arc
	 *	\return <span class='code'>true</span> if an end point was set, <span class='code'>false</span> otherwise. */
	bool				ShowEndPoint(ShapePoint & out_end) const;
};

/*! The LeaderLineClippingElement class is a user space object.  It is used to define clipping of leader lines around a text background
If LeaderLineClippingElement does not have another ShapeElement set for the clip region, it will use the background shape.
If LeaderLineClippingElement has another ShapeElement set for the clip region, it will use that instead*/
class HPS_API LeaderLineClippingElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty LeaderLineClippingElement object. */
	LeaderLineClippingElement();

	/*! This constructor creates a LeaderLineClippingElement object that contains the same settings as the source ShapeElement.
	* 	The copy will only be successful if the source shape element is really an upcast of a line clipping shape element.  Otherwise the copy
	* 	will fail and the resulting LeaderLineClippingElement will be invalid.
	*	\param in_that The source ShapeElement to copy. */
	LeaderLineClippingElement(ShapeElement const & in_that);

	/*! The copy constructor creates a new LeaderLineClippingElement object that contains the same settings as the source LeaderLineClippingElement.
	* 	\param in_that The source LeaderLineClippingElement to copy. */
	LeaderLineClippingElement(LeaderLineClippingElement const & in_that);

	/*! The move constructor creates a LeaderLineClippingElement by transferring the underlying impl of the rvalue reference to this LeaderLineClippingElement
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to a LeaderLineClippingElement to take the impl from. */
	LeaderLineClippingElement(LeaderLineClippingElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LeaderLineClippingElement thereby avoiding a copy.
	* 	\param in_that An rvalue reference to a PolygonShapeElement to take the impl from.
	* 	\return A reference to this LeaderLineClippingElement. */
	LeaderLineClippingElement & operator=(LeaderLineClippingElement && in_that);

	~LeaderLineClippingElement();

	static const HPS::Type staticType = HPS::Type::LeaderLineClippingElement;
	HPS::Type			ObjectType() const { return staticType; };

	bool ShowClipShapeType(HPS::Type& out_type);

	/*! Shows the explicit Polygon clip shape for this LeaderLineClippingElement. If the wrong type is provided, will return false
	* 	\param out_shape The explicit clip shape.
	*	\return <span class='code'>true</span> if out_shape was set, <span class='code'>false</span> otherwise.  */
	bool ShowShape(PolygonShapeElement& out_shape) const;

	/*! Shows the explicit Ellipse clip shape for this LeaderLineClippingElement. If the wrong type is provided, will return false
	* 	\param out_shape The explicit clip shape.
	*	\return <span class='code'>true</span> if out_shape was set, <span class='code'>false</span> otherwise.  */
	bool ShowShape(EllipseShapeElement& out_shape) const;

	/*! Shows the explicit EllipticalArc clip shape for this LeaderLineClippingElement. If the wrong type is provided, will return false
	* 	\param out_shape The explicit clip shape.
	*	\return <span class='code'>true</span> if out_shape was set, <span class='code'>false</span> otherwise.  */
	bool ShowShape(EllipticalArcShapeElement& out_shape) const;

	/*! Shows the explicit Circle clip shape for this LeaderLineClippingElement. If the wrong type is provided, will return false
	* 	\param out_shape The explicit clip shape.
	*	\return <span class='code'>true</span> if out_shape was set, <span class='code'>false</span> otherwise.  */
	bool ShowShape(CircleShapeElement& out_shape) const;

	/*! Shows the explicit Ciruclar Arc clip shape for this LeaderLineClippingElement. If the wrong type is provided, will return false
	* 	\param out_shape The explicit clip shape.
	*	\return <span class='code'>true</span> if out_shape was set, <span class='code'>false</span> otherwise.  */
	bool ShowShape(CircularArcShapeElement& out_shape) const;

	/*! Sets the explicit Polygon clip shape for this LeaderLineClippingElement. if no explicit shape is set, the background shape will be used
	* 	\param in_shape The shape to clip leader lines with. */
	LeaderLineClippingElement & SetShape(const PolygonShapeElement & in_shape);

	/*! Sets the explicit Ellipse clip shape for this LeaderLineClippingElement. if no explicit shape is set, the background shape will be used
	* 	\param in_shape The shape to clip leader lines with. */
	LeaderLineClippingElement & SetShape(const EllipseShapeElement& in_shape);

	/*! Sets the explicit Elliptical Arcclip shape for this LeaderLineClippingElement. if no explicit shape is set, the background shape will be used
	* 	\param in_shape The shape to clip leader lines with. */
	LeaderLineClippingElement & SetShape(const EllipticalArcShapeElement & in_shape);

	/*! Sets the explicit Circle clip shape for this LeaderLineClippingElement. if no explicit shape is set, the background shape will be used
	* 	\param in_shape The shape to clip leader lines with. */
	LeaderLineClippingElement & SetShape(const  CircleShapeElement & in_shape);

	/*! Sets the explicit Circular Arc clip shape for this LeaderLineClippingElement. if no explicit shape is set, the background shape will be used
	* 	\param in_shape The shape to clip leader lines with. */
	LeaderLineClippingElement & SetShape(const  CircularArcShapeElement & in_shape);

	/*! Unsets the explicit clip shape and returns to the default functionality of clipping around the background shape */
	LeaderLineClippingElement & UnSetShape();
};

/*! The AnchorShapeElement class is a user space object.  It is used to define anchor elements to make up shapes for text backgrounds.
 *  Anchor points are point to which text leader lines connect.
 *  If no anchor elements are defined, all ShapePoints used to construct the shape will be used as anchor points.
 *  If at least one anchor point is defined, only explicitly defined anchor points will be used. */
class HPS_API AnchorShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty AnchorShapeElement object. */
	AnchorShapeElement();

	/*! This constructor creates a AnchorShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of an anchor shape element.  Otherwise the copy
	 * 	will fail and the resulting AnchorShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	AnchorShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a AnchorShapeElement AnchorShapeElement object that contains the same settings as the source AnchorShapeElement.
	 * 	\param in_that The source CircleShapeElement to copy. */
	AnchorShapeElement(AnchorShapeElement const & in_that);

	/*! This constructor creates a AnchorShapeElement with the specified anchor point.
	 *	\param in_anchor_point The anchor point. */
	explicit AnchorShapeElement(ShapePoint const & in_anchor_point);

	/*! This constructor creates a AnchorShapeElement with the specified parameters.
	 *	\param in_anchor_point The anchor point.
	 *	\param in_intermediate_points Intermediate points between the leader line and the anchor point
	 *	\param in_connection Whether the first intermediate point is connected to the anchor point by a line. */
	explicit AnchorShapeElement(ShapePoint const & in_anchor_point, ShapePointArray const & in_intermediate_points, bool in_connection);

	/*! The move constructor creates a AnchorShapeElement by transferring the underlying impl of the rvalue reference to this AnchorShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a AnchorShapeElement to take the impl from. */
	AnchorShapeElement(AnchorShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this AnchorShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a AnchorShapeElement to take the impl from.
	 * 	\return A reference to this AnchorShapeElement. */
	AnchorShapeElement & operator=(AnchorShapeElement && in_that);

	~AnchorShapeElement();

	static const HPS::Type staticType = HPS::Type::AnchorShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the anchor point for this AnchorShapeElement.
	 * 	\param in_anchor The anchor point. */
	AnchorShapeElement & SetAnchor(ShapePoint const & in_anchor);

	/*! Shows the anchor for this AnchorShapeElement.
	 * 	\param out_anchor The anchor point.
	 *	\return <span class='code'>true</span> if an anchor point was set, <span class='code'>false</span> otherwise. */
	bool				ShowAnchor(ShapePoint & out_anchor) const;

	/*! Sets the intermediate points for this AnchorShapeElement.
	 * 	\param in_intermediate_points The points between the anchor and the leader line. */
	AnchorShapeElement & SetIntermediatePoints(ShapePointArray const & in_intermediate_points);

	/*! Shows the intermediate points for this AnchorShapeElement.
	 * 	\param out_intermediate_points The points between the anchor point and the leader line.
	 *	\return <span class='code'>true</span> if intermediate points were set, <span class='code'>false</span> otherwise. */
	bool				ShowIntermediatePoints(ShapePointArray & out_intermediate_points) const;

	/*! Unsets the intermediate points for this AnchorShapeElement. */
	AnchorShapeElement & UnsetIntermediatePoints();

	/*! Sets the connection setting for this AnchorShapeElement.
	 * 	\param in_connection Whether the first intermediate point connects to the anchor point. */
	AnchorShapeElement & SetConnection(bool in_connection);

	/*! Shows the connection setting for this AnchorShapeElement.
	 * 	\param out_connection Whether the first intermediate point connects to the anchor point.
	 *	\return <span class='code'>true</span> if a connection setting was set, <span class='code'>false</span> otherwise. */
	bool				ShowConnection(bool & out_connection) const;

	/*! Unsets the connection setting for this AnchorShapeElement. */
	AnchorShapeElement & UnsetConnection();
};


/*! The LineShapeElement class is a user space object.  It is used to define line elements to make up shapes for text backgrounds. */
class HPS_API LineShapeElement : public ShapeElement
{
public:
	/*! The default constructor creates an empty LineShapeElement object. */
	LineShapeElement();

	/*! This constructor creates a LineShapeElement object that contains the same settings as the source ShapeElement.
	 * 	The copy will only be successful if the source shape element is really an upcast of a line shape element.  Otherwise the copy
	 * 	will fail and the resulting LineShapeElement will be invalid.
	 *	\param in_that The source ShapeElement to copy. */
	LineShapeElement(ShapeElement const & in_that);

	/*! The copy constructor creates a LineShapeElement object that contains the same settings as the source LineShapeElement.
	 * 	\param in_that The source LineShapeElement to copy. */
	LineShapeElement(LineShapeElement const & in_that);

	/*! This constructor creates a LineShapeElement with the specified points.
	 *	\param in_points The points making up the line. */
	explicit LineShapeElement(ShapePointArray const & in_points);

	/*! This constructor creates a LineShapeElement with the specified points.
	 * 	\param in_count Size of the following array.
	 *	\param in_points The points for the line. */
	LineShapeElement(size_t in_count, ShapePoint const in_points []);

	/*! This constructor creates a two-point LineShapeElement with the specified points.
	 * 	\param in_start The start of the line.
	 *	\param in_end The end of the line. */
	LineShapeElement(ShapePoint const & in_start, ShapePoint const & in_end);

	/*! The move constructor creates a LineShapeElement by transferring the underlying impl of the rvalue reference to this LineShapeElement
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LineShapeElement to take the impl from. */
	LineShapeElement(LineShapeElement && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LineShapeElement thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a LineShapeElement to take the impl from.
	 * 	\return A reference to this LineShapeElement. */
	LineShapeElement & operator=(LineShapeElement && in_that);

	~LineShapeElement();

	static const HPS::Type staticType = HPS::Type::LineShapeElement;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Sets the points for this LineShapeElement.
	 * 	\param in_points The points making up the line. */
	LineShapeElement & SetPoints(ShapePointArray const & in_points);

	/*! Sets the points for this LineShapeElement.
	* 	\param in_count The size of the following array.
	 * 	\param in_points The points making up the line. */
	LineShapeElement & SetPoints(size_t in_count, ShapePoint const in_points []);

	/*! Shows the points for this LineShapeElement.
	 * 	\param out_points The points for this line
	 *	\return <span class='code'>true</span> if points were set, <span class='code'>false</span> otherwise. */
	bool				ShowPoints(ShapePointArray & out_points) const;
};

//////////////////////////////////////////////////////////////////////
////////////////////// Portfolio and Definitions /////////////////////
//////////////////////////////////////////////////////////////////////


/*! The Definition class is a smart pointer to a database object.  It is the base class for all definition objects. */
class HPS_API Definition : public Object
{
public:
	/*! The default constructor creates an uninitialized Definition object.  The Type() function will return Type::None. */
	Definition();

	/*! The copy constructor creates a Definition object that shares the underlying smart-pointer of the source Definition.
	 *	\param in_that The source Definition to copy. */
	Definition(Definition const & in_that);

	/*! Associate this Definition with the same underlying impl as the source Definition.
	 *	\param in_that The source Definition for the assignment.
	 *	\return A reference to this Definition. */
	Definition & operator=(Definition const & in_that);

	/*! The move constructor creates a Definition by transferring the underlying impl of the rvalue reference to this Definition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a Definition to take the impl from. */
	Definition(Definition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Definition thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a Definition to take the impl from.
	 *	\return A reference to this Definition. */
	Definition & operator=(Definition && in_that);

	virtual ~Definition();

	static const HPS::Type staticType = HPS::Type::Definition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Removes this definition from the owning portfolio. */
	void				Undefine();

	/*! Get the portfolio that owns this Definition.
	 *	\return The portfolio that owns this Definition. */
	PortfolioKey		Owner() const;

	/*! Get the name given to this Definition when it was defined.
	 *	\return UTF8-encoded name of this Definition. */
	UTF8				Name() const;

	/*! Associate this Definition with the same underlying impl as the source Definition.
	 *	\param in_that The source Definition for the assignment. */
	virtual void		Assign(Definition const & in_that);

	/*!	Check if the source Definition is equivalent to this Definition.
	 *	\param in_that The source Definition to compare to this Definition.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(Definition const & in_that) const;

	/*!	Check if the source Definition is equivalent to this Definition.
	 *	\param in_that The source Definition to compare to this Definition.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(Definition const & in_that) const;

	/*!	Check if the source Definition is not equivalent to this Definition.
	 *	\param in_that The source Definition to compare to this Definition.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(Definition const & in_that) const;
};


/*! The PortfolioKey class is a smart pointer to a database object.  Portfolios are special objects that can only contain definitions.
 *	A segment can use a portfolio to gain access to the definitions it contains. */
class HPS_API PortfolioKey : public Key
{
public:
	/*! The default constructor creates an uninitialized PortfolioKey object.  The Type() function will return Type::None. */
	PortfolioKey();

	/*! This constructor creates a PortfolioKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of an offscreen window.  Otherwise the copy
	 * 	will fail and the resulting PortfolioKey will be invalid.
	 *	\param in_key The source Key to copy. */
	explicit PortfolioKey(Key const & in_that);

	/*! The copy constructor creates a PortfolioKey object that shares the underlying smart-pointer of the source PortfolioKey.
	 *	\param in_that The source PortfolioKey to copy. */
	PortfolioKey(PortfolioKey const & in_that);

	/*! Associate this PortfolioKey with the same underlying impl as the source PortfolioKey.
	 *	\param in_that The source PortfolioKey for the assignment.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey & operator=(PortfolioKey const & in_that);

	/*! The move constructor creates a PortfolioKey by transferring the underlying impl of the rvalue reference to this PortfolioKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a PortfolioKey to take the impl from. */
	PortfolioKey(PortfolioKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this PortfolioKey thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a PortfolioKey to take the impl from.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey & operator=(PortfolioKey && in_that);

	~PortfolioKey();

	static const HPS::Type staticType = HPS::Type::PortfolioKey;
	HPS::Type					ObjectType() const { return staticType; };

	// Define

	/*! Creates a new texture definition in this portfolio with the specified name, based on the specified image and with the default texture options.
	 *	This will replace any existing texture of the same name within this portfolio.  The image source must be defined within the same portfolio,
	 *	if it is not, the returned definition will be invalid.
	 *	\param in_name UTF8-encoded name for the new texture definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source image for the new texture definition.
	 *	\return A newly created TextureDefinition. */
	TextureDefinition			DefineTexture(char const * in_name, ImageDefinition const & in_source);

	/*! Creates a new texture definition in this portfolio with the specified name, based on the specified image and with the specified texture options.
	 *	This will replace any existing texture of the same name within this portfolio.  The image source must be defined within the same portfolio,
	 *	if it is not, the returned definition will be invalid.
	 *	\param in_name UTF8-encoded name for the new texture definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source image for the new texture definition.
	 *	\param in_options The texture options for the new texture definition.
	 *	\return A newly created TextureDefinition. */
	TextureDefinition			DefineTexture(char const * in_name, ImageDefinition const & in_source, TextureOptionsKit const & in_options);


	/*! Creates a new cube map definition in this portfolio with the specified name, based on the specified images and with the default texture options.
	 *	This will replace any existing cube map of the same name within this portfolio.  The image sources must be defined within the same portfolio,
	 *	if they are not, the returned definition will be invalid.
	 *	\param in_name UTF8-encoded name for the new cube map definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 * 	\param in_negative_z The source image for the negative z-axis for the new cube map definition.
	 * 	\param in_positive_z The source image for the positive z-axis for the new cube map definition.
	 * 	\param in_negative_x The source image for the negative x-axis for the new cube map definition.
	 * 	\param in_positive_x The source image for the positive x-axis for the new cube map definition.
	 * 	\param in_negative_y The source image for the negative y-axis for the new cube map definition.
	 * 	\param in_positive_y The source image for the positive y-axis for the new cube map definition.
	 *	\return A newly created CubeMapDefinition. */
	CubeMapDefinition			DefineCubeMap(char const * in_name, ImageDefinition const & in_negative_z, ImageDefinition const & in_positive_z,
											ImageDefinition const & in_negative_x, ImageDefinition const & in_positive_x,
											ImageDefinition const & in_negative_y, ImageDefinition const & in_positive_y);

	/*! Creates a new cube map definition in this portfolio with the specified name, based on the specified images and with the specified texture options.
	 *	This will replace any existing cube map of the same name within this portfolio.  The image sources must be defined within the same portfolio,
	 *	if they are not, the returned definition will be invalid.
	 *	\param in_name UTF8-encoded name for the new cube map definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 * 	\param in_negative_z The source image for the negative z-axis for the new cube map definition.
	 * 	\param in_positive_z The source image for the positive z-axis for the new cube map definition.
	 * 	\param in_negative_x The source image for the negative x-axis for the new cube map definition.
	 * 	\param in_positive_x The source image for the positive x-axis for the new cube map definition.
	 * 	\param in_negative_y The source image for the negative y-axis for the new cube map definition.
	 * 	\param in_positive_y The source image for the positive y-axis for the new cube map definition.
	 *	\param in_options The texture options for the new cube map definition.
	 *	\return A newly created CubeMapDefinition. */
	CubeMapDefinition			DefineCubeMap(char const * in_name, ImageDefinition const & in_negative_z, ImageDefinition const & in_positive_z,
											ImageDefinition const & in_negative_x, ImageDefinition const & in_positive_x,
											ImageDefinition const & in_negative_y, ImageDefinition const & in_positive_y, TextureOptionsKit const & in_options);


	/*! Creates a new image definition in this portfolio with the specified name from the source ImageKit.  This will replace any existing image
	 *	of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new image definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source ImageKit for the new image definition.
	 *	\return A newly created ImageDefinition. */
	ImageDefinition				DefineImage(char const * in_name, ImageKit const & in_source);


	/*! Creates a new named style definition in this portfolio with the specified name using the source SegmentKey.  This will replace any existing
	 *	named style of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new named style definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_style_source The source SegmentKey for the new named style definition.
	 *	\return A newly created NamedStyleDefinition. */
	NamedStyleDefinition		DefineNamedStyle(char const * in_name, SegmentKey const & in_style_source);


	/*! Creates a new material palette definition in this portfolio with the specified name using the source MaterialKit array.  This will replace any existing
	 *	material palette of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new material palette definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source MaterialKit array for the new material palette definition.
	 *	\return A newly created MaterialPaletteDefinition. */
	MaterialPaletteDefinition	DefineMaterialPalette(char const * in_name, MaterialKitArray const & in_source);

	/*! Creates a new material palette definition in this portfolio with the specified name using the source MaterialKit array.  This will replace any existing
	 *	material palette of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new material palette definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_count Size of the following array.
	 *	\param in_source The source MaterialKit array for the new material palette definition.
	 *	\return A newly created MaterialPaletteDefinition. */
	MaterialPaletteDefinition	DefineMaterialPalette(char const * in_name, size_t in_count, MaterialKit const in_source []);


	/*! Creates a new glyph definition in this portfolio with the specified name using the source GlyphKit.  This will replace any existing
	 *	glyph of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new glyph definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source GlyphKit for the new glyph definition.
	 *	\return A newly created GlyphDefinition. */
	GlyphDefinition				DefineGlyph(char const * in_name, GlyphKit const & in_source);


	/*! Creates a new line pattern definition in this portfolio with the specified name using the source LinePatternKit.  This will replace any existing
	 *	line pattern of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new line pattern definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source LinePatternKit for the new line pattern definition.
	 *	\return A newly created LinePatternDefinition. */
	LinePatternDefinition		DefineLinePattern(char const * in_name, LinePatternKit const & in_source);


	/*! Internal use only - customers should not use. Creates a new shader definition in this portfolio with the specified name using the source ShaderKit.  This will replace any existing
	 *	shader of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new shader definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source ShaderKit for the new shader definition.
	 *	\return A newly created ShaderDefinition. */
	ShaderDefinition			DefineShader(char const * in_name, ShaderKit const & in_source);

	/*! Creates a new sjape definition in this portfolio with the specified name using the source ShapeKit.
	 *	This will replace any existing shape of the same name within this portfolio.
	 *	\param in_name UTF8-encoded name for the new shape definition. If null_ptr or empty string is used for this parameter, a nameless definition will be created.
	 *	\param in_source The source ShapeKit for the new shape definition.
	 *	\return A newly created ShapeDefinition. */
	ShapeDefinition				DefineShape(char const * in_name, ShapeKit const & in_source);

	// UnDefine

	/*! Remove the texture definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the texture to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineTexture(char const * in_name);

	/*! Remove the cube map definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the cube map to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineCubeMap(char const * in_name);

	/*! Remove the image definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the image to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineImage(char const * in_name);

	/*! Remove the named style definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the named style to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineNamedStyle(char const * in_name);

	/*! Remove the material palette definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the material palette to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineMaterialPalette(char const * in_name);

	/*! Remove the glyph definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the glyph to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineGlyph(char const * in_name);

	/*! Remove the line pattern definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the line pattern to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineLinePattern(char const * in_name);

	/*! Internal use only - customers should not use. Remove the shader definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the shader to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineShader(char const * in_name);

	/*! Remove the shape definition with the specified name from this portfolio.
	 *	\param in_name UTF8-encoded name of the shape to remove.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				UndefineShape(char const * in_name);

	// Import collections
	/*! Copy all definitions from the specified portfolio into this portfolio.  By default, existing definitions of the same name within this
	 *	portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the definitions from.
	 *	\param in_replace_existing Whether to replace existing definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportPortfolio(PortfolioKey const & in_portfolio, bool in_replace_existing = true);


	/*! Copy all texture definitions from the specified portfolio into this portfolio.  By default, existing texture definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the texture definitions from.
	 *	\param in_replace_existing Whether to replace existing texture definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllTextures(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all cube map definitions from the specified portfolio into this portfolio.  By default, existing cube map definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the cube map definitions from.
	 *	\param in_replace_existing Whether to replace existing cube map definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllCubeMaps(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all image definitions from the specified portfolio into this portfolio.  By default, existing image definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the image definitions from.
	 *	\param in_replace_existing Whether to replace existing image definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllImages(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all named style definitions from the specified portfolio into this portfolio.  By default, existing named style definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the named style definitions from.
	 *	\param in_replace_existing Whether to replace existing named style definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllNamedStyles(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all material palette definitions from the specified portfolio into this portfolio.  By default, existing material palette definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the material palette definitions from.
	 *	\param in_replace_existing Whether to replace existing material palette definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllMaterialPalettes(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all glyph definitions from the specified portfolio into this portfolio.  By default, existing glyph definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the glyph definitions from.
	 *	\param in_replace_existing Whether to replace existing glyph definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllGlyphs(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all line pattern definitions from the specified portfolio into this portfolio.  By default, existing line pattern definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the line pattern definitions from.
	 *	\param in_replace_existing Whether to replace existing line pattern definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllLinePatterns(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Internal use only - customers should not use. Copy all shader definitions from the specified portfolio into this portfolio.  By default, existing shader definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the shader definitions from.
	 *	\param in_replace_existing Whether to replace existing shader definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllShaders(PortfolioKey const & in_portfolio, bool in_replace_existing = true);

	/*! Copy all shape definitions from the specified portfolio into this portfolio.  By default, existing shape definitions of the same name within
	 *	this portfolio will be replaced, unless otherwise specified.
	 *	\param in_portfolio The source portfolio to copy the shape definitions from.
	 *	\param in_replace_existing Whether to replace existing shape definitions of the same name.  Defaults to <span class='code'>true</span>.
	 *	\return A reference to this PortfolioKey. */
	PortfolioKey &				ImportAllShapes(PortfolioKey const & in_portfolio, bool in_replace_existing = true);


	// Import individual definitions
	/*! Copy the specified texture definition into this portfolio.  This will replace an existing texture definition of the same name.
	 *	\param in_definition The source texture definition to copy into this portfolio.
	 *	\return A newly created TextureDefinition. */
	TextureDefinition			ImportTexture(TextureDefinition const & in_definition);

	/*! Copy the specified cube map definition into this portfolio.  This will replace an existing cube map definition of the same name.
	 *	\param in_definition The source cube map definition to copy into this portfolio.
	 *	\return A newly created CubeMapDefinition. */
	CubeMapDefinition			ImportCubeMap(CubeMapDefinition const & in_definition);

	/*! Copy the specified image definition into this portfolio.  This will replace an existing image definition of the same name.
	 *	\param in_definition The source image definition to copy into this portfolio.
	 *	\return A newly created ImageDefinition. */
	ImageDefinition				ImportImage(ImageDefinition const & in_definition);

	/*! Copy the specified named style definition into this portfolio.  This will replace an existing named style definition of the same name.
	 *	\param in_definition The source named style definition to copy into this portfolio.
	 *	\return A newly created NamedStyleDefinition. */
	NamedStyleDefinition		ImportNamedStyle(NamedStyleDefinition const & in_definition);

	/*! Copy the specified material palette definition into this portfolio.  This will replace an existing material palette definition of the same name.
	 *	\param in_definition The source material palette definition to copy into this portfolio.
	 *	\return A newly created MaterialPaletteDefinition. */
	MaterialPaletteDefinition	ImportMaterialPalette(MaterialPaletteDefinition const & in_definition);

	/*! Copy the specified glyph definition into this portfolio.  This will replace an existing glyph definition of the same name.
	 *	\param in_definition The source glyph definition to copy into this portfolio.
	 *	\return A newly created GlyphDefinition. */
	GlyphDefinition				ImportGlyph(GlyphDefinition const & in_definition);

	/*! Copy the specified line pattern definition into this portfolio.  This will replace an existing line pattern definition of the same name.
	 *	\param in_definition The source line pattern definition to copy into this portfolio.
	 *	\return A newly created LinePatternDefinition. */
	LinePatternDefinition		ImportLinePattern(LinePatternDefinition const & in_definition);

	/*! Internal use only - customers should not use. Copy the specified shader definition into this portfolio.  This will replace an existing shader definition of the same name.
	 *	\param in_definition The source shader definition to copy into this portfolio.
	 *	\return A newly created ShaderDefinition. */
	ShaderDefinition			ImportShader(ShaderDefinition const & in_definition);

	/*! Copy the specified shape definition into this portfolio.  This will replace an existing shape definition of the same name.
	 *	\param in_definition The source shape definition to copy into this portfolio.
	 *	\return A newly created ShapeDefinition. */
	ShapeDefinition			ImportShape(ShapeDefinition const & in_definition);


	// Show
	/*!	\return The number of definitions in this portfolio. */
	size_t						GetDefinitionCount() const;

	/*!	\return The number of texture definitions in this portfolio. */
	size_t						GetTextureDefinitionCount() const;

	/*!	\return The number of cube map definitions in this portfolio. */
	size_t						GetCubeMapDefinitionCount() const;

	/*!	\return The number of image definitions in this portfolio. */
	size_t						GetImageDefinitionCount() const;

	/*!	\return The number of named style definitions in this portfolio. */
	size_t						GetNamedStyleDefinitionCount() const;

	/*!	\return The number of material palette definitions in this portfolio. */
	size_t						GetMaterialPaletteDefinitionCount() const;

	/*!	\return The number of glyph definitions in this portfolio. */
	size_t						GetGlyphDefinitionCount() const;

	/*!	\return The number of line pattern definitions in this portfolio. */
	size_t						GetLinePatternDefinitionCount() const;

	/*!	Internal use only - customers should not use.
	\return The number of shader definitions in this portfolio. */
	size_t						GetShaderDefinitionCount() const;

	/*!	\return The number of shape definitions in this portfolio. */
	size_t						GetShapeDefinitionCount() const;

	/*! Finds the texture definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the texture to find in this portfolio.
	 *	\return <span class='code'>true</span> if a texture definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowTextureDefinition(char const * in_name) const;

	/*! Finds the texture definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the texture to find in this portfolio.
	 *	\param out_found The texture definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a texture definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowTextureDefinition(char const * in_name, TextureDefinition & out_found) const;

	/*! Shows all textures defined within this portfolio.
	 *	\param out_definitions The array of textures defined within this portfolio.
	 *	\return <span class='code'>true</span> if any textures are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllTextureDefinitions(TextureDefinitionArray & out_definitions) const;

	/*! Finds the cube map definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the cube map to find in this portfolio.
	 *	\return <span class='code'>true</span> if a cube map definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowCubeMapDefinition(char const * in_name) const;

	/*! Finds the cube map definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the cube map to find in this portfolio.
	 *	\param out_found The cube map definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a cube map definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowCubeMapDefinition(char const * in_name, CubeMapDefinition & out_found) const;

	/*! Shows all cube maps defined within this portfolio.
	 *	\param out_definitions The array of cube maps defined within this portfolio.
	 *	\return <span class='code'>true</span> if any cube maps are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllCubeMapDefinitions(CubeMapDefinitionArray & out_definitions) const;

	/*! Finds the image definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the image to find in this portfolio.
	 *	\return <span class='code'>true</span> if an image definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowImageDefinition(char const * in_name) const;

	/*! Finds the image definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the image to find in this portfolio.
	 *	\param out_found The image definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if an image definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowImageDefinition(char const * in_name, ImageDefinition & out_found) const;

	/*! Shows all images defined within this portfolio.
	 *	\param out_definitions The array of images defined within this portfolio.
	 *	\return <span class='code'>true</span> if any images are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllImageDefinitions(ImageDefinitionArray & out_definitions) const;

	/*! Finds the named style definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the named style to find in this portfolio.
	 *	\return <span class='code'>true</span> if a named style definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowNamedStyleDefinition(char const * in_name) const;

	/*! Finds the named style definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the named style to find in this portfolio.
	 *	\param out_found The named style definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a named style definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowNamedStyleDefinition(char const * in_name, NamedStyleDefinition & out_found) const;

	/*! Shows all named styles defined within this portfolio.
	 *	\param out_definitions The array of named styles defined within this portfolio.
	 *	\return <span class='code'>true</span> if any named styles are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllNamedStyleDefinitions(NamedStyleDefinitionArray & out_definitions) const;

	/*! Finds the material palette definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the material palette to find in this portfolio.
	 *	\return <span class='code'>true</span> if a material palette definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowMaterialPaletteDefinition(char const * in_name) const;

	/*! Finds the material palette definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the material palette to find in this portfolio.
	 *	\param out_found The material palette definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a material palette definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowMaterialPaletteDefinition(char const * in_name, MaterialPaletteDefinition & out_found) const;

	/*! Shows all material palettes defined within this portfolio.
	 *	\param out_definitions The array of material palettes defined within this portfolio.
	 *	\return <span class='code'>true</span> if any material palettes are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllMaterialPaletteDefinitions(MaterialPaletteDefinitionArray & out_definitions) const;

	/*! Finds the glyph definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the glyph to find in this portfolio.
	 *	\return <span class='code'>true</span> if a glyph definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowGlyphDefinition(char const * in_name) const;

	/*! Finds the glyph definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the glyph to find in this portfolio.
	 *	\param out_found The glyph definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a glyph definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowGlyphDefinition(char const * in_name, GlyphDefinition & out_found) const;

	/*! Shows all glyphs defined within this portfolio.
	 *	\param out_definitions The array of glyphs defined within this portfolio.
	 *	\return <span class='code'>true</span> if any glyphs are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllGlyphDefinitions(GlyphDefinitionArray & out_definitions) const;

	/*! Finds the line pattern definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the line pattern to find in this portfolio.
	 *	\return <span class='code'>true</span> if a line pattern definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowLinePatternDefinition(char const * in_name) const;

	/*! Finds the line pattern definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the line pattern to find in this portfolio.
	 *	\param out_found The line pattern definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a line pattern definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowLinePatternDefinition(char const * in_name, LinePatternDefinition & out_found) const;

	/*! Shows all line patterns defined within this portfolio.
	 *	\param out_definitions The array of line patterns defined within this portfolio.
	 *	\return <span class='code'>true</span> if any line patterns are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllLinePatternDefinitions(LinePatternDefinitionArray & out_definitions) const;

	/*! Internal use only - customers should not use.  Finds the shader definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the shader to find in this portfolio.
	 *	\return <span class='code'>true</span> if a shader definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowShaderDefinition(char const * in_name) const;

	/*! Internal use only - customers should not use.  Finds the shader definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the shader to find in this portfolio.
	 *	\param out_found The shader definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a shader definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowShaderDefinition(char const * in_name, ShaderDefinition & out_found) const;

	/*! Internal use only - customers should not use. Shows all shaders defined within this portfolio.
	 *	\param out_definitions The array of shaders defined within this portfolio.
	 *	\return <span class='code'>true</span> if any shaders are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllShaderDefinitions(ShaderDefinitionArray & out_definitions) const;

	/*! Finds the shape definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the shape to find in this portfolio.
	 *	\return <span class='code'>true</span> if a shape definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowShapeDefinition(char const * in_name) const;

	/*! Finds the shape definition with the specified name in this portfolio.
	 *	\param in_name UTF8-encoded name of the shape to find in this portfolio.
	 *	\param out_found The shape definition from this portfolio with the specified name.
	 *	\return <span class='code'>true</span> if a shape definition with the specified name was found, <span class='code'>false</span> otherwise. */
	bool						ShowShapeDefinition(char const * in_name, ShapeDefinition & out_found) const;

	/*! Shows all shapes defined within this portfolio.
	 *	\param out_definitions The array of shapes defined within this portfolio.
	 *	\return <span class='code'>true</span> if any shapes are defined in this portfolio, <span class='code'>false</span> otherwise. */
	bool						ShowAllShapeDefinitions(ShapeDefinitionArray & out_definitions) const;

private:
	/*! MoveTo is private because portfolios cannot be moved to a segment. */
	void						MoveTo(SegmentKey const & in_new_owner);

	/*! CopyTo is private because portfolios cannot be copied to a segment. */
	Key							CopyTo(SegmentKey const & in_destination) const;
};



/*! The GlyphDefinition class is a smart pointer to a database object.  It is a handler to a glyph defined within a portfolio. */
class HPS_API GlyphDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized GlyphDefinition object.  The Type() function will return Type::None. */
	GlyphDefinition();

	/*! This constructor creates an GlyphDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a glyph definition.  Otherwise the copy
	 * 	will fail and the resulting GlyphDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	GlyphDefinition(Definition const & in_that);

	/*! The copy constructor creates an GlyphDefinition object that shares the underlying smart-pointer of the source GlyphDefinition.
	 *	\param in_that The source GlyphDefinition to copy. */
	GlyphDefinition(GlyphDefinition const & in_that);

	/*! Associate this GlyphDefinition with the same underlying impl as the source GlyphDefinition.
	 *	\param in_that The source GlyphDefinition for the assignment.
	 *	\return A reference to this GlyphDefinition. */
	GlyphDefinition & operator=(GlyphDefinition const & in_that);

	/*! The move constructor creates a GlyphDefinition by transferring the underlying impl of the rvalue reference to this GlyphDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a GlyphDefinition to take the impl from. */
	GlyphDefinition(GlyphDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this GlyphDefinition thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a GlyphDefinition to take the impl from.
	 *	\return A reference to this GlyphDefinition. */
	GlyphDefinition & operator=(GlyphDefinition && in_that);

	~GlyphDefinition();

	static const HPS::Type staticType = HPS::Type::GlyphDefinition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Redefine the glyph for this GlyphDefinition.
	 *	\param in_kit The new glyph for this GlyphDefinition. */
	void				Set(GlyphKit const & in_kit);

	/*! Shows the glyph for this GlyphDefinition.
	 *	\param out_kit The glyph for this GlyphDefinition. */
	void				Show(GlyphKit & out_kit) const;
};


/*! The TextureDefinition class is a smart pointer to a database object.  It is a handler to a texture defined within a portfolio. */
class HPS_API TextureDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized TextureDefinition object.  The Type() function will return Type::None. */
	TextureDefinition();

	/*! This constructor creates a TextureDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a texture definition.  Otherwise the copy
	 * 	will fail and the resulting TextureDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	TextureDefinition(Definition const & in_that);

	/*! The copy constructor creates an TextureDefinition object that shares the underlying smart-pointer of the source TextureDefinition.
	 *	\param in_that The source TextureDefinition to copy. */
	TextureDefinition(TextureDefinition const & in_that);

	/*! Associate this TextureDefinition with the same underlying impl as the source TextureDefinition.
	 *	\param in_that The source TextureDefinition for the assignment.
	 *	\return A reference to this TextureDefinition. */
	TextureDefinition & operator=(TextureDefinition const & in_that);

	/*! The move constructor creates a TextureDefinition by transferring the underlying impl of the rvalue reference to this TextureDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextureDefinition to take the impl from. */
	TextureDefinition(TextureDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextureDefinition thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a TextureDefinition to take the impl from.
	 *	\return A reference to this TextureDefinition. */
	TextureDefinition & operator=(TextureDefinition && in_that);

	~TextureDefinition();

	static const HPS::Type staticType = HPS::Type::TextureDefinition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Redefine the image for this TextureDefinition.
	 *	\param in_source The new image for this TextureDefinition. */
	void				SetSource(ImageDefinition const & in_source);

	/*! Show the image for this TextureDefinition.
	 *	\param out_source The image for this TextureDefinition.
	 *	\return <span class='code'>true</span> if an image definition was found in the same Portfolio as this TextureDefinition, <span class='code'>false</span> otherwise. */
	bool				ShowSource(ImageDefinition & out_source) const;

	/*! Show the name of the source image for this TextureDefinition.
	 *  If the source image for this TextureDefinition resides in a separate portfolio, users can use this method to retrieve the name of the source image,
	 *  and use KeyPath::ShowEffectiveImageDefinition with the image name to retrieve the image definition.
	 *	\param out_source The name of the source image for this TextureDefinition.
	 *	\return <span class='code'>true</span> if able to retrieve the name of the source image, <span class='code'>false</span> otherwise. */
	bool				ShowSource(UTF8 & out_source) const;

	/*! Redefine the texture options for this TextureDefinition.
	 *	\param in_options The new texture options for this TextureDefinition. */
	void				SetOptions(TextureOptionsKit const & in_options);

	/*! Show the texture options for this TextureDefinition.
	 *	\param out_options The texture options for this TextureDefinition. */
	void				ShowOptions(TextureOptionsKit & out_options) const;

};

/*!
<p>The TextureOptionsKit class is a user space object.  It is used for setting texture options when defining textures or cube maps. Calling HPS::TextureOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#textureoptions">this table</a>.</p>
*/
class HPS_API TextureOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty TextureOptionsKit object. */
	TextureOptionsKit();

	/*! The copy constructor creates a new TextureOptionsKit object that contains the same settings as the source TextureOptionsKit.
	 * 	\param in_kit The source TextureOptionsKit to copy. */
	TextureOptionsKit(TextureOptionsKit const & in_kit);

	/*! The move constructor creates a TextureOptionsKit by transferring the underlying impl of the rvalue reference to this TextureOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TextureOptionsKit to take the impl from. */
	TextureOptionsKit(TextureOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TextureOptionsKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a TextureOptionsKit to take the impl from.
	 * 	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit & operator=(TextureOptionsKit && in_that);

	virtual ~TextureOptionsKit();

	static const HPS::Type staticType = HPS::Type::TextureOptionsKit;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Creates a TextureOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return A TextureOptionsKit with the default settings. */
	static TextureOptionsKit	GetDefault();

	/*! Copies the source TextureOptionsKit into this TextureOptionsKit.
	 * 	\param in_kit The source TextureOptionsKit to copy. */
	void						Set(TextureOptionsKit const & in_kit);

	/*! Copies this TextureOptionsKit into the given TextureOptionsKit.
	 * 	\param out_kit The TextureOptionsKit to populate with the contents of this TextureOptionsKit. */
	void						Show(TextureOptionsKit & out_kit) const;

	/*! Copies the source TextureOptionsKit into this TextureOptionsKit.
	 * 	\param in_kit The source TextureOptionsKit to copy.
	 * 	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			operator=(TextureOptionsKit const & in_kit);

	/*! Indicates whether this TextureOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this TextureOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source TextureOptionsKit is equivalent to this TextureOptionsKit.
	 *	\param in_kit The source TextureOptionsKit to compare to this TextureOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(TextureOptionsKit const & in_kit) const;

	/*!	Check if the source TextureOptionsKit is equivalent to this TextureOptionsKit.
	 *	\param in_kit The source TextureOptionsKit to compare to this TextureOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(TextureOptionsKit const & in_kit) const;

	/*!	Check if the source TextureOptionsKit is not equivalent to this TextureOptionsKit.
	 *	\param in_kit The source TextureOptionsKit to compare to this TextureOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(TextureOptionsKit const & in_kit) const;

	/*! Sets whether the texture should act as a decal, i.e., whether diffuse colors will be allowed through transparent
	 * 	portions of a diffuse texture.  This only affects a diffuse texture on layer <span class='code'>0</code>.
	 * 	\param in_state Whether the texture should act as a decal.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetDecal(bool in_state);

	/*! Sets whether the texture should be down-sampled.
	 * 	\param in_state Whether the texture should be down-sampled.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetDownSampling(bool in_state);

	/*! Sets whether the texture should be modulated with materials from layers below it.  This only applies to diffuse textures.
	 * 	\param in_state Whether the texture should be modulated with materials from layers below it.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetModulation(bool in_state);

	/*! Sets the parameter offset for the texture, i.e., the offset into the texture parameter list to use at each vertex to locate the parameters for the texture.
	 * 	\param in_offset The parameter offset for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetParameterOffset(size_t in_offset);

	/*! Sets the parameterization source for the texture.
	 * 	\param in_source The parameterization source for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetParameterizationSource(Material::Texture::Parameterization in_source);

	/*! Sets how the texture will be tiled for parameters outside the range <span class='code'>[0, 1]</span>.
	 * 	\param in_tiling How the texture will be tiled for parameters outside the range <span class='code'>[0, 1]</span>.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetTiling(Material::Texture::Tiling in_tiling);

	/*! Sets the interpolation filter to use for the texture.
	 * 	\param in_filter The interpolation filter to use for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetInterpolationFilter(Material::Texture::Interpolation in_filter);

	/*! Sets the decimation filter to use for the texture.
	 * 	\param in_filter The decimation filter to use for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetDecimationFilter(Material::Texture::Decimation in_filter);

	/*! Sets the transform matrix to use for the texture.
	 * 	\param in_transform The transform matrix to use for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetTransformMatrix(MatrixKit const & in_transform);

	/*! Sets the value scaling (linear remapping) of texture element values.
	 * 	\param in_min The value to which zero will be remapped.
	 * 	\param in_max The value to which one will be remapped.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			SetValueScale(float in_min, float in_max);

	/*! Removes whether the texture should act as a decal.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetDecal();

	/*! Removes whether to down-sample the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetDownSampling();

	/*! Removes whether the texture should modulate with materials from layers below it.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetModulation();

	/*! Removes the parameter offset for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetParameterOffset();

	/*! Removes the parameter source for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetParameterizationSource();

	/*! Removes how the texture will be tiled for parameters outside the range <span class='code'>[0, 1]</span>.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetTiling();

	/*! Removes the interpolation filter for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetInterpolationFilter();

	/*! Removes the decimation filter for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetDecimationFilter();

	/*! Removes the transform matrix for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetTransformMatrix();

	/*! Removes the value scale for the texture.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetValueScale();

	/*! Removes all settings from this TextureOptionsKit.
	 *	\return A reference to this TextureOptionsKit. */
	TextureOptionsKit &			UnsetEverything();

	/*! Shows whether the texture should act as a decal.
	 *	\param out_state Whether the texture should act as a decal.
	 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDecal(bool & out_state) const;

	/*! Shows whether the texture should be down-sampled.
	 *	\param out_state Whether the texture should be down-sampled.
	 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDownSampling(bool & out_state) const;

	/*! Shows whether the texture should be modulated with materials from layers below it.
	 *	\param out_state Whether the texture should be be modulated with materials from layers below it.
	 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
	bool						ShowModulation(bool & out_state) const;

	/*! Shows the parameter offset for the texture.
	 *	\param out_offset The parameter offset for the texture.
	 *	\return <span class='code'>true</span> if the offset is valid, <span class='code'>false</span> otherwise. */
	bool						ShowParameterOffset(size_t & out_offset) const;

	/*! Shows the parameterization source for the texture.
	 *	\param out_source The parametererization source for the texture.
	 *	\return <span class='code'>true</span> if the parameterization source is valid, <span class='code'>false</span> otherwise. */
	bool						ShowParameterizationSource(Material::Texture::Parameterization & out_source) const;

	/*! Shows how the texture will be tiled for parameters outside the range <span class='code'>[0, 1]</span>.
	 * 	\param out_tiling How the texture will be tiled for parameters outside the range <span class='code'>[0, 1]</span>.
	 *	\return <span class='code'>true</span> if the tiling is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTiling(Material::Texture::Tiling & out_tiling) const;

	/*! Shows the interpolation filter for the texture.
	 * 	\param out_filter The interpolation filter for the texture.
	 *	\return <span class='code'>true</span> if the filter is valid, <span class='code'>false</span> otherwise. */
	bool						ShowInterpolationFilter(Material::Texture::Interpolation & out_filter) const;

	/*! Shows the decimation filter for the texture.
	 * 	\param out_filter The decimation filter for the texture.
	 *	\return <span class='code'>true</span> if the filter is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDecimationFilter(Material::Texture::Decimation & out_filter) const;

	/*! Shows the transform matrix for the texture.
	 * 	\param out_transform The transform matrix for the texture.
	 *	\return <span class='code'>true</span> if the transform matrix is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTransformMatrix(MatrixKit & out_transform) const;

	/*! Shows the value scale for the texture.
	 * 	\param out_min The value to which zero will be remapped.
	 * 	\param out_max The value to which one will be remapped.
	 *	\return <span class='code'>true</span> if the filter is valid, <span class='code'>false</span> otherwise. */
	bool						ShowValueScale(float & out_min, float & out_max) const;
};


/*!	The Image class contains objects for importing image files and enumerations used when defining images in Visualize. */
class HPS_API Image
{
public:
	/*! \enum Format
	 * 	Enumerates the various image formats that Visualize supports. */
	enum class Format : uint32_t
	{
		RGB,				//!< Uncompressed, one unsigned byte per channel, three unsigned bytes per pixel, RGB order.
		RGBA,				//!< Uncompressed, one unsigned byte per channel, four unsigned bytes per pixel, RGBA order.
		ARGB,				//!< Uncompressed, one unsigned byte per channel, four unsigned bytes per pixel, ARGB order.
		Mapped8,			//!< Uncompressed, one unsigned byte per pixel, each unsigned byte is an index into a material palette.
		Grayscale,			//!< Uncompressed, one unsigned byte per pixel.
		Bmp,				//!< Uncompressed, 1bpp (Mono), 8 bpp (Greyscale), 16 bpp (ARGB/RGB), 24bpp (RGB), 32bpp (ARGB).
		Jpeg,				//!< Compressed, JPEG format.
		Png,				//!< Compressed, PNG format.
		Targa,				//!< Compressed, TARGA Format.
		DXT1,				//!< Compressed, DXT1 Format.
		DXT3,				//!< Compressed, DXT3 Format.
		DXT5				//!< Compressed, DXT5 Format.
	};

	/*!	The HPS::Image::ExportOptionsKit class contains options that will be used to export image files. Calling HPS::Image::ExportOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#window-options">this table</a>. */
class HPS_API ExportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ExportOptionsKit object. */
		ExportOptionsKit();

		/*! The copy constructor creates a new ExportOptionsKit object that contains the same settings as the source ExportOptionsKit.
		 * 	\param in_kit The source ExportOptionsKit to copy. */
		ExportOptionsKit(ExportOptionsKit const & in_kit);

		/*! The move constructor creates an ExportOptionsKit by transferring the underlying impl of the rvalue reference to this ExportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from.*/
		ExportOptionsKit(ExportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ExportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from.
		 * 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit & operator=(ExportOptionsKit && in_that);

		virtual ~ExportOptionsKit();

	static const HPS::Type staticType = HPS::Type::ImageExportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Creates a ExportOptionsKit which contains the default settings.  The returned object will not necessarily have values
		 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
		 * 	\return A ExportOptionsKit with the default settings. */
		static ExportOptionsKit	GetDefault();

		/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
		 * 	\param in_kit The source ExportOptionsKit to copy. */
		void					Set(ExportOptionsKit const & in_kit);

		/*! Copies this ExportOptionsKit into the given ExportOptionsKit.
		 * 	\param out_kit The ExportOptionsKit to populate with the contents of this ExportOptionsKit. */
		void					Show(ExportOptionsKit & out_kit) const;

		/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
		 * 	\param in_kit The source ExportOptionsKit to copy.
		 * 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		operator=(ExportOptionsKit const & in_kit);

		/*! Indicates whether this ExportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ExportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
		 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ExportOptionsKit const & in_kit) const;

		/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
		 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ExportOptionsKit const & in_kit) const;

		/*!	Check if the source ExportOptionsKit is not equivalent to this ExportOptionsKit.
		 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ExportOptionsKit const & in_kit) const;

		/*! Sets the width and height (in pixels) of the image. If this is not specified , an exception will be thrown on export.
		 * 	\param in_width The width (in pixels) of the image.
		 * 	\param in_height The height (in pixels) of the image.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		SetSize(unsigned int in_width, unsigned int in_height);

		/*! Sets the format of the image.  This must be specified when exporting any image.
		 * 	\param in_format The format of the image.
		 *	\return A reference to this ExportOptionsKit.
		 *	\sa Export format <a href="../../prog_guide/appendix_default_attribute_values.html#image-export-format">default value</a> */
		ExportOptionsKit &		SetFormat(Image::Format in_format);

		/*! Sets whether the image background will be transparent.
		*	This setting is only valid when exporting a PNG image.
		* 	\param in_state Whether the image background will be transparent.
		*	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		SetTransparentBackground(bool in_state);

		/*! Removes the width and height of the image.
		 * 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetSize();

		/*! Removes the format of the image.
		 * 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetFormat();

		/*! Removes the transparent background setting of the image.
		* 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetTransparentBackground();

		/*! Removes all settings from this ExportOptionsKit.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetEverything();

		/*! Shows the width and height (in pixels) of the image.
		 *	\param out_width The width (in pixels) of the image.
		 *	\param out_height The height (in pixels) of the image.
		 *	\return <span class='code'>true</span> if the width and height are valid, <span class='code'>false</span> otherwise. */
		bool					ShowSize(unsigned int & out_width, unsigned int & out_height) const;

		/*! Shows the format of the image.
		 *	\param out_format The format of the image.
		 *	\return <span class='code'>true</span> if the format is valid, <span class='code'>false</span> otherwise. */
		bool					ShowFormat(Image::Format & out_format) const;

		/*! Shows transparent background setting for this image
		*	\param out_state The transparent background setting for this image.
		*	\return <span class='code'>true</span> if a background preference was specified, <span class='code'>false</span> otherwise. */
		bool					ShowTransparentBackground(bool & out_state) const;
	};

	/*!	The ImportOptionsKit class contains options that will be used to import image files and will be set on the ImageKit returned by File::Import. */
class HPS_API ImportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportOptionsKit object. */
		ImportOptionsKit();

		/*! The copy constructor creates a new ImportOptionsKit object that contains the same settings as the source ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		ImportOptionsKit(ImportOptionsKit const & in_kit);

		/*! The move constructor creates an ImportOptionsKit by transferring the underlying impl of the rvalue reference to this ImportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.*/
		ImportOptionsKit(ImportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit & operator=(ImportOptionsKit && in_that);

		virtual ~ImportOptionsKit();

	static const HPS::Type staticType = HPS::Type::ImageImportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		void					Set(ImportOptionsKit const & in_kit);

		/*! Copies this ImportOptionsKit into the given ImportOptionsKit.
		 * 	\param out_kit The ImportOptionsKit to populate with the contents of this ImportOptionsKit. */
		void					Show(ImportOptionsKit & out_kit) const;

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		operator=(ImportOptionsKit const & in_kit);

		/*! Indicates whether this ImportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is not equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportOptionsKit const & in_kit) const;

		/*! Sets the width and height (in pixels) of the image.  This does not need to be set when importing image files which contain
		 * 	this information (i.e., Image::Jpeg, Image::Png or Image::Targa).  If this is not specified for images files which do not
		 * 	contain this information, an exception will be thrown on import.
		 * 	\param in_width The width (in pixels) of the image.
		 * 	\param in_height The height (in pixels) of the image.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetSize(unsigned int in_width, unsigned int in_height);

		/*! Sets the format of the image.  This must be specified when importing any image.
		 * 	\param in_format The format of the image.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetFormat(Image::Format in_format);

		/*! Sets whether to down-sample the image.  This setting will be copied over to the ImageKit returned from File::Import.  It doesn't need
		 * 	to be set for the import to succeed.
		 * 	\param in_state Whether to down-sample the image.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetDownSampling(bool in_state);

		/*! Sets the compression quality for the image.  This setting will be copied over to the ImageKit returned from File::Import.  It doesn't need
		 * 	to be set for the import to succeed.
		 * 	\param in_quality The compression quality for the image.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetCompressionQuality(float in_quality);

		/*! Removes the width and height of the image.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetSize();

		/*! Removes the format of the image.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetFormat();

		/*! Removes whether to down-sample the image.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetDownSampling();

		/*! Removes the compression quality for the image.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetCompressionQuality();

		/*! Removes all settings from this ImportOptionsKit.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetEverything();

		/*! Shows the width and height (in pixels) of the image.
		 *	\param out_width The width (in pixels) of the image.
		 *	\param out_height The height (in pixels) of the image.
		 *	\return <span class='code'>true</span> if the width and height are valid, <span class='code'>false</span> otherwise. */
		bool					ShowSize(unsigned int & out_width, unsigned int & out_height) const;

		/*! Shows the format of the image.
		 *	\param out_format The format of the image.
		 *	\return <span class='code'>true</span> if the format is valid, <span class='code'>false</span> otherwise. */
		bool					ShowFormat(Image::Format & out_format) const;

		/*! Shows whether to down-sample the image.
		 *	\param out_state whether to down-sample the image.
		 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
		bool					ShowDownSampling(bool & out_state) const;

		/*! Shows the compression quality for the image.
		 *	\param out_quality The compression quality for the image.
		 *	\return <span class='code'>true</span> if the compression quality is valid, <span class='code'>false</span> otherwise. */
		bool					ShowCompressionQuality(float & out_quality) const;
	};

	/*!	The File class provides a function to import and export image files. */
	class HPS_API File
	{
	public:
		/*!	Performs a synchronous import of the specified image file.  The function returns an ImageKit with the data from
		 * 	the image file and with the specified options.  May throw an IOException if a problem occurs during import.
		 * 	\param in_file_name Name of image file from which to get the data.
		 *	\param in_options Options to use during import and to set on the ImageKit returned by this function.
		 *	\return An ImageKit containing the data from the specified file and with the specified options. */
		static ImageKit Import(char const * in_file_name, ImportOptionsKit const & in_options);

		/*!	Performs a synchronous export to an image of the specified window.
		 *  May throw an IOException if a problem occurs during export.
		 * 	\param in_file_name Name of image file to which to save the data.
		 * 	\param in_window The WindowKey where the screen-shot will be taken
		 *	\param in_options Options to use during export. If the option does not have size defined
			the size of in_window is used. */
		static void Export(char const * in_file_name, HPS::WindowKey const & in_window, ExportOptionsKit const & in_options);

		/*!	Performs a synchronous export to an image of the specified window.
		 *  May throw an IOException if a problem occurs during export.
		 * 	\param in_file_name Name of image file to which to save the data.
		 * 	\param in_window The WindowKey where the screen-shot will be taken
		 *	\param in_width The width of the exported image, in pixels
		 *  \param in_height The height of the exported image, in pixels
		 *  \param in_format The format of the exported image, defaults to PNG
		 *  \param in_transparent_background Whether to render the background as transparent. Only valid if in_format is PNG. Defaults to false. */
		static void Export(char const * in_file_name, HPS::WindowKey const & in_window, unsigned int in_width, unsigned int in_height, Format in_format = Format::Png, bool in_transparent_background = false);

		/*! Performs a synchronous export to an image from the specified ImageKit
		 * May throw an exception if a problem occurs during export, or if the image kit provided is incomplete
		 * \param in_file_name Name of image file to which to save the data.
		 * \param in_image_kit ImageKit containing the data, size and format of the image to be exported */
		static void Export(char const * in_file_name, HPS::ImageKit const & in_image_kit);

	private:
		//! Private default constructor to prevent instantiation.
		File();
	};

private:
	//! Private default constructor to prevent instantiation.
	Image();
};


/*! The ImageKit class is a user space object.  It is used for specifying all data associated with images. */
class HPS_API ImageKit : public Kit
{
public:
	/*! The default constructor creates an empty ImageKit object. */
	ImageKit();

	/*! The copy constructor creates a new ImageKit object that contains the same settings as the source ImageKit.
	 * 	\param in_kit The source ImageKit to copy. */
	ImageKit(ImageKit const & in_kit);

	/*! This constructor creates a new ImageKit object that contains the same settings as the source ImageKit but converts it to the
	 * 	specified format.
	 * 	\param in_kit The source ImageKit to copy and convert.
	 * 	\param in_format The format to convert the source ImageKit to. */
	ImageKit(ImageKit const & in_kit, HPS::Image::Format in_format);

	/*! The move constructor creates an ImageKit by transferring the underlying impl of the rvalue reference to this ImageKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an ImageKit to take the impl from. */
	ImageKit(ImageKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImageKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an ImageKit to take the impl from.
	 * 	\return A reference to this ImageKit. */
	ImageKit & operator=(ImageKit && in_that);

	virtual ~ImageKit();

	static const HPS::Type staticType = HPS::Type::ImageKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source ImageKit into this ImageKit.
	 * 	\param in_kit The source ImageKit to copy. */
	void				Set(ImageKit const & in_kit);

	/*! Copies this ImageKit into the given ImageKit.
	 * 	\param out_kit The ImageKit to populate with the contents of this ImageKit. */
	void				Show(ImageKit & out_kit) const;

	/*! Copies the source ImageKit into this ImageKit.
	 * 	\param in_kit The source ImageKit to copy.
	 * 	\return A reference to this ImageKit. */
	ImageKit &			operator=(ImageKit const & in_kit);

	/*! Indicates whether this ImageKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ImageKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source ImageKit is equivalent to this ImageKit.
	 *	\param in_kit The source ImageKit to compare to this ImageKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(ImageKit const & in_kit) const;

	/*!	Check if the source ImageKit is equivalent to this ImageKit.
	 *	\param in_kit The source ImageKit to compare to this ImageKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(ImageKit const & in_kit) const;

	/*!	Check if the source ImageKit is not equivalent to this ImageKit.
	 *	\param in_kit The source ImageKit to compare to this ImageKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(ImageKit const & in_kit) const;

	/*! Copies the source ImageKit into this ImageKit but converts it to the specified format.
	 * 	\param in_kit The source ImageKit to copy and convert.
	 * 	\param in_format The format to convert the source ImageKit to. */
	void				Convert(ImageKit const & in_kit, HPS::Image::Format in_format);

	/*! Converts this ImageKit to the specified format.
	 * 	\param in_format The format to convert the ImageKit to. */
	void				Convert(HPS::Image::Format in_format);

	/*! Sets the width and height (in pixels) of the image.
	 * 	\param in_width The width (in pixels) of the image.
	 * 	\param in_height The height (in pixels) of the image.
	 *	\return A reference to this ImageKit. */
	ImageKit &			SetSize(unsigned int in_width, unsigned int in_height);

	/*! Sets the data for the image.
	 * 	\param in_image_data The array of data for the image.
	 *	\return A reference to this ImageKit. */
	ImageKit &			SetData(ByteArray const & in_image_data);

	/*! Sets the data for the image.
	 * 	\param in_byte_count The size of the following array.
	 * 	\param in_image_data The array of data for the image.
	 *	\return A reference to this ImageKit. */
	ImageKit &			SetData(size_t in_byte_count, byte const in_image_data []);

	/*! Sets the format of the image.
	 * 	\param in_format The format of the image.
	 *	\return A reference to this ImageKit. */
	ImageKit &			SetFormat(Image::Format in_format);

	/*! Sets the whether to down-sample the image.
	 * 	\param in_state Whether to down-sample the image.
	 *	\return A reference to this ImageKit. */
	ImageKit &			SetDownSampling(bool in_state);

	/*! Sets the compression quality for the image.  Values range from highest compression and poorest quality (0) to no compression and full quality (1).
	 * 	\param in_quality The compression quality for the image, a floating point value between 0 and 1.
	 *	\return A reference to this ImageKit. */
	ImageKit &			SetCompressionQuality(float in_quality);

	/*! Removes the width and height of the image.
	 * 	\return A reference to this ImageKit. */
	ImageKit &			UnsetSize();

	/*! Removes the data for the image.
	 * 	\return A reference to this ImageKit. */
	ImageKit &			UnsetData();

	/*! Removes the format of the image.
	 * 	\return A reference to this ImageKit. */
	ImageKit &			UnsetFormat();

	/*! Removes whether to down-sample the image.
	 * 	\return A reference to this ImageKit. */
	ImageKit &			UnsetDownSampling();

	/*! Removes the compression quality for the image.
	 * 	\return A reference to this ImageKit. */
	ImageKit &			UnsetCompressionQuality();

	/*! Removes all settings from this ImageKit.
	 *	\return A reference to this ImageKit. */
	ImageKit &			UnsetEverything();

	/*! Shows the width and height (in pixels) of the image.
	 *	\param out_width The width (in pixels) of the image.
	 *	\param out_height The height (in pixels) of the image.
	 *	\return <span class='code'>true</span> if the width and height are valid, <span class='code'>false</span> otherwise. */
	bool				ShowSize(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the data for the image.
	 *	\param out_image_data The array of data for the image.
	 *	\return <span class='code'>true</span> if the data array is valid, <span class='code'>false</span> otherwise. */
	bool				ShowData(ByteArray & out_image_data) const;

	/*! Shows the format of the image.
	 *	\param out_format The format of the image.
	 *	\return <span class='code'>true</span> if the format is valid, <span class='code'>false</span> otherwise. */
	bool				ShowFormat(Image::Format & out_format) const;

	/*! Shows whether to down-sample the image.
	 *	\param out_state whether to down-sample the image.
	 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
	bool				ShowDownSampling(bool & out_state) const;

	/*! Shows the compression quality for the image.
	 *	\param out_quality The compression quality for the image.
	 *	\return <span class='code'>true</span> if the compression quality is valid, <span class='code'>false</span> otherwise. */
	bool				ShowCompressionQuality(float & out_quality) const;
};


/*! The HPS::OffScreenWindowOptionsControl class is a smart pointer that is tied to a database object.  It is used to query offscreen-window-specific
 * 	options on an OffScreenWindowKey. This control also gives you the ability to make a screenshot of the Visualize scene using ShowImage. <a
 *  href="../../prog_guide/appendix_default_attribute_values.html#window-options">This table</a> lists default values for the various segment attributes accessible from
 * HPS::OffScreenWindowOptionsControl. */
class HPS_API OffScreenWindowOptionsControl : public Control
{
public:
	/*! This constructor creates a OffScreenWindowOptionsControl object which is tied to the specified offscreen window.
	 * 	\param in_window The offscreen window which this OffScreenWindowOptionsControl should operate on. */
	explicit OffScreenWindowOptionsControl(OffScreenWindowKey & in_seg);

	/*! The copy constructor creates a OffScreenWindowOptionsControl object that shares the underlying smart-pointer of the source
	 * 	OffScreenWindowOptionsControl.
	 *	\param in_that The source OffScreenWindowOptionsControl to copy. */
	OffScreenWindowOptionsControl(OffScreenWindowOptionsControl const & in_that);

	/*! The move constructor creates an OffScreenWindowOptionsControl by transferring the underlying impl of the rvalue reference to this
	 * 	OffScreenWindowOptionsControl thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an OffScreenWindowOptionsControl to take the impl from. */
	OffScreenWindowOptionsControl(OffScreenWindowOptionsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this OffScreenWindowOptionsControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an OffScreenWindowOptionsControl to take the impl from.
	 * 	\return A reference to this OffScreenWindowOptionsControl. */
	OffScreenWindowOptionsControl & operator=(OffScreenWindowOptionsControl && in_that);

	~OffScreenWindowOptionsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::OffScreenWindowOptionsControl;
	HPS::Type						ObjectType() const { return staticType; };

	/*! Share the underlying smart-pointer of the OffScreenWindowOptionsControl source.
	 *	\param in_that The OffScreenWindowOptionsControl source of the assignment.
	 *	\return A reference to this OffScreenWindowOptionsControl. */
	OffScreenWindowOptionsControl &	operator=(OffScreenWindowOptionsControl const & in_that);

	/*! Sets the width and height in pixels of the associated offscreen window.
	 *	\param in_width The width in pixels of the associated offscreen window.
	 *	\param in_height The height in pixels of the associated offscreen window.
	 *	\return A reference to this OffScreenWindowOptionsControl. */
	OffScreenWindowOptionsControl &	SetSize(unsigned int in_width, unsigned int in_height);

	/*! Sets the native image format to store data in.
	 *  \param in_format Format image data will be stored in.
	 * 	\param in_quality The compression quality for the image data (when applicable).
	 *	\return A reference to this OffScreenWindowOptionsControl. */
	OffScreenWindowOptionsControl &	SetNativeFormat(Window::ImageFormat in_format, float in_quality = 1.0f);

    /*! Supplies an array of fonts to be used as fallbacks for when a character can not be found in the active font.
	    \param in_fonts An array of UTF8 encoded strings that correspond to the fallback fonts being used.*/
    OffScreenWindowOptionsControl & SetFallbackFonts(UTF8Array const & in_fonts);

    /*! Unsets any fonts currently used as fallback fonts.*/
    OffScreenWindowOptionsControl & UnsetFallbackFonts();

    /*! Returns an array of fonts set to be used as fallbacks for when a character can not be found in the active font.
	    \param out_fonts An array of UTF8 encoded strings that correspond to the fallback fonts being used.*/
    size_t                          ShowFallbackFonts(UTF8Array & out_fonts) const;

	/*! Shows the driver for the associated offscreen window.
	 *	\param out_driver The driver for the associated offscreen window.
	 *	\return <span class='code'>true</span> if a driver was set, <span class='code'>false</span> otherwise. */
	bool							ShowDriver(Window::Driver & out_driver) const;

	/*! Sets the anti-alias options for this OffScreenWindowOptionsControl.
	* 	\param in_state Whether the associated off-screen window should be anti-alias capable.
	* 	\param in_samples The number of anti-alias samples to use for the associated off-screen window.  Defaults to <span class='code'>4</span>.
	*	\return A reference to this OffScreenWindowOptionsControl. */
	OffScreenWindowOptionsControl &		SetAntiAliasCapable(bool in_state, unsigned int in_samples = 4);

	/*!	Manipulates the state of screen anti-aliasing.
	*	\param in_state Whether screen anti-aliasing should be used.
	*	\return A reference to this object. */
	OffScreenWindowOptionsControl &		SetScreenAntiAliasing(bool in_state);

	/*! Shows the whether this offscreen window is anti-alias capable, and if so, how many samples it uses for anti-aliasing.
	 *	\param out_state Whether this offscreen window is anti-alias capable.
	 *	\param out_samples The number of anti-alias samples supported by this offscreen window.
	 *	\return <span class='code'>true</span> if any anti-alias options were set, <span class='code'>false</span> otherwise. */
	bool							ShowAntiAliasCapable(bool & out_state, unsigned int & out_samples) const;

	/*! Shows the width and height in pixels of the associated offscreen window.
	 *	\param out_width The width in pixels of the associated offscreen window.
	 *	\param out_height The height in pixels of the associated offscreen window.
	 *	\return <span class='code'>true</span> if a height and width were set, <span class='code'>false</span> otherwise. */
	bool							ShowSize(unsigned int & out_width, unsigned int & out_height) const;

	/*! Shows the contents of this offscreen window into the provided ImageKit in the specified format.
	 *	\param in_format The format of the image to generate.
	 *	\param out_image The contents of this offscreen window as an image in the specified format.
	 *	\return <span class='code'>true</span> if the shown image is valid, <span class='code'>false</span> otherwise. */
	bool							ShowImage(Image::Format in_format, ImageKit & out_image) const;

	/*! Shows the image bytes in the native format for this OffScreenWindow.
	 *  \param in_quality Desired quality for compressed image formats.
	 *  \param out_bytes Image data as an array of bytes.
	 *	\return <span class='code'>true</span> if the shown image is valid, <span class='code'>false</span> otherwise. */
	bool							ShowImage(ByteArray & out_bytes) const;

	/*! Shows the hardware resident option of the associated offscreen window.
	 * 	\param out_state Whether the image data for this offscreen window should be stored exclusively in video memory.
	 *	\return <span class='code'>true</span> if a hardware resident option was set, <span class='code'>false</span> otherwise. */
	bool							ShowHardwareResident(bool & out_state) const;

	/*! Shows the opacity of the associated offscreen window
	* 	\param out_state Whether the offscreen window supports opacity in the window background.
	* 	\param out_opacity The opacity value that will be applied when rendering the window background.
	*	\return <span class='code'>true</span> if an opacity option was set, <span class='code'>false</span> otherwise. */
	bool							ShowOpacity(bool & out_state, float & out_opacity) const;

	/*! Shows the native format and quality of the associated offscreen window.
	 *  \param out_format Format image data will be stored in.
	 * 	\param out_quality The compression quality for the image data (when applicable).
	*	\return <span class='code'>true</span> if a native format option was set, <span class='code'>false</span> otherwise. */
	bool							ShowNativeFormat(Window::ImageFormat & out_format, float & out_quality) const;

	/*! Shows the framebuffer retention setting for the associated offscreen window.
	*	\param out_retain The framebuffer retention setting for the associated offscreen window.
	*	\return <span class='code'>true</span> if framebuffer retention option was set, <span class='code'>false</span> otherwise. */
	bool								ShowFramebufferRetention(bool & out_retain) const;


private:
	//! Private default constructor to prevent instantiation without an offscreen window.
	OffScreenWindowOptionsControl();
};


/*! The OffScreenWindowKey class is a smart pointer to a database object.  Offscreen windows are special types of windows that represent
 * 	images that can be rendered into. */
class HPS_API OffScreenWindowKey : public WindowKey
{
public:
	/*! The default constructor creates an uninitialized OffScreenWindowKey object.  The Type() function will return Type::None. */
	OffScreenWindowKey();

	/*! The copy constructor creates an OffScreenWindowKey object that shares the underlying smart-pointer of the source Key.
	 * 	The copy will only be successful if the source key is really an upcast of an offscreen window.  Otherwise the copy
	 * 	will fail and the resulting OffScreenWindowKey will be invalid.
	 *	\param in_key The source Key to copy. */
	OffScreenWindowKey(Key const & in_key);

	/*! The copy constructor creates a OffScreenWindowKey object that shares the underlying smart-pointer of the source OffScreenWindowKey.
	 *	\param in_that The source OffScreenWindowKey to copy. */
	OffScreenWindowKey(OffScreenWindowKey const & in_that);

	/*! The move constructor creates an OffScreenWindowKey by transferring the underlying impl of the rvalue reference to this OffScreenWindowKey
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an OffScreenWindowKey to take the impl from. */
	OffScreenWindowKey(OffScreenWindowKey && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this OffScreenWindowKey thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an OffScreenWindowKey to take the impl from.
	 * 	\return A reference to this OffScreenWindowKey. */
	OffScreenWindowKey & operator=(OffScreenWindowKey && in_that);

	~OffScreenWindowKey();

	static const HPS::Type staticType = HPS::Type::OffScreenWindowKey;
	HPS::Type								ObjectType() const { return staticType; };

	/*! Gets a control that allows querying options specific to offscreen windows.
	 * 	\return A control that allows querying options specific to offscreen windows. */
	OffScreenWindowOptionsControl const		GetWindowOptionsControl() const;

	/*! Gets a control that allows querying options specific to offscreen windows.
	 * 	\return A control that allows querying options specific to offscreen windows. */
	OffScreenWindowOptionsControl			GetWindowOptionsControl();

	/*! Shows the offscreen-window-specific options for this OffScreenWindowKey.
	 * 	\param out_kit The offscreen-window-specific options for this OffScreenWindowKey.
	 *	\return <span class='code'>true</span> if any options are set, <span class='code'>false</span> otherwise. */
	bool									ShowWindowOptions(OffScreenWindowOptionsKit & out_kit) const;
};




/*! The ImageDefinition class is a smart pointer to a database object.  It is a handle to an image defined within a portolfio. */
class HPS_API ImageDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized ImageDefinition object.  The Type() function will return Type::None. */
	ImageDefinition();

	/*! This constructor creates an ImageDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of an image definition.  Otherwise the copy
	 * 	will fail and the resulting ImageDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	ImageDefinition(Definition const & in_that);

	/*! The copy constructor creates an ImageDefinition object that shares the underlying smart-pointer of the source ImageDefinition.
	 *	\param in_that The source ImageDefinition to copy. */
	ImageDefinition(ImageDefinition const & in_that);

	/*! Associate this ImageDefinition with the same underlying impl as the source ImageDefinition.
	 *	\param in_that The source ImageDefinition for the assignment.
	 *	\return A reference to this ImageDefinition. */
	ImageDefinition & operator=(ImageDefinition const & in_that);

	/*! The move constructor creates an ImageDefinition by transferring the underlying impl of the rvalue reference to this ImageDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to an ImageDefinition to take the impl from. */
	ImageDefinition(ImageDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImageDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an ImageDefinition to take the impl from.
	 * 	\return A reference to this ImageDefinition. */
	ImageDefinition & operator=(ImageDefinition && in_that);

	~ImageDefinition();

	static const HPS::Type staticType = HPS::Type::ImageDefinition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Redefine the image for this ImageDefinition.
	 * 	\param in_kit The new image for this ImageDefinition. */
	void				Set(ImageKit const & in_kit);

	/*! Shows the image for this ImageDefinition.
	 * 	\param out_kit The image for this ImageDefinition. */
	void				Show(ImageKit & out_kit) const;
};

/*! The CubeMapDefinition class is a smart pointer to a database object.  It is a handle to a cube map defined within a portfolio. */
class HPS_API CubeMapDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized CubeMapDefinition object.  The Type() function will return Type::None. */
	CubeMapDefinition();

	/*! This constructor creates a CubeMapDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a cube map definition.  Otherwise the copy
	 * 	will fail and the resulting CubeMapDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	CubeMapDefinition(Definition const & in_that);

	/*! The copy constructor creates a CubeMapDefinition object that shares the underlying smart-pointer of the source CubeMapDefinition.
	 *	\param in_that The source CubeMapDefinition to copy. */
	CubeMapDefinition(CubeMapDefinition const & in_that);

	/*! Associate this CubeMapDefinition with the same underlying impl as the source CubeMapDefinition.
	 *	\param in_that The source CubeMapDefinition for the assignment.
	 *	\return A reference to this CubeMapDefinition. */
	CubeMapDefinition & operator=(CubeMapDefinition const & in_that);

	/*! The move constructor creates a CubeMapDefinition by transferring the underlying impl of the rvalue reference to this CubeMapDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CubeMapDefinition to take the impl from. */
	CubeMapDefinition(CubeMapDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CubeMapDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a CubeMapDefinition to take the impl from.
	 * 	\return A reference to this CubeMapDefinition. */
	CubeMapDefinition & operator=(CubeMapDefinition && in_that);

	~CubeMapDefinition();

	static const HPS::Type staticType = HPS::Type::CubeMapDefinition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Redefine the images for this CubeMapDefinition.
	 * 	\param in_negative_z The new image for the negative z-axis.
	 * 	\param in_positive_z The new image for the positive z-axis.
	 * 	\param in_negative_x The new image for the negative x-axis.
	 * 	\param in_positive_x The new image for the positive x-axis.
	 * 	\param in_negative_y The new image for the negative y-axis.
	 * 	\param in_positive_y The new image for the positive y-axis. */
	void				SetSource(ImageDefinition const & in_negative_z, ImageDefinition const & in_positive_z,
								ImageDefinition const & in_negative_x, ImageDefinition const & in_positive_x,
								ImageDefinition const & in_negative_y, ImageDefinition const & in_positive_y);

	/*! Show the images for this CubeMapDefinition.
	 * 	\param out_negative_z The image for the negative z-axis.
	 * 	\param out_positive_z The image for the positive z-axis.
	 * 	\param out_negative_x The image for the negative x-axis.
	 * 	\param out_positive_x The image for the positive x-axis.
	 * 	\param out_negative_y The image for the negative y-axis.
	 * 	\param out_positive_y The image for the positive y-axis. */
	void				ShowSource(ImageDefinition & out_negative_z, ImageDefinition & out_positive_z,
								ImageDefinition & out_negative_x, ImageDefinition & out_positive_x,
								ImageDefinition & out_negative_y, ImageDefinition & out_positive_y) const;

	/*! Show the images for this CubeMapDefinition.
	 * 	\param out_image_sources The source images packed as:
	 *	negative z-axis, positive z-axis, negative x-axis, positive x-axis, negative y-axis, positive y-axis. */
	void				ShowSource(ImageDefinitionArray & out_image_sources) const;

	/*! Redefine the texture options for this CubeMapDefinition.
	 * 	\param in_options The new texture options for this CubeMapDefinition. */
	void				SetOptions(TextureOptionsKit const & in_options);

	/*! Show the texture options for this CubeMapDefinition.
	 * 	\param out_options The texture options for this CubeMapDefinition. */
	void				ShowOptions(TextureOptionsKit & out_options) const;
};


/*! The NamedStyleDefinition class is a smart pointer to a database object.  It is a handle to a named style defined within a portfolio. */
class HPS_API NamedStyleDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized NamedStyleDefinition object.  The Type() function will return Type::None. */
	NamedStyleDefinition();

	/*! This constructor creates a NamedStyleDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a named style definition.  Otherwise the copy
	 * 	will fail and the resulting NamedStyleDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	NamedStyleDefinition(Definition const & in_that);

	/*! The copy constructor creates a NamedStyleDefinition object that shares the underlying smart-pointer of the source NamedStyleDefinition.
	 *	\param in_that The source NamedStyleDefinition to copy. */
	NamedStyleDefinition(NamedStyleDefinition const & in_that);

	/*! Associate this NamedStyleDefinition with the same underlying impl as the source NamedStyleDefinition.
	 *	\param in_that The source NamedStyleDefinition for the assignment.
	 *	\return A reference to this NamedStyleDefinition. */
	NamedStyleDefinition & operator=(NamedStyleDefinition const & in_that);

	/*! The move constructor creates a NamedStyleDefinition by transferring the underlying impl of the rvalue reference to this NamedStyleDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a NamedStyleDefinition to take the impl from. */
	NamedStyleDefinition(NamedStyleDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this NamedStyleDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a NamedStyleDefinition to take the impl from.
	 * 	\return A reference to this NamedStyleDefinition. */
	NamedStyleDefinition & operator=(NamedStyleDefinition && in_that);

	~NamedStyleDefinition();

	static const HPS::Type staticType = HPS::Type::NamedStyleDefinition;
	HPS::Type							ObjectType() const { return staticType; };

	/*! Get the source segment for this NamedStyleDefinition.
	 * 	\return The source segment for this NamedStyleDefinition.  This is the segment that contains attributes that are associated with
	 * 		this named style. */
	SegmentKey							GetSource() const;
};


/*! The MaterialPaletteDefinition class is a smart pointer to a database object.  It is a handle to a material palette defined within a portfolio. */
class HPS_API MaterialPaletteDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized MaterialPaletteDefinition object.  The Type() function will return Type::None. */
	MaterialPaletteDefinition();

	/*! This constructor creates a MaterialPaletteDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a material palette definition.  Otherwise the copy
	 * 	will fail and the resulting MaterialPaletteDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	MaterialPaletteDefinition(Definition const & in_that);

	/*! The copy constructor creates a MaterialPaletteDefinition object that shares the underlying smart-pointer of the source MaterialPaletteDefinition.
	 *	\param in_that The source MaterialPaletteDefinition to copy. */
	MaterialPaletteDefinition(MaterialPaletteDefinition const & in_that);

	/*! Associate this MaterialPaletteDefinition with the same underlying impl as the source MaterialPaletteDefinition.
	 *	\param in_that The source MaterialPaletteDefinition for the assignment.
	 *	\return A reference to this MaterialPaletteDefinition. */
	MaterialPaletteDefinition & operator=(MaterialPaletteDefinition const & in_that);

	/*! The move constructor creates a MaterialPaletteDefinition by transferring the underlying impl of the rvalue reference to this
	 * 	MaterialPaletteDefinition thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MaterialPaletteDefinition to take the impl from. */
	MaterialPaletteDefinition(MaterialPaletteDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MaterialPaletteDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a MaterialPaletteDefinition to take the impl from.
	 * 	\return A reference to this MaterialPaletteDefinition. */
	MaterialPaletteDefinition & operator=(MaterialPaletteDefinition && in_that);

	~MaterialPaletteDefinition();

	static const HPS::Type staticType = HPS::Type::MaterialPaletteDefinition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Redefine the material array for this MaterialPaletteDefinition.
	 * 	\param in_source The new array of materials for this MaterialPaletteDefinition. */
	void				Set(MaterialKitArray const & in_source);

	/*! Redefine the material array for this MaterialPaletteDefinition.
	 * 	\param in_count Size of the following array.
	 * 	\param in_source The new array of materials for this MaterialPaletteDefinition. */
	void				Set(size_t in_count, MaterialKit const in_source []);

	/*! Shows the material array for this MaterialPaletteDefinition.
	 * 	\param out_source The array of materials for this MaterialPaletteDefinition. */
	void				Show(MaterialKitArray & out_source) const;
};



/*! The LinePatternDefinition class is a smart pointer to a database object.  It is a handle to a line pattern defined within a portfolio. */
class HPS_API LinePatternDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized LinePatternDefinition object.  The Type() function will return Type::None. */
	LinePatternDefinition();

	/*! This constructor creates a LinePatternDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a line pattern definition.  Otherwise the copy
	 * 	will fail and the resulting LinePatternDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	LinePatternDefinition(Definition const & in_that);

	/*! The copy constructor creates a LinePatternDefinition object that shares the underlying smart-pointer of the source LinePatternDefinition.
	 *	\param in_that The source LinePatternDefinition to copy. */
	LinePatternDefinition(LinePatternDefinition const & in_that);

	/*! Associate this LinePatternDefinition with the same underlying impl as the source LinePatternDefinition.
	 *	\param in_that The source LinePatternDefinition for the assignment.
	 *	\return A reference to this LinePatternDefinition. */
	LinePatternDefinition & operator=(LinePatternDefinition const & in_that);

	/*! The move constructor creates a LinePatternDefinition by transferring the underlying impl of the rvalue reference to this LinePatternDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a LinePatternDefinition to take the impl from. */
	LinePatternDefinition(LinePatternDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this LinePatternDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a LinePatternDefinition to take the impl from.
	 * 	\return A reference to this LinePatternDefinition. */
	LinePatternDefinition & operator=(LinePatternDefinition && in_that);

	~LinePatternDefinition();

	static const HPS::Type staticType = HPS::Type::LinePatternDefinition;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Redefine the line pattern for this LinePatternDefinition.
	 * 	\param in_kit The new line pattern for this LinePatternDefinition. */
	void				Set(LinePatternKit const & in_kit);

	/*! Shows the line pattern for this LinePatternDefinition.
	 * 	\param out_kit The line pattern for this LinePatternDefinition. */
	void				Show(LinePatternKit & out_kit) const;
};



/*!	The Shader class contains objects for importing shader source files and enumerations used when defining shaders in Visualize. Shaders are for internal use only - customers should not use shaders. */
class HPS_API Shader
{
public:
	/*! \enum Parameterization
	 *	Enumeration of the parameterization sources for shaders, i.e., how to map the shader to geometry. */
	enum class Parameterization : uint32_t
	{
		/*! Use a cylindrical mapping for the shader. */
		Cylinder,
		/*! Shader Parameterization. */
		PhysicalReflection,
		/*! Use the <span class='code'>(x,y,z)</span> coordinates for the object before transforms have been applied for the shader. */
		Object,
		/*! Use the natural mapping for meshes, NURBS surfaces and shells for the shader.
		 * 	For meshes, shaders will be stretched in the range <span class='code'>[0,1]</span>.
		 * 	For NURBS surfaces, shaders will be mapped in the range <span class='code'>[0,(control point count - degree)]</span>.
		 * 	For shells, shaders will be mapped such that <span class='code'>u=x+z</span> and <span class='code'>v=x+y</span>
		 * 	where <span class='code'>(x,y,z)</span> is in object space. */
		NaturalUV,
		/*! Shader Parameterization. */
		ReflectionVector,
		/*! Shader Parameterization. */
		SurfaceNormal,
		/*! Use a spherical mapping for the shader. */
		Sphere,
		/*! Use the mapping explicitly defined on the geometry for the shader. */
		UV,
		/*! Use the <span class='code'>(x, y, z)</span> coordinates for the object after transforms have been applied for the shader. */
		World
	};

	/*!	The ImportOptionsKit class contains settings that will be set on the ShaderKit which is returned by File::Import. */
class HPS_API ImportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportOptionsKit object. */
		ImportOptionsKit();

		/*! The copy constructor creates a new ImportOptionsKit object that contains the same settings as the source ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		ImportOptionsKit(ImportOptionsKit const & in_kit);

		/*! The move constructor creates an ImportOptionsKit by transferring the underlying impl of the rvalue reference to this ImportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from. */
		ImportOptionsKit(ImportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit & operator=(ImportOptionsKit && in_that);

		virtual ~ImportOptionsKit();

	static const HPS::Type staticType = HPS::Type::ShaderImportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		void					Set(ImportOptionsKit const & in_kit);

		/*! Copies this ImportOptionsKit into the given ImportOptionsKit.
		 * 	\param out_kit The ImportOptionsKit to populate with the contents of this ImportOptionsKit. */
		void					Show(ImportOptionsKit & out_kit) const;

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		operator=(ImportOptionsKit const & in_kit);

		/*! Indicates whether this ImportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is not equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportOptionsKit const & in_kit) const;

		/*! Sets whether to apply diffuse textures from layers greater than <span class='code>0</span> on top of the shader when it
		 * 	is applied to geometry.
		 * 	\param in_state Whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top
		 * 		of the shader when it is applied to geometry.  If <span class='code'>true</span>, the additional textures will be applied;
		 * 		if <span class='code'>false</span>, the additional textures will not be applied.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetMultitexture(bool in_state);

		/*! Sets the parameterization source for the shader.
		 *	\param in_source The parameterization source for the shader.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetParameterizationSource(Parameterization in_source);

		/*! Sets the transform matrix for the shader.
		 *	\param in_transform The transform matrix for the shader.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetTransformMatrix(MatrixKit const & in_transform);

		/*! Removes whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top of the
		 * 	shader when it is applied to geometry.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetMultitexture();

		/*! Removes the parameterization source for the shader.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetParameterizationSource();

		/*! Removes the transform matrix for the shader.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetTransformMatrix();

		/*! Removes all settings from this ImportOptionsKit.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetEverything();

		/*! Shows whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top of the
		 * 	shader when it is applied to geometry.
		 *	\param out_state whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top
		 *		of the shader when it is applied to geometry.
		 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
		bool					ShowMultitexture(bool & out_state) const;

		/*! Shows the parameterization source for the shader.
		 *	\param out_source The parameterization source for the shader.
		 *	\return <span class='code'>true</span> if the parameterization source is valid, <span class='code'>false</span> otherwise. */
		bool					ShowParameterizationSource(Parameterization & out_source) const;

		/*! Shows the transform matrix for the shader.
		 *	\param out_transform The transform matrix for the shader.
		 *	\return <span class='code'>true</span> if the transform is valid, <span class='code'>false</span> otherwise. */
		bool					ShowTransformMatrix(MatrixKit & out_transform) const;
	};

	/*!	The File class provides a function to import shader files. */
	class HPS_API File
	{
	public:
		/*!	Performs a synchronous import of the specified shader file.  The function returns a ShaderKit with the source code from
		 * 	the shader file and with the specified options.  May throw an IOException if a problem occurs during import.
		 * 	\param in_file_name Name of shader file from which to get the source code.
		 *	\param in_options Options to set on the ShaderKit returned by this function.
		 *	\return A ShaderKit containing the source from the specified file and with the specified options. */
		static ShaderKit Import(char const * in_file_name, ImportOptionsKit const & in_options);

	private:
		//! Private default constructor to prevent instantiation.
		File();
	};

private:
	//! Private default constructor to prevent instantiation.
	Shader();
};


/*! Internal use only - customers should not use. The ShaderKit class is a user space object.  It is used for specifying all settings related to a ShaderDefinition. */
class HPS_API ShaderKit : public Kit
{
public:
	/*! The default constructor creates an empty ShaderKit object. */
	ShaderKit();

	/*! The copy constructor creates a new ShaderKit object that contains the same settings as the source ShaderKit.
	 * 	\param in_kit The source ShaderKit to copy. */
	ShaderKit(ShaderKit const & in_kit);

	/*! The move constructor creates a ShaderKit by transferring the underlying impl of the rvalue reference to this ShaderKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShaderKit to take the impl from. */
	ShaderKit(ShaderKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShaderKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShaderKit to take the impl from.
	 * 	\return A reference to this ShaderKit. */
	ShaderKit & operator=(ShaderKit && in_that);

	virtual ~ShaderKit();

	static const HPS::Type staticType = HPS::Type::ShaderKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source ShaderKit into this ShaderKit.
	 * 	\param in_kit The source ShaderKit to copy. */
	void				Set(ShaderKit const & in_kit);

	/*! Copies this ShaderKit into the given ShaderKit.
	 * 	\param out_kit The ShaderKit to populate with the contents of this ShaderKit. */
	void				Show(ShaderKit & out_kit) const;

	/*! Copies the source ShaderKit into this ShaderKit.
	 * 	\param in_kit The source ShaderKit to copy.
	 * 	\return A reference to this ShaderKit. */
	ShaderKit &			operator=(ShaderKit const & in_kit);

	/*! Indicates whether this ShaderKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ShaderKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source ShaderKit is equivalent to this ShaderKit.
	 *	\param in_kit The source ShaderKit to compare to this ShaderKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(ShaderKit const & in_kit) const;

	/*!	Check if the source ShaderKit is equivalent to this ShaderKit.
	 *	\param in_kit The source ShaderKit to compare to this ShaderKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(ShaderKit const & in_kit) const;

	/*!	Check if the source ShaderKit is not equivalent to this ShaderKit.
	 *	\param in_kit The source ShaderKit to compare to this ShaderKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(ShaderKit const & in_kit) const;

	/*! Sets the source code for the shader.
	 *	\param in_source The source code for the shader.
	 *	\return A reference to this ShaderKit. */
	ShaderKit &			SetSource(char const * in_source);

	/*! Sets whether to apply diffuse textures from layers greater than <span class='code>0</span> on top of the shader when it
	 * 	is applied to geometry.
	 * 	\param in_state Whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top
	 * 		of the shader when it is applied to geometry.  If <span class='code'>true</span>, the additional textures will be applied;
	 * 		if <span class='code'>false</span>, the addtional textures will not be applied.
	 *	\return A reference to this ShaderKit. */
	ShaderKit &			SetMultitexture(bool in_state);

	/*! Sets the parameterization source for the shader.
	 *	\param in_source The parameterization source for the shader.
	 *	\return A reference to this ShaderKit. */
	ShaderKit &			SetParameterizationSource(Shader::Parameterization in_source);

	/*! Sets the transform matrix for the shader.
	 *	\param in_transform The transform matrix for the shader.
	 *	\return A reference to this ShaderKit. */
	ShaderKit &			SetTransformMatrix(MatrixKit const & in_transform);

	/*! Removes the source code for the shader.
	 * 	\return A reference to this ShaderKit. */
	ShaderKit &			UnsetSource();

	/*! Removes whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top of the
	 * 	shader when it is applied to geometry.
	 * 	\return A reference to this ShaderKit. */
	ShaderKit &			UnsetMultitexture();

	/*! Removes the parameterization source for the shader.
	 * 	\return A reference to this ShaderKit. */
	ShaderKit &			UnsetParameterizationSource();

	/*! Removes the transform matrix for the shader.
	 * 	\return A reference to this ShaderKit. */
	ShaderKit &			UnsetTransformMatrix();

	/*! Removes all settings from this ShaderKit.
	 *	\return A reference to this ShaderKit. */
	ShaderKit &			UnsetEverything();

	/*! Shows the source code for the shader.
	 *	\param out_source The source code for the shader.
	 *	\return <span class='code'>true</span> if the source code is valid, <span class='code'>false</span> otherwise. */
	bool				ShowSource(UTF8 & out_source) const;

	/*! Shows whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top of the
	 * 	shader when it is applied to geometry.
	 *	\param out_state whether to apply diffuse textures from layers greater than <span class='code'>0</span> on top
	 *		of the shader when it is applied to geometry.
	 *	\return <span class='code'>true</span> if the flag is valid, <span class='code'>false</span> otherwise. */
	bool				ShowMultitexture(bool & out_state) const;

	/*! Shows the parameterization source for the shader.
	 *	\param out_source The parameterization source for the shader.
	 *	\return <span class='code'>true</span> if the parameterization source is valid, <span class='code'>false</span> otherwise. */
	bool				ShowParameterizationSource(Shader::Parameterization & out_source) const;

	/*! Shows the transform matrix for the shader.
	 *	\param out_transform The transform matrix for the shader.
	 *	\return <span class='code'>true</span> if the transform is valid, <span class='code'>false</span> otherwise. */
	bool				ShowTransformMatrix(MatrixKit & out_transform) const;
};


/*! Internal use only - customers should not use. The ShaderDefinition class is a smart pointer to a database object.  It is a handle to a shader defined within a portfolio. */
class HPS_API ShaderDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized ShaderDefinition object.  The Type() function will return Type::None. */
	ShaderDefinition();

	/*! This constructor creates a ShaderDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a shader definition.  Otherwise the copy
	 * 	will fail and the resulting ShaderDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	ShaderDefinition(Definition const & in_that);

	/*! The copy constructor creates a ShaderDefinition object that shares the underlying smart-pointer of the source ShaderDefinition.
	 *	\param in_that The source ShaderDefinition to copy. */
	ShaderDefinition(ShaderDefinition const & in_that);

	/*! Associate this ShaderDefinition with the same underlying impl as the source ShaderDefinition.
	 *	\param in_that The source ShaderDefinition for the assignment.
	 *	\return A reference to this ShaderDefinition. */
	ShaderDefinition & operator=(ShaderDefinition const & in_that);

	/*! The move constructor creates a ShaderDefinition by transferring the underlying impl of the rvalue reference to this ShaderDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShaderDefinition to take the impl from. */
	ShaderDefinition(ShaderDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShaderDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShaderDefinition to take the impl from.
	 * 	\return A reference to this ShaderDefinition. */
	ShaderDefinition & operator=(ShaderDefinition && in_that);

	~ShaderDefinition();

	static const HPS::Type staticType = HPS::Type::ShaderDefinition;
	HPS::Type	ObjectType() const { return staticType; };

	/*! Redefine the shader for this ShaderDefinition.
	 * 	\param in_kit The new shader for this ShaderDefinition. */
	void				Set(ShaderKit const & in_kit);

	/*! Shows the shader for this ShaderDefinition.
	 * 	\param out_kit The shader for this ShaderDefinition. */
	void				Show(ShaderKit & out_kit) const;
};

/*! The ShapeKit class is a user space object.  It is used for specifying all settings related to a ShapeDefinition. */
class HPS_API ShapeKit : public Kit
{
public:
	/*! The default constructor creates an empty ShapeKit object. */
	ShapeKit();

	/*! The copy constructor creates a new ShapeKit object that contains the same settings as the source ShapeKit.
	 * 	\param in_kit The source ShapeKit to copy. */
	ShapeKit(ShapeKit const & in_kit);

	/*! The move constructor creates a ShapeKit by transferring the underlying impl of the rvalue reference to this ShapeKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShapeKit to take the impl from. */
	ShapeKit(ShapeKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShapeKit thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShapeKit to take the impl from.
	 * 	\return A reference to this ShapeKit. */
	ShapeKit & operator=(ShapeKit && in_that);

	virtual ~ShapeKit();

	static const HPS::Type staticType = HPS::Type::ShapeKit;
	HPS::Type			ObjectType() const { return staticType; };

	/*! Copies the source ShapeKit into this ShapeKit.
	 * 	\param in_kit The source ShapeKit to copy. */
	void				Set(ShapeKit const & in_kit);

	/*! Copies this ShapeKit into the given ShapeKit.
	 * 	\param out_kit The ShapeKit to populate with the contents of this ShapeKit. */
	void				Show(ShapeKit & out_kit) const;

	/*! Copies the source ShapeKit into this ShapeKit.
	 * 	\param in_kit The source ShapeKit to copy.
	 * 	\return A reference to this ShapeKit. */
	ShapeKit &			operator=(ShapeKit const & in_kit);

	/*! Indicates whether this ShapeKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this ShapeKit, <span class='code'>false</span> otherwise. */
	bool				Empty() const;

	/*!	Check if the source ShapeKit is equivalent to this ShapeKit.
	 *	\param in_kit The source ShapeKit to compare to this ShapeKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				Equals(ShapeKit const & in_kit) const;

	/*!	Check if the source ShapeKit is equivalent to this ShapeKit.
	 *	\param in_kit The source ShapeKit to compare to this ShapeKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool				operator==(ShapeKit const & in_kit) const;

	/*!	Check if the source ShapeKit is not equivalent to this ShapeKit.
	 *	\param in_kit The source ShapeKit to compare to this ShapeKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool				operator!=(ShapeKit const & in_kit) const;

	/*! Creates a ShapeKit which contains the definition of the specified default shape.
	 * 	\param in_default_shape The default shape for which to get the corresponding ShapeKit.
	 * 	\return A ShapeKit which contains the definition of the specified default shape. */
	static HPS::ShapeKit 	GetDefault(Shape::Default in_default_shape);

	/*! Sets the elements for this ShapeKit.  This must be specified when defining a shape.
	 * 	\param in_def The array of elements for the shape.
	 * 	\return A reference to this ShapeKit. */
	ShapeKit &				SetElements(ShapeElementArray const & in_def);

	/*! Sets the elements for this ShapeKit.  This must be specified when defining a shape.
	 * 	\param in_count Size of the following array.
	 * 	\param in_def The array of elements for the shape.
	 * 	\return A reference to this ShapeKit. */
	ShapeKit &				SetElements(size_t in_count, ShapeElement const in_def []);

	/*! Set a single element for this ShapeKit.  This must be specified when defining a shape.
	 * 	\param in_element A reference to the ShapeElement to set on this kit.
	 * 	\return A reference to this ShapeKit. */
	ShapeKit &				SetElement(ShapeElement const & in_element);

	/*! Removes the elements for the shape.
	 * 	\return A reference to this ShapeKit. */
	ShapeKit &				UnsetElements();

	/*! Removes all settings from this ShapeKit.
	 *	\return A reference to this ShapeKit. */
	ShapeKit &				UnsetEverything();

	/*! Shows the elements for this ShapeKit.
	 * 	\param out_def The elements for the shape.
	 *	\return <span class='code'>true</span> if elements were set, <span class='code'>false</span> otherwise. */
	bool					ShowElements(ShapeElementArray & out_def) const;

};

/*! The ShapeDefinition class is a smart pointer to a database object.  It is a handle to a shape defined within a portfolio. */
class HPS_API ShapeDefinition : public Definition
{
public:
	/*! The default constructor creates an uninitialized ShapeDefinition object.  The Type() function will return Type::None. */
	ShapeDefinition();

	/*! This constructor creates a ShapeDefinition object that shares the underlying smart-pointer of the source Definition.
	 * 	The copy will only be successful if the source definition is really an upcast of a shader definition.  Otherwise the copy
	 * 	will fail and the resulting ShapeDefinition will be invalid.
	 *	\param in_that The source Definition to copy. */
	ShapeDefinition(Definition const & in_that);

	/*! The copy constructor creates a ShapeDefinition object that shares the underlying smart-pointer of the source ShapeDefinition.
	 *	\param in_that The source ShapeDefinition to copy. */
	ShapeDefinition(ShapeDefinition const & in_that);

	/*! Associate this ShapeDefinition with the same underlying impl as the source ShapeDefinition.
	 *	\param in_that The source ShapeDefinition for the assignment.
	 *	\return A reference to this ShapeDefinition. */
	ShapeDefinition & operator=(ShapeDefinition const & in_that);

	/*! The move constructor creates a ShapeDefinition by transferring the underlying impl of the rvalue reference to this ShapeDefinition
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a ShapeDefinition to take the impl from. */
	ShapeDefinition(ShapeDefinition && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ShapeDefinition thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a ShapeDefinition to take the impl from.
	 * 	\return A reference to this ShapeDefinition. */
	ShapeDefinition & operator=(ShapeDefinition && in_that);

	~ShapeDefinition();

	static const HPS::Type staticType = HPS::Type::ShapeDefinition;
	HPS::Type	ObjectType() const { return staticType; };

	/*! Redefine the shape for this ShapeDefinition.
	 * 	\param in_kit The new shader for this ShapeDefinition. */
	void				Set(ShapeKit const & in_kit);

	/*! Shows the shape for this ShapeDefinition.
	 * 	\param out_kit The shape for this ShapeDefinition. */
	void				Show(ShapeKit & out_kit) const;
};


//////////////////////////////////////////////////////////////////////
/////////////////////// Actions and Globals //////////////////////////
//////////////////////////////////////////////////////////////////////
class HPS_API CutGeometryGatheringOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty CutGeometryGatheringOptionsKit object. */
	CutGeometryGatheringOptionsKit();

	/*! The copy constructor creates a new CutGeometryGatheringOptionsKit object that contains the same settings as the source CutGeometryGatheringOptionsKit.
	 * 	\param in_kit The source CutGeometryGatheringOptionsKit to copy. */
	CutGeometryGatheringOptionsKit(CutGeometryGatheringOptionsKit const & in_kit);

	/*! The move constructor creates a CutGeometryGatheringOptionsKit by transferring the underlying impl of the rvalue reference to this CutGeometryGatheringOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a CutGeometryGatheringOptionsKit to take the impl from. */
	CutGeometryGatheringOptionsKit(CutGeometryGatheringOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this CutGeometryGatheringOptionsKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a CutGeometryGatheringOptionsKit to take the impl from.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		operator=(CutGeometryGatheringOptionsKit && in_that);

	virtual ~CutGeometryGatheringOptionsKit();

	static const HPS::Type staticType = HPS::Type::CutGeometryGatheringOptionsKit;
	HPS::Type								ObjectType() const {return staticType;};

	/*! Creates a CutGeometryGatheringOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return A CutGeometryGatheringOptionsKit with the default settings. */
	static CutGeometryGatheringOptionsKit	GetDefault();

	/*! Copies the source CutGeometryGatheringOptionsKit into this CutGeometryGatheringOptionsKit.
	 * 	\param in_kit The source CutGeometryGatheringOptionsKit to copy. */
	void									Set(CutGeometryGatheringOptionsKit const & in_kit);

	/*! Copies this CutGeometryGatheringOptionsKit into the given CutGeometryGatheringOptionsKit.
	 * 	\param out_kit The CutGeometryGatheringOptionsKit to populate with the contents of this CutGeometryGatheringOptionsKit. */
	void									Show(CutGeometryGatheringOptionsKit & out_kit) const;

	/*! Copies the source CutGeometryGatheringOptionsKit into this CutGeometryGatheringOptionsKit.
	 * 	\param in_kit The source CutGeometryGatheringOptionsKit to copy.
	 * 	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		operator=(CutGeometryGatheringOptionsKit const & in_kit);

	/*! Indicates whether this CutGeometryGatheringOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this CutGeometryGatheringOptionsKit, <span class='code'>false</span> otherwise. */
	bool									Empty() const;

	/*!	Check if the source CutGeometryGatheringOptionsKit is equivalent to this CutGeometryGatheringOptionsKit.
	 *	\param in_kit The source CutGeometryGatheringOptionsKit to compare to this CutGeometryGatheringOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool									Equals(CutGeometryGatheringOptionsKit const & in_kit) const;

	/*!	Check if the source CutGeometryGatheringOptionsKit is equivalent to this CutGeometryGatheringOptionsKit.
	 *	\param in_kit The source CutGeometryGatheringOptionsKit to compare to this CutGeometryGatheringOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool									operator==(CutGeometryGatheringOptionsKit const & in_kit) const;

	/*!	Check if the source CutGeometryGatheringOptionsKit is not equivalent to this CutGeometryGatheringOptionsKit.
	 *	\param in_kit The source CutGeometryGatheringOptionsKit to compare to this CutGeometryGatheringOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool									operator!=(CutGeometryGatheringOptionsKit const & in_kit) const;


	/*!	Sets a single cutting section for which to collect capping geometry.  If this is not specified, caps for all cutting sections will be collected.
	 *	\param in_cutter A single cutting section that is interesting for capping geometry collection.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		SetCuttingSection(CuttingSectionKey const & in_cutter);

	/*!	If a single cutting section is specified, this sets the plane offset into that section.  If this is not set, all planes in that section will be collected.
	 *	\param in_offset An offset for a single plane in a cutting section.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		SetOffset(size_t in_offset);

	/*!	Sets the level at which to collect the capping geometry.
	 *	\param in_level Whether the capping geometry should be collected from just a single segment or an entire subtree.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		SetLevel(CuttingSection::GatheringLevel in_level);

	/*!	Sets whether the implicit color is collected with the capping geometry.
	 *	\param in_color Whether the color is collected.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		SetColor(bool in_color);


	/*! Removes a single cutting section for which to collect capping geometry.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		UnsetCuttingSection();

	/*! Removes an offset for a single plane in a cutting section.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		UnsetOffset();

	/*! Removes the level setting at which to collect the capping geometry.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		UnsetLevel();

	/*! Removes the color setting when collecting the capping geometry.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		UnsetColor();

	/*! Removes all settings from this CutGeometryGatheringOptionsKit.
	 *	\return A reference to this CutGeometryGatheringOptionsKit. */
	CutGeometryGatheringOptionsKit &		UnsetEverything();


	/*! Shows a cutting section that is interesting for capping geometry collection.
	 *	\param out_cutter A cutting section that is interesting for capping geometry collection.
	 *	\return <span class='code'>true</span> if a cutting section was set, <span class='code'>false</span> otherwise. */
	bool									ShowCuttingSection(CuttingSectionKey & out_cutter) const;

	/*! Shows an offset for a single plane in a cutting section.
	 *	\param out_offset An offset for a single plane in a cutting section.
	 *	\return <span class='code'>true</span> if an offset was set, <span class='code'>false</span> otherwise. */
	bool									ShowOffset(size_t & out_offset) const;

	/*! Shows the level at which to collect the capping geometry.
	*	\param out_level Whether the capping geometry should be collected from just a single segment or an entire subtree.
	 *	\return <span class='code'>true</span> if a level was set, <span class='code'>false</span> otherwise. */
	bool									ShowLevel(CuttingSection::GatheringLevel & out_level) const;

	/*! Shows the color gathering preference whe collecting capping geometry.
	*	\param out_color Whether the implicit color of the capping geometry should be collected along with the geometry.
	 *	\return <span class='code'>true</span> if a color gathering preference was set, <span class='code'>false</span> otherwise. */
	bool									ShowColor(bool & out_color) const;
};

/*! The SearchOptionsKit class is a user space object.  It contains options used when performing a search. */
class HPS_API SearchOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty SearchOptionsKit object. */
	SearchOptionsKit();

	/*! The copy constructor creates a new SearchOptionsKit object that contains the same settings as the source SearchOptionsKit.
	 * 	\param in_kit The source SearchOptionsKit to copy. */
	SearchOptionsKit(SearchOptionsKit const & in_kit);

	/*! The move constructor creates a SearchOptionsKit by transferring the underlying impl of the rvalue reference to this SearchOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SearchOptionsKit to take the impl from. */
	SearchOptionsKit(SearchOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SearchOptionsKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SearchOptionsKit to take the impl from.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit & operator=(SearchOptionsKit && in_that);

	virtual ~SearchOptionsKit();

	static const HPS::Type staticType = HPS::Type::SearchOptionsKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a SearchOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return A SearchOptionsKit with the default settings. */
	static SearchOptionsKit		GetDefault();

	/*! Copies the source SearchOptionsKit into this SearchOptionsKit.
	 * 	\param in_kit The source SearchOptionsKit to copy. */
	void						Set(SearchOptionsKit const & in_kit);

	/*! Copies this SearchOptionsKit into the given SearchOptionsKit.
	 * 	\param out_kit The SearchOptionsKit to populate with the contents of this SearchOptionsKit. */
	void						Show(SearchOptionsKit & out_kit) const;

	/*! Copies the source SearchOptionsKit into this SearchOptionsKit.
	 * 	\param in_kit The source SearchOptionsKit to copy.
	 * 	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			operator=(SearchOptionsKit const & in_kit);

	/*! Indicates whether this SearchOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this SearchOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source SearchOptionsKit is equivalent to this SearchOptionsKit.
	 *	\param in_kit The source SearchOptionsKit to compare to this SearchOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(SearchOptionsKit const & in_kit) const;

	/*!	Check if the source SearchOptionsKit is equivalent to this SearchOptionsKit.
	 *	\param in_kit The source SearchOptionsKit to compare to this SearchOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(SearchOptionsKit const & in_kit) const;

	/*!	Check if the source SearchOptionsKit is not equivalent to this SearchOptionsKit.
	 *	\param in_kit The source SearchOptionsKit to compare to this SearchOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(SearchOptionsKit const & in_kit) const;

	/*! Sets the type of entity to look for when performing a search.
	 *	\param in_request The type of entity to look for.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			SetCriteria(Search::Type in_request);

	/*! Sets the behavior to use when performing a search.
	 *	\param in_behavior The behavior to use when performing a search.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			SetBehavior(Search::Behavior in_behavior);

	/*! Sets the type of entities to look for when performing a search.
	 *	\param in_requests Array of the entity types to look for.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			SetCriteria(SearchTypeArray const & in_requests);

	/*! Sets the type of entities to look for when performing a search.
	 *	\param in_count Size of the next array.
	 *	\param in_requests Array of the entity types to look for.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			SetCriteria(size_t in_count, Search::Type const in_requests []);

	/*! Sets which segments to look in when performing a search.
	 *	\param in_search_space Which segments to look in when performing a search.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			SetSearchSpace(Search::Space in_search_space);

	/*! Removes the behavior to use when performing a search.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			UnsetBehavior();

	/*! Removes the entity types to look for when performing a search.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			UnsetCriteria();

	/*! Removes which segments to look in when performing a search.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			UnsetSearchSpace();

	/*! Removes all settings from this SearchOptionsKit.
	 *	\return A reference to this SearchOptionsKit. */
	SearchOptionsKit &			UnsetEverything();

	/*! Shows the behavior to use when performing a search.
	 *	\param out_behavior The behavior to use when performing a search.
	 *	\return <span class='code'>true</span> if a behavior was set, <span class='code'>false</span> otherwise. */
	bool						ShowBehavior(Search::Behavior & out_behavior) const;

	/*! Shows the entity types to look for when performing a search.
	 *	\param out_types Array of the entity types to look for.
	 *	\return <span class='code'>true</span> if the array is valid, <span class='code'>false</span> otherwise. */
	bool						ShowCriteria(SearchTypeArray & out_types) const;

	/*! Shows which segments to look in when performing a search.
	 *	\param out_search_space Which segments to look in when performing a search.
	 *	\return <span class='code'>true</span> if the search space is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSearchSpace(Search::Space & out_search_space) const;
};

/*! The TreeContext class is a user space object.  It contains a spatial partition used for shell selection and shell relation computations.
 *	If many such operations will be performed without modifying the segment tree, using the same TreeContext for all of them can be
 *  a significant optimization.  If a TreeContext is not specified, a new one is computed internally each time.*/
class HPS_API TreeContext : public Object
{
public:
	/*! The default constructor creates a new TreeContext object.
	 *	\param in_create whether to create the underlying spatial tree context. */
	TreeContext(bool in_create = true);

	/*! The copy constructor shares a TreeContext object.
	 *	\param in_that The source TreeContext to share. */
	TreeContext(TreeContext const & in_that);

	/*! The move constructor creates a new TreeContext by transferring the underlying impl of the rvalue reference to this TreeContext
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TreeContext to take the impl from. */
	TreeContext(TreeContext && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TreeContext thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a TreeContext to take the impl from.
	 *	\return A reference to this TreeContext. */
	TreeContext &		operator=(TreeContext && in_that);

	/*! The destructor cleans up the tree context created by the constructor. */
	virtual ~TreeContext();

	static const HPS::Type staticType = HPS::Type::TreeContext;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Shares the source TreeContext.
	 * 	\param in_kit The source TreeContext to share.
	 * 	\return A reference to this TreeContext. */
	TreeContext &		operator=(TreeContext const & in_that);

	/*!	Check if the source TreeContext is the same as this TreeContext.
	 *	\param in_kit The source TreeContext to compare to this TreeContext.
	 *	\return <span class='code'>true</span> if the objects are identical, <span class='code'>false</span> otherwise. */
	bool				Equals(TreeContext const & in_that) const;

	/*!	Check if the source TreeContext is the same as this TreeContext.
	 *	\param in_kit The source TreeContext to compare to this TreeContext.
	 *	\return <span class='code'>true</span> if the objects are identical, <span class='code'>false</span> otherwise. */
	bool				operator==(TreeContext const & in_that) const;

	/*!	Check if the source TreeContext is not the same as this TreeContext.
	 *	\param in_kit The source TreeContext to compare to this TreeContext.
	 *	\return <span class='code'>true</span> if the objects are not identical, <span class='code'>false</span> otherwise. */
	bool				operator!=(TreeContext const & in_that) const;

};

/*! The SelectionOptionsKit class is a user space object.  It contains options related to selection. Default values for the SelectionOptionsKit can be found in <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">this table</a>. */
class HPS_API SelectionOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty SelectionOptionsKit object. */
	SelectionOptionsKit();

	/*! The copy constructor creates a new SelectionOptionsKit object that contains the same settings as the source SelectionOptionsKit.
	 * 	\param in_kit The source SelectionOptionsKit to copy. */
	SelectionOptionsKit(SelectionOptionsKit const & in_kit);

	/*! The move constructor creates a SelectionOptionsKit by transferring the underlying impl of the rvalue reference to this SelectionOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectionOptionsKit to take the impl from. */
	SelectionOptionsKit(SelectionOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectionOptionsKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a SelectionOptionsKit to take the impl from.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		operator=(SelectionOptionsKit && in_that);

	virtual ~SelectionOptionsKit();

	static const HPS::Type staticType = HPS::Type::SelectionOptionsKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a SelectionOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return A SelectionOptionsKit with the default settings. */
	static SelectionOptionsKit	GetDefault();

	/*! Copies the source SelectionOptionsKit into this SelectionOptionsKit.
	 * 	\param in_kit The source SelectionOptionsKit to copy. */
	void						Set(SelectionOptionsKit const & in_kit);

	/*! Copies this SelectionOptionsKit into the given SelectionOptionsKit.
	 * 	\param out_kit The SelectionOptionsKit to populate with the contents of this SelectionOptionsKit. */
	void						Show(SelectionOptionsKit & out_kit) const;

	/*! Copies the source SelectionOptionsKit into this SelectionOptionsKit.
	 * 	\param in_kit The source SelectionOptionsKit to copy.
	 * 	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		operator=(SelectionOptionsKit const & in_kit);

	/*! Indicates whether this SelectionOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this SelectionOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source SelectionOptionsKit is equivalent to this SelectionOptionsKit.
	 *	\param in_kit The source SelectionOptionsKit to compare to this SelectionOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(SelectionOptionsKit const & in_kit) const;

	/*!	Check if the source SelectionOptionsKit is equivalent to this SelectionOptionsKit.
	 *	\param in_kit The source SelectionOptionsKit to compare to this SelectionOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(SelectionOptionsKit const & in_kit) const;

	/*!	Check if the source SelectionOptionsKit is not equivalent to this SelectionOptionsKit.
	 *	\param in_kit The source SelectionOptionsKit to compare to this SelectionOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(SelectionOptionsKit const & in_kit) const;

	/*! Sets the selection proximity in centimeters or object-relative-units (ORU), depending
	 * on the selection-routine being utilized. The selection proximity augments point-based or
	 * shell-based selections by also factoring in the area surrounding the selection-point or
	 * selection-shell.
	 *
	 * For HPS::SelectionControl::SelectByPoint, this specifies the radius in
	 * centimeters around the selection within which objects will be returned as selected.
	 * The value must be positive.
	 *
	 * For HPS::SelectionControl::SelectByShell, this specifies a distance in
     * object-relative-units that determines whether a selection is performed. A positive
	 * proximity value will cause the selection algorithm to perform a selection when the
	 * distance between the two bodies is <= proximity, which means the bodies do not have
	 * to be touching in order for Visualize to perform a selection.  If the proximity == 0,
	 * the bodies must be coincident or penetrating for a selection to occur. If proximity < 0,
	 * the shells must penetrate each other by at least that amount before a selection is performed.
	 *
	 * %Selection %proximity is not relevant for other selection types.
	 *
     * When using HPS::SelectionControl::SelectByShell, false positives or negatives for selection may occur if the proximity and/or selection shells meet any of the following criteria:
     * - The absolute value of a negative proximity is much larger than the actual intersection of the shells.   An example would be a shell that represents a thin plate or a thinly-walled tube, and the specified proximity is larger than the thickness of the plate or tube.
     * - %Selection shells ("probes") have vertices with complex intersections
     * - %Selection shells ("probes") have concavities, especially multiple adjacent concavities.
     *
	 * \param in_proximity The radius around the selection within which objects will be returned as selected.
	 * \return A reference to this SelectionOptionsKit.
	 * \sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 * \sa <a href="../../prog_guide/0601_selection.html#proximity_collision">Collision detection proximity</a>
	 */
	SelectionOptionsKit &		SetProximity(float in_proximity);

	/*! Sets the level at which selection will occur.
	 *	\param in_level The level at which selection will occur.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetLevel(Selection::Level in_level);

	/*! Sets the internal selection limit.  The internal selection limit is the maximum number of subentities for shells and meshes that will be
	 *	returned if performing subentity selection.
	 *	\param in_limit The internal selection limit.
	 *  \return A reference to this SelectionOptionsKit
	 *  \sa <a href="../../prog_guide/0601_selection.html#internal_limit">Internal limit in Programming Guide</a> */
	SelectionOptionsKit &		SetInternalLimit(size_t in_limit);

	/*! Sets the related selection limit.  The related selection limit is the maximum number of items that will be returned as selected when performing
	 *	a selection.  A related selection limit of <span class='code'>0</span> would result in only the first item getting returned.  If the value is
	 *	greater than <span class='code'>0</span>, this indicates the number of additional items beyond the first to return.  The order of these additional
	 *	items will depend on whether sorting is enabled (see \ref SetSorting()).
	 *	\param in_limit Limit on the number of items that will be returned as selected when performing a selection.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 *  \sa <a href="../../prog_guide/0601_selection.html#related_limit">Related limit in Programming Guide</a>
	 *  \sa SetSorting(Selection::Sorting)
	 */
	SelectionOptionsKit &		SetRelatedLimit(size_t in_limit);

	/*! Sets whether to sort selection results.  This is only relevant if the related selection limit is greater than <span class='code'>0</span> (see SetRelatedLimit).
	 *	Sorting works on an entity level. Subentity components like edges, vertices and faces are not sorted.
	 *	\param in_sorting Whether to sort selection results.  A value of <span class='code'>true</span> is equivalent to passing Selection::Sorting::Default
	 *		to SetSorting(Selection::Sorting), and a value of <span class='code'>false</span> is equivalent to passing Selection::Sorting::Off to SetSorting(Selection::Sorting).
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 *	\deprecated This function exists for compatibility and SetSorting(Selection::Sorting) should be preferred in general usage. */
	SelectionOptionsKit &		SetSorting(bool in_sorting);

	/*! Sets how selection results will be sorted.
	 *
	 *  This is only relevant if the related selection limit is greater than <span class='code'>0</span> (see \ref SetRelatedLimit()).
	 *	Sorting works on an entity level. Subentity components like edges, vertices, and faces are not sorted.
	 *
	 *  This option has no effect on SelectByShell.
	 *
	 *  For SelectByPoint, all values of the Selection::Sorting enum apply. Selection::Sorting::Default is an alias for Selection::Sorting::Proximity.
	 *
	 *  For all other selection types, Selection::Sorting::Proximity does not apply. Selection::Sorting::Default is an alias for Selection::Sorting::ZSorting.
	 *	\param in_sorting The type of selection sorting to use.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 *  \sa <a href="../../prog_guide/0601_selection.html#related_limit">Related limit in Programming Guide</a>
	 *  \sa SetRelatedLimit()
	 */
	SelectionOptionsKit &		SetSorting(Selection::Sorting in_sorting);

	/*! Sets the type of selection algorithm to use.  This setting has no effect on object space selections (i.e., select by shell, volume and ray).
	 *	\param in_algorithm The type of selection algorithm to use.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetAlgorithm(Selection::Algorithm in_algorithm);

	/*! Sets the selection granularity to use.
	 *	\param in_granularity The selection granularity to use.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetGranularity(Selection::Granularity in_granularity);

	/*! Sets the starting location at which selection testing will begin.
	 *	If the selection is being performed from a window, there must be a path from this segment to that window.
	 *	\param in_start_segment A segment, that must be a child of the window key, in which to begin selection testing.
	 *	\param in_scope_only If <span class = 'code'>true</span> selections will only occur in the provided scope segment,
	 *  otherwise selections will occur in subsegments and includes of in_start_segment as well.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		SetScope(SegmentKey const & in_start_segment, bool in_scope_only = false);

	/*! Sets the starting location at which selection testing will begin.
	 *	If the selection is being performed from a window, there must be a path from this segment to that window.
	 *	\param in_start_path A path of segments and includes, leaf to root, from the segment to begin selection testing to the window key.
	 *	\param in_scope_only If <span class = 'code'>true</span> selections will only occur in the leaf segments of in_start_path,
	 *  otherwise selections will occur in subsegments and includes of the leaf segments of in_start_path as well.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		SetScope(KeyPath const & in_start_path, bool in_scope_only = false);

	/*! Sets a TreeContext to be used for this selection.  If many shell selections are going to be computed without modifying the segment tree,
	 *	using the same tree context for all of them can be a significant optimization.  If a TreeContext is not specified, a new one is computed each time.
	 * \param in_tree_context The tree context to use for this relation test.
	 * \return A reference to this object. */
	SelectionOptionsKit &		SetTreeContext(TreeContext const & in_tree_context);

	/*! Sets whether to respect the extent culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * extent culling option (see \ref HPS::CullingKit) will be ignored.
	 *	\param in_state Whether to respect the extent culling option during selection.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetExtentCullingRespected(bool in_state);

	/*! Sets whether to respect the deferral extent culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * deferral extent culling option (see \ref HPS::CullingKit) will be ignored.
	 *	\param in_state Whether to respect the deferral extent culling option during selection.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetDeferralExtentCullingRespected(bool in_state);

	/*! Sets whether to respect the frustum culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * frustum culling option (see \ref HPS::CullingKit) will be ignored.
	 *	\param in_state Whether to respect the frustum culling option during selection.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetFrustumCullingRespected(bool in_state);

	/*! Sets whether to respect the vector culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * vector culling option (see \ref HPS::CullingKit) will be ignored.
	 *	\param in_state Whether to respect the vector culling option during selection.
	 *	\return A reference to this SelectionOptionsKit.
	 *	\sa Default value <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsKit &		SetVectorCullingRespected(bool in_state);

	/*! Sets whether to respect the volume culling option during selection. If this value is set to <span class='code'>false</span>, the
	*   volume culling option (see \ref HPS::CullingKit) will be ignored.
	*	\param in_state Whether to respect the volume culling option during selection.
	*	\return A reference to this SelectionOptionsKit.
	*	\sa Default value <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	*/
	SelectionOptionsKit &		SetVolumeCullingRespected(bool in_state);

	/*! Sets whether to respect the distance culling option during selection. If this value is set to <span class='code'>false</span>, the
	*   distance culling option (see \ref HPS::CullingKit) will be ignored.
	*	\param in_state Whether to respect the distance culling option during selection.
	*	\return A reference to this SelectionOptionsKit.
	*	\sa Default value <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	*/
	SelectionOptionsKit &		SetDistanceCullingRespected(bool in_state);

	/*! Sets selectability options that are applied during the selection.
	* \param in_selectability A \ref HPS::SelectabilityKit that encapsulates the selectability options to set on this kit.
	* \return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		SetSelectability(SelectabilityKit const & in_selectability);

	/*! Sets a condition that is applied during the selection. This allows you to use condition logic during a
	 * selection without actually activating those conditions in the scene.
	 * \param in_condition The condition to set on this kit, replacing any existing conditions.
	 * \return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		SetCondition(char const * in_condition);

	/*! Sets conditions that are applied during the selection. This allows you to use condition logic during a
	* selection without actually activating those conditions in the scene.
	* \param in_conditions The conditions to set on this kit, replacing any existing conditions.
	* \return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		SetConditions(UTF8Array const & in_conditions);

	/*! Sets conditions that are applied during the selection. This allows you to use condition logic during a
	* selection without actually activating those conditions in the scene.
	* \param in_conditions The conditions to set on this kit, replacing any existing conditions.
	* \return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		SetConditions(size_t in_count, UTF8 const in_conditions[]);


	/*! Removes the selectability settings.
	*	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetSelectability();

	/*! Removes the selection proximity.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetProximity();

	/*! Removes the selection level.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetLevel();

	/*! Removes the internal selection limit.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetInternalLimit();

	/*! Removes the related selection limit.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetRelatedLimit();

	/*! Removes the selection sorting setting.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetSorting();

	/*! Removes the selection algorithm.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetAlgorithm();

	/*! Removes the selection granularity.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetGranularity();

	/*! Removes the selection scope setting from this SelectionOptionsKit.
	 *	\return A reference to this object. */
	SelectionOptionsKit &		UnsetScope();

	/*! Removes the tree context from this SelectionOptionsKit.
	 *	\return A reference to this object. */
	SelectionOptionsKit &		UnsetTreeContext();

	/*! Removes the extent culling respected option.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetExtentCullingRespected();

	/*! Removes the deferral extent culling respected option.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetDeferralExtentCullingRespected();

	/*! Removes the frustum culling respected option.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetFrustumCullingRespected();

	/*! Removes the vector culling respected option.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetVectorCullingRespected();

	/*! Removes the volume culling respected option.
	*	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetVolumeCullingRespected();

	/*! Removes the distance culling respected option.
	*	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetDistanceCullingRespected();

	/*! Unsets all conditions in this kit. */
	SelectionOptionsKit &		UnsetConditions();

	/*! Removes all settings from this SelectionOptionsKit.
	 *	\return A reference to this SelectionOptionsKit. */
	SelectionOptionsKit &		UnsetEverything();


	/*! Shows the selection proximity.
	 *	\param out_proximity The selection proximity.
	 *	\return <span class='code'>true</span> if the proximity is valid, <span class='code'>false</span> otherwise. */
	bool						ShowProximity(float & out_proximity) const;

	/*! Shows the selection level.
	 *	\param out_level The selection level.
	 *	\return <span class='code'>true</span> if the level is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLevel(Selection::Level & out_level) const;

	/*! Shows the internal selection limit.
	 *	\param out_limit The internal selection limit.
	 *	\return <span class='code'>true</span> if the internal selection limit is valid, <span class='code'>false</span> otherwise. */
	bool						ShowInternalLimit(size_t & out_limit) const;

	/*! Shows the related selection limit.
	 *	\param out_limit The related selection limit.
	 *	\return <span class='code'>true</span> if the related selection limit is valid, <span class='code'>false</span> otherwise. */
	bool						ShowRelatedLimit(size_t & out_limit) const;

	/*! Shows the type of selection sorting.
	 *	\param out_sorting The type of selection sorting to use.
	 *	\return <span class='code'>true</span> if the selection sorting type is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSorting(Selection::Sorting & out_sorting) const;

	/*! Shows the selection algorithm.
	 *	\param out_algorithm The selection algorithm.
	 *	\return <span class='code'>true</span> if the selection algorithm is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAlgorithm(Selection::Algorithm & out_algorithm) const;

	/*! Shows the selection granularity.
	 *	\param out_granularity The selection granularity.
	 *	\return <span class='code'>true</span> if the selection granularity is valid, <span class='code'>false</span> otherwise. */
	bool						ShowGranularity(Selection::Granularity & out_granularity) const;

	/*! Shows the starting location at which selection testing will begin.
	 *	\param out_start_path A segment or collection of segments and includes organized from leaf to root.
	 *	\param out_scope_only Whether selections will only occur in the leaf segments of out_start_path or if they can occur
	 *  in subsegments and includes of the leaf segments of out_start_path.
	 *	\return <span class='code'>true</span> if a selection scope was set, <span class='code'>false</span> otherwise. */
	bool						ShowScope(KeyPath & out_start_path, bool & out_scope_only) const;

	/*! Shows the tree context for this SelectionOptionsKit.
	 *	\param out_tree_context The tree context to use for this relation test.
	 *	\return <span class='code'>true</span> if a tree context was set, <span class='code'>false</span> otherwise. */
	bool						ShowTreeContext(TreeContext & out_tree_context) const;

	/*! Shows the extent culling respected state.
	 *	\param out_state The extent culling respected state.
	 *	\return <span class='code'>true</span> if the extent culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowExtentCullingRespected(bool & out_state) const;

	/*! Shows the deferral extent culling respected state.
	 *	\param out_state The deferral extent culling respected state.
	 *	\return <span class='code'>true</span> if the deferral extent culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDeferralExtentCullingRespected(bool & out_state) const;

	/*! Shows the frustum culling respected state.
	 *	\param out_state The frustum culling respected state.
	 *	\return <span class='code'>true</span> if the frustum culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFrustumCullingRespected(bool & out_state) const;

	/*! Shows the vector culling respected state.
	 *	\param out_state The vector culling respected state.
	 *	\return <span class='code'>true</span> if the vector culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVectorCullingRespected(bool & out_state) const;

	/*! Shows the volume culling respected state.
	*	\param out_state The volume culling respected state.
	*	\return <span class='code'>true</span> if the volume culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVolumeCullingRespected(bool & out_state) const;

	/*! Shows the distance culling respected state.
	*	\param out_state The distance culling respected state.
	*	\return <span class='code'>true</span> if the distance culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDistanceCullingRespected(bool & out_state) const;

	/*! Shows the selectability settings.
	*	\param out_selectability The selectability settings
	*	\return <span class='code'>true</span> if the selectability settings are valid, <span class='code'>false</span> otherwise. */
	bool						ShowSelectability(HPS::SelectabilityKit & out_selectability) const;

	/*! Shows all conditions in this kit.
	*	\return <span class='code'>true</span> if theere are conditions to show, <span class='code'>false</span> otherwise. */
	bool						ShowConditions(UTF8Array & out_conditions) const;
};



/*!
<p>The HPS::SelectionOptionsControl class is a smart pointer that is tied to a database object.  It is used to set selection related options on a HPS::WindowKey. Options include the selection algorithm, granularity, internal limit, related limit, level, proximity, and sorting. Default values for the various fields of HPS::SelectionOptionsControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">here</a>.</p>
*/
class HPS_API SelectionOptionsControl : public Control
{
public:
	/*! This constructor creates a SelectionOptionsControl object which is tied to the specified window.
	 * 	\param in_window The window which this SelectionOptionsControl should operate on. */
	explicit SelectionOptionsControl(WindowKey const & in_window);

	/*! The copy constructor creates a SelectionOptionsControl object that shares the underlying smart-pointer of the source SelectionOptionsControl.
	 *	\param in_that The source SelectionOptionsControl to copy. */
	SelectionOptionsControl(SelectionOptionsControl const & in_that);

	/*! The move constructor creates a SelectionOptionsControl by transferring the underlying impl of the rvalue reference to this SelectionOptionsControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectionOptionsControl to take the impl from. */
	SelectionOptionsControl(SelectionOptionsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectionOptionsControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a SelectionOptionsControl to take the impl from.
	 * 	\return A reference to this SelectionOptionsControl. */
	SelectionOptionsControl & operator=(SelectionOptionsControl && in_that);

	~SelectionOptionsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::SelectionOptionsControl;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the SelectionOptionsControl source.
	 *	\param in_that The SelectionOptionsControl source of the assignment.
	 *	\return A reference to this SelectionOptionsControl. */
	SelectionOptionsControl &	operator=(SelectionOptionsControl const & in_that);

	/*! Sets the selection proximity in centimeters or object-relative-units (ORU), depending
	 * on the selection-routine being utilized. The selection proximity augments point-based or
	 * shell-based selections by also factoring in the area surrounding the selection-point or
	 * selection-shell.
	 *
	 * For HPS::SelectionControl::SelectByPoint, this specifies the radius in
	 * centimeters around the selection within which objects will be returned as selected.
	 * The value must be positive.
	 *
	 * For HPS::SelectionControl::SelectByShell, this specifies a distance in
     * object-relative-units that determines whether a selection is performed. A positive
	 * proximity value will cause the selection algorithm to perform a selection when the
	 * distance between the two bodies is <= proximity, which means the bodies do not have
	 * to be touching in order for Visualize to perform a selection.  If the proximity == 0,
	 * the bodies must be coincident or penetrating for a selection to occur. If proximity < 0,
	 * the shells must penetrate each other by at least that amount before a selection is performed.
	 *
	 * %Selection %proximity is not relevant for other selection types.
	 *
     * When using HPS::SelectionControl::SelectByShell, false positives or negatives for selection may occur if the proximity and/or selection shells meet any of the following criteria:
     * - The absolute value of a negative proximity is much larger than the actual intersection of the shells.   An example would be a shell that represents a thin plate or a thinly-walled tube, and the specified proximity is larger than the thickness of the plate or tube.
     * - %Selection shells ("probes") have vertices with complex intersections
     * - %Selection shells ("probes") have concavities, especially multiple adjacent concavities.
     *
	 * \param in_proximity The radius around the selection within which objects will be returned as selected.
	 * \return A reference to this SelectionOptionsKit.
	 * \sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 * \sa <a href="../../prog_guide/0601_selection.html#proximity_collision">Collision detection proximity</a>
	 */
	SelectionOptionsControl &	SetProximity(float in_proximity);

	/*! Sets the level at which selection will occur.
	 *	\param in_level The level at which selection will occur.
	 *	\return A reference to this SelectionOptionsControl.
	*	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	*/
	SelectionOptionsControl &	SetLevel(Selection::Level in_level);

	/*! Sets the internal selection limit.  The internal selection limit is the maximum number of subentities for shells and meshes that will be
	 *	returned if performing subentity selection.
	 *	\param in_limit The internal selection limit.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetInternalLimit(size_t in_limit);

	/*! Sets the related selection limit.  The related selection limit is the maximum number of items that will be returned as selected when performing
	 *	a selection.  A related selection limit of <span class='code'>0</span> would result in only the first item getting returned.  If the value is
	 *	greater than <span class='code'>0</span>, this indicates the number of additional items beyond the first to return.  The order of these additional
	 *	items will depend on whether sorting is enabled (see \ref SetSorting()).
	 *	\param in_limit Limit on the number of items that will be returned as selected when performing a selection.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 *  \sa SetSorting(Selection::Sorting)
	 */
	SelectionOptionsControl &	SetRelatedLimit(size_t in_limit);

	/*! Sets whether to sort selection results.  This is only relevant if the related selection limit is greater than <span class='code'>0</span> (see SetRelatedLimit).
	 *	Sorting works on an entity level. Subentity components like edges, vertices and faces are not sorted.
	 *	\param in_sorting Whether to sort selection results.  A value of <span class='code'>true</span> is equivalent to passing Selection::Sorting::Default
	 *		to SetSorting(Selection::Sorting), and a value of <span class='code'>false</span> is equivalent to passing Selection::Sorting::Off to SetSorting(Selection::Sorting).
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 *	\deprecated This function exists for compatibility and SetSorting(Selection::Sorting) should be preferred in general usage. */
	SelectionOptionsControl &	SetSorting(bool in_sorting);

	/*! Sets how selection results will be sorted.
	 *
	 *  This is only relevant if the related selection limit is greater than <span class='code'>0</span> (see \ref SetRelatedLimit()).
	 *	Sorting works on an entity level. Subentity components like edges, vertices, and faces are not sorted.
	 *
	 *  This option has no effect on SelectByShell.
	 *
	 *  For SelectByPoint, all values of the Selection::Sorting enum apply. Selection::Sorting::Default is an alias for Selection::Sorting::Proximity.
	 *
	 *  For all other selection types, Selection::Sorting::Proximity does not apply. Selection::Sorting::Default is an alias for Selection::Sorting::ZSorting.
	 *	\param in_sorting The type of selection sorting to use.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 *  \sa <a href="../../prog_guide/0601_selection.html#related_limit">Related limit in Programming Guide</a>
	 *  \sa SetRelatedLimit()
	 */
	SelectionOptionsControl &	SetSorting(Selection::Sorting in_sorting);

	/*! Sets the type of selection algorithm to use.  This setting has no effect on object space selections (i.e., select by shell, volume and ray).
	 *	\param in_algorithm The type of selection algorithm to use.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetAlgorithm(Selection::Algorithm in_algorithm);

	/*! Sets the selection granularity to use.
	 *	\param in_granularity The selection granularity to use.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetGranularity(Selection::Granularity in_granularity);

	/*! Sets whether to respect the extent culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * extent culling option (see \ref HPS::CullingControl) will be ignored.
	 *	\param in_state Whether to respect the extent culling option during selection.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetExtentCullingRespected(bool in_state);

	/*! Sets whether to respect the deferral extent culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * deferral extent culling option (see \ref HPS::CullingControl) will be ignored.
	 *	\param in_state Whether to respect the deferral extent culling option during selection.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetDeferralExtentCullingRespected(bool in_state);

	/*! Sets whether to respect the frustum culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * frustum culling option (see \ref HPS::CullingControl) will be ignored.
	 *	\param in_state Whether to respect the frustum culling option during selection.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetFrustumCullingRespected(bool in_state);

	/*! Sets whether to respect the vector culling option during selection. If this value is set to <span class='code'>false</span>, the
	 * vector culling option (see \ref HPS::CullingControl) will be ignored.
	 *	\param in_state Whether to respect the vector culling option during selection.
	 *	\return A reference to this SelectionOptionsControl.
	 *	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	 */
	SelectionOptionsControl &	SetVectorCullingRespected(bool in_state);

	/*! Sets whether to respect the volume culling option during selection. If this value is set to <span class='code'>false</span>, the
	* volume culling option (see \ref HPS::CullingControl) will be ignored.
	*	\param in_state Whether to respect the volume culling option during selection.
	*	\return A reference to this SelectionOptionsControl.
	*	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	*/
	SelectionOptionsControl &	SetVolumeCullingRespected(bool in_state);

	/*! Sets whether to respect the distance culling option during selection. If this value is set to <span class='code'>false</span>, the
	* distance culling option (see \ref HPS::CullingControl) will be ignored.
	*	\param in_state Whether to respect the distance culling option during selection.
	*	\return A reference to this SelectionOptionsControl.
	*	\sa <a href="../../prog_guide/appendix_default_attribute_values.html#selection-options">Default value</a>
	*/
	SelectionOptionsControl &	SetDistanceCullingRespected(bool in_state);


	/*!	Removes the Proximity setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetProximity();

	/*!	Removes the Selection Level setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetLevel();

	/*!	Removes the Internal Limit setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetInternalLimit();

	/*!	Removes the Related Limit setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetRelatedLimit();

	/*!	Removes the Sorting setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetSorting();

	/*!	Removes the Algorithm setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetAlgorithm();

	/*!	Removes the Granularity setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetGranularity();

	/*!	Removes the Extent Culling setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetExtentCullingRespected();

	/*!	Removes the Deferral Culling setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetDeferralExtentCullingRespected();

	/*!	Removes the Frustum Culling setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetFrustumCullingRespected();

	/*!	Removes the Vector Culling setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	 * as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl & UnsetVectorCullingRespected();

	/*!	Removes the Volume Culling setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	* as specified by SelectionOptionsKit::GetDefault().
	*	\return A reference to this object. */
	SelectionOptionsControl & UnsetVolumeCullingRespected();

	/*!	Removes the distance Culling setting from this control.  If the control is attached to a WindowKey this function restores the default setting
	* as specified by SelectionOptionsKit::GetDefault().
	*	\return A reference to this object. */
	SelectionOptionsControl & UnsetDistanceCullingRespected();

	/*!	Removes all settings from this control.  If the control is attached to a WindowKey this function restores the default settings of this
	 *  control as specified by SelectionOptionsKit::GetDefault().
	 *	\return A reference to this object. */
	SelectionOptionsControl &	UnsetEverything();

	/*! Shows the selection proximity for the associated window.
	 *	\param out_proximity The selection proximity for the associated window.
	 *	\return <span class='code'>true</span> if the proximity is valid, <span class='code'>false</span> otherwise. */
	bool						ShowProximity(float & out_proximity) const;

	/*! Shows the selection level for the associated window.
	 *	\param out_level The selection level for the associated window.
	 *	\return <span class='code'>true</span> if the level is valid, <span class='code'>false</span> otherwise. */
	bool						ShowLevel(Selection::Level & out_level) const;

	/*! Shows the internal selection limit for the associated window.
	 *	\param out_limit The internal selection limit for the associated window.
	 *	\return <span class='code'>true</span> if the internal selection limit is valid, <span class='code'>false</span> otherwise. */
	bool						ShowInternalLimit(size_t & out_limit) const;

	/*! Shows the related selection limit for the associated window.
	 *	\param out_limit The related selection limit for the associated window.
	 *	\return <span class='code'>true</span> if the related selection limit is valid, <span class='code'>false</span> otherwise. */
	bool						ShowRelatedLimit(size_t & out_limit) const;

	/*! Shows the type of selection sorting for the associated window.
	 *	\param out_sorting The type of selection sorting to use for the associated window.
	 *	\return <span class='code'>true</span> if the selection sorting type is valid, <span class='code'>false</span> otherwise. */
	bool						ShowSorting(Selection::Sorting & out_sorting) const;

	/*! Shows the selection algorithm for the associated window.
	 *	\param out_algorithm The selection algorithm for the associated window.
	 *	\return <span class='code'>true</span> if the selection algorithm is valid, <span class='code'>false</span> otherwise. */
	bool						ShowAlgorithm(Selection::Algorithm & out_algorithm) const;

	/*! Shows the selection granularity for the associated window.
	 *	\param out_granularity The selection granularity for the associated window.
	 *	\return <span class='code'>true</span> if the selection granularity is valid, <span class='code'>false</span> otherwise. */
	bool						ShowGranularity(Selection::Granularity & out_granularity) const;

	/*! Shows the extent culling respected state for the associated window.
	 *	\param out_state The extent culling respected state.
	 *	\return <span class='code'>true</span> if the extent culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowExtentCullingRespected(bool & out_state) const;

	/*! Shows the deferral extent culling respected state for the associated window.
	 *	\param out_state The deferral extent culling respected state.
	 *	\return <span class='code'>true</span> if the deferral extent culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDeferralExtentCullingRespected(bool & out_state) const;

	/*! Shows the frustum culling respected state for the associated window.
	 *	\param out_state The frustum culling respected state.
	 *	\return <span class='code'>true</span> if the frustum culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowFrustumCullingRespected(bool & out_state) const;

	/*! Shows the vector culling respected state for the associated window.
	 *	\param out_state The vector culling respected state.
	 *	\return <span class='code'>true</span> if the vector culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVectorCullingRespected(bool & out_state) const;

	/*! Shows the volume culling respected state for the associated window.
	*	\param out_state The volume culling respected state.
	*	\return <span class='code'>true</span> if the volume culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowVolumeCullingRespected(bool & out_state) const;

	/*! Shows the distance culling respected state for the associated window.
	*	\param out_state The distance culling respected state.
	*	\return <span class='code'>true</span> if the distance culling respected state is valid, <span class='code'>false</span> otherwise. */
	bool						ShowDistanceCullingRespected(bool & out_state) const;

private:
	//! Private default constructor to prevent instantiation without a window.
	SelectionOptionsControl();
};



/*! The SelectionItem class is a smart-pointer to a database object.  It represents an item in a SelectionResults object. */
class HPS_API SelectionItem : public Object
{
public:
	/*! The default constructor creates an uninitialized SelectionItem object.  The Type() function will return Type::None. */
	SelectionItem();

	/*! The copy constructor creates a SelectionItem object that shares the underlying smart-pointer of the source SelectionItem.
	 *	\param in_that The source SelectionItem to copy.  */
	SelectionItem(SelectionItem const & in_that);

	/*! The move constructor creates a SelectionItem by transferring the underlying impl of the rvalue reference to this SelectionItem
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectionItem to take the impl from. */
	SelectionItem(SelectionItem && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectionItem thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a SelectionItem to take the impl from.
	 * 	\return A reference to this SelectionItem. */
	SelectionItem & operator=(SelectionItem && in_that);

	virtual ~SelectionItem();

	static const HPS::Type staticType = HPS::Type::SelectionItem;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Associate this SelectionItem with the same underlying impl as the source SelectionItem.
	 *	\param in_that The source SelectionItem for the assignment. */
	void					Set(SelectionItem const & in_that);

	/*! Associate this SelectionItem with the same underlying impl as the source SelectionItem.
	 *	\param in_that The source SelectionItem for the assignment.
	 *	\return A reference to this SelectionItem. */
	SelectionItem &			operator=(SelectionItem const & in_that);

	/*!	Check if the source SelectionItem is equivalent to this SelectionItem.
	 *	\param in_kit The source SelectionItem to compare to this SelectionItem.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(SelectionItem const & in_that) const;

	/*!	Check if the source SelectionItem is equivalent to this SelectionItem.
	 *	\param in_kit The source SelectionItem to compare to this SelectionItem.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(SelectionItem const & in_that) const;

	/*!	Check if the source SelectionItem is not equivalent to this SelectionItem.
	 *	\param in_kit The source SelectionItem to compare to this SelectionItem.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(SelectionItem const & in_that) const;

	/*! Shows the selection level used when this item was selected.
	 * 	\param out_level The selection level used when this item was selected.
	 *	\return <span class='code'>true</span> if the selection level is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSelectionLevel(Selection::Level & out_level) const;

	/*! Shows the key for the item that was selected.
	 * 	\param out_selection The key for the item that was selected.
	 *	\return <span class='code'>true</span> if the key is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSelectedItem(Key & out_selection) const;

	/*! Shows the key path for the item that was selected.
	 * 	\param out_path The key path for the item that was selected.
	 *	\return <span class='code'>true</span> if the key path is valid, <span class='code'>false</span> otherwise. */
	bool					ShowPath(KeyPath & out_path) const;

	/*! Shows the indices to the faces within a shell or mesh for the item that was selected if using subentity selection.
	 * 	\param out_faces The indices to the faces within a shell or mesh for the item that was selected.
	 *	\return <span class='code'>true</span> if the indices array is valid, <span class='code'>false</span> otherwise. */
	bool					ShowFaces(SizeTArray & out_faces) const;

	/*! Shows the indices to the vertices within a shell, mesh, line, polygon, or NURBS curve for the item that was selected if using subentity selection.
	 * 	\param out_faces The indices to the vertices within a shell, mesh, line, polygon, or NURBS curve for the item that was selected.
	 *	\return <span class='code'>true</span> if the indices array is valid, <span class='code'>false</span> otherwise. */
	bool					ShowVertices(SizeTArray & out_vertices) const;

	/*! Shows the indices to the edges (i.e., indices to the vertices at each end of an edge) within a shell, mesh, or polygon for the item that
	 * 	was selected if using subentity selection.
	 * 	\param out_faces The indices to the edges within a shell, mesh, or polygon for the item that was selected.
	 *	\return <span class='code'>true</span> if the indices array is valid, <span class='code'>false</span> otherwise. */
	bool					ShowEdges(SizeTArray & out_vertices1, SizeTArray & out_vertices2) const;

	/*! Shows the indices to the characters within a text string for the item that was selected if using subentity selection.
	 * 	\param out_characters The indices to the characters within a text string for the item that was selected.
	 *	\return <span class='code'>true</span> if the indices array is valid, <span class='code'>false</span> otherwise. */
	bool					ShowCharacters(SizeTArray & out_characters) const;

	/*! Shows the selection position in window space for the item that was selected.
	 * 	\param out_location The selection position in window space for the item that was selected.
	 *	\return <span class='code'>true</span> if the window space position is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSelectionPosition(WindowPoint & out_location) const;

	/*! Shows the selection position in world space for the item that was selected.
	 * 	\param out_location The selection position in world space for the item that was selected.
	 *	\return <span class='code'>true</span> if the world space position is valid, <span class='code'>false</span> otherwise. */
	bool					ShowSelectionPosition(WorldPoint & out_location) const;

	/*! Shows the Z-normalized selection position in window space for the item that was selected.
	 * 	\param out_location The selection position in window space with a normalized Z-coordinate for the item that was selected.
	 *	\return <span class='code'>true</span> if the window space position is valid, <span class='code'>false</span> otherwise. */
	bool					ShowNormalizedSelectionPosition(WindowPoint & out_location) const;

};

/*! The SelectionResultsIterator class is used to iterate over a SelectionResults object and access the SelectionItem objects contained within it. */
class HPS_API SelectionResultsIterator : public Object
{
public:
	/*! The default constructor creates a SelectionResultsIterator object which is not associated with a SelectionResults object. */
	SelectionResultsIterator();

	/*! The copy constructor creates a SelectionResultsIterator object associated with the same SelectionResults object as the source
	 * 	SelectionResultsIterator and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	 * 	\param in_that The source SelectionResultsIterator object to copy. */
	SelectionResultsIterator(SelectionResultsIterator const & in_that);

	/*! The move constructor creates a SelectionResultsIterator by transferring the underlying impl of the rvalue reference to this SelectionResultsIterator
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectionResultsIterator to take the impl from. */
	SelectionResultsIterator(SelectionResultsIterator && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectionResultsIterator thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a SelectionResultsIterator to take the impl from.
	 * 	\return A reference to this SelectionResultsIterator. */
	SelectionResultsIterator & operator=(SelectionResultsIterator && in_that);

	~SelectionResultsIterator();

	static const HPS::Type staticType = HPS::Type::SelectionResultsIterator;
	HPS::Type								ObjectType() const {return staticType;}

	/*! Copies the source SelectionResultsIterator into this SelectionResultsIterator.
	 * 	\param in_that The source SelectionResultsIterator to copy.
	 * 	\return A reference to this SelectionResultsIterator. */
	SelectionResultsIterator &				operator=(SelectionResultsIterator const & in_that);

	/*! Copies the source SelectionResultsIterator into this SelectionResultsIterator.
	 * 	\param in_that The source SelectionResultsIterator to copy. */
	void									Set(SelectionResultsIterator const & in_that);

	/*! Advances the iterator to the next selection item. */
	void									Next();

	/*! The prefix increment operator advances this iterator and returns it.
	 * 	\return A reference to this SelectionResultsIterator. */
	SelectionResultsIterator &				operator++();

	/*! The postfix increment operator advances this iterator and returns a copy of the it prior to advancement.
	 * 	\return A copy of this SelectionResultsIterator prior to having advanced it. */
	SelectionResultsIterator				operator++(int in_val);

	/*! Comparison operator between iterators to compare equality
		\param in_search_results_iterator The iterator to compare to */
	bool									operator==(SelectionResultsIterator const & in_search_results_iterator);

	/*! Comparison operator between iterators to compare inequality
		\param in_search_results_iterator The iterator to compare to */
	bool									operator!=(SelectionResultsIterator const & in_search_results_iterator);


	/*! Indicates whether this SearchResultsIterator is pointing to a valid selection item.
	 * 	\return <span class='code'>true</span> if this SearchResultsIterator is pointing to a valid item, <span class='code'>false</span> otherwise. */
	bool									IsValid() const;

	/*! Reset this SearchResultsIterator so it points to the first selection item in the associated SelectionResults object. */
	void									Reset();

	/*! Get the selection item this SelectionResultsIterator is currently pointing at.  This will throw an exception if this iterator is not valid.
	 * 	\return The selection item this SelectionResultsIterator is currently pointing at. */
	SelectionItem							GetItem() const;

	/*! Get the selection item this SelectionResultsIterator is currently pointing at.  This will throw an exception if this iterator is not valid.
	 * 	\return The selection item this SelectionResultsIterator is currently pointing at. */
	SelectionItem							operator*() const;


};

/*! The SelectionResults class is a smart pointer to a database object.  It is a handle to the results of a
 *	selection action and allows iteration over them.  When there are no remaining handles to a given selection result,
 *	the memory associated with it is freed. */
class HPS_API SelectionResults : public Object
{
public:
	/*! The default constructor creates an empty SelectionResults object which is not associated with any selection action. */
	SelectionResults();

	/*! The copy constructor creates a SelectionResults object that shares the underlying smart-pointer of the source SelectionResults.
	 *	\param in_that The source SelectionResults to copy.  */
	SelectionResults(SelectionResults const & in_that);

	/*! The move constructor creates a SelectionResults by transferring the underlying impl of the rvalue reference to this SelectionResults
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectionResults to take the impl from. */
	SelectionResults(SelectionResults && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectionResults thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a SelectionResults to take the impl from.
	 * 	\return A reference to this SelectionResults. */
	SelectionResults & operator=(SelectionResults && in_that);

	~SelectionResults();

	static const HPS::Type staticType = HPS::Type::SelectionResults;
	HPS::Type					ObjectType() const {return staticType;}

	/*! Share the underlying smart-pointer of the SelectionResults source.
	 *	\param in_that The SelectionResults source of the assignment. */
	void						Assign(SelectionResults const & in_that);

	/*! Share the underlying smart-pointer of the SelectionResults source.
	 *	\param in_that The SelectionResults source of the assignment.
	 *	\return A reference to this SelectionResults. */
	SelectionResults &			operator=(SelectionResults const & in_that);

	/*!	Check if the source SelectionResults is equivalent to this SelectionResults.
	 *	\param in_that The source SelectionResults to compare to this SelectionResults.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(SelectionResults const & in_that) const;

	/*!	Check if the source SelectionResults is equivalent to this SelectionResults.
	 *	\param in_that The source SelectionResults to compare to this SelectionResults.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(SelectionResults const & in_that) const;

	/*!	Check if the source SelectionResults is not equivalent to this SelectionResults.
	 *	\param in_that The source SelectionResults to compare to this SelectionResults.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(SelectionResults const & in_that) const;

	/*! Resets this object to its initial, uninitialized state. */
	virtual void				Reset();

	/*! Gets the selection level used when the associated selection action occurred.
	 * 	\return The selection level used when the associated selection action occurred. */
	Selection::Level			GetSelectionLevel() const;

	/*! Gets the number of items selected when the associated selection action occurred.
	 * 	\return Number of items selected when the associated selection action occurred. */
	size_t						GetCount() const;

	/*! Get an iterator that can be used to iterate through the selection results.
	 * 	\return An iterator that can be used to iterate through the selection results. */
	SelectionResultsIterator	GetIterator() const;

	/*!	Perform a set union of elements in this SelectionResults object with the elements of the supplied SelectionResults.
	 *	This will fail if the SelectionResults selections were performed at different levels (e.g. Entity vs Segment).
	 *	The resulting SelectionResults will be unsorted, even if the sources were sorted.
	 *	\param in_that The SelectionResults to union with this object.
	 *	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool						Union(SelectionResults const & in_that);

	/*!	Perform a set intersection of elements in this SelectionResults object with the elements of the supplied SelectionResults.
	 *	This will fail if the SelectionResults selections were performed at different levels (e.g. Entity vs Segment).
	 *	\param in_that The SelectionResults to intersect with this object.
	 *	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool						Intersect(SelectionResults const & in_that);

	/*!	Perform a symmetric difference (similar to XOR) of elements in this SelectionResults object with the elements of the supplied SelectionResults.
	 *	This will fail if the SelectionResults selections were performed at different levels (e.g. Entity vs Segment).
	 *	The resulting SelectionResults will be unsorted, even if the sources were sorted.
	 *	\param in_that The SelectionResults to take the symmetric difference of with this object.
	 *	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool						SymmetricDifference(SelectionResults const & in_that);

	/*!	Removes elements from this SelectionResults that also occur in the supplied SelectionResults.
	 *	This will fail if the SelectionResults selections were performed at different levels (e.g. Entity vs Segment).
	 *	\param in_that The SelectionResults to subtract from this object.
	 *	\return <span class='code'>true</span> if the operation succeeded, <span class='code'>false</span> otherwise. */
	bool						Difference(SelectionResults const & in_that);

	/*! Copy the selection results from another SelectionResults object.
	 *	\param in_that The SelectionResults source of the copy. */
	void						Copy(SelectionResults const & in_that);
};

/*! The SelectionControl class is a smart pointer that is tied to a database object. It is used to perform both window space selections
 * 	(by point, by area, by polygon, by line) and object space selections (by shell, by volume, by ray). */
class HPS_API SelectionControl : public Control
{
public:
	/*! This constructor creates a SelectionControl object which is tied to the specified window.
	 * 	\param in_window The window which this SelectionControl should operate on. */
	explicit SelectionControl(WindowKey const & in_window);

	/*! The copy constructor creates a SelectionControl object that shares the underlying smart-pointer of the source SelectionControl.
	 *	\param in_that The source SelectionControl to copy.  */
	SelectionControl(SelectionControl const & in_that);

	/*! The move constructor creates a SelectionControl by transferring the underlying impl of the rvalue reference to this SelectionControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a SelectionControl to take the impl from. */
	SelectionControl(SelectionControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this SelectionControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a SelectionControl to take the impl from.
	 * 	\return A reference to this SelectionControl. */
	SelectionControl & operator=(SelectionControl && in_that);

	~SelectionControl();

	static const HPS::Type staticType = HPS::Type::SelectionControl;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the SelectionControl source.
	 *	\param in_that The SelectionControl source of the assignment.
	 *	\return A reference to this SelectionControl. */
	SelectionControl &	operator=(SelectionControl const & in_that);

	/*! Perform a window space point selection starting at the specified segment using the specified selection options.
	 * 	\param in_location Point in window space at which to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByPoint(Point const & in_location, SelectionOptionsKit const & in_options, SelectionResults & out_results) const;

	/*! Perform a window space point selection starting at the specified segment using selection options set in segment tree.
	 * 	\param in_location Point in window space at which to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByPoint(Point const & in_location, SelectionResults & out_results) const;

	/*! Perform a window space area selection starting at the specified segment using the specified selection options.
	 * 	\param in_area Rectangle in window space at which to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByArea(Rectangle const & in_area, SelectionOptionsKit const & in_options, SelectionResults & out_results) const;

	/*! Perform a window space area selection starting at the specified segment using selection options set in the segment tree.
	 * 	\param in_area Rectangle in window space at which to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByArea(Rectangle const & in_area, SelectionResults & out_results) const;

	/*! Perform a window space polygon selection starting at the specified segment using the specified selection options.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_points Polygon in window space at which to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByPolygon(PointArray const & in_points, SelectionOptionsKit const & in_options, SelectionResults & out_results) const;

	/*! Perform a window space polygon selection starting at the specified segment using selection options set in the segment tree.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_points Polygon in window space at which to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByPolygon(PointArray const & in_points, SelectionResults & out_results) const;

	/*! Perform a window space polygon selection starting at the specified segment using the specified selection options.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_point_count Size of the following array.
	 * 	\param in_points Polygon in window space for the polygon at which to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByPolygon(size_t in_point_count, Point const in_points [], SelectionOptionsKit const & in_options, SelectionResults & out_results) const;

	/*! Perform a window space polygon selection starting at the specified segment using selection options set in the segment tree.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_point_count Size of the following array.
	 * 	\param in_points Polygon in window space at which to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByPolygon(size_t in_point_count, Point const in_points [], SelectionResults & out_results) const;

	/*! Perform a window space line selection starting at the specified segment using the specified selection options.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_points Line in window space at which to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByLine(PointArray const & in_points, SelectionOptionsKit const & in_options, SelectionResults & out_results) const;

	/*! Perform a window space line selection starting at the specified segment using the selection options set in the segment tree.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_points Line in window space at which to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByLine(PointArray const & in_points, SelectionResults & out_results) const;

	/*! Perform a window space line selection starting at the specified segment using the specified selection options.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_point_count Size of the following array.
	 * 	\param in_points Line in window space at which to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByLine(size_t in_point_count, Point const in_points [], SelectionOptionsKit const & in_options, SelectionResults & out_results) const;

	/*! Perform a window space line selection with the specified line and start segment using the selection options set in the segment tree.
	 *  Items outside of the frustum can be selected through this method when using Analytic selection.
	 * 	\param in_point_count Size of the following array.
	 * 	\param in_points Line in window space at which to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByLine(size_t in_point_count, Point const in_points [], SelectionResults & out_results) const;


	//Object space selections

	/*! Performs an object space selection by shell starting at the specified segment using the specified selection options. This method can only select faceted geometry.
	 * 	\param in_shell Shell to use to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByShell(ShellKit const & in_shell, SelectionOptionsKit const & in_options, SelectionResults & out_results);

	/*! Performs an object space selection by shell starting at the specified segment using the selection options set in the segment tree. This method can only select faceted geometry.
	 * 	\param in_shell Shell to use to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByShell(ShellKit const & in_shell, SelectionResults & out_results);

	/*! Performs an object space selection by shell starting at the specified segment using the specified selection options. This method can only select faceted geometry.
	 * 	\param in_shell Shell in the database to use to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByShell(ShellKey const & in_shell, SelectionOptionsKit const & in_options, SelectionResults & out_results);

	/*! Performs an object space selection by shell starting at the specified segment using the selection options set in the segment tree. This method can only select faceted geometry.
	 * 	\param in_shell Shell in the database to use to perform the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByShell(ShellKey const & in_shell, SelectionResults & out_results);


	/*! Performs an object space selection by volume starting at the specified segment using the specified selection options.
	 * 	If the volume is invalid, i.e., min &gt; max for any component, an exception will be thrown.
	 * 	\param in_volume Volume to use when performing the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByVolume(SimpleCuboid const & in_volume, SelectionOptionsKit const & in_options, SelectionResults & out_results);

	/*! Performs an object space selection by volume starting at the specified segment using the selection options set in the segment tree.
	 * 	If the volume is invalid, i.e., min &gt; max for any component, an exception will be thrown.
	 * 	\param in_volume Volume to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByVolume(SimpleCuboid const & in_volume, SelectionResults & out_results);


	/*! Performs an object space selection by ray starting at the specified segment using the specified selection options. This method can only select faceted geometry.
	 * 	\param in_start_point Start point of ray.
	 * 	\param in_direction Direction vector for ray.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByRay(Point const & in_start_point, Vector const & in_direction, SelectionOptionsKit const & in_options, SelectionResults & out_results);

	/*! Performs an object space selection by ray starting at the specified segment using the selection options set in the segment tree. This method can only select faceted geometry.
	 * 	\param in_start_point Start point of ray.
	 * 	\param in_direction Direction vector for ray.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	size_t		 		SelectByRay(Point const & in_start_point, Vector const & in_direction, SelectionResults & out_results);

private:
	//! Private default constructor to prevent instantiation without a window.
	SelectionControl();
};



/*! The HighlightOptionsKit class is a user space object.  It is used to hold settings needed when performing a highlight or unhighlight. HPS::HighlightOptionsKit::GetDefault() will return a highlight options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#highlight-options">this table</a>. */
class HPS_API HighlightOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty HighlightOptionsKit object. */
	HighlightOptionsKit();

	/*! This constructor creates a HighlightOptionsKit object with the specified style name set on it.
	 * 	\param in_style_name The style name to set on this HighlightOptionsKit. */
	HighlightOptionsKit(char const * in_style_name);

	/*! This constructor creates a HighlightOptionsKit object with the specified style and secondary style names set on it.
	 * 	\param in_style_name The style name to set on this HighlightOptionsKit.
	 * 	\param in_secondary_style_name The style name to set on this HighlightOptionsKit. */
	HighlightOptionsKit(char const * in_style_name, char const * in_secondary_style_name);

	/*! The copy constructor creates a new HighlightOptionsKit object that contains the same settings as the source HighlightOptionsKit.
	 * 	\param in_kit The source HighlightOptionsKit to copy. */
	HighlightOptionsKit(HighlightOptionsKit const & in_kit);

	/*! The move constructor creates a HighlightOptionsKit by transferring the underlying impl of the rvalue reference to this HighlightOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a HighlightOptionsKit to take the impl from. */
	HighlightOptionsKit(HighlightOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HighlightOptionsKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a HighlightOptionsKit to take the impl from.
	 *	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit & operator=(HighlightOptionsKit && in_that);

	virtual ~HighlightOptionsKit();

	static const HPS::Type staticType = HPS::Type::HighlightOptionsKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a HighlightOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return A HighlightOptionsKit with the default settings. */
	static HighlightOptionsKit	GetDefault();

	/*! Copies the source HighlightOptionsKit into this HighlightOptionsKit.
	 * 	\param in_kit The source HighlightOptionsKit to copy. */
	void						Set(HighlightOptionsKit const & in_kit);

	/*! Copies this HighlightOptionsKit into the given HighlightOptionsKit.
	 * 	\param out_kit The HighlightOptionsKit to populate with the contents of this HighlightOptionsKit. */
	void						Show(HighlightOptionsKit & out_kit) const;

	/*! Copies the source HighlightOptionsKit into this HighlightOptionsKit.
	 * 	\param in_kit The source HighlightOptionsKit to copy.
	 * 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		operator=(HighlightOptionsKit const & in_kit);

	/*! Indicates whether this HighlightOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this HighlightOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source HighlightOptionsKit is equivalent to this HighlightOptionsKit.
	 *	\param in_kit The source HighlightOptionsKit to compare to this HighlightOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(HighlightOptionsKit const & in_kit) const;

	/*!	Check if the source HighlightOptionsKit is equivalent to this HighlightOptionsKit.
	 *	\param in_kit The source HighlightOptionsKit to compare to this HighlightOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(HighlightOptionsKit const & in_kit) const;

	/*!	Check if the source HighlightOptionsKit is not equivalent to this HighlightOptionsKit.
	 *	\param in_kit The source HighlightOptionsKit to compare to this HighlightOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(HighlightOptionsKit const & in_kit) const;

	/*! Sets whether the highlight(s) to apply (or unapply) are passive.
	* 	\param in_pasive If set to true attribute locks set on the path being highlighted will be honored by the highlight. If set to false
		attribute locks set on the path being highlighted will be overriden by the highlight. If unspecified the default is false. If this HighlightOptionsKit
		is being passed to an Unhighlight call, only highlights whose passiveness match in_pasive will be removed.
	* 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		SetPassive(bool in_pasive);

	/*! Sets the name of the style to apply (or unapply) when highlighting (or unhighlighting).
	 * 	\param in_style_name UTF8-encoded style name. If this HighlightOptionsKit
		is being passed to an Unhighlight call, only highlights whose style name match in_style_name will be removed.
	 * 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		SetStyleName(char const * in_style_name);

	/*! Sets the name of the secondary style to apply (or unapply) when highlighting (or unhighlighting).
	 * 	\param in_style_name UTF8-encoded style name.
	 * 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		SetSecondaryStyleName(char const * in_style_name);

	/*!	Allows highlighting to take place in a segment without triggering a full-screen redraw.
	*	If any type of overlay is used, transparency in the highlighted object(s) will be ignored.
	*	\note If in_overlay is specified as Drawing::Overlay::None, Drawing::Overlay::InPlace will be used instead
	*	\param in_overlay The type of overlay, if any, to be used. If this HighlightOptionsKit
		is being passed to an Unhighlight call, only highlights whose overlay type match in_overlay will be removed.
	*	\return A reference to this object.
	*	\sa Overlay <a href="../../prog_guide/appendix_default_attribute_values.html#highlight-options">default value</a>
	*/
	HighlightOptionsKit &		SetOverlay(Drawing::Overlay in_overlay);

	/*!	Whether to inject a notification event after highlighting (or unhighlighting).
	 *	\param in_state Whether to inject a notification event after highlighting (or unhighlighting).
	 *	\return A reference to this HighlightOptionsKit.
	 *	\sa Notification <a href="../../prog_guide/appendix_default_attribute_values.html#highlight-options">default value</a>
	 */
	HighlightOptionsKit &		SetNotification(bool in_state);

	/*! Sets whether subentity highlighting is enabled.
	* 	\param in_enable Whether subentity highlighting is enabled.
	* 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		SetSubentityHighlighting(bool in_enable);

	/*! Removes any preference on whether this highlight is passive or active.
	* 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		UnsetPassive();

	/*! Removes the style to apply (or unapply) when highlighting (or unhighlighting).
	 * 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		UnsetStyleName();

	/*! Removes the secondary style to apply (or unapply) when highlighting (or unhighlighting).
	 * 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		UnsetSecondaryStyleName();

	/*!	Removes an overlay setting.
	*	\return A reference to this object. */
	HighlightOptionsKit &		UnsetOverlay();

	/*!	Removes the notification setting.
	*	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		UnsetNotification();

	/*! Removes whether subentity highlighting is enabled.
	* 	\return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		UnsetSubentityHighlighting();

	/*! Removes all settings from this HighlightOptionsKit.
	 * \return A reference to this HighlightOptionsKit. */
	HighlightOptionsKit &		UnsetEverything();

	/*! Shows whether the highlight(s) to apply (or unapply) is passive.
	* 	\param out_pasive Indicates whether the highlight(s) to apply (or unapply) is passive.
	* 	\return A reference to this HighlightOptionsKit. */
	bool						ShowPassive(bool & out_pasive) const;

	/*! Shows the name of the style to apply (or unapply) when highlighting (or unhighlighting).
	 * 	\param out_style_name UTF8-encoded style name.
	 *	\return <span class='code'>true</span> if a style was specified, <span class='code'>false</span> otherwise. */
	bool						ShowStyleName(UTF8 & out_style_name) const;

	/*! Shows the name of the secondary style to apply (or unapply) when highlighting (or unhighlighting).
	 * 	\param out_style_name UTF8-encoded style name.
	 *	\return <span class='code'>true</span> if a style was specified, <span class='code'>false</span> otherwise. */
	bool						ShowSecondaryStyleName(UTF8 & out_style_name) const;

	/*! Shows the overlay setting.
	 *	\param out_overlay The type of overlay, if any, used.
	 *	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOverlay(Drawing::Overlay & out_overlay) const;

	/*! Shows the notification setting.
	 *	\param out_state Whether to inject a notification event after highlighting (or unhighlighting).
	 *	\return <span class='code'>true</span> if a notification setting was specified, <span class='code'>false</span> otherwise. */
	bool						ShowNotification(bool & out_state) const;

	/*! Shows whether subentity highlighting is enabled.
	* 	\param out_enable Whether subentity highlighting is enabled.
	*	\return <span class='code'>true</span> if a flag was specified, <span class='code'>false</span> otherwise. */
	bool						ShowSubentityHighlighting(bool & out_enable) const;
};

/*! The HighlightSearchOptionsKit class is a user space object.  It is used to filter highlight queries via HighlightControl::ShowHighlightState, HighlightControl::ShowHighlightStates,
 *	and WindowKey::FindHighlights. */
class HPS_API HighlightSearchOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty HighlightSearchOptionsKit object. */
	HighlightSearchOptionsKit();

	/*! The copy constructor creates a new HighlightSearchOptionsKit object that contains the same settings as the source HighlightSearchOptionsKit.
	* 	\param in_kit The source HighlightSearchOptionsKit to copy. */
	HighlightSearchOptionsKit(HighlightSearchOptionsKit const & in_kit);

	/*! The move constructor creates a HighlightSearchOptionsKit by transferring the underlying impl of the rvalue reference to this HighlightSearchOptionsKit
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to a HighlightSearchOptionsKit to take the impl from. */
	HighlightSearchOptionsKit(HighlightSearchOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HighlightSearchOptionsKit thereby avoiding a copy.
	*	\param in_that An rvalue reference to a HighlightSearchOptionsKit to take the impl from.
	*	\return A reference to this HighlightSearchOptionsKit. */
	HighlightSearchOptionsKit & operator=(HighlightSearchOptionsKit && in_that);

	virtual ~HighlightSearchOptionsKit();

	static const HPS::Type staticType = HPS::Type::HighlightSearchOptionsKit;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Creates a HighlightSearchOptionsKit which contains the default settings.  The returned object will not necessarily have values
	* 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	* 	\return A HighlightSearchOptionsKit with the default settings. */
	static HighlightSearchOptionsKit	GetDefault();

	/*! Copies the source HighlightSearchOptionsKit into this HighlightSearchOptionsKit.
	* 	\param in_kit The source HighlightSearchOptionsKit to copy. */
	void						Set(HighlightSearchOptionsKit const & in_kit);

	/*! Copies this HighlightSearchOptionsKit into the given HighlightSearchOptionsKit.
	* 	\param out_kit The HighlightSearchOptionsKit to populate with the contents of this HighlightSearchOptionsKit. */
	void						Show(HighlightSearchOptionsKit & out_kit) const;

	/*! Copies the source HighlightSearchOptionsKit into this HighlightSearchOptionsKit.
	* 	\param in_kit The source HighlightSearchOptionsKit to copy.
	* 	\return A reference to this HighlightSearchOptionsKit. */
	HighlightSearchOptionsKit &	operator=(HighlightSearchOptionsKit const & in_kit);

	/*! Indicates whether this HighlightSearchOptionsKit has any values set on it.
	* 	\return <span class='code'>true</span> if no values are set on this HighlightSearchOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source HighlightSearchOptionsKit is equivalent to this HighlightSearchOptionsKit.
	*	\param in_kit The source HighlightSearchOptionsKit to compare to this HighlightSearchOptionsKit.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(HighlightSearchOptionsKit const & in_kit) const;

	/*!	Check if the source HighlightSearchOptionsKit is equivalent to this HighlightSearchOptionsKit.
	*	\param in_kit The source HighlightSearchOptionsKit to compare to this HighlightSearchOptionsKit.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(HighlightSearchOptionsKit const & in_kit) const;

	/*!	Check if the source HighlightSearchOptionsKit is not equivalent to this HighlightSearchOptionsKit.
	*	\param in_kit The source HighlightSearchOptionsKit to compare to this HighlightSearchOptionsKit.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(HighlightSearchOptionsKit const & in_kit) const;


	/*!	Sets the name of the style to look for when querying highlights.  Only highlights using this style will be returned by highlight queries.
	* 	\param in_style_name UTF8-encoded style name.
	* 	\return A reference to this HighlightSearchOptionsKit. */
	HighlightSearchOptionsKit &	SetStyleName(char const * in_style_name);

	/*!	Sets the names of the styles to look for when querying highlights.  Only highlights using any style in the array will be returned by highlight queries.
	* 	\param in_style_names UTF8-encoded style names.
	* 	\return A reference to this HighlightSearchOptionsKit. */
	HighlightSearchOptionsKit &	SetStyleNames(UTF8Array const & in_style_names);

	/*!	Sets the overlay type to look for when querying highlights.  Only highlights using this overlay type will be returned by highlight queries.
	*	\param in_overlay Overlay type.
	*	\return A reference to this object. */
	HighlightSearchOptionsKit &	SetOverlay(Drawing::Overlay in_overlay);

	/*!	Sets the overlay types to look for when querying highlights.  Only highlights using any overlay types in the array will be returned by highlight queries.
	*	\param in_overlays Overlay types.
	*	\return A reference to this object. */
	HighlightSearchOptionsKit &	SetOverlays(DrawingOverlayArray const & in_overlays);


	/*! Removes all style filters.
	* 	\return A reference to this HighlightSearchOptionsKit. */
	HighlightSearchOptionsKit &	UnsetStyleNames();

	/*!	Removes all overlay filters.
	*	\return A reference to this object. */
	HighlightSearchOptionsKit &	UnsetOverlays();

	/*! Removes all settings from this HighlightSearchOptionsKit.
	* \return A reference to this HighlightSearchOptionsKit. */
	HighlightSearchOptionsKit &	UnsetEverything();


	/*! Shows the names of the styles to look for when querying highlights.
	* 	\param out_style_names UTF8-encoded style names.
	*	\return <span class='code'>true</span> if any style was specified, <span class='code'>false</span> otherwise. */
	bool						ShowStyleNames(UTF8Array & out_style_names) const;

	/*! Shows the overlay types to look for when querying highlights.
	*	\param out_overlays Overlay types.
	*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
	bool						ShowOverlays(DrawingOverlayArray & out_overlays) const;
};

/*! The HighlightState class is a user space object.  It is used to return highlight information from HighlightControl::ShowHighlightState or HighlightControl::ShowHighlightStates. */
class HPS_API HighlightState : public Object
{
public:
	/*! The default constructor creates an empty HighlightState object. */
	HighlightState();

	/*! The copy constructor creates a new HighlightState object that contains the same settings as the source HighlightState.
	* 	\param in_that The source HighlightState to copy. */
	HighlightState(HighlightState const & in_that);

	/*! The move constructor creates a HighlightState by transferring the underlying impl of the rvalue reference to this HighlightState
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to a HighlightState to take the impl from. */
	HighlightState(HighlightState && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HighlightState thereby avoiding a copy.
	* 	\param in_that An rvalue reference to a HighlightState to take the impl from.
	* 	\return A reference to this HighlightState. */
	HighlightState & operator=(HighlightState && in_that);

	~HighlightState();

	static const HPS::Type staticType = HPS::Type::HighlightState;
	HPS::Type					ObjectType() const { return staticType; };

	/*! Copies the source HighlightState into this HighlightState.
	* 	\param in_that The source HighlightState to copy. */
	void						Assign(HighlightState const & in_that);

	/*! Copies the source HighlightState into this HighlightState.
	* 	\param in_that The source HighlightState to copy.
	* 	\return A reference to this HighlightState. */
	HighlightState &			operator=(HighlightState const & in_that);

	/*!	Check if the source HighlightState is equivalent to this HighlightState.
	*	\param in_kit The source HighlightState to compare to this HighlightState.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(HighlightState const & in_that) const;

	/*!	Check if the source HighlightState is equivalent to this HighlightState.
	*	\param in_kit The source HighlightState to compare to this HighlightState.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator== (HighlightState const & in_that) const;

	/*!	Check if the source HighlightState is not equivalent to this HighlightState.
	*	\param in_kit The source HighlightState to compare to this HighlightState.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!= (HighlightState const & in_that) const;

	/*!	Sets the flags for this HighlightState.  This facilitates the return of highlight state data to the user,
	*	and is not meant to be used outside of that use case. */
	void						Set(bool in_directly_highlighted, bool in_subentity_highlighted, bool in_inherits_highlight, bool in_on_highlight_path);

	/*!	Indicates if a highlight exists on the queried key or key path.
	*	\return Whether a highlight exists on the queried key or key path. */
	bool						GetDirectlyHighlighted() const;

	/*!	Indicates if a sub-entity highlight exists on the queried key or key path.  This value is only meaningful if the queried key or leaf of the
	*	key path is a shell or mesh since these are the only geometries for which it is possible to have subentity highlights.
	*	\return Whether a subentity highlight exists on the queried key or key path. */
	bool						GetSubentityHighlighted() const;

	/*!	Indicates if a highlight exists above the queried key or key path.
	*	\return Whether a highlight exists above the queried key or key path. */
	bool						GetInheritsHighlight() const;

	/*!	Indicates if a highlight exists below the queried key or key path.
	*	\return Whether a highlight exists below the queried key or key path. */
	bool						GetOnHighlightPath() const;
};

/*! An iterator used for traversing results from a search on an associated HighlightSearchResults object. */
class HPS_API HighlightSearchResultsIterator : public Object
{
public:

	/*! The default constructor creates a new HighlightSearchResultsIterator object that is not associated with any HighlightSearchResults object. */
	HighlightSearchResultsIterator();

	/*! The copy constructor initializes a new HighlightSearchResultsIterator object that is associated with the same HighlightSearchResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	\param in_search_results_iterator The source of the copy.  */
	HighlightSearchResultsIterator(HighlightSearchResultsIterator const & in_search_results_iterator);

	/*! The move constructor creates a HighlightSearchResultsIterator by transferring the underlying impl of the rvalue reference to this HighlightSearchResultsIterator
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to HighlightSearchResultsIterator to take the impl from.*/
	HighlightSearchResultsIterator(HighlightSearchResultsIterator && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HighlightSearchResultsIterator thereby avoiding a copy.
	* \param in_that An rvalue reference to an HighlightSearchResultsIterator to take the impl from.
	* \return A reference to this HighlightSearchResultsIterator. */
	HighlightSearchResultsIterator & operator=(HighlightSearchResultsIterator && in_that);

	~HighlightSearchResultsIterator();

	static const HPS::Type staticType = HPS::Type::HighlightSearchResultsIterator;
	HPS::Type							ObjectType() const { return staticType; }

	/*! Copies a HighlightSearchResultsIterator object, associating this object with the same HighlightSearchResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	\param in_search_results_iterator The source of the copy.
	\return a reference to this object.  */
	HighlightSearchResultsIterator &	operator=(HighlightSearchResultsIterator const & in_search_results_iterator);

	/*! Copies a HighlightSearchResultsIterator object, associating this object with the same HighlightSearchResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	This method is functionally equivalent to the overloaded assignment operator except for the return value.
	\param in_search_results_iterator The source of the copy.  */
	void								Set(HighlightSearchResultsIterator const & in_search_results_iterator);

	/*! Advances the iterator to the next search result item */
	void								Next();

	/*! Advances the iterator to the next search result item
	\return A reference to this object.  */
	HighlightSearchResultsIterator &	operator++();

	/*! Advances the iterator to the next search result item
	\return A reference to this object.  */
	HighlightSearchResultsIterator		operator++(int in_val);

	/*! Comparison operator between iterators to compare equality
	\param in_search_results_iterator The iterator to compare to */
	bool								operator==(HighlightSearchResultsIterator const & in_search_results_iterator);

	/*! Comparison operator between iterators to compare inequality
	\param in_search_results_iterator The iterator to compare to */
	bool								operator!=(HighlightSearchResultsIterator const & in_search_results_iterator);

	/*! Queries the validity of this iterator location.  Invalid locations would include uninitialized
	iterators and iterators that had walked past the last element.
	\return <span class='code'>true</span> if this iterator is pointing to a valid item, false otherwise. */
	bool								IsValid() const;

	/*! Resets iterator to the beginning of the associated search results. */
	void								Reset();

	/*! Returns the item that this iterator is currently pointing at.  Throws an InvalidObjectException if the iterator is not valid.
	This method is functionally equivalent to the overloaded operator*.
	\return The current item.  */
	KeyPath								GetItem() const;

	/*! Returns the item that this iterator is currently pointing at.  Throws an InvalidObjectException if the iterator is not valid.
	\return The current item.  */
	KeyPath								operator*() const;

	/*! Returns the highlight style for the key path that this iterator is currently pointing at.
	Throws an InvalidObjectException if the iterator is not valid.
	\return The highlight style. */
	UTF8								GetStyleName() const;

	/*! Returns the overlay type for the key path that this iterator is currently pointing at.
	Throws an InvalidObjectException if the iterator is not valid.
	\return The overlay type. */
	Drawing::Overlay					GetOverlay() const;

	/*! Indicates whether the highlight associated with this iterator is passive.
	Throws an InvalidObjectException if the iterator is not valid.
	\return Whether the highlight is passive. */
	bool								GetPassive() const;
};

/*! The HighlightSearchResults class is a smart-pointer to a database object.  It contains the results of a FindHighlights operation. */
class HPS_API HighlightSearchResults : public Object
{
public:
	//!  The default constructor creates an empty HighlightSearchResults object, not associated with any search
	HighlightSearchResults();

	/*!  The copy constructor creates a new HighlightSearchResults object that shares the underlying smart-pointer of the source.
	\param in_search_results The source of the copy.  */
	HighlightSearchResults(HighlightSearchResults const & in_search_results);

	/*! The move constructor creates a HighlightSearchResults by transferring the underlying impl of the rvalue reference to this HighlightSearchResults
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to HighlightSearchResults to take the impl from.*/
	HighlightSearchResults(HighlightSearchResults && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HighlightSearchResults thereby avoiding a copy.
	* \param in_that An rvalue reference to an HighlightSearchResults to take the impl from.
	* \return A reference to this HighlightSearchResults. */
	HighlightSearchResults & operator=(HighlightSearchResults && in_that);

	/*! Resets this object to its initial, uninitialized state. */
	virtual void					Reset();

	//!  The destructor decrements the number of users of the search results.  If there are no remaining users, the results are released.
	~HighlightSearchResults();

	static const HPS::Type staticType = HPS::Type::HighlightSearchResults;
	HPS::Type						ObjectType() const { return staticType; }

	/*! Share the underlying smart-pointer if the assignment source.  This method is functionally
	equivalent to the overloaded assignment operator except for the return value.
	\param in_search_results The source of the assignment.  */
	void							Assign(HighlightSearchResults const & in_search_results);

	/*! Share the underlying smart-pointer of the HighlightSearchResults source.
	*	\param in_that The HighlightSearchResults source of the assignment.
	*	\return A reference to this HighlightSearchResults. */
	HighlightSearchResults &		operator=(HighlightSearchResults const & in_search_results);

	/*! Gets the number of items that were found in the associated search.
	\return The number of unique items found.  */
	size_t							GetCount() const;

	/*! Returns a HighlightSearchResultsIterator used to iterate through the found search results.
	\return An iterator pointing to the beginning of the search results list.  */
	HighlightSearchResultsIterator	GetIterator() const;
};



/*! An iterator used for traversing results from a optimize on an associated OptimizeMappingResults object. */
class HPS_API OptimizeMappingResultsIterator : public Object
{
public:

	/*! The default constructor creates a new OptimizeMappingResultsIterator object that is not associated with any OptimizeMappingResults object. */
	OptimizeMappingResultsIterator();

	/*! The copy constructor initializes a new OptimizeMappingResultsIterator object that is associated with the same OptimizeMappingResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	\param in_mapping_results_iterator The source of the copy.  */
	OptimizeMappingResultsIterator(OptimizeMappingResultsIterator const & in_mapping_results_iterator);

	/*! The move constructor creates a OptimizeMappingResultsIterator by transferring the underlying impl of the rvalue reference to this OptimizeMappingResultsIterator
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to OptimizeMappingResultsIterator to take the impl from.*/
	OptimizeMappingResultsIterator(OptimizeMappingResultsIterator && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this OptimizeMappingResultsIterator thereby avoiding a copy.
	* \param in_that An rvalue reference to an OptimizeMappingResultsIterator to take the impl from.
	* \return A reference to this OptimizeMappingResultsIterator. */
	OptimizeMappingResultsIterator & operator=(OptimizeMappingResultsIterator && in_that);

	~OptimizeMappingResultsIterator();

	static const HPS::Type staticType = HPS::Type::OptimizeMappingResultsIterator;
	HPS::Type							ObjectType() const { return staticType; }

	/*! Copies a OptimizeMappingResultsIterator object, associating this object with the same OptimizeMappingResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	\param in_mapping_results_iterator The source of the copy.
	\return a reference to this object.  */
	OptimizeMappingResultsIterator &	operator=(OptimizeMappingResultsIterator const & in_mapping_results_iterator);

	/*! Copies a OptimizeMappingResultsIterator object, associating this object with the same OptimizeMappingResults
	object as the source and at the same location in the results.  Subsequent changes to either iterator will not affect the other.
	This method is functionally equivalent to the overloaded assignment operator except for the return value.
	\param in_mapping_results_iterator The source of the copy.  */
	void								Set(OptimizeMappingResultsIterator const & in_mapping_results_iterator);

	/*! Advances the iterator to the next search result item */
	void								Next();

	/*! Advances the iterator to the next search result item
	\return A reference to this object.  */
	OptimizeMappingResultsIterator &	operator++();

	/*! Advances the iterator to the next search result item
	\return A reference to this object.  */
	OptimizeMappingResultsIterator		operator++(int in_val);

	/*! Comparison operator between iterators to compare equality
	\param in_mapping_results_iterator The iterator to compare to */
	bool								operator==(OptimizeMappingResultsIterator const & in_mapping_results_iterator);

	/*! Comparison operator between iterators to compare inequality
	\param in_mapping_results_iterator The iterator to compare to */
	bool								operator!=(OptimizeMappingResultsIterator const & in_mapping_results_iterator);

	/*! Queries the validity of this iterator location.  Invalid locations would include uninitialized
	iterators and iterators that had walked past the last element.
	\return <span class='code'>true</span> if this iterator is pointing to a valid item, false otherwise. */
	bool								IsValid() const;

	/*! Resets iterator to the beginning of the associated search results. */
	void								Reset();

	/*! Returns the item that this iterator is currently pointing at.  Throws an InvalidObjectException if the iterator is not valid.
	This method is functionally equivalent to the overloaded operator*.
	\return The current item.  */
	Key									GetItem() const;

	/*! Returns the item that this iterator is currently pointing at.  Throws an InvalidObjectException if the iterator is not valid.
	\return The current item.  */
	Key									operator*() const;

	/*! Returns the item that this iterator is currently pointing at.  Throws an InvalidObjectException if the iterator is not valid.
	*	\param out_shell_key The post merge shell that this item is in.
	*	\param out_vertex_offset The offset that the vertices from the item start in the post merge shell.
	*	\param out_face_offset The offset that the faces from the item start in the post merge shell.
	*	\param out_edge_offset The offset that the edges from the item start in the post merge shell.
	*	\return True if the out params are valid */
	bool								GetMergedShellInfo(ShellKey & out_shell_key, size_t & out_vertex_offset, size_t  & out_face_offset, size_t  & out_edge_offset) const;

};

/*! The OptimizeMappingResults class is a smart-pointer to a database object.  It contains the results of an OptimizeWithMapping operation. */
class HPS_API OptimizeMappingResults : public Object
{
public:
	//!  The default constructor creates an empty OptimizeMappingResults object, not associated with any optimize.
	OptimizeMappingResults();

	/*!  The copy constructor creates a new OptimizeMappingResults object that shares the underlying smart-pointer of the source.
	\param in_mappping The source of the copy.  */
	OptimizeMappingResults(OptimizeMappingResults const & in_mappping);

	/*! The move constructor creates a OptimizeMappingResults by transferring the underlying impl of the rvalue reference to this OptimizeMappingResults
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to OptimizeMappingResults to take the impl from.*/
	OptimizeMappingResults(OptimizeMappingResults && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this OptimizeMappingResults thereby avoiding a copy.
	* \param in_that An rvalue reference to an OptimizeMappingResults to take the impl from.
	* \return A reference to this OptimizeMappingResults. */
	OptimizeMappingResults & operator=(OptimizeMappingResults && in_that);

	/*! Resets this object to its initial, uninitialized state. */
	virtual void					Reset();

	//!  The destructor decrements the number of users of the results.  If there are no remaining users, the results are released.
	~OptimizeMappingResults();

	static const HPS::Type staticType = HPS::Type::OptimizeMappingResults;
	HPS::Type						ObjectType() const { return staticType; }

	/*! Share the underlying smart-pointer if the assignment source.  This method is functionally
	*	equivalent to the overloaded assignment operator except for the return value.
	*	\param in_search_results The source of the assignment.  */
	void							Assign(OptimizeMappingResults const & in_mappping);

	/*! Share the underlying smart-pointer of the OptimizeMappingResults source.
	*	\param in_mappping The OptimizeMappingResults source of the assignment.
	*	\return A reference to this HighlightSearchResults. */
	OptimizeMappingResults &		operator=(OptimizeMappingResults const & in_mappping);

	/*! Gets the number of items that were recorded in the associated optimize.
	*	\return The number of unique items.  */
	size_t							GetCount() const;

	/*! Flush original shells that were merged.
	*	GetCount will return 0 after this operations so information must be read before flushing.
	*	\return True if any items were flushed.  */
	bool							FlushMerged();

	/*! Returns a OptimizeMappingResultsIterator used to iterate through the optimize results.
	*	\return An iterator pointing to the beginning of the optimize results list.  */
	OptimizeMappingResultsIterator	GetIterator() const;
};


/*! The HPS::HighlightControl class is a smart pointer that is tied to a database object.  It is used to control highlight and unhighlight
 * 	operations on selection results, search results, key paths and keys. <a href="../../prog_guide/appendix_default_attribute_values.html#highlight-options">This table</a> lists default *  values for the various segment attributes accessible from HPS::HighlightControl. */
class HPS_API HighlightControl : public Control
{
public:
	/*! This constructor creates a HighlightControl object which is tied to the specified window.
	 * 	\param in_window The window which this HighlightControl should operate on. */
	explicit HighlightControl(WindowKey const & in_window);

	/*! The copy constructor creates a HighlightControl object that shares the underlying smart-pointer of the source HighlightControl.
	 *	\param in_that The source HighlightControl to copy.  */
	HighlightControl(HighlightControl const & in_that);

	/*! The move constructor creates a HighlightControl by transferring the underlying impl of the rvalue reference to this HighlightControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a HighlightControl to take the impl from. */
	HighlightControl(HighlightControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this HighlightControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a HighlightControl to take the impl from.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl & operator=(HighlightControl && in_that);

	~HighlightControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::HighlightControl;
	HPS::Type			ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the HighlightControl source.
	 *	\param in_that The HighlightControl source of the assignment.
	 *	\return A reference to this HighlightControl. */
	HighlightControl &	operator=(HighlightControl const & in_that);

	/*! Highlight the specified selection results using the specified highlight options.
	 * 	\param in_items The selection results to highlight.  If there are invalid selection items in the selection results, an exception will be thrown.
	 * 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(SelectionResults const & in_items, HighlightOptionsKit const & in_options, bool in_remove_existing = true);

	/*! Highlight the specified selection item using the specified highlight options.
	 * 	\param in_item The selection item to highlight.  If the selection item is invalid, an exception will be thrown.
	 * 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(SelectionItem const & in_item, HighlightOptionsKit const & in_options, bool in_remove_existing = true);

	/*! Highlight the specified search results using the specified highlight options.
	 * 	\param in_items The search results to highlight.  If there are invalid keys in the selection results, an exception will be thrown.
	 * 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(SearchResults const & in_items, HighlightOptionsKit const & in_options, bool in_remove_existing = true);

	/*! Highlight the specified key path using the specified highlight options.
	 * 	\param in_item The key path to highlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	 * 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(KeyPath const & in_item, HighlightOptionsKit const & in_options, bool in_remove_existing = true);

	/*! Highlight the specified key using the specified highlight options.
	 * 	\param in_item The key to highlight.  If the key is invalid, an exception will be thrown.
	 * 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(Key const & in_item, HighlightOptionsKit const & in_options, bool in_remove_existing = true);

	/*! Highlight specified subentities for the specified key path using the specified highlight options.
	* 	\param in_item The key path to highlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	* 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	*	\param in_vertices An array of vertex indices, specfying vertices to highlight.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to highlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces An array of faces indices specifying faces to highlight.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(KeyPath const & in_item, HighlightOptionsKit const & in_options, SizeTArray const & in_vertices, SizeTArray const &  in_edges1, SizeTArray const & in_edges2, SizeTArray const & in_faces, bool in_remove_existing = true);

	/*! Highlight the specified key using the specified highlight options.
	* 	\param in_item The key to highlight.  If the key is invalid, an exception will be thrown.
	* 	\param in_options The options to use when performing the highlight.  If there is no highlight style specified, an exception will be thrown.
	*	\param in_vertices An array of vertex indices, specifying vertices to highlight.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to highlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces An array of faces indices specifying faces to highlight.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(Key const & in_item, HighlightOptionsKit const & in_options, SizeTArray const & in_vertices, SizeTArray const &  in_edges1, SizeTArray const & in_edges2, SizeTArray const & in_faces, bool in_remove_existing = true);

	/*! Highlight subentities from the specified item using the specified highlight options.
	* 	\param in_item The key path to highlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	* 	\param in_options The options to use when performing the highlight.
	*	\param in_vertices_count The number of elements to read from the in_vertices array.
	*	\param in_vertices An array of vertex indices, specifying vertices to highlight.
	*	\param in_edges_count The number of elements to read from the in_edges1/in_edges2 arrays.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to highlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces_count The number of elements to read from the in_faces array.
	*	\param in_faces An array of faces indices specifying faces to highlight.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(
		KeyPath const & in_item,
		HighlightOptionsKit const & in_options,
		size_t in_vertices_count,
		size_t const in_vertices[],
		size_t in_edges_count,
		size_t const in_edges1[],
		size_t const in_edges2[],
		size_t in_faces_count,
		size_t const in_faces[],
		bool in_remove_existing = true);

	/*! Highlight subentities from the specified item using the specified highlight options.
	* 	\param in_item The key to highlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	* 	\param in_options The options to use when performing the highlight.
	*	\param in_vertices_count The number of elements to read from the in_vertices array.
	*	\param in_vertices An array of vertex indices, specifying vertices to highlight.
	*	\param in_edges_count The number of elements to read from the in_edges1/in_edges2 arrays.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to highlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces_count The number of elements to read from the in_faces array.
	*	\param in_faces An array of faces indices specifying faces to highlight.
	 *  \param in_remove_existing Indicates whether this highlight should flush existing highlights at the specified path for the desired overlay type.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Highlight(
		Key const & in_item,
		HighlightOptionsKit const & in_options,
		size_t in_vertices_count,
		size_t const in_vertices[],
		size_t in_edges_count,
		size_t const in_edges1[],
		size_t const in_edges2[],
		size_t in_faces_count,
		size_t const in_faces[],
		bool in_remove_existing = true);

	/*! Unhighlight the specified selection results by removing the specified highlight options.
	 * 	\param in_items The selection results to unhighlight.  If there are invalid selection items in the selection results, an exception will be thrown.
	 * 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(SelectionResults const & in_items, HighlightOptionsKit const & in_options = HighlightOptionsKit());

	/*! Unhighlight the specified selection item by removing the specified highlight options.
	 * 	\param in_item The selection item to unhighlight.  If the selection item is invalid, an exception will be thrown.
	 * 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(SelectionItem const & in_item, HighlightOptionsKit const & in_options = HighlightOptionsKit());

	/*! Unhighlight the specified search results by removing the specified highlight options.
	 * 	\param in_items The search results to unhighlight.  If there are invalid keys in the search results, an exception will be thrown.
	 * 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(SearchResults const & in_items, HighlightOptionsKit const & in_options = HighlightOptionsKit());

	/*! Unhighlight the specified key path by removing the specified highlight options.
	 * 	\param in_item The key path to unhighlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	 * 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(KeyPath const & in_item, HighlightOptionsKit const & in_options = HighlightOptionsKit());

	/*! Unhighlight the specified key by removing the specified highlight options.
	 * 	\param in_item The key to unhighlight.  If the key is invalid, an exception will be thrown..
	 * 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(Key const & in_item, HighlightOptionsKit const & in_options = HighlightOptionsKit());

	/*! Unhighlight subentities from the specified key path by removing the specified highlight options.
	* 	\param in_item The key path to unhighlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	* 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	*	\param in_vertices An array of vertex indices, specifying vertices to unhighlight.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to unhighlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces An array of faces indices specifying faces to unhighlight.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(KeyPath const & in_item, HighlightOptionsKit const & in_options, SizeTArray const & in_vertices, SizeTArray const &  in_edges1, SizeTArray const & in_edges2, SizeTArray const & in_faces);

	/*! Unhighlight subentities from the specified item by removing the specified highlight options.
	* 	\param in_item The key to unhighlight.  If the key is invalid, an exception will be thrown..
	* 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	*	\param in_vertices An array of vertex indices, specifying vertices to unhighlight.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to unhighlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces An array of faces indices specifying faces to unhighlight.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(Key const & in_item, HighlightOptionsKit const & in_options, SizeTArray const & in_vertices, SizeTArray const &  in_edges1, SizeTArray const & in_edges2, SizeTArray const & in_faces);

	/*! Unhighlight subentities from the specified item by removing the specified highlight options.
	* 	\param in_item The key path to unhighlight.  If there are no keys or invalid keys in the key path, an exception will be thrown.
	* 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	*	\param in_vertices_count The number of elements to read from the in_vertices array.
	*	\param in_vertices An array of vertex indices, specifying vertices to unhighlight.
	*	\param in_edges_count The number of elements to read from the in_edges1/in_edges2 arrays.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to unhighlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces_count The number of elements to read from the in_faces array.
	*	\param in_faces An array of faces indices specifying faces to unhighlight.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(
		KeyPath const & in_item,
		HighlightOptionsKit const & in_options,
		size_t in_vertices_count,
		size_t const in_vertices[],
		size_t in_edges_count,
		size_t const in_edges1[],
		size_t const in_edges2[],
		size_t in_faces_count,
		size_t const in_faces[]);

	/*! Unhighlight subentities from the specified item by removing the specified highlight options.
	* 	\param in_item The key to unhighlight.  If the key is invalid, an exception will be thrown..
	* 	\param in_options The highlight options to be removed.  Defaults to an empty HighlightOptionsKit.
	*	\param in_vertices_count The number of elements to read from the in_vertices array.
	*	\param in_vertices An array of vertex indices, specifying vertices to unhighlight.
	*	\param in_edges_count The number of elements to read from the in_edges1/in_edges2 arrays.
	*	\param in_edges1 An array of vertex indices, which when paired with the corresponding entries in the in_edges2 array, define a list of edges to unhighlight.
	*	\param in_edges2 An array of vertex indices to be paired with entries in in_edges1 array to define the edge list.
	*	\param in_faces_count The number of elements to read from the in_faces array.
	*	\param in_faces An array of faces indices specifying faces to unhighlight.
	* 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(
		Key const & in_item,
		HighlightOptionsKit const & in_options,
		size_t in_vertices_count,
		size_t const in_vertices[],
		size_t in_edges_count,
		size_t const in_edges1[],
		size_t const in_edges2[],
		size_t in_faces_count,
		size_t const in_faces[]);

	/*! Unhighlight geometry which was highlighted with the specified HighlightOptionsKit.
	 * 	\param in_options The highlight options to be removed.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	Unhighlight(HighlightOptionsKit const & in_options);

	/*! Unhighlight everything in the window associated with this HighlightControl.
	 * 	\return A reference to this HighlightControl. */
	HighlightControl &	UnhighlightEverything();

	/*! Show the highlight information for the given key and search options.
	 *	\param in_key Key to get highlight information for.
	 *	\param in_search_options Search options constraining what type of highlights to look for.  If this is empty, all highlights will be considered.
	 *	\param out_state Highlight information for the queried key. */
	void ShowHighlightState(
		Key const & in_key,
		HighlightSearchOptionsKit const & in_search_options,
		HighlightState & out_state) const;

	/*! Show the highlight information for the given key path and search options.
	 *	\param in_key_path Key path to get highlight information for.
	 *	\param in_search_options Search options constraining what type of highlights to look for.  If this is empty, all highlights will be considered.
	 *	\param out_state Highlight information for the queried key path. */
	void ShowHighlightState(
		KeyPath const & in_key_path,
		HighlightSearchOptionsKit const & in_search_options,
		HighlightState & out_state) const;

	/*! Show the highlight information for the given keys and search options.
	 *	\param in_keys Keys to get highlight information for.
	 *	\param in_search_options Search options constraining what type of highlights to look for.  If this is empty, all highlights will be considered.
	 *	\param out_states Highlight information for the queried keys. */
	void ShowHighlightStates(
		KeyArray const & in_keys,
		HighlightSearchOptionsKit const & in_search_options,
		HighlightStateArray & out_states) const;

	/*! Show the highlight information for the given key paths and search options.
	 *	\param in_key_paths Key paths to get highlight information for.
	 *	\param in_search_options Search options constraining what type of highlights to look for.  If this is empty, all highlights will be considered.
	 *	\param out_states Highlight information for the queried key paths. */
	void ShowHighlightStates(
		KeyPathArray const & in_key_paths,
		HighlightSearchOptionsKit const & in_search_options,
		HighlightStateArray & out_states) const;

private:
	//! Private default constructor to prevent instantiation without a window.
	HighlightControl();
};

/*! The HPS::UpdateOptionsKit class is a user space object.  It contains options related to selection. Calling HPS::UpdateOptionsKit::GetDefault() will return a kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#update-options">this table</a>. */
class HPS_API UpdateOptionsKit : public Kit
{
public:
	/*! The default constructor creates an empty UpdateOptionsKit object. */
	UpdateOptionsKit();

	/*! The copy constructor creates a new UpdateOptionsKit object that contains the same settings as the source UpdateOptionsKit.
	 * 	\param in_kit The source UpdateOptionsKit to copy. */
	UpdateOptionsKit(UpdateOptionsKit const & in_kit);

	/*! The move constructor creates a UpdateOptionsKit by transferring the underlying impl of the rvalue reference to this UpdateOptionsKit
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a UpdateOptionsKit to take the impl from. */
	UpdateOptionsKit(UpdateOptionsKit && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this UpdateOptionsKit thereby avoiding a copy.
	 *	\param in_that An rvalue reference to a UpdateOptionsKit to take the impl from.
	 *	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			operator=(UpdateOptionsKit && in_that);

	virtual ~UpdateOptionsKit();

	static const HPS::Type staticType = HPS::Type::UpdateOptionsKit;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Creates a UpdateOptionsKit which contains the default settings.  The returned object will not necessarily have values
	 * 	set for every option, but it will have settings for those options where it is reasonable to have a default.
	 * 	\return A UpdateOptionsKit with the default settings. */
	static UpdateOptionsKit		GetDefault();

	/*! Copies the source UpdateOptionsKit into this UpdateOptionsKit.
	 * 	\param in_kit The source UpdateOptionsKit to copy. */
	void						Set(UpdateOptionsKit const & in_kit);

	/*! Copies this UpdateOptionsKit into the given UpdateOptionsKit.
	 * 	\param out_kit The UpdateOptionsKit to populate with the contents of this UpdateOptionsKit. */
	void						Show(UpdateOptionsKit & out_kit) const;

	/*! Copies the source UpdateOptionsKit into this UpdateOptionsKit.
	 * 	\param in_kit The source UpdateOptionsKit to copy.
	 * 	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			operator=(UpdateOptionsKit const & in_kit);

	/*! Indicates whether this UpdateOptionsKit has any values set on it.
	 * 	\return <span class='code'>true</span> if no values are set on this UpdateOptionsKit, <span class='code'>false</span> otherwise. */
	bool						Empty() const;

	/*!	Check if the source UpdateOptionsKit is equivalent to this UpdateOptionsKit.
	 *	\param in_kit The source UpdateOptionsKit to compare to this UpdateOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(UpdateOptionsKit const & in_kit) const;

	/*!	Check if the source UpdateOptionsKit is equivalent to this UpdateOptionsKit.
	 *	\param in_kit The source UpdateOptionsKit to compare to this UpdateOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator==(UpdateOptionsKit const & in_kit) const;

	/*!	Check if the source UpdateOptionsKit is not equivalent to this UpdateOptionsKit.
	 *	\param in_kit The source UpdateOptionsKit to compare to this UpdateOptionsKit.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!=(UpdateOptionsKit const & in_kit) const;

	/*! Sets the type of update of this UpdateOptionsKit.
	 * 	\param in_type The type of update that this UpdateOptionsKit will perform.
	 * 	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			SetUpdateType(HPS::Window::UpdateType in_type);

	/*! Sets the time limit of this UpdateOptionsKit.
	 * 	\param in_time_limit The time limit for this UpdateOptionsKit update.
	 * 	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			SetTimeLimit(HPS::Time in_time_limit);

	/*! Removes the type of control for this UpdateOptionsKit.
	 *	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			UnsetUpdateType();

	/*! Removes the time limit of this UpdateOptionsKit.
	 *	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			UnsetTimeLimit();

	/*! Removes all settings from this UpdateOptionsKit.
	 *	\return A reference to this UpdateOptionsKit. */
	UpdateOptionsKit &			UnsetEverything();


	/*! Shows the type of control from this UpdateOptionsKit.
	 *	\param out_type The type of update.
	 *	\return <span class='code'>true</span> if the type is valid, <span class='code'>false</span> otherwise. */
	bool						ShowUpdateType(HPS::Window::UpdateType & out_type) const;

	/*! Shows the time limit from this UpdateOptionsKit.
	 *	\param out_proximity The selection proximity.
	 *	\return <span class='code'>true</span> if the time limit is valid, <span class='code'>false</span> otherwise. */
	bool						ShowTimeLimit(HPS::Time & out_time_limit) const;

};



/*!
<p>The HPS::UpdateOptionsControl class is a smart pointer that is tied to a database object. It is used to set selection related options on a HPS::WindowKey. Options include the selection algorithm, granularity, internal limit, related limit, level, proximity, and sorting. </p>

<p>Default values for the various fields of HPS::UpdateOptionsControl can be found <a href="../../prog_guide/appendix_default_attribute_values.html#update-options">here</a>.</p>
*/
class HPS_API UpdateOptionsControl : public Control
{
public:
	/*! This constructor creates a UpdateOptionsControl object which is tied to the specified window.
	 * 	\param in_window The window which this UpdateOptionsControl should operate on. */
	explicit UpdateOptionsControl(WindowKey const & in_window);

	/*! The copy constructor creates a UpdateOptionsControl object that shares the underlying smart-pointer of the source UpdateOptionsControl.
	 *	\param in_that The source UpdateOptionsControl to copy. */
	UpdateOptionsControl(UpdateOptionsControl const & in_that);

	/*! The move constructor creates a UpdateOptionsControl by transferring the underlying impl of the rvalue reference to this UpdateOptionsControl
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a UpdateOptionsControl to take the impl from. */
	UpdateOptionsControl(UpdateOptionsControl && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this UpdateOptionsControl thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a UpdateOptionsControl to take the impl from.
	 * 	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl & operator=(UpdateOptionsControl && in_that);

	~UpdateOptionsControl();

	virtual HPS::Type		Type() const { return ObjectType(); }

	static const HPS::Type staticType = HPS::Type::UpdateOptionsControl;
	HPS::Type						ObjectType() const {return staticType;};

	/*! Share the underlying smart-pointer of the UpdateOptionsControl source.
	 *	\param in_that The UpdateOptionsControl source of the assignment.
	 *	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl &			operator=(UpdateOptionsControl const & in_that);

	/*! Sets the type of update of this UpdateOptionsControl.
	 * 	\param in_type The type of update that this UpdateOptionsControl will perform.
	 * 	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl &			SetUpdateType(HPS::Window::UpdateType in_type);

	/*! Sets the time limit of this UpdateOptionsControl.
	 * 	\param in_time_limit The time limit for this UpdateOptionsControl update.
	 * 	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl &			SetTimeLimit(HPS::Time in_time_limit);

	/*! Removes the type of control for this update Control. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by UpdateOptionsKit::GetDefault().
	 *	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl &			UnsetUpdateType();

	/*! Removes the time limit of this UpdateOptionsControl. If the control is attached to a WindowKey this function restores the default value of this
	*   setting as specified by UpdateOptionsKit::GetDefault().
	 *	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl &			UnsetTimeLimit();

	/*! Removes all settings from this UpdateOptionsControl. If the control is attached to a WindowKey this function restores the default settings of this
	*   control as specified by UpdateOptionsKit::GetDefault().
	 *	\return A reference to this UpdateOptionsControl. */
	UpdateOptionsControl &			UnsetEverything();

	/*! Shows the type of control from this UpdateOptionsControl.
	 *	\param out_type The type of update.
	 *	\return <span class='code'>true</span> if the type is valid, <span class='code'>false</span> otherwise. */
	bool							ShowUpdateType(HPS::Window::UpdateType & out_type) const;

	/*! Shows the time limit from this UpdateOptionsControl.
	 *	\param out_proximity The selection proximity.
	 *	\return <span class='code'>true</span> if the time limit is valid, <span class='code'>false</span> otherwise. */
	bool							ShowTimeLimit(HPS::Time & out_time_limit) const;

private:
	//! Private default constructor to prevent instantiation without a window.
	UpdateOptionsControl();
};

/*! The World class is a special object that must be constructed prior to making any database calls and must exist for
 * 	the life of the application. */
class HPS_API World : public Object
{
public:
	/*! This constructor creates a new World object with the given license.  The license string determines what functionality
	 * 	is available in Visualize.  There should only be one World object that is constructed during the life of the application.
	 *  Optionally it is possible to start Code Generation, which logs every call to the HPS API for debugging purposes.
	 *  While Code Generation is active, HPS performance will be slower than usual.
	 * 	\param in_license UTF8-encoded license string for Visualize.
	 * 	\param in_code_generation_directory UTF8-encoded directory where the output of Code Generation will be stored. The directory must already exist.*/
	World(char const * in_license, char const * in_code_generation_directory = nullptr);

	/*! The destructor will shutdown the database and invalidate all objects within it. */
	~World();

	static const HPS::Type staticType = HPS::Type::World;
	HPS::Type		ObjectType() const {return staticType;};

	/*! Sets the directory which contains the material library for Visualize.  This must be specified to ensure any files which use the
	 * 	material library display correctly.
	 * 	\param in_directory UTF8-encoded directory name.
	 * 	\return A reference to this World object. */
	World &			SetMaterialLibraryDirectory(char const * in_directory);

	/*! Sets the directory which contains fonts for use by Visualize.  This must be specified for Visualize to make use of any fonts
	 * 	beyond those Visualize defines itself.
	 * 	\param in_directory UTF8-encoded directory name.
	 * 	\return A reference to this World object. */
	World &			SetFontDirectory(char const * in_directory);

	/*! Sets the directories which contain fonts for use by Visualize.  This must be specified for Visualize to make use of any fonts
	 * 	beyond those Visualize defines itself.
	 * 	\param in_count Size of the following array.
	 * 	\param in_directories Array of UTF8-encoded directory names.
	 * 	\return A reference to this World object. */
	World &			SetFontDirectories(size_t in_count, UTF8 const in_directories[]);

	/*! Sets the directories which contain fonts for use by Visualize.  This must be specified for Visualize to make use of any fonts
	 * 	beyond those Visualize defines itself.
	 * 	\param in_directories Array of UTF8-encoded directory names.
	 * 	\return A reference to this World object. */
	World &			SetFontDirectories(UTF8Array const & in_directories);

	/*! Sets the driver configuration file (i.e., a plain text file which can force device specific behavior) for Visualize.  To ensure the
	 * 	settings within the configuration file take effect, this file must be specified prior to creating a driver which will be affected
	 * 	by the settings.
	 * 	\param in_filename UTF8-encoded file name.
	 * 	\return A reference to this World object. */
	World &			SetDriverConfigFile(char const * in_filename);

	/*! Sets the directory which contains the Exchange and Publish libraries.  If this is set, the Exchange and Publish Visualize modules
	 * 	will try to load the libraries from this directory.  If this is not set, those modules will try to load the libraries from the
	 * 	directories in the application's PATH.  Note that this function will append the given directory to the PATH.
	 * 	\param in_directory UTF8-encoded directory name.
	 * 	\return A reference to this World object. */
	World &			SetExchangeLibraryDirectory(char const * in_directory);

	/*! Sets the resource directory for Publish.  This is not the directory which contains the libraries (see World::SetExchangeLibraryDirectory),
	 * 	but rather the directory which contains fonts and associated mappings and files used during PDF generation.  This directory must
	 * 	be specified to make use of the Publish module.
	 * 	\param in_directory UTF8-encoded directory name.
	 * 	\return A reference to this World object. */
	World &			SetPublishResourceDirectory(char const * in_directory);

	/*! Sets the schema directory for Parasolid.
	 *  This directory must be specified to make use of the Parasolid module.
	 *	\note Using this function will set the P_SCHEMA environment variable to the given directory as well.
	 * 	\param in_directory UTF8-encoded directory name.
	 * 	\return A reference to this World object. */
	World &			SetParasolidSchemaDirectory(char const * in_directory);

	/*! Sets the Parasolid Bodyshop directory.
	 *	If this directory is specified, Exchange will use the Parasolid Bodyshop
	 *	to translate files to Parasolid parts.
	 * 	\param in_directory UTF8-encoded directory name.
	 * 	\return A reference to this World object. */
	World &			SetParasolidBodyshopDirectory(char const * in_directory);

	/*! Removes the material library directory for Visualize.
	 * 	\return A reference to this World object. */
	World &			UnsetMaterialLibraryDirectory();

	/*! Removes the font directories for Visualize.
	 * 	\return A reference to this World object. */
	World &			UnsetFontDirectories();

	/*! Removes the driver configuration file for Visualize.
	 * 	\return A reference to this World object. */
	World &			UnsetDriverConfigFile();

	/*! Removes the Exchange and Publish library directory.  Note, this will remove the previously specified directory from the PATH.
	 * 	\return A reference to this World object. */
	World &			UnsetExchangeLibraryDirectory();

	/*! Removes the Publish resource directory.
	 * 	\return A reference to this World object. */
	World &			UnsetPublishResourceDirectory();

	/*! Removes the Parasolid schema directory.
	 * 	\return A reference to this World object. */
	World &			UnsetParasolidSchemaDirectory();

	/*! Removes the Parasolid Bodyshop directory.
	 * 	\return A reference to this World object. */
	World &			UnsetParasolidBodyshopDirectory();

	/*! Shows the material library directory for Visualize.
	 * 	\param out_directory UTF8-encoded directory name.
	 *	\return <span class='code'>true</span> if a material library directory was specified, <span class='code'>false</span> otherwise. */
	bool			ShowMaterialLibraryDirectory(UTF8 & out_directory) const;

	/*! Shows the font directories for Visualize.
	 * 	\param out_directories Array of UTF8-encoded directory names.
	 *	\return <span class='code'>true</span> if font directories were specified, <span class='code'>false</span> otherwise. */
	bool			ShowFontDirectories(UTF8Array & out_directories) const;

	/*! Shows the driver configuration file for Visualize.
	 * 	\param out_filename UTF8-encoded file names.
	 *	\return <span class='code'>true</span> if font directories were specified, <span class='code'>false</span> otherwise. */
	bool			ShowDriverConfigFile(UTF8 & out_filename) const;

	/*! Shows the Exchange and Publish library directory.
	 * 	\param out_directory UTF8-encoded directory name.
	 *	\return <span class='code'>true</span> if an Exchange and Publish directory was specified, <span class='code'>false</span> otherwise. */
	bool			ShowExchangeLibraryDirectory(UTF8 & out_directory) const;

	/*! Shows the Publish resource directory.
	 * 	\param out_directory UTF8-encoded directory name.
	 *	\return <span class='code'>true</span> if a Publish resource directory was specified, <span class='code'>false</span> otherwise. */
	bool			ShowPublishResourceDirectory(UTF8 & out_directory) const;

	/*! Shows the Parasolid schema directory.
	 * 	\param out_directory UTF8-encoded directory name.
	 *	\return <span class='code'>true</span> if a Parasolid schema directory was specified, <span class='code'>false</span> otherwise. */
	bool			ShowParasolidSchemaDirectory(UTF8 & out_directory) const;

	/*! Shows the Parasolid Bodyshop directory.
	 * 	\param out_directory UTF8-encoded directory name.
	 *	\return <span class='code'>true</span> if a Parasolid Bodyshop directory was specified, <span class='code'>false</span> otherwise. */
	bool			ShowParasolidBodyshopDirectory(UTF8 & out_directory) const;

	/*! Adds a comment to the generated code. Useful to guide a developer towards the source of a problem.
	*  Code Generation must be started before this function can be called.
	*  \param in_comment A comment to be embedded in the code generation.*/
	static void		AddCodeGenerationComment(UTF8 const & in_comment);

	/*! Stops Code Generation. */
	static void		StopCodeGeneration();

private:
	//! Private default constructor to prevent instantiation without license.
	World();

	/*! Not available here. */
	virtual void		Reset() {}
};


/*!

<p>The EmergencyHandler class is the base class for an custom EmergencyHandler. An EmergencyHandler allows the developer to provide custom logic to handle 'emergency' situations. For example, one can set a soft memory limit using
HPS::Database::SetSoftMemoryLimit. If that limit is hit, Visualize will call the EmergencyHandler.</p>

 <br/>

<p style="margin-top: 8px;">An EmergencyHandler is set by calling HPS::Database::SetEmergencyHandler. Only one
EmergencyHandler can be set on the Database. If you try to set a second handler, the
first one will be overwritten.</p>

 <br/>

<p style="margin-top: 8px;">The default emergency handler will print a few diagnostics to stdout (when run in debug mode), but will make no attempt to recover from the emergency condition.</p>
 */
class HPS_API EmergencyHandler
{
public:

	/*! A constructor for an EmergencyHandler. */
	EmergencyHandler() {}

	virtual ~EmergencyHandler();

	/*! Returns a unique identifier that is shared by all objects of the same class. */
	intptr_t			GetClassID() const;

	/*! Visualize will call the EmergencyHandler::Handle method if any of the
		handler-enabling conditions are reached. The Emergency::Code value describes
		the type of condition. */
	virtual void	Handle(char const * message, HPS::Emergency::Code code) = 0;

	static void *		operator new (size_t in_size){ return Memory::Allocate(in_size); }
	static void			operator delete (void * in_ptr, size_t in_size) throw () { HPS_UNREFERENCED(in_size); Memory::Free(in_ptr); }
};


/*! The Database class is a special type that is never intended to be instantiated.  It contains static functions for creating
 *	top-level database objects as well as performing global queries and actions. */
class HPS_API Database
{
public:
	/*! This function will pump the stand-alone window event system once by default.
	*	If once is false then the calling thread will loop pumping events and will only
	*   return when the last window of any type exits.
	* 	\param in_once determines if the stand-alone events are pumped once or forever.*/
	static void						Execute(bool in_once=true);

	/*! Queries the number of milliseconds that have elapsed since Visualize started.
	 * 	\return The number of milliseconds that have elapsed since Visualize started. */
	static Time						GetTime();

	/*! Sleep for the number of milliseconds requested. */
	static void						Sleep(Time milliseconds);

	/*! Relinquish any internally cached memory to the system. This can reduce
	performance and stability if overused. If your application inserts or removes items
	from the Visualize database continuously, this function should *not* be used, even as
	a means of 'obtaining more memory' for the application. Otherwise, Visualize will
	simply allocate more memory from the operating system. This is slower than using its
	built in memory manager to allocate from its currently available memory pool. However,
	if you have a case where database interactions have perhaps reached a point of
	stabilization (for example, a model is loaded and has been interacted with already,
	and no other operations are going to incur extra memory usage), this function
	could prove useful by having Visualize free up its unused portion of allocated memory.

	This function should generally not be called on 32-bit Windows operating systems,
	because it can significantly shorten the life of an application. When memory is freed
	back to the system on 32-bit Windows, the real memory gets freed and defragmented by
	the OS, but the virtual address space does not. If an application keeps allocating and
	freeing system memory during its lifetime, memory will run out due to the address
	space fragmentation, even though physical memory might still be available. While
	64-bit systems do not have the 'virtual address space fragmentation' issue, you
	typically should avoid calling this method, and rely on Visualize to manage its
	allocated memory during the lifetime of your application.

	Note that you can track Visualize's current memory usage by calling
	HPS::Database::ShowMemoryUsage.
	*/
	static void						RelinquishMemory();


	/*! Returns information about system memory usage.
	*
	* It may be useful to know how much memory Visualize is using to store graphical
	* information. Visualize utilizes its own internal memory manager. It generally
	* allocates memory in large chunks from the operating system, then parcels the
	* chunks out as needed by the database. Upon entity deletion, Visualize will keep
	* some cached information, as well as the chunks of memory associated with the deleted
	* items, effectively 'recycling' them. <i>Allocated</i> memory indicates the total size
	* of all chunks; <i>used</i> memory indicates the amount that's currently parceled out.
	*
	* The memory usage information is also useful during debugging - you might be able to use
	* it to determine if your program (or perhaps Visualize) is "leaking" memory - for
	* example, not cleaning up the segment tree properly after a procedure is finished.
	*
	* Some changes and deletions in the database might cause immediate changes in the memory
	* usage statistics, while others might be delayed until after the next update.
	*
	* Because of the nature of Visualize's built-in memory allocation methods, only a call
	* to HPS::Database::RelinquishMemory or HPS::Database::Reset can clean up memory that
	* has been allocated but not used and return it to the operating system. However,
	* HPS::Database::RelinquishMemory should be used with care, so be sure to review the
	* documentation.
	*
	* \param out_allocated	Total bytes currently allocated from the OS.
	* \param out_used		Total bytes currently in use by the database. */
	static void						ShowMemoryUsage(size_t & out_allocated, size_t & out_used);

	/*!
	Performs a complete reset of the Visualize database. All segments are deleted and
	all window displays are terminated. This will leave all keys, controls, and dispatchers
	invalid. Kits are preserved. This can never be called from inside an event handler.

	It may be appropriate to call this method if your application doesn't need to use
	Visualize for a while. */
	static void						Reset();

	/*! Synchronizes the database, guaranteeing that all queued actions and updates have been performed. */
	static void						Synchronize();

	/*! Get a list of all windows (application, stand-alone, and offscreen) which are active (have been created but not deleted).
	 * 	\return List of all currently active windows. */
	static WindowKeyArray			GetWindowKeys();

	/*! Get a list of all root segments which are active (have been created but not deleted).
	 * 	\return List of all currently active root segments. */
	static SegmentKeyArray			GetRootSegments();

	/*! Get a list of all portfolios which are active (have been created but not deleted).
	 * 	\return List of all currently active portfolios. */
	static PortfolioKeyArray		GetPortfolios();

	/*! Get the material library portfolio.  This is the portfolio which contains all relevant definitions for materials coming from the material library.  It is provided
	 *	to facilitate importing definitions from this portfolio, or to allow examination of the definitions in the portfolio.  It should not be deleted, and if it is, the
	 *	scene will not render correctly if a file was loaded which depended on the material library.
	 * 	\return The material library portfolio. */
	static PortfolioKey const		GetMaterialLibraryPortfolio();

	/*! Create an application window for the given window handle that Visualize can draw into with the specified driver.
	 * 	By default Visualize will try to create an anti-alias capable driver.
	 * 	\param in_window_handle Handle to the window that Visualize will draw into.
	 * 	\param in_driver Type of driver Visualize should create.  Defaults to Window::Driver::Default3D.
	 * 	\return An application window key corresponding to the given handle using the specified driver. */
	static ApplicationWindowKey		CreateApplicationWindow(WindowHandle in_window_handle, Window::Driver in_driver = Window::Driver::Default3D);

	/*! Create an application window for the given window handle that Visualize can draw into with the specified options.
	 * 	\param in_window_handle Handle to the window that Visualize will draw into.
	 * 	\param in_options Options for the application window.
	 * 	\return An application window key corresponding to the given handle using the specified options. */
	static ApplicationWindowKey		CreateApplicationWindow(WindowHandle in_window_handle, ApplicationWindowOptionsKit const & in_options);

#if TARGET_OS_ANDROID == 0 && !defined(__APPLE__)
	/*! Create a stand-alone window with the specified driver.  By default Visualize will try to create an anti-alias capable driver.
	 * 	\param in_driver Type of driver Visualize should create.  Defaults to Window::Driver::Default3D.
	 * Standalone windows are not supported on Android, iOS, or macOS as all GUI / windowing is controlled at the application level.
	 * 	\return An stand-alone window key using the specified driver. */
	static StandAloneWindowKey		CreateStandAloneWindow(Window::Driver in_driver = Window::Driver::Default3D);

	/*! Create a stand-alone window with the specified options.
	 * 	\param in_options Options for the stand-alone window.
	 * Standalone windows are not supported on Android, iOS, or macOS as all GUI / windowing is controlled at the application level.
	 * 	\return An stand-alone window key using the specified options. */
	static StandAloneWindowKey		CreateStandAloneWindow(StandAloneWindowOptionsKit const & in_options);
#endif

	/*! Create an offscreen window of the given height and width with the specified driver.  By default Visualize will try to create an
	 * 	anti-alias capable driver.
	 * 	\param in_width Width of the offscreen window in pixels.
	 * 	\param in_height Height of the offscreen window in pixels.
	 * 	\param in_driver Type of driver Visualize should create.  Defaults to Window::Driver::Default3D.
	 * 	\return An offscreen window key of the specified size using the specified driver. */
	static OffScreenWindowKey		CreateOffScreenWindow(unsigned int in_width, unsigned int in_height, Window::Driver in_driver = Window::Driver::Default3D);

	/*! Create an offscreen window of the given height and width with the specified options.
	 * 	\param in_width Width of the offscreen window in pixels.
	 * 	\param in_height Height of the offscreen window in pixels.
	 * 	\param in_options Options for the offscreen window.
	 * 	\return An offscreen window key of the specified size using the specified options. */
	static OffScreenWindowKey		CreateOffScreenWindow(unsigned int in_width, unsigned int in_height, OffScreenWindowOptionsKit const & in_options);

	/*! Create an offscreen window with the specified driver. By default, Visualize will try to create an
	 * 	anti-alias capable driver.
	 * 	\param in_destination_image An RGB or RGBA image definition that the offscreen window will be rendered to.
	 * 	\param in_driver Type of driver Visualize should create.  Defaults to Window::Driver::Default3D.
	 * 	\return An offscreen window key of the specified size using the specified driver. */
	static OffScreenWindowKey		CreateOffScreenWindow(ImageDefinition const & in_destination_image, Window::Driver in_driver = Window::Driver::Default3D);

	/*! Create an offscreen window of the given height and width with the specified options.
	 * 	\param in_destination_image An RGB or RGBA image definition that the offscreen window will be rendered to.
	 * 	\param in_options Options for the offscreen window.
	 * 	\return An offscreen window key of the specified size using the specified options. */
	static OffScreenWindowKey		CreateOffScreenWindow(ImageDefinition const & in_destination_image, OffScreenWindowOptionsKit const & in_options);

	/*! Create a new root segment, i.e., a segment without an owner.
	*	\return A new root segment key. */
	static SegmentKey				CreateRootSegment();

	/*! Create a new portfolio.
	*	\return A new portfolio key. */
	static PortfolioKey				CreatePortfolio();

	/*! Create a new EventDispatcher with a dedicated thread ready to dispatch events to handlers.
	*	\return A new EventDispatcher. */
	static EventDispatcher			CreateEventDispatcher();

	/*! Create a new EventDispatcher with a dedicated thread ready to dispatch events to handlers.
	* 	\param in_name A specific name for the new dispatcher.
	*	\return A new EventDispatcher. */
	static EventDispatcher			CreateEventDispatcher(char const * in_name);

	/*! Performs an object space selection by shell starting at the specified segment using the specified selection options. This method can only select faceted geometry.
	 * 	\param in_shell Shell to use to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	static size_t					SelectByShell(ShellKit const & in_shell,
												SelectionOptionsKit const & in_options,
												SelectionResults & out_results);

	/*! Performs an object space selection by shell starting at the specified segment using the specified selection options. This method can only select faceted geometry.
	 * 	\param in_shell Shell in the database to use to perform the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	static size_t					SelectByShell(ShellKey const & in_shell,
												SelectionOptionsKit const & in_options,
												SelectionResults & out_results);

	/*! Performs an object space selection by volume starting at the specified segment using the specified selection options.
	 * 	If the volume is invalid, i.e., min &gt; max for any component, an exception will be thrown.
	 * 	\param in_volume Volume to use when performing the selection.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	static size_t					SelectByVolume(SimpleCuboid const & in_volume,
												SelectionOptionsKit const & in_options,
												SelectionResults & out_results);

	/*! Performs an object space selection by ray starting at the specified segment using the specified selection options. This method can only select faceted geometry.
	 * 	\param in_start_point Start point of ray.
	 * 	\param in_direction Direction vector for ray.
	 * 	\param in_options Selection options to use when performing the selection.
	 * 	\param out_results Results of the selection.
	 * 	\return Number of selected items. */
	static size_t					SelectByRay(Point const & in_start_point, Vector const & in_direction,
												SelectionOptionsKit const & in_options,
												SelectionResults & out_results);

	/*! Get the event dispatcher associated with the database.  All database information, errors and warnings will be injected into this EventDispatcher.
	 * 	\return The event dispatcher associated with the database. */
	static EventDispatcher const &	GetEventDispatcher();


	/*! Provides the filter state of an InformationEvent.
	* 	\param in_code The info code in to operate on.
	* 	\return If the specified code is filtered. */
	static bool GetInformationEventFilter(HPS::Info::Code in_code);

	/*! Provides the filter state of a WarningEvents.
	* 	\param in_code The info code in to operate on.
	* 	\return If the specified code is filtered. */
	static bool GetWarningEventFilter(HPS::Info::Code in_code);

	/*! Provides the filter state of an ErrorEvent.
	* 	\param in_code The info code in to operate on.
	* 	\return If the specified code is filtered. */
	static bool GetErrorEventFilter(HPS::Info::Code in_code);

	/*! Sets if a specific code for InformationEvent should be filtered.
	* 	\param in_code The info code in to operate on.
	* 	\param in_filtered The new filter state desired.
	* 	\return The old value for the specified code. */
	static bool SetInformationEventFilter(HPS::Info::Code in_code, bool in_filtered);

	/*! Sets if a specific code for WarningEvent should be filtered.
	* 	\param in_code The info code in to operate on.
	* 	\param in_filtered The new filter state desired.
	* 	\return The old value for the specified code. */
	static bool SetWarningEventFilter(HPS::Info::Code in_code, bool in_filtered);

	/*! Sets if a specific code for ErrorEvent should be filtered.
	* 	\param in_code The info code in to operate on.
	* 	\param in_filtered The new filter state desired.
	* 	\return The old value for the specified code. */
	static bool SetErrorEventFilter(HPS::Info::Code in_code, bool in_filtered);


	/*! Sets a custom EmergencyHandler.
	* 	\param in_emergency_handler The EmergencyHandler to use. */
	static void SetEmergencyHandler(HPS::EmergencyHandler const & in_emergency_handler);

	/*! Sets the default EmergencyHandler. */
	static void UnsetEmergencyHandler();

	/*! Gets the value at which the EmergencyHandler will be activated for SoftMemoryLimit.
	* 	\return The current value in bytes. */
	static size_t GetSoftMemoryLimit();

	/*! Sets the value at which the EmergencyHandler will be activated for SoftMemoryLimit.
	* 	\param in_limit_bytes The new limit value in bytes.
	* 	\return The old value in bytes. */
	static size_t SetSoftMemoryLimit(size_t in_limit_bytes);

	/*! Gets the byte limit used for OOC file loading.
	* 	\return The current value in bytes. */
	static size_t GetOOCMemoryLimit();

	/*! Sets the byte limit used for OOC file loading.  A limit of zero bytes restores the default value.
	* 	\param in_limit_bytes The new limit value in bytes.
	* 	\return The old value in bytes. */
	static size_t SetOOCMemoryLimit(size_t in_limit_bytes);

	/*! Checks whether the specified driver type is present and available for use.
	* 	\param in_driver the driver type to check availability for.
	* 	\return Whether the driver is available or not. */
	static bool IsDriverAvailable(HPS::Window::Driver in_driver);

	/*! Returns a list of the names of the GPUs available on the system.
	*	This function is only available if DirectX11 is supported on your device.
	*	If DirectX11 is not supported the function will return false and out_available_gpus will be empty.
	* 	\param out_available_gpus the names of the GPU available on the system.
	* 	\return Whether Visualize could obtain a list of available GPUs. */
	static bool ShowAvailableGPUs(HPS::UTF8Array & out_available_gpus);

private:
	//! Private default constructor to prevent instantiation.
	Database();
};


//////////////////////////////////////////////////////////////////////
///////////////////////////// Events /////////////////////////////////
//////////////////////////////////////////////////////////////////////



/*! The EventDispatcher class is used for injecting any events and dealing with event handlers which handle those events. */
class HPS_API EventDispatcher : public Object
{
public:
	/*! The default constructor creates an uninitialized EventDispatcher object which cannot be subscribed to.
	 *	\sa Database::CreateEventDispatcher() */
	EventDispatcher();

	/*! The copy constructor creates an EventDispatcher object that points to the same underlying impl as the source EventDispatcher.
	 * 	\param in_that The source EventHandler to point to. */
	EventDispatcher(EventDispatcher const & in_that);

	/*! The move constructor creates a EventDispatcher by transferring the underlying impl of the rvalue reference to this EventDispatcher
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a EventDispatcher to take the impl from. */
	EventDispatcher(EventDispatcher && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EventDispatcher thereby avoiding a copy.
	 *	\param in_that An rvalue reference to an EventDispatcher to take the impl from.
	 *	\return A reference to this EventDispatcher. */
	EventDispatcher & operator=(EventDispatcher && in_that);

	virtual ~EventDispatcher();

	static const HPS::Type staticType = HPS::Type::EventDispatcher;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Associate this EventDispatcher with the same underlying impl as the source EventDispatcher.
	 *	\param in_that The source EventDispatcher for the assignment.
	 *	\return A reference to this EventDispatcher. */
	EventDispatcher &		operator=(EventDispatcher const & in_that);

	/*!	Check if the source EventDispatcher is equivalent to this object.
	*	\param in_that The source EventDispatcher to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					Equals(EventDispatcher const & in_that) const;

	/*!	Check if the source EventDispatcher is equivalent to this object.
	 *	\param in_that The source EventDispatcher to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool					operator==(EventDispatcher const & in_that) const;

	/*!	Check if the source EventDispatcher is not equivalent to this object.
	 *	\param in_that The source EventDispatcher to compare to this object.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool					operator!=(EventDispatcher const & in_that) const;

	/*! Add the specified event handler to the list of subscribers for events of the specified type on this EventDispatcher.
	 * 	\param in_handler Event handler to add to the subscriber list for events of the given type.
	 * 	\param in_type Type of event to add the handler for.
	 *	\return <span class='code'>true</span> if the subscription was successful, <span class='code'>false</span> otherwise. */
	bool					Subscribe(EventHandler const & in_handler, intptr_t in_type) const;

	/*! Remove the specified event handler from the list of subscribers for events of the specified type on this EventDispatcher.
	 * 	\param in_handler Event handler to remove from the subscriber list for events of the given type.
	 * 	\param in_type Type of event to remove the handler for.
	 *	\return <span class='code'>true</span> if the unsubscription was successful, <span class='code'>false</span> otherwise. */
	bool					UnSubscribe(EventHandler const & in_handler, intptr_t in_type) const;

	/*! Remove the specified event handler from the list of subscribers for events of the specified type on this EventDispatcher.
	 * 	\param in_handler Event handler to remove from the subscriber list for events of the given type.
	 * 	\param in_type Type of event to remove the handler for.
	 *	\return <span class='code'>true</span> if the unsubscription was successful, <span class='code'>false</span> otherwise. */
	bool					UnSubscribe(EventHandler const & in_handler) const;

	/*! Remove the specified event handler from the list of subscribers for events of the specified type on this EventDispatcher.
	 * 	\param in_type Type of event to remove the handler for.
	 *	\return <span class='code'>true</span> if the unsubscription was successful, <span class='code'>false</span> otherwise. */
	bool					UnSubscribe(intptr_t in_type) const;

	/*! Inject the specified event and propagate it to all subscribed handlers in the order of subscription.
	 * 	\param in_event Event to inject and propagate.
	 *	\return <span class='code'>true</span> if the event injection was successful, <span class='code'>false</span> otherwise. */
	bool					InjectEvent(Event const & in_event) const;

	/*! Inject the specified event and propagate it to all subscribed handlers in the order of subscription and return an EventNotifier
	 * 	associated with the injected event.
	 * 	\param in_event Event to inject and propagate.
	 *	\return An event notifier associated with the injected event. */
	EventNotifier			InjectEventWithNotifier(Event const & in_event) const;

	/*! Shutdown this EventDispatcher asynchronously.  Any pending events injected into this EventDispatcher will be processed prior
	 * 	to shutdown, but no new events can be injected. */
	void Shutdown() const;

	/*! Query whether the asynchronous shutdown has completed.
	 *	\return <span class='code'>true</span> if the event dispatcher has shutdown, <span class='code'>false</span> otherwise. */
	bool IsShutdown() const;


	/*! Sets the EventDispatcher's name
	* 	\param in_name Name to set. */
	void SetName(char const * in_name) const;

	/*! Shows the EventDispatcher's name
	* 	\param out_name Current name of this EventDispatcher. */
	void ShowName(UTF8 & out_name) const;

private:
	/*! Not available here. */
	virtual void		Reset() {}
};


/*! The EventHandler class is the base class for any event handler that can be created.  All custom event handlers should
 * 	inherit from this. */
class HPS_API EventHandler : public Object
{
public:
	/*! The default constructor creates an EventHandler object not subscribed to any event. */
	EventHandler();

	/*! The copy constructor creates a new EventHandler object that points to the same underlying impl as the source EventHandler.
	 * 	\param in_that The source EventHandler to point to. */
	EventHandler(EventHandler const & in_that);

	/*! The move constructor creates an EventHandler by transferring the underlying impl of the rvalue reference to this EventHandler
	 * 	thereby avoiding a copy and allocation.
	 *	\param in_that An rvalue reference to an EventHandler to take the impl from. */
	EventHandler(EventHandler && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this EventHandler thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to an EventHandler to take the impl from.
	 * 	\return A reference to this EventHandler. */
	EventHandler & operator=(EventHandler && in_that);

	/*! Share the underlying smart-pointer of the EventHandler source.
	 *	\param in_that The EventHandler source of the assignment.
	 *	\return A reference to this EventHandler. */
	EventHandler & operator=(EventHandler const & in_that);

	virtual ~EventHandler();

	static const HPS::Type staticType = HPS::Type::EventHandler;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Add this EventHandler object to the list of subscribers for events of the specified type on the specified EventDispatcher.
	 * 	\param in_dispatcher Dispatcher from which to receive events of the given type.
	 * 	\param in_type Type of event to receive from the dispatcher.
	 *	\return <span class='code'>true</span> if the subscription was successful, <span class='code'>false</span> otherwise. */
	bool					Subscribe(EventDispatcher const & in_dispatcher, intptr_t in_type) const;

	/*! Remove this EventHandler object from the list of subscribers for events of the specified type on the specified EventDispatcher.
	 * 	\param in_dispatcher Dispatcher from which to no longer receive events of the given type.
	 * 	\param in_type Type of event to no longer receive from the dispatcher.
	 *	\return <span class='code'>true</span> if the unsubscription was successful, <span class='code'>false</span> otherwise. */
	bool					UnSubscribe(EventDispatcher const & in_dispatcher, intptr_t in_type) const;

	/*! Remove this EventHandler object from the list of subscribers for all events on the specified EventDispatcher.
	 * 	\param in_dispatcher Dispatcher from which to no longer receive events.
	 *	\return <span class='code'>true</span> if the unsubscription was successful, <span class='code'>false</span> otherwise. */
	bool					UnSubscribe(EventDispatcher const & in_dispatcher) const;

	/*! Remove this EventHandler object from all events on all EventDispatchers. */
	void					UnSubscribeEverything() const;

	/*! Resets this object to its initial, uninitialized state. */
	virtual void			Reset() { UnSubscribeEverything(); }

	/*! Notifies the EventDispatcher that this handler is being invalidated and no further events should be dispatched to it.
		This method must be called in any derived class destructors. */
	void					Shutdown();

	/*! \enum HandleResult
	 * 	Enumeration of the values the EventHandler uses to indicate if it handled an event. */
	enum class HandleResult : uint32_t
	{
		Handled,		//!< The event was handled by this EventHandler.  Consume the event if possible.
		NotHandled		//!< The event was not handled by this EventHandler.  Pass to the next handler if any or if possible.
	};

	/*! Function that gets triggered if this EventHandler receives an event it is subscribed to.  This should be overridden by
	 * 	subclasses of EventHandler to perform any custom behavior.
	 * 	\param in_event Event which was triggered.
	 *	\return <span class='code'>Handled</span> if the event was handled, <span class='code'>NotHandled</span> otherwise. */
	virtual HandleResult Handle(Event const * in_event) { HPS_UNREFERENCED(in_event); return HandleResult::NotHandled;};
};



/*! The TimerTickEvent class is the event that will be triggered for each timer tick. */
class HPS_API TimerTickEvent : public Event
{
public:
	/*! The default constructor creates a TimerTickEvent object. */
	TimerTickEvent() : Event()
	{
		channel = GetClassID();
		consumable = false;
	}


	/*! This constructor converts an Event Object to a TimerTickEvent object.
	 * 	\param in_event The Event Object to be converted. */
	TimerTickEvent(Event const & in_event) : Event(in_event)
	{
		if(in_event.GetChannel() != Object::ClassID<TimerTickEvent>())
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
	}

	~TimerTickEvent();

	/*! Allocates and returns a copy of this TimerEvent.
	 * 	\return A copy of this TimerEvent. */
	Event * Clone() const
	{
		TimerTickEvent * new_event = new TimerTickEvent(*this);
		return new_event;
	}

	/*! Determines if this TimerTickEvent can be drop in favor of the following time tick event.
	 * 	\param in_that_event Event to compare with this TimerTickEvent.
	 * 	\return <span class='code'>true</span> if this event can be dropped, <span class='code'>false</span> otherwise. */
	virtual bool Drop(Event const * in_that_event) const
	{
		HPS_UNREFERENCED(in_that_event);
		return true;
	}

	virtual intptr_t Freshen() const {
		return GetClassID();
	}
};

/*! The HighlightEvent class is the event that will be triggered for each highlight or unhighlight call. */
class HPS_API HighlightEvent : public Event
{
public:
	enum class Action : uint32_t
	{
		None = 0,
		Highlight,
		Unhighlight,
	};

	/*! The default constructor creates an empty HighlightEvent object. */
	HighlightEvent() : Event()
	{
		channel = GetClassID();
		consumable = false;
		action = Action::None;
	}

	HighlightEvent(Action in_action, SelectionResults const & in_results = SelectionResults(), HighlightOptionsKit const & in_options = HighlightOptionsKit())
		: Event(), action(in_action), results(in_results), options(in_options)
	{
		channel = GetClassID();
		consumable = false;
	}

	/*! This constructor converts an Event Object to a HighlightEvent object.
	 * 	\param in_event The Event Object to be converted. */
	HighlightEvent(Event const & in_event) : Event(in_event)
	{
		if (in_event.GetChannel() == Object::ClassID<HighlightEvent>())
		{
			auto that = static_cast<HighlightEvent const &>(in_event);
			action = that.action;
			results = that.results;
			options = that.options;
		}
		else
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
	}

	~HighlightEvent();

	/*! Allocates and returns a copy of this HighlightEvent.
	 * 	\return A copy of this HighlightEvent. */
	Event * Clone() const
	{
		HighlightEvent * new_event = new HighlightEvent(*this);
		return new_event;
	}

	Action action;
	SelectionResults results;
	HighlightOptionsKit options;
};

/*! The InformationEvent class is the event that will be generated if an asynchronous informational message occurs. */
class HPS_API InformationEvent : public Event
{
public:
	/*! The default constructor creates a InformationEvent object with an empty message and code of <span class='code'>Unknown</span>. */
	InformationEvent() : Event(), code(HPS::Info::Code::Unknown) { channel = GetClassID(); }

	/*! This constructor creates a InformationEvent object with a specified information and code of <span class='code'>Unknown</span>.
	* 	\param in_message A message describing the nature of the information. */
	InformationEvent(char const * in_message);

	/*! This constructor creates a InformationEvent object with a specified information and code.
	* 	\param in_message A message describing the nature of the information.
	* 	\param in_code A code describing the nature of the information. */
	InformationEvent(char const * in_message, HPS::Info::Code	in_code);

	/*! This constructor converts an Event Object to a InformationEvent object.
	* 	\param in_event The Event Object to be converted. */
	InformationEvent(Event const & in_event) : Event(in_event)
	{
		if (in_event.GetChannel() == Object::ClassID<InformationEvent>())
		{
			InformationEvent const * event = static_cast<InformationEvent const *>(&in_event);
			message = event->message;
			code = event->code;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	~InformationEvent();

	/*! Allocates and returns a copy of this InformationEvent.
	* 	\return A copy of this InformationEvent. */
	Event * Clone() const
	{
		InformationEvent * new_event = new InformationEvent(*this);
		return new_event;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(InformationEvent const & in_that) const
	{
		return message == in_that.message && code == in_that.code;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (InformationEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (InformationEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	UTF8 message;			//!< The warning information for this WarningEvent.
	HPS::Info::Code	code;	//!< The warning code for this InformationEvent.
};


/*! The WarningEvent class is the event that will be generated if an asynchronous warning occurs. */
class HPS_API WarningEvent : public Event
{
public:
	/*! The default constructor creates a WarningEvent object with an empty message and code of <span class='code'>Unknown</span>. */
	WarningEvent() : Event(), code(HPS::Info::Code::Unknown) { channel = GetClassID(); }

	/*! This constructor creates a WarningEvent object with a specified message and code of <span class='code'>Unknown</span>.
	 * 	\param in_message A message describing the nature of the warning. */
	WarningEvent(char const * in_message);

	/*! This constructor creates a WarningEvent object with a specified message and code.
	* 	\param in_message A message describing the nature of the warning.
	* 	\param in_code A code describing the nature of the warning. */
	WarningEvent(char const * in_message, HPS::Info::Code in_code);

	/*! This constructor converts an Event Object to a WarningEvent object.
	 * 	\param in_event The Event Object to be converted. */
	WarningEvent(Event const & in_event) : Event(in_event)
	{
		if(in_event.GetChannel() == Object::ClassID<WarningEvent>())
		{
			WarningEvent const * event = static_cast<WarningEvent const *>(&in_event);
			message = event->message;
			code = event->code;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	~WarningEvent();

	/*! Allocates and returns a copy of this WarningEvent.
	 * 	\return A copy of this WarningEvent. */
	Event * Clone() const
	{
		WarningEvent * new_event = new WarningEvent(*this);
		return new_event;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(WarningEvent const & in_that) const
	{
		return message == in_that.message && code == in_that.code;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (WarningEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (WarningEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	UTF8 message;			//!< The warning message for this WarningEvent.
	HPS::Info::Code	code;	//!< The warning code for this WarningEvent.
};


/*! The ErrorEvent class is the event that will be generated if an asynchronous error occurs. */
class HPS_API ErrorEvent : public Event
{
public:
	/*! The default constructor creates an ErrorEvent object with an empty message and code of <span class='code'>Unknown</span>. */
	ErrorEvent() : Event(), code(HPS::Info::Code::Unknown) { channel = GetClassID(); }

	/*! This constructor creates an ErrorEvent object with a specified message and code of <span class='code'>Unknown</span>.
	 * 	\param in_message A message describing the nature of the error. */
	ErrorEvent(char const * in_message);

	/*! This constructor creates a ErrorEvent object with a specified message and code.
	* 	\param in_message A message describing the nature of the error.
	* 	\param in_code A code describing the nature of the error. */
	ErrorEvent(char const * in_message, HPS::Info::Code	in_code);

	/*! This constructor converts an Event Object to an ErrorEvent object.
	 * 	\param in_event The Event Object to be converted. */
	ErrorEvent(Event const & in_event) : Event(in_event)
	{
		if(in_event.GetChannel() == Object::ClassID<ErrorEvent>())
		{
			ErrorEvent const * event = static_cast<ErrorEvent const *>(&in_event);
			message = event->message;
			code = event->code;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	~ErrorEvent();

	/*! Allocates and returns a copy of this ErrorEvent.
	 * 	\return A copy of this ErrorEvent. */
	Event * Clone() const
	{
		ErrorEvent * new_event = new ErrorEvent(*this);
		return new_event;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(ErrorEvent const & in_that) const
	{
		return message == in_that.message && code == in_that.code;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (ErrorEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (ErrorEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	UTF8 message;			//!< The error message for this ErrorEvent.
	HPS::Info::Code code;	//!< The error code for this ErrorEvent.
};


#if TARGET_OS_ANDROID == 0 && !defined(__APPLE__)
/*! The StandAloneWindowEvent class is the event that is generated by a Standalone window. */
class HPS_API StandAloneWindowEvent : public Event
{
public:

	/*!	\enum Action
	 * 	Enumeration of various actions StandAloneWindowEvent. */
	enum class Action : uint32_t
	{
		Unknown,	//!< The StandAloneWindow has recieved a unknown message.
		Close,		//!< The StandAloneWindow has recieved a close.
		FocusIn,
		FocusOut,
	};

	/*! The default constructor creates an StandAloneWindowEvent object with an empty message and code of <span class='code'>0</span>. */
	StandAloneWindowEvent() : Event(), action(Action::Unknown) { channel = GetClassID(); }


	/*! This constructor creates a StandAloneWindowEvent object for a given action.
	 * 	\param in_action Action of this StandAloneWindowEvent. */
	StandAloneWindowEvent(Action in_action) : Event(), action(in_action) { channel = GetClassID(); }

	/*! This constructor converts an Event Object to a StandAloneWindowEvent object.
	 * 	\param in_event The Event Object to be converted. */
	StandAloneWindowEvent(Event const & in_event) : Event(in_event)
	{
		if(in_event.GetChannel() == Object::ClassID<StandAloneWindowEvent>())
		{
			StandAloneWindowEvent const * event = static_cast<StandAloneWindowEvent const *>(&in_event);
			action = event->action;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	~StandAloneWindowEvent();

	/*! Allocates and returns a copy of this ErrorEvent.
	 * 	\return A copy of this ErrorEvent. */
	Event * Clone() const
	{
		StandAloneWindowEvent * new_event = new StandAloneWindowEvent(*this);
		return new_event;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_event The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(StandAloneWindowEvent const & in_that) const
	{
		return action == in_that.action;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_event The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (StandAloneWindowEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_event The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (StandAloneWindowEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	Action action; //!< The action for this StandAloneWindowEvent.
};
#endif

/*! The FocusLostEvent class is the event that is generated when an application loses focus */
class HPS_API FocusLostEvent : public Event
{
public:
	/*! The default constructor creates a FocusLostEvent. */
	FocusLostEvent() :
		Event()
	{ channel = GetClassID(); }

	~FocusLostEvent();

	/*! Allocates and returns a copy of this FocusLostEvent.
	 * 	\return A copy of this FocusLostEvent. */
	Event * Clone() const
	{
		FocusLostEvent * new_event = new FocusLostEvent(*this);
		return new_event;
	}
};

/*! The TextInputEvent class is the event that is generated when an application receives text input */
class HPS_API TextInputEvent : public Event
{
	public:
	/*! The default constructor creates a TextInputEvent. */
	TextInputEvent() :
		Event()
	{ channel = GetClassID(); }

	/*! This constructor creates a TextInputEvent object for a given text string.
	 * 	\param in_text Text associated to this TextInputEvent. */
	TextInputEvent(char const * in_text) : Event(), text(in_text, "utf8") { channel = GetClassID(); }

	/*! This constructor converts an Event Object to a TextInputEvent object.
	 * 	\param in_event The Event Object to be converted. */
	TextInputEvent(Event const & in_event) : Event(in_event)
	{
		if(in_event.GetChannel() == Object::ClassID<TextInputEvent>())
		{
			TextInputEvent const * event = static_cast<TextInputEvent const *>(&in_event);
			text = event->text;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_event The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(TextInputEvent const & in_that) const
	{
		return text == in_that.text;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_event The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (TextInputEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_event The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (ErrorEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	~TextInputEvent();

	/*! Allocates and returns a copy of this TextInputEvent.
	 * 	\return A copy of this TextInputEvent. */
	Event * Clone() const
	{
		TextInputEvent * new_event = new TextInputEvent(*this);
		return new_event;
	}

	HPS::UTF8 text;	//!< The text for this TextInputEvent.
};


/*! The UpdateCompletedEvent class is the event that is generated when an update is completed 
* Note: Updates happen on a per-WindowKey basis, therefore, EventHandler objects which handle UpdateCompletedEvents
* need to be subscribed to the EventDispatcher of the WindowKey whose update needs to be monitored.
* Example: <span class='code'>myWindow.GetEventDspatcher().Subscribe(*my_handler, HPS::Object::ClassID<HPS::UpdateCompletedEvent>());</span> */
class HPS_API UpdateCompletedEvent : public Event
{
public:
	/*! The default constructor creates a UpdateCompletedEvent. */
	UpdateCompletedEvent() : Event(), update_time(-1) { channel = GetClassID(); }

	/*! The constructor creates a UpdateCompletedEvent. */
	UpdateCompletedEvent(Time in_update_time, Window::UpdateStatus in_update_status) : Event(), update_time(in_update_time), update_status(in_update_status) { channel = GetClassID(); }

	/*! This constructor converts an Event Object to an UpdateCompletedEvent object.
	 * 	\param in_event The Event Object to be converted. */
	UpdateCompletedEvent(Event const & in_event) : Event(in_event)
	{
		if(in_event.GetChannel() == Object::ClassID<UpdateCompletedEvent>())
		{
			UpdateCompletedEvent const * event = static_cast<UpdateCompletedEvent const *>(&in_event);
			update_time = event->update_time;
			update_status = event->update_status;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	virtual ~UpdateCompletedEvent();

	/*! Allocates and returns a copy of this UpdateCompletedEvent.
	 * 	\return A copy of this UpdateCompletedEvent. */
	Event * Clone() const
	{
		UpdateCompletedEvent * new_event = new UpdateCompletedEvent(*this);
		return new_event;
	}

	Time		update_time;
	Window::UpdateStatus update_status;
};

/*! The ImportStatusEvent class is the event that can be used by importers to let the user know what they are currently working on */
class HPS_API ImportStatusEvent : public Event
{
public:
	/*! The default constructor creates a ImportStatusEvent. */
	ImportStatusEvent()
		: Event()
	{ channel = GetClassID(); }

	ImportStatusEvent(char const * in_message)
		: Event()
		, import_status_message(in_message, "utf8")
	{ channel = GetClassID(); }

	/*! This constructor converts an Event Object to an ImportStatusEvent object.
	 * 	\param in_event The Event Object to be converted. */
	ImportStatusEvent(Event const & in_event) : Event(in_event)
	{
		if (in_event.GetChannel() == Object::ClassID<ImportStatusEvent>())
		{
			auto event = static_cast<ImportStatusEvent const &>(in_event);
			import_status_message = event.import_status_message;
		}
		else
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
	}

	~ImportStatusEvent();

	/*! Allocates and returns a copy of this ImportStatusEvent.
		* 	\return A copy of this ImportStatusEvent. */
	Event * Clone() const
	{
		ImportStatusEvent * new_event = new ImportStatusEvent(*this);
		return new_event;
	}

	HPS::UTF8 import_status_message;
};

/*! The ShowKeyboardEvent class is the event that can be used on mobile devices to request that the software keyboard be shown */
class HPS_API ShowKeyboardEvent : public Event
{
public:
    /*! The default constructor creates a ShowKeyboardEvent. */
    ShowKeyboardEvent()
    : Event()
    { channel = GetClassID(); }

    /*! This constructor converts an Event Object to an ShowKeyboardEvent object.
     * 	\param in_event The Event Object to be converted. */
    ShowKeyboardEvent(Event const & in_event) : Event(in_event)
    {
        if (in_event.GetChannel() != Object::ClassID<ShowKeyboardEvent>())
            throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
    }

    ~ShowKeyboardEvent();

    /*! Allocates and returns a copy of this ShowKeyboardEvent.
     * 	\return A copy of this ShowKeyboardEvent. */
    Event * Clone() const
    {
        ShowKeyboardEvent * new_event = new ShowKeyboardEvent(*this);
        return new_event;
    }

};

/*! The HideKeyboardEvent class is the event that can be used on mobile devices to request that the software keyboard be hidden */
class HPS_API HideKeyboardEvent : public Event
{
public:
    /*! The default constructor creates a HideKeyboardEvent. */
    HideKeyboardEvent()
    : Event()
    { channel = GetClassID(); }

    /*! This constructor converts an Event Object to an HideKeyboardEvent object.
     * 	\param in_event The Event Object to be converted. */
    HideKeyboardEvent(Event const & in_event) : Event(in_event)
    {
        if (in_event.GetChannel() != Object::ClassID<HideKeyboardEvent>())
            throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
    }

    ~HideKeyboardEvent();

    /*! Allocates and returns a copy of this HideKeyboardEvent.
     * 	\return A copy of this HideKeyboardEvent. */
    Event * Clone() const
    {
        HideKeyboardEvent * new_event = new HideKeyboardEvent(*this);
        return new_event;
    }

};

/*!	Various modifier keys that could be active for an InputEvent. */
class HPS_API ModifierKeys
{
public:
	/*!	The default constructor creates a ModifierKeys object with no modifiers active. */
	ModifierKeys() : modifiers(_key_none) {}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool Equals(ModifierKeys const & in_that) const
	{
		return modifiers == in_that.modifiers;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool operator== (ModifierKeys const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool operator!= (ModifierKeys const & in_that) const
	{
		return !Equals(in_that);
	}

	/*!	Indicates whether no modifiers are active.
	*	\return <span class='code'>true</span> if no modifier keys are active, <span class='code'>false</span> otherwise. */
	bool None() const { return modifiers == _key_none; }

	/*!	Indicates whether any shift key (right or left) is active.
	*	\return <span class='code'>true</span> if any shift key is active, <span class='code'>false</span> otherwise. */
	bool Shift() const { return (modifiers & _key_shift) != 0; }

	/*!	Indicates whether any control key (right or left) is active.
	*	\return <span class='code'>true</span> if any control key is active, <span class='code'>false</span> otherwise. */
	bool Control() const { return (modifiers & _key_control) != 0; }

	/*!	Indicates whether any alt key (right or left) is active.
	*	\return <span class='code'>true</span> if any alt key is active, <span class='code'>false</span> otherwise. */
	bool Alt() const { return (modifiers & _key_alt) != 0; }

	/*!	Indicates whether any meta key (right or left) is active.
	*	\return <span class='code'>true</span> if any meta key is active, <span class='code'>false</span> otherwise. */
	bool Meta() const { return (modifiers & _key_meta) != 0; }

	/*!	Indicates whether the caps lock button is active
	*	\return <span class='code'>true</span> if the caps lock key is active, <span class = 'code'>false</span> otherwise. */
	bool CapsLock() const {return (modifiers & _key_caps_lock) != 0; }

	/*!	Indicates whether the num lock button is active
	*	\return <span class='code'>true</span> if the num lock key is active, <span class = 'code'>false</span> otherwise. */
	bool NumLock() const {return (modifiers & _key_num_lock) != 0; }

	/*!	Indicates whether the scroll lock button is active
	*	\return <span class='code'>true</span> if the scroll lock key is active, <span class = 'code'>false</span> otherwise. */
	bool ScrollLock() const {return (modifiers & _key_scroll_lock) != 0; }

	/*!	Indicates whether the right shift button is active
	*	\return <span class='code'>true</span> if the right shift key is active, <span class = 'code'>false</span> otherwise. */
	bool RightShift() const {return (modifiers & _key_right_shift) != 0; }

	/*!	Indicates whether the left shift button is active
	*	\return <span class='code'>true</span> if the left shift key is active, <span class = 'code'>false</span> otherwise. */
	bool LeftShift() const {return (modifiers & _key_left_shift) != 0; }

	/*!	Indicates whether the right control button is active
	*	\return <span class='code'>true</span> if the right control key is active, <span class = 'code'>false</span> otherwise. */
	bool RightControl() const {return (modifiers & _key_right_control) != 0; }

	/*!	Indicates whether the left control button is active
	*	\return <span class='code'>true</span> if the left control key is active, <span class = 'code'>false</span> otherwise. */
	bool LeftControl() const {return (modifiers & _key_left_control) != 0; }

	/*!	Indicates whether the right alt button is active
	*	\return <span class='code'>true</span> if the right alt key is active, <span class = 'code'>false</span> otherwise. */
	bool RightAlt() const {return (modifiers & _key_right_alt) != 0; }

	/*!	Indicates whether the left alt button is active
	*	\return <span class='code'>true</span> if the left alt key is active, <span class = 'code'>false</span> otherwise. */
	bool LeftAlt() const {return (modifiers & _key_left_alt) != 0; }

	/*!	Indicates whether the right meta button is active
	*	\return <span class='code'>true</span> if the right meta key is active, <span class = 'code'>false< /span> otherwise. */
	bool RightMeta() const {return (modifiers & _key_right_meta) != 0; }

	/*!	Indicates whether the left meta button is active
	*	\return <span class='code'>true</span> if the left meta key is active, <span class = 'code'>false< /span> otherwise. */
	bool LeftMeta() const {return (modifiers & _key_left_meta) != 0; }

	/*!	Indicates whether all modifiers of the input parameter are present in this object.
	*	\param in_keys A collection of modifiers to check against this object.
	*	\return <span class='code'>true</span> if all of the input modifiers are active, <span class='code'>false</span> otherwise. */
	bool HasAll(ModifierKeys const & in_keys) const { return (modifiers & in_keys.modifiers) == in_keys.modifiers; }

	/*!	Indicates whether any modifiers of the input parameter are present in this object.
	*	\param in_keys A collection of modifiers to check against this object.
	*	\return <span class='code'>true</span> if any of the modifiers are active, <span class='code'>false</span> otherwise. */
	bool HasAny(ModifierKeys const & in_keys) const { return (modifiers & in_keys.modifiers) != 0; }


	/*!	Sets the state of the shift key modifier
	*	\param in_state <span class='code'>true</span> if at least one shift key (right or left) is active, <span class='code'>false</span> otherwise. */
	void Shift(bool in_state) { if(in_state) modifiers |= _key_shift; else modifiers &= ~(_key_shift); }

	/*!	Sets the state of the control key modifier
	*	\param in_state <span class='code'>true</span> if at least one control key (right or left) is active, <span class='code'>false</span> otherwise. */
	void Control(bool in_state) { if(in_state) modifiers |= _key_control; else modifiers &= ~(_key_control); }

	/*!	Sets the state of the alt key modifier
	*	\param in_state <span class='code'>true</span> if at least one alt key (right or left) is active, <span class='code'>false</span> otherwise. */
	void Alt(bool in_state) { if(in_state) modifiers |= _key_alt; else modifiers &= ~(_key_alt); }

	/*!	Sets the state of the meta key modifier
	*	\param in_state <span class='code'>true</span> if at least one meta key (right or left) is active, <span class='code'>false</span> otherwise. */
	void Meta(bool in_state) { if(in_state) modifiers |= _key_meta; else modifiers &= ~(_key_meta); }

	/*!	Sets the state of the caps lock key modifier
	*	\param in_state <span class='code'>true</span> if the caps lock key is active, <span class='code'>false</span> otherwise. */
	void CapsLock(bool in_state) { if (in_state) modifiers |= _key_caps_lock; else modifiers &= ~(_key_caps_lock); }

	/*!	Sets the state of the num lock key modifier
	*	\param in_state <span class='code'>true</span> if the num lock key is active, <span class='code'>false</span> otherwise. */
	void NumLock(bool in_state) { if (in_state) modifiers |= _key_num_lock; else modifiers &= ~(_key_num_lock); }

	/*!	Sets the state of the scroll lock key modifier
	*	\param in_state <span class='code'>true</span> if the scroll lock key is active, <span class='code'>false</span> otherwise. */
	void ScrollLock(bool in_state) { if (in_state) modifiers |= _key_scroll_lock; else modifiers &= ~(_key_scroll_lock); }

	/*!	Sets the state of the right shift key modifier
	*	\param in_state <span class='code'>true</span> if the right shift key is active, <span class='code'>false</span> otherwise. */
	void RightShift(bool in_state) { if (in_state) modifiers |= _key_right_shift; else modifiers &= ~(_key_right_shift); }

	/*!	Sets the state of the left shift key modifier
	*	\param in_state <span class='code'>true</span> if the left shift key is active, <span class='code'>false</span> otherwise. */
	void LeftShift(bool in_state) { if (in_state) modifiers |= _key_left_shift; else modifiers &= ~(_key_left_shift); }

	/*!	Sets the state of the right control key modifier
	*	\param in_state <span class='code'>true</span> if the right control key is active, <span class='code'>false</span> otherwise. */
	void RightControl(bool in_state) { if (in_state) modifiers |= _key_right_control; else modifiers &= ~(_key_right_control); }

	/*!	Sets the state of the left control key modifier
	*	\param in_state <span class='code'>true</span> if the left control key is active, <span class='code'>false</span> otherwise. */
	void LeftControl(bool in_state) { if (in_state) modifiers |= _key_left_control; else modifiers &= ~(_key_left_control); }

	/*!	Sets the state of the right alt key modifier
	*	\param in_state <span class='code'>true</span> if the right alt key is active, <span class='code'>false</span> otherwise. */
	void RightAlt(bool in_state) { if (in_state) modifiers |= _key_right_alt; else modifiers &= ~(_key_right_alt); }

	/*!	Sets the state of the left alt key modifier
	*	\param in_state <span class='code'>true</span> if the left alt key is active, <span class='code'>false</span> otherwise. */
	void LeftAlt(bool in_state) { if (in_state) modifiers |= _key_left_alt; else modifiers &= ~(_key_left_alt); }

	/*!	Sets the state of the right meta key modifier
	*	\param in_state <span class='code'>true</span> if the right meta key is active, <span class='code'>false</span> otherwise. */
	void RightMeta(bool in_state) { if (in_state) modifiers |= _key_right_meta; else modifiers &= ~(_key_right_meta); }

	/*!	Sets the state of the left meta key modifier
	*	\param in_state <span class='code'>true</span> if the left meta key is active, <span class='code'>false</span> otherwise. */
	void LeftMeta(bool in_state) { if (in_state) modifiers |= _key_left_meta; else modifiers &= ~(_key_left_meta); }

	/*!	Merges the buttons from two ModifierKeys objects.
	*	\param in_modifiers_to_merge A collection of modifiers to merge with the modifiers of this object.
	*	\return A new ModifierKeys object. */
	ModifierKeys operator+ (ModifierKeys const & in_modifiers_to_merge)
	{
		ModifierKeys ret;
		ret.modifiers = modifiers | in_modifiers_to_merge.modifiers;
		return ret;
	}

	/*!	Creates a new ModifierKeys object representing the removal of the modifiers of another ModifierKeys object from this object.
	*	\param in_modifiers_to_remove A collection of modifiers to remove from those of this object.
	*	\return A new ModifierKeys object. */
	ModifierKeys operator- (ModifierKeys const & in_modifiers_to_remove)
	{
		ModifierKeys ret;
		ret.modifiers = modifiers & ~in_modifiers_to_remove.modifiers;
		return ret;
	}

	/*!	Merges the modifiers from another ModifierKeys object into this one.
	*	\param in_modifiers_to_merge A collection of modifiers to merge with the modifiers of this object.
	*	\return A reference to this object. */
	ModifierKeys & operator+= (ModifierKeys const & in_modifiers_to_merge) { *this = *this + in_modifiers_to_merge; return *this; }

	/*!	Removes the modifiers of another ModifierKeys object from this one.
	*	\param in_modifiers_to_remove A collection of modifiers to remove from those of this object.
	*	\return A reference to this object. */
	ModifierKeys & operator-= (ModifierKeys const & in_modifiers_to_remove) { *this = *this - in_modifiers_to_remove; return *this; }


	/*!	Creates a new ModifierKeys object with the shift key active.
	*   Use this function if your application does not need to differentiate between left and right shift buttons
	*	\return A new ModifierKeys object with the shift key active. */
	static ModifierKeys KeyShift() { ModifierKeys ret; ret.Shift(true); return ret; }

	/*!	Creates a new ModifierKeys object with the control key active.
	*   Use this function if your application does not need to differentiate between left and right control buttons
	*	\return A new ModifierKeys object with the control key active. */
	static ModifierKeys KeyControl() { ModifierKeys ret; ret.Control(true); return ret; }

	/*!	Creates a new ModifierKeys object with the alt key active.
	*   Use this function if your application does not need to differentiate between left and right alt buttons
	*	\return A new ModifierKeys object with the alt key active. */
	static ModifierKeys KeyAlt() { ModifierKeys ret; ret.Alt(true); return ret; }

	/*!	Creates a new ModifierKeys object with the meta key active.
	*   Use this function if your application does not need to differentiate between left and right meta buttons
	*	\return A new ModifierKeys object with the meta key active. */
	static ModifierKeys KeyMeta() { ModifierKeys ret; ret.Meta(true); return ret; }

	/*!	Creates a new ModifierKeys object with the caps lock key active.
	*	\return A new ModifierKeys object with the caps lock key active. */
	static ModifierKeys KeyCapsLock() { ModifierKeys ret; ret.CapsLock(true); return ret; }

	/*!	Creates a new ModifierKeys object with the num lock key active.
	*	\return A new ModifierKeys object with the num lock key active. */
	static ModifierKeys KeyNumLock() { ModifierKeys ret; ret.NumLock(true); return ret; }

	/*!	Creates a new ModifierKeys object with the scroll lock key active.
	*	\return A new ModifierKeys object with the scroll lock key active. */
	static ModifierKeys KeyScrollLock() { ModifierKeys ret; ret.ScrollLock(true); return ret; }

	/*!	Creates a new ModifierKeys object with the right shift key active.
	*	\return A new ModifierKeys object with the right shift key active. */
	static ModifierKeys KeyRightShift() { ModifierKeys ret; ret.RightShift(true); return ret; }

	/*!	Creates a new ModifierKeys object with the left shift key active.
	*	\return A new ModifierKeys object with the left shift key active. */
	static ModifierKeys KeyLeftShift() { ModifierKeys ret; ret.LeftShift(true); return ret; }

	/*!	Creates a new ModifierKeys object with the right control key active.
	*	\return A new ModifierKeys object with the right control key active. */
	static ModifierKeys KeyRightControl() { ModifierKeys ret; ret.RightControl(true); return ret; }

	/*!	Creates a new ModifierKeys object with the left control key active.
	*	\return A new ModifierKeys object with the left control key active. */
	static ModifierKeys KeyLeftControl() { ModifierKeys ret; ret.LeftControl(true); return ret; }

	/*!	Creates a new ModifierKeys object with the right alt key active.
	*	\return A new ModifierKeys object with the right alt key active. */
	static ModifierKeys KeyRightAlt() { ModifierKeys ret; ret.RightAlt(true); return ret; }

	/*!	Creates a new ModifierKeys object with the left alt key active.
	*	\return A new ModifierKeys object with the left alt key active. */
	static ModifierKeys KeyLeftAlt() { ModifierKeys ret; ret.LeftAlt(true); return ret; }

	/*!	Creates a new ModifierKeys object with the right meta key active.
	*	\return A new ModifierKeys object with the right meta key active. */
	static ModifierKeys KeyRightMeta() { ModifierKeys ret; ret.RightMeta(true); return ret; }

	/*!	Creates a new ModifierKeys object with the left meta key active.
	*	\return A new ModifierKeys object with the left meta key active. */
	static ModifierKeys KeyLeftMeta() { ModifierKeys ret; ret.LeftMeta(true); return ret; }

protected:

	/*! \enum Modifiers
	* 	Modifier key bitfield constants. */
	enum Modifiers
	{
		_key_none			= 0x0000,
		_key_caps_lock		= 0x0001,
		_key_num_lock		= 0x0002,
		_key_scroll_lock	= 0x0004,
		_key_right_shift	= 0x0008,
		_key_left_shift		= 0x0010,
		_key_right_control	= 0x0020,
		_key_left_control	= 0x0040,
		_key_right_alt		= 0x0080,
		_key_left_alt		= 0x0100,
		_key_right_meta		= 0x0200,
		_key_left_meta		= 0x0400,
		_key_shift			= _key_left_shift | _key_right_shift,
		_key_control		= _key_left_control | _key_right_control,
		_key_alt			= _key_left_alt | _key_right_alt,
		_key_meta			= _key_left_meta | _key_right_meta,
	};

	int modifiers;
};


/*!	The InputEvent class is the base class for input events such as MouseEvent, TouchEvent, and KeyboardEvent.
*	It contains functionality which is common to all input event types, namely the state of modifier keys. */
class HPS_API InputEvent : public Event
{
public:

	/*! This constructor creates a default InputEvent object. */
	InputEvent() : Event() { channel = GetClassID(); }

	/*! This constructor creates a new InputEvent with the specified modifier keys initialized.
	 * 	\param in_modifiers The modifier keys associated with the new Event. */
	InputEvent(ModifierKeys const & in_modifiers) : Event(), ModifierKeyState(in_modifiers) { channel = GetClassID(); }

	~InputEvent();

	/*! Allocates and returns a copy of this InputEvent.
	 * 	\return A copy of this InputEvent. */
	Event * Clone() const
	{
		InputEvent * new_event = new InputEvent(*this);
		return new_event;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(InputEvent const & in_that) const
	{
		if ( GetClassID() == in_that.GetClassID())
			return ModifierKeyState == in_that.ModifierKeyState;
		return false;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (InputEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (InputEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	/*! Queries which modifier keys are active
	 *	\return A ModifierKeys object, which represents which modifier keys are active */
	ModifierKeys GetModifierKeys() const
	{
		return ModifierKeyState;
	}

	ModifierKeys ModifierKeyState;	//!< The modifier keys which are active for this InputEvent.
};

/*!	The TouchEvent class is the event generated for each touch action on a multi-touch device. */
class HPS_API TouchEvent : public InputEvent
{
public:
	/*!	\enum Action
	 * 	Enumeration of various actions touches can undergo for a TouchEvent. */
	enum class Action : uint32_t
	{
		TouchDown,	//!< A touch, or touches, has just gone down.
		TouchUp,	//!< A touch, or touches, has just gone up.
		Move,		//!< A touch, or touches, has just moved.
	};

	/*! The default constructor creates an uninitialized TouchEvent object. */
	TouchEvent() : InputEvent() { channel = GetClassID(); }

	/*! This constructor creates a TouchEvent object for a given action without an array of Touches.
	 *  Specifying TouchUp without an array of Touches clears tracked touches.
	 * 	\param in_action Action of this TouchEvent.
	 * 	\param in_modifier The modifier keys for this TouchEvent. */
	TouchEvent(Action in_action, ModifierKeys in_modifier = ModifierKeys())
		: InputEvent(in_modifier), CurrentAction(in_action) { channel = GetClassID(); }

	/*! This constructor creates a TouchEvent object for a given action with an array of Touches.
	 *  Specifying TouchUp with an empty an array of Touches clears tracked touches.
	 * 	\param in_action Action of this TouchEvent.
	 *	\param in_touches An array or touches for this TouchEvent.
	 * 	\param in_modifier The modifier keys for this TouchEvent. */
	TouchEvent(Action in_action, TouchArray const & in_touches, ModifierKeys in_modifier = ModifierKeys())
		: InputEvent(in_modifier), CurrentAction(in_action), Touches(in_touches) { channel = GetClassID(); }

	/*! This constructor creates a TouchEvent object for a given action with an array of Touches.
	 *  Specifying TouchUp with an empty an array of Touches clears tracked touches.
	 * 	\param in_action Action of this TouchEvent.
	 *	\param in_touch_count the number of Touches in the touch array.
	 *	\param in_touches An array or touches for this TouchEvent.
	 * 	\param in_modifier The modifier keys for this TouchEvent. */
	TouchEvent(Action in_action, size_t in_touch_count, Touch const in_touches[], ModifierKeys in_modifier = ModifierKeys())
		: InputEvent(in_modifier), CurrentAction(in_action), Touches(in_touches, in_touches + in_touch_count) { channel = GetClassID(); }


	/*! This constructor converts an Event Object to a TouchEvent object.
	 * 	\param in_event The Event Object to be converted. */
	TouchEvent(Event const & in_event) : InputEvent()
	{
		if(in_event.GetChannel() == Object::ClassID<TouchEvent>())
		{
			TouchEvent const * event = static_cast<TouchEvent const *>(&in_event);
			channel = GetClassID();
			CurrentAction = event->CurrentAction;
			Touches = event->Touches;
			ModifierKeyState = event->ModifierKeyState;
		}
		else
			throw HPS::InvalidSpecificationException("Invalid Event type to cast from.");
	}

	~TouchEvent();


	/*! Allocates and returns a copy of this TouchEvent.
	 * 	\return A copy of this TouchEvent. */
	Event * Clone() const
	{
		TouchEvent * new_event = new TouchEvent(*this);
		return new_event;
	}

	/*! Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(InputEvent const & in_that) const
	{
		if (GetClassID() == in_that.GetClassID())
			return Equals(static_cast<TouchEvent>(in_that));
		return false;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool Equals(TouchEvent const & in_that) const
	{
		return InputEvent::Equals(in_that) && Touches == in_that.Touches && CurrentAction == in_that.CurrentAction;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (TouchEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (TouchEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	/*! Determines if this TouchEvent can be dropped in favor of the following touch event.
	 * 	\param in_that_event Event to compare with this TouchEvent.
	 * 	\return <span class='code'>true</span> if this event can be dropped, <span class='code'>false</span> otherwise. */
	virtual bool Drop(Event const * in_that_event) const
	{
		HPS::TouchEvent const * that_touch_event = static_cast<HPS::TouchEvent const *>(in_that_event);

		if (CurrentAction == that_touch_event->CurrentAction && CurrentAction == Action::Move
			&& Touches.size() == that_touch_event->Touches.size() )
		{
			TouchArray these_touches = Touches;
			TouchArray those_touches = that_touch_event->Touches;

			std::sort(those_touches.begin(), those_touches.end(), sort_predicate);
			std::sort(these_touches.begin(), these_touches.end(), sort_predicate);

			for (size_t i = 0 ; i < these_touches.size() ; i++)
			{
				if (these_touches[i].ID != those_touches[i].ID)
					return false;
			}
			return true;
		}

		return false;
	}

	HPS::TouchEvent::Action CurrentAction;	//!< The action for the touches of this TouchEvent.
	HPS::TouchArray Touches;				//!< Array of Touches for this TouchEvent.

private:
	/*! Private method used for sorting Touch objects.
	 * 	\param in_a First Touch to compare with the second Touch.
	 * 	\param in_b Second Touch to compare with the first Touch.
	 *	\return <span class='code'>true</span> if the first Touch should be placed before the second Touch,
	 *		<span class='code'>false</span> otherwise. */
	static bool sort_predicate(Touch const & in_a, Touch const & in_b)
	{
		return static_cast<int>(in_a.ID) < static_cast<int>(in_b.ID);
	}
};


/*!	Mouse buttons that could be active for a MouseEvent. */
class HPS_API MouseButtons
{
public:
	/*!	The default constructor creates a MouseButtons object with no modifiers active. */
	MouseButtons() : buttons(_button_none) {}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool Equals(MouseButtons const & in_that) const
	{
		return buttons == in_that.buttons;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool operator== (MouseButtons const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool operator!= (MouseButtons const & in_that) const
	{
		return !Equals(in_that);
	}

	/*!	Indicates whether no buttons are active.
	*	\return <span class='code'>true</span> if no mouse buttons are active, <span class='code'>false</span> otherwise. */
	bool None() const { return buttons == _button_none; }

	/*!	Indicates whether the left button is down.
	*	\return <span class='code'>true</span> if the left button is down, <span class='code'>false</span> otherwise. */
	bool Left() const { return (buttons & _button_left) != 0; }

	/*!	Indicates whether the right button is down.
	*	\return <span class='code'>true</span> if the right button is down, <span class='code'>false</span> otherwise. */
	bool Right() const { return (buttons & _button_right) != 0; }

	/*!	Indicates whether the middle button is down.
	*	\return <span class='code'>true</span> if the middle button is down, <span class='code'>false</span> otherwise. */
	bool Middle() const { return (buttons & _button_middle) != 0; }

	/*!	Indicates whether the X1 button is down.
	*	\return <span class='code'>true</span> if the X1 button is down, <span class='code'>false</span> otherwise. */
	bool X1() const { return (buttons & _button_x1) != 0; }

	/*!	Indicates whether the X2 button is down.
	*	\return <span class='code'>true</span> if the X2 button is down, <span class='code'>false</span> otherwise. */
	bool X2() const { return (buttons & _button_x2) != 0; }


	/*!	Indicates whether all buttons of the input parameter are present in this object.
	*	\param in_buttons A collection of mouse buttons to check against this object.
	*	\return <span class='code'>true</span> if all of the input buttons are active, <span class='code'>false</span> otherwise. */
	bool HasAll(MouseButtons const & in_buttons) const { return (buttons & in_buttons.buttons) == in_buttons.buttons; }

	/*!	Indicates whether any buttons of the input parameter are present in this object.
	*	\param in_buttons A collection of mouse buttons to check against this object.
	*	\return <span class='code'>true</span> if any of the input buttons are active, <span class='code'>false</span> otherwise. */
	bool HasAny(MouseButtons const & in_buttons) const { return (buttons & in_buttons.buttons) != 0; }

	/*!	Sets the state of the left button.
	*	\param in_state <span class='code'>true</span> if the button is down, <span class='code'>false</span> otherwise. */
	void Left(bool in_state) { if(in_state) buttons |= _button_left; else buttons &= ~(_button_left); }

	/*!	Sets the state of the right button.
	*	\param in_state <span class='code'>true</span> if the button is down, <span class='code'>false</span> otherwise. */
	void Right(bool in_state) { if(in_state) buttons |= _button_right; else buttons &= ~(_button_right); }

	/*!	Sets the state of the middle button.
	*	\param in_state <span class='code'>true</span> if the button is down, <span class='code'>false</span> otherwise. */
	void Middle(bool in_state) { if(in_state) buttons |= _button_middle; else buttons &= ~(_button_middle); }

	/*!	Sets the state of the X1 button.
	*	\param in_state <span class='code'>true</span> if the button is down, <span class='code'>false</span> otherwise. */
	void X1(bool in_state) { if(in_state) buttons |= _button_x1; else buttons &= ~(_button_x1); }

	/*!	Sets the state of the X2 button.
	*	\param in_state <span class='code'>true</span> if the button is down, <span class='code'>false</span> otherwise. */
	void X2(bool in_state) { if(in_state) buttons |= _button_x2; else buttons &= ~(_button_x2); }

	/*!	Merges the buttons from two MouseButtons objects.
	*	\param in_buttons_to_merge A collection of mouse buttons to merge with the buttons of this object.
	*	\return A new MouseButtons object. */
	MouseButtons operator+ (MouseButtons const & in_buttons_to_merge)
	{
		MouseButtons ret;
		ret.buttons = buttons | in_buttons_to_merge.buttons;
		return ret;
	}

	/*!	Creates a new MouseButtons object representing the removal of the buttons of another MouseButtons object from this object.
	*	\param in_buttons_to_remove A collection of mouse buttons to remove from those of this object.
	*	\return A new MouseButtons object. */
	MouseButtons operator- (MouseButtons const & in_buttons_to_remove)
	{
		MouseButtons ret;
		ret.buttons = buttons & ~in_buttons_to_remove.buttons;
		return ret;
	}

	/*!	Merges the buttons from another MouseButtons object into this one.
	*	\param in_buttons_to_merge A collection of mouse buttons to merge with the buttons of this object.
	*	\return A reference to this object. */
	MouseButtons & operator+= (MouseButtons const & in_buttons_to_merge) { *this = *this + in_buttons_to_merge; return *this; }

	/*!	Removes the buttons of another MouseButtons object from this one.
	*	\param in_buttons_to_remove A collection of mouse buttons to remove from those of this object.
	*	\return A reference to this object. */
	MouseButtons & operator-= (MouseButtons const & in_buttons_to_remove) { *this = *this - in_buttons_to_remove; return *this; }


	/*!	Creates a new MouseButtons object with the left button active.
	*	\return A new MouseButtons object with the left button active. */
	static MouseButtons ButtonLeft() { MouseButtons ret; ret.Left(true); return ret; }

	/*!	Creates a new MouseButtons object with the right button active.
	*	\return A new MouseButtons object with the right button active. */
	static MouseButtons ButtonRight() { MouseButtons ret; ret.Right(true); return ret; }

	/*!	Creates a new MouseButtons object with the middle button active.
	*	\return A new MouseButtons object with the middle button active. */
	static MouseButtons ButtonMiddle() { MouseButtons ret; ret.Middle(true); return ret; }

	/*!	Creates a new MouseButtons object with the X1 button active.
	*	\return A new MouseButtons object with the X1 button active. */
	static MouseButtons ButtonX1() { MouseButtons ret; ret.X1(true); return ret; }

	/*!	Creates a new MouseButtons object with the X2 button active.
	*	\return A new MouseButtons object with the X2 button active. */
	static MouseButtons ButtonX2() { MouseButtons ret; ret.X2(true); return ret; }

protected:

	/*! \enum Buttons
	* 	Mouse button bitfield constants. */
	enum Buttons
	{
		_button_none		= 0x0000,
		_button_left		= 0x0001,
		_button_right		= 0x0002,
		_button_middle		= 0x0004,
		_button_x1			= 0x0008,
		_button_x2			= 0x0010
	};

	int buttons;
};

/*!	The MouseEvent class is the event generated for each mouse action. */
class HPS_API MouseEvent : public InputEvent
{
public:

	/*!	\enum Action
	 * 	Enumeration of various actions a mouse can undergo for a MouseEvent. */
	enum class Action : uint32_t
	{
		ButtonUp,		//! A mouse button has been released.
		ButtonDown,		//! A mouse button has been pressed.
		Move,			//! The mouse location has changed.
		Scroll,			//! The scroll wheel has been moved.
		Enter,			//! The mouse cursor has moved into the active window.
		Leave			//! The mouse cursor has moved out of the active window.
	};

	/*! The default constructor creates an uninitialized MouseEvent object. */
	MouseEvent() : InputEvent() { channel = GetClassID(); }

	/*! This constructor creates a MouseEvent object for a given action.
	 * 	\param in_action Action of this MouseEvent.
	 * 	\param in_location The location in window space of the mouse cursor.
	 * 	\param in_button If the action is a button event, this is the button.
	 * 	\param in_modifier The modifier keys for this MouseEvent.
	 * 	\param in_click_count The number of clicks received. */
	MouseEvent(Action in_action, WindowPoint in_location, MouseButtons in_button = MouseButtons(), ModifierKeys in_modifier = ModifierKeys(), size_t in_click_count = 0)
		: InputEvent(in_modifier), CurrentAction(in_action), Location(in_location), CurrentButton(in_button), WheelDelta(0), ClickCount(in_click_count) { channel = GetClassID(); }

	/*! This constructor creates a MouseEvent object, most useful for a wheel action.
	 * 	\param in_action Action of the mouse for this MouseEvent.
	 *	\param in_wheel_delta If the action involves the mouse wheel, this is the amount the wheel moved.
		It is positive if the mouse wheel is moved forward (away from the user) or negative if the mouse wheel is moved downward (toward the user).
	* 	\param in_location The location in window space of the mouse cursor.
	* 	\param in_modifier The modifier keys for this MouseEvent.
	* 	\param in_click_count The number of clicks received. */
	MouseEvent(Action in_action, float in_wheel_delta, WindowPoint in_location = WindowPoint(0,0,0), ModifierKeys in_modifier = ModifierKeys(), size_t in_click_count = 0)
		: InputEvent(in_modifier), CurrentAction(in_action), Location(in_location), WheelDelta(in_wheel_delta), ClickCount(in_click_count) { channel = GetClassID(); }

	/*! This constructor converts an Event Object to a MouseEvent object.
	 * 	\param in_event The Event Object to be converted. */
	MouseEvent(Event const & in_event) : InputEvent()
	{
		if(in_event.GetChannel() == Object::ClassID<MouseEvent>())
		{
			MouseEvent const * event = static_cast<MouseEvent const *>(&in_event);
			channel = GetClassID();
			CurrentAction = event->CurrentAction;
			Location = event->Location;
			CurrentButton = event->CurrentButton;
			WheelDelta = event->WheelDelta;
			ClickCount = event->ClickCount;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	~MouseEvent();

	/*! Allocates and returns a copy of this MouseEvent.
	 * 	\return A copy of this MouseEvent. */
	Event * Clone() const
	{
		MouseEvent * new_event = new MouseEvent(*this);
		return new_event;
	}

	/*! Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(InputEvent const & in_that) const
	{
		if (GetClassID() == in_that.GetClassID())
			return Equals(static_cast<MouseEvent>(in_that));
		return false;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(MouseEvent const & in_that) const
	{
		return InputEvent::Equals(in_that) && CurrentAction == in_that.CurrentAction
			&& CurrentButton == in_that.CurrentButton && WheelDelta == in_that.WheelDelta
			&& Location == in_that.Location && ClickCount == in_that.ClickCount;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (MouseEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_kit The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (MouseEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	/*! Determines if this MouseEvent can be dropped in favor of the following mouse event.
	 * 	\param in_that_event Event to compare with this MouseEvent.
	 * 	\return <span class='code'>true</span> if this event can be dropped, <span class='code'>false</span> otherwise. */
	virtual bool Drop(Event const * in_that_event) const
	{
		HPS::MouseEvent const * that_mouse_event = static_cast<HPS::MouseEvent const *>(in_that_event);

		if (CurrentAction == that_mouse_event->CurrentAction &&
			(CurrentAction == Action::ButtonDown || CurrentAction == Action::ButtonUp || CurrentAction == Action::Move) &&
			CurrentButton == that_mouse_event->CurrentButton)
			return true;

		return false;
	}

	virtual intptr_t Freshen() const {

		if (CurrentAction == Action::Move)
			return GetClassID();

		return 0;
	}

	HPS::MouseEvent::Action			CurrentAction;	//!< The action for this MouseEvent.
	WindowPoint						Location;		//!< Location in window space of the mouse cursor.
	HPS::MouseButtons				CurrentButton;	//!< If the action involves a button, this is the button.
	float							WheelDelta;		//!< If the action involves the mouse wheel, this is the amount the wheel moved.  It is positive if the mouse wheel is moved forward (away from the user) or negative if the mouse wheel is moved downward (toward the user).
	size_t							ClickCount;		//!< The number of clicks received
};


/*! The KeyboardEvent class is the event generated for each key press and release. */
class HPS_API KeyboardEvent : public InputEvent
{
public:
	/*!	\enum Action
	 * 	Enumeration of various states keyboard codes can have for a KeyboardEvent. */
	enum class Action : uint32_t
	{
		None,		//!< Key is not currently pressed, nor was it just released.
		KeyDown,	//!< Key was pressed.
		KeyUp		//!< Key was released.
	};

	/*! The default constructor creates a KeyboardEvent object with no current action nor any keyboard codes. */
	KeyboardEvent() : InputEvent(), CurrentAction(Action::None) { channel = GetClassID(); }

	/*! This constructor creates a KeyboardEvent object for a given action without any keyboard codes.
	 * 	\param in_action Action of the keys for this KeyboardEvent.
	 * 	\param in_modifiers The modifier keys for this KeyboardEvent. */
	KeyboardEvent(KeyboardEvent::Action in_action, ModifierKeys in_modifiers = ModifierKeys())
		: InputEvent(in_modifiers), CurrentAction(in_action) { channel = GetClassID(); }

	/*! This constructor creates a KeyboardEvent object for a given action with a list of keyboard codes.
	 * 	\param in_action Action of the keys for this KeyboardEvent.
	 * 	\param in_keyboardcode_count Size of the following array.
	 * 	\param in_keyboardcodes Array of the keyboard codes for this KeyboardEvent.
	 * 	\param in_modifiers The modifier keys for this KeyboardEvent. */
	KeyboardEvent(KeyboardEvent::Action in_action, size_t in_keyboardcode_count, HPS::KeyboardCode const in_keyboardcodes[], ModifierKeys in_modifiers = ModifierKeys())
		: InputEvent(in_modifiers), CurrentAction(in_action)
	{
		channel = GetClassID();
		KeyboardCodes.assign(in_keyboardcodes, in_keyboardcodes + in_keyboardcode_count);
	}

	/*! This constructor creates a KeyboardEvent object for a given action with a list of keyboard codes.
	 * 	\param in_action Action of the keys for this KeyboardEvent.
	 * 	\param in_keyboardcodes Array of the keyboard codes for this KeyboardEvent.
	 * 	\param in_modifiers The modifier keys for this KeyboardEvent. */
	KeyboardEvent(KeyboardEvent::Action in_action, KeyboardCodeArray const & in_keyboardcodes, ModifierKeys in_modifiers = ModifierKeys())
		: InputEvent(in_modifiers), CurrentAction(in_action)
	{
		channel = GetClassID();
		KeyboardCodes = in_keyboardcodes;
	}

	/*! This constructor converts an Event Object to a MouseEvent object.
	 * 	\param in_event The Event Object to be converted. */
	KeyboardEvent(Event const & in_event) : InputEvent()
	{
		if(in_event.GetChannel() == Object::ClassID<KeyboardEvent>())
		{
			KeyboardEvent const * event = static_cast<KeyboardEvent const *>(&in_event);
			channel = GetClassID();
			KeyboardCodes = event->KeyboardCodes;
			CurrentAction = event->CurrentAction;
		}
		else
		{
			throw HPS::InvalidSpecificationException("Invalid Event Type to Cast From.");
		}
	}

	~KeyboardEvent();

	/*! Allocates and returns a copy of this KeyboardEvent.
	 * 	\return A copy of this KeyboardEvent. */
	Event * Clone() const
	{
		KeyboardEvent * new_event = new KeyboardEvent(*this);
		return new_event;
	}

	/*! Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(InputEvent const & in_that) const
	{
		if (GetClassID() == in_that.GetClassID())
			return Equals(static_cast<KeyboardEvent>(in_that));
		return false;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool Equals(KeyboardEvent const & in_that) const
	{
		return InputEvent::Equals(in_that) && CurrentAction == in_that.CurrentAction && KeyboardCodes == in_that.KeyboardCodes;
	}

	/*!	Check if the source object is equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator== (KeyboardEvent const & in_that) const
	{
		return Equals(in_that);
	}

	/*!	Check if the source object is not equivalent to this object.
	*	\param in_that The source object to compare to this object.
	*	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	virtual bool operator!= (KeyboardEvent const & in_that) const
	{
		return !Equals(in_that);
	}

	/*! Sets the keyboard codes for this KeyboardEvent.
	 * 	\param in_keyboardcode_count Size of the following array.
	 * 	\param in_keyboardcodes Array of the keyboard codes for this KeyboardEvent. */
	void SetKeyboardCodes(size_t in_keyboardcode_count, HPS::KeyboardCode const in_keyboardcodes[])
	{
		KeyboardCodes.assign(in_keyboardcodes, in_keyboardcodes + in_keyboardcode_count);
	}

	/*! Sets the keyboard codes for this KeyboardEvent.
	 * 	\param in_keyboardcodes Array of the keyboard codes for this KeyboardEvent. */
	void SetKeyboardCodes(HPS::KeyboardCodeArray const & in_keyboardcodes)
	{
		KeyboardCodes = in_keyboardcodes;
	}

	HPS::KeyboardCodeArray		KeyboardCodes;	//!< Array of keyboard codes for this KeyboardEvent.
	HPS::KeyboardEvent::Action	CurrentAction;	//!< The action for the keyboard codes for this KeyboardEvent.
};


/*!	The MouseState class represents the state of the mouse or similar pointer device for a particular event. */
class HPS_API MouseState : public Object
{
public:
	/*! The default constructor creates an empty MouseState object. */
	MouseState();

	/*! The copy constructor creates a new MouseState object that contains the same settings as the source MouseState.
	 * 	\param in_that The source MouseState to copy. */
	MouseState(MouseState const & in_that);

	/*! The move constructor creates a MouseState by transferring the underlying impl of the rvalue reference to this MouseState
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a MouseState to take the impl from. */
	MouseState(MouseState && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this MouseState thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a MouseState to take the impl from.
	 * 	\return A reference to this MouseState. */
	MouseState & operator=(MouseState && in_that);

	~MouseState();

	static const HPS::Type staticType = HPS::Type::MouseState;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Copies the source MouseState into this MouseState.
	 * 	\param in_that The source MouseState to copy. */
	void						Assign(MouseState const & in_that);

	/*! Copies the source MouseState into this MouseState.
	 * 	\param in_that The source MouseState to copy.
	 * 	\return A reference to this MouseState. */
	MouseState &				operator=(MouseState const & in_that);

	/*!	Check if the source MouseState is equivalent to this MouseState.
	 *	\param in_kit The source MouseState to compare to this MouseState.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(MouseState const & in_that) const;

	/*!	Check if the source MouseState is equivalent to this MouseState.
	 *	\param in_kit The source MouseState to compare to this MouseState.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator== (MouseState const & in_that) const;

	/*!	Check if the source MouseState is not equivalent to this MouseState.
	 *	\param in_kit The source MouseState to compare to this MouseState.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!= (MouseState const & in_that) const;

	/*!	Checks if this MouseState has all of the specified properties.
	 *	\param in_mouse_trigger The mouse button properties to test for.
	 *	\param in_modifier_trigger The modifier keys properties to test for.
	 *	\return <span class='code'>true</span> if this MouseState has all of the specified properties, <span class='code'>false</span> otherwise. */
	bool						HasAll(MouseButtons in_mouse_trigger, ModifierKeys in_modifier_trigger) const;

	/*!	Sets the properties of this MouseState.
	 * \param in_path The list of keys up to the window which had focus for this mouse event.
	 * \param in_event The mouse event.
	 * \param in_point The location, in window space of the mouse cursor for this mouse event.
	 * \param in_buttons The state of the mouse buttons immediately after this mouse event.
	 * \param in_modifiers The state of modifier keys for this mouse event.*/
	void						Set(KeyArray const & in_path, MouseEvent const & in_event, WindowPoint const & in_point, MouseButtons in_buttons = MouseButtons(), ModifierKeys in_modifiers = ModifierKeys());

	/*! Get the active event for this MouseState.  This will throw an exception if there is no active action for this MouseState.
	 * 	\return The action for this MouseState. */
	HPS::MouseEvent				GetActiveEvent() const;

	/*! Get the window which had focus when the mouse represented by this MouseState underwent the active action.
	 *  This will throw an exception if there is no event source for this MouseState.
	 * 	\return The window which had focus when the mouse represented by this MouseState underwent the active action. */
	HPS::WindowKey				GetEventSource() const;

	/*! Get the relevant list of keys up to the window which had focus when the mouse represented by this MouseState underwent the active action.
	 *  This will throw an exception if there is no event path for this MouseState.
	 * 	\return The relevant list of keys up to the window which had focus when the mouse event represented by this MouseState underwent the active action. */
	HPS::KeyArray				GetEventPath() const;

	/*! Get the current state of the mouse buttons immediately after the active event.
	*	\return The state of the mouse buttons. */
	MouseButtons				GetButtons() const;

	/*! Get the current mouse position.
	*	\return The location, in window space of the mouse cursor. */
	WindowPoint					GetLocation() const;

	/*! Get an object representing the state of modifier keys for this MouseState.
	*	\return An object representing the state of modifier keys. */
	ModifierKeys				GetModifierKeys() const;

	/*! Sets the active event for this MouseState.
	 * 	\param in_event The action for this MouseState. */
	void SetActiveEvent(MouseEvent const & in_event);

	/*! Sets the relevant list of keys up to the window which had focus for this mouse event.
	 * 	\param in_path The relevant list of keys up to the window which had focus when the mouse event represented by this MouseState underwent the active action. */
	void SetEventPath(KeyArray const & in_path);

	/*! Sets the current state of the mouse buttons immediately after the active event.
	*	\param in_buttons The state of the mouse buttons. */
	void SetButtons(MouseButtons in_buttons);

	/*! Sets the current mouse position.
	*	\param in_point The location, in window space of the mouse cursor. */
	void SetLocation(WindowPoint const & in_point);

	/*! Sets an object representing the state of modifier keys for this MouseState.
	*	\param in_modifiers An object representing the state of modifier keys. */
	void SetModifierKeys(ModifierKeys in_modifiers);
};



/*!	The TouchState class represents the state of touches on a multi-touch device for a particular event. */
class HPS_API TouchState : public Object
{
public:
	/*! The default constructor creates an empty TouchState object. */
	TouchState();

	/*! The copy constructor creates a new TouchState object that contains the same settings as the source TouchState.
	 * 	\param in_that The source TouchState to copy. */
	TouchState(TouchState const & in_that);

	/*! The move constructor creates a TouchState by transferring the underlying impl of the rvalue reference to this TouchState
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a TouchState to take the impl from. */
	TouchState(TouchState && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this TouchState thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a TouchState to take the impl from.
	 * 	\return A reference to this TouchState. */
	TouchState & operator=(TouchState && in_that);

	~TouchState();

	static const HPS::Type staticType = HPS::Type::TouchState;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Copies the source TouchState into this TouchState.
	 * 	\param in_that The source TouchState to copy. */
	void						Assign(TouchState const & in_that);

	/*! Copies the source TouchState into this TouchState.
	 * 	\param in_that The source TouchState to copy.
	 * 	\return A reference to this TouchState. */
	TouchState &				operator=(TouchState const & in_that);

	/*!	Check if the source TouchState is equivalent to this TouchState.
	 *	\param in_kit The source TouchState to compare to this TouchState.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(TouchState const & in_that) const;

	/*!	Check if the source TouchState is equivalent to this TouchState.
	 *	\param in_kit The source TouchState to compare to this TouchState.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator== (TouchState const & in_that) const;

	/*!	Check if the source TouchState is not equivalent to this TouchState.
	 *	\param in_kit The source TouchState to compare to this TouchState.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!= (TouchState const & in_that) const;

	/*!	Sets the properties of this TouchState.
	 * \param in_path The list of keys up to the window which had focus for this touch event.
	 * \param in_event The touch event.
	 * \param in_touches The touches down during this touch event.
	 * \param in_modifiers The state of modifier keys for this touch event.*/
	void						Set(KeyArray const & in_path, TouchEvent const & in_event, TouchArray const & in_touches, ModifierKeys in_modifiers = ModifierKeys());

	/*! Get the active event for this TouchState.  This will throw an exception if there is no active action for this TouchState.
	*	\return The action for the active touches for this TouchState. */
	HPS::TouchEvent				GetActiveEvent() const;

	/*! Get the window which had focus when the touches represented by this TouchState underwent the active action.
	 *  This will throw an exception if there is no event source for this TouchState.
	 * 	\return The window which had focus when the touches represented by this TouchState underwent the active action. */
	HPS::WindowKey				GetEventSource() const;

	/*! Get the relevant list of keys up to the window which had focus when the touches represented by this TouchState underwent the active action.
	*	This will throw an exception if there is no event path for this TouchState.
	*	\return The relevant list of keys up to the window which had focus when the touches represented by this TouchState underwent the active action. */
	HPS::KeyArray				GetEventPath() const;

	/*! Get the number of touches currently down in this TouchState.
	*	\return Number of touches. */
	size_t						GetTouchCount() const;

	/*! Get the touches currently down in this TouchState.
	*	\return The list of touches. */
	HPS::TouchArray				GetTouches() const;

	/*! Get an object representing the state of modifier keys for this TouchState.
	 *	\return An object representing the state of modifier keys.  */
	ModifierKeys				GetModifierKeys() const;

	/*! Sets the active event for this TouchState.
	 * 	\param in_event The action for this TouchState. */
	void SetActiveEvent(TouchEvent const & in_event);

	/*! Sets the relevant list of keys up to the window which had focus for this touch event.
	 * 	\param in_path The relevant list of keys up to the window which had focus when the touches represented by this TouchState underwent the active action. */
	void SetEventPath(KeyArray const & in_path);

	/*! Sets the touches currently down in this TouchState.
	*	\param in_touches The list of touches. */
	void SetTouches(TouchArray const & in_touches);

	/*! Sets an object representing the state of modifier keys for this TouchState.
	*	\param in_modifiers An object representing the state of modifier keys. */
	void SetModifierKeys(ModifierKeys in_modifiers);
};



/*!	The KeyboardState class represents the state of a keyboard for a particular event. */
class HPS_API KeyboardState : public Object
{
public:
	/*! The default constructor creates an empty KeyboardState object. */
	KeyboardState();

	/*! The copy constructor creates a new KeyboardState object that contains the same settings as the source KeyboardState.
	 * 	\param in_that The source KeyboardState to copy. */
	KeyboardState(KeyboardState const & in_that);

	/*! The move constructor creates a KeyboardState by transferring the underlying impl of the rvalue reference to this KeyboardState
	 * 	thereby avoiding a copy and allocation.
	 * 	\param in_that An rvalue reference to a KeyboardState to take the impl from. */
	KeyboardState(KeyboardState && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this KeyboardState thereby avoiding a copy.
	 * 	\param in_that An rvalue reference to a KeyboardState to take the impl from.
	 * 	\return A reference to this KeyboardState. */
	KeyboardState & operator=(KeyboardState && in_that);

	~KeyboardState();

	static const HPS::Type staticType = HPS::Type::KeyboardState;
	HPS::Type					ObjectType() const {return staticType;};

	/*! Copies the source KeyboardState into this KeyboardState.
	 * 	\param in_that The source KeyboardState to copy. */
	void						Assign(KeyboardState const & in_that);

	/*! Copies the source KeyboardState into this KeyboardState.
	 * 	\param in_that The source KeyboardState to copy.
	 * 	\return A reference to this KeyboardState. */
	KeyboardState &				operator=(KeyboardState const & in_that);

	/*!	Check if the source KeyboardState is equivalent to this KeyboardState.
	 *	\param in_that The source KeyboardState to compare to this KeyboardState.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						Equals(KeyboardState const & in_that) const;

	/*!	Check if the source KeyboardState is equivalent to this KeyboardState.
	 *	\param in_that The source KeyboardState to compare to this KeyboardState.
	 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
	bool						operator== (KeyboardState const & in_that) const;

	/*!	Check if the source KeyboardState is not equivalent to this KeyboardState.
	 *	\param in_that The source KeyboardState to compare to this KeyboardState.
	 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
	bool						operator!= (KeyboardState const & in_that) const;

	/*!	Sets the properties of this KeyboardState.
	 * \param in_path The list of keys up to the window which had focus for this keyboard event.
	 * \param in_event The keyboard event.
	 * \param in_keyboard_codes The list of keyboard codes for keys currently down during this keyboard event.
	 * \param in_modifiers The state of modifier keys for this keyboard event. */
	void						Set(KeyArray const & in_path, KeyboardEvent const & in_event, KeyboardCodeArray const & in_keyboard_codes, ModifierKeys in_modifiers = ModifierKeys());

	/*! Get the active event for this KeyboardState.  This will throw an exception if there is no active action for this KeyboardState.
	*	\return The action for the active keyboard codes for this KeyboardState. */
	HPS::KeyboardEvent			GetActiveEvent() const;

	/*! Get the window which had focus when the keys represented by this KeyboardState were pressed or released.
	*	This will throw an exception if there is no event source for this KeyboardState.
	*	\return The window which had focus when the keys represented by this KeyboardState were pressed or released. */
	HPS::WindowKey				GetEventSource() const;

	/*! Get the relevant list of keys up to the window which had focus when the keys represented by this KeyboardState were pressed or released.
	*	This will throw an exception if there is no event path for this KeyboardState.
	*	\return The relevant list of keys up to the window which had focus when the keys represented by this KeyboardState were pressed or released. */
	HPS::KeyArray				GetEventPath() const;

	/*! Get the number of keys currently down in this KeyboardState.
	*	\return Number of active and inactive keyboard codes. */
	size_t						GetKeyboardCodeCount() const;

	/*! Get the list of keyboard codes for keys currently down in this KeyboardState.
	*	\return The list of active and inactive keyboard codes. */
	HPS::KeyboardCodeArray		GetKeyboardCodes() const;

	/*! Get the state of a specific keyboard code for this KeyboardState.
	*	\param in_key_code The keyboard code for which to query the action.
	*	\return <span class='code'>true</span> if the key is down, <span class='code'>false</span> otherwise. */
	bool						GetKeyState(HPS::KeyboardCode in_key_code) const;

	/*! Get an object representing the state of modifier keys for this KeyboardState.
	*	\return An object representing the state of modifier keys. */
	ModifierKeys				GetModifierKeys() const;

	/*! Sets the active event for this KeyboardState.
	 * 	\param in_event The action for this KeyboardState. */
	void SetActiveEvent(KeyboardEvent const & in_event);

	/*! Sets the relevant list of keys up to the window which had focus for this keyboard event.
	 * 	\param in_path The relevant list of keys up to the window which had focus when the keyboard event represented by this KeyboardState underwent the active action. */
	void SetEventPath(KeyArray const & in_path);

	/*! Sets the list of keyboard codes for keys currently down in this KeyboardState.
	*	\param in_keyboard_codes The list of keyboard codes for keys currently down during this keyboard event. */
	void SetKeyboardCodes(KeyboardCodeArray const & in_keyboard_codes);

	/*! Sets an object representing the state of modifier keys for this KeyboardState.
	*	\param in_modifiers An object representing the state of modifier keys. */
	void SetModifierKeys(ModifierKeys in_modifiers);
};


/*! The IONotifier class is a smart-pointer that is associated with an asynchronous file import or export.  It is used to interact with an ongoing
* 	file IO or get the results from a completed IO operation. */
class HPS_API IONotifier : public Object
{
public:
	/*! The default constructor creates an IONotifier object which is not associated with any file IO operation. */
	IONotifier();

	/*! The copy constructor creates a new IONotifier object that is associated with the same file IO as the source IONotifier.
	* 	\param in_that The source IONotifier to copy. */
	IONotifier(IONotifier const & in_that);

	/*! The move constructor creates an IONotifier by transferring the underlying impl of the rvalue reference to this IONotifier
	* 	thereby avoiding a copy and allocation.
	* 	\param in_that An rvalue reference to an IONotifier to take the impl from. */
	IONotifier(IONotifier && in_that);

	/*! The move assignment operator transfers the underlying impl of the rvalue reference to this IONotifier thereby avoiding a copy.
	* 	\param in_that An rvalue reference to an IONotifier to take the impl from.
	* 	\return A reference to this ImportNotfier. */
	IONotifier &			operator=(IONotifier && in_that);

	virtual ~IONotifier();

	static const HPS::Type staticType = HPS::Type::IONotifier;
	HPS::Type				ObjectType() const {return staticType;};

	/*! Associate this IONotifier with the same file IO operation as the source IONotifier.
	*	\param in_that The source IONotifier for the assignment.
	*	\return A reference to this IONotifier. */
	IONotifier &			operator=(IONotifier const & in_that);

	/*! Associate this IONotifier with the same file IO operation as the source IONotifier.
	*	\param in_that The source IONotifier for the assignment. */
	void					Assign(IONotifier const & in_that);

	/*! Cause this thread to sleep until the asynchronous file IO operation associated with this notifier is complete.
	 * \return A reference to this IONotifier. */
	IONotifier &			Wait();

	/*! Query the status of the file IO operation for this notifier.
	*	\return The current state of the file import. */
	IOResult				Status() const;

	/*! Query the status and completion percentage of the file IO for this notifier.
	* 	\param out_percent_complete Float in the range [0,1] indicating the current percentage complete.
	* 	\return The current state of the file import. */
	IOResult				Status(float & out_percent_complete) const;

	/*! Requests to cancel the asynchronous file IO if it is still in progress. The \ref Cancel() function will return
	 * synchronously, however there may be some delay between when the cancel request is made and when
	 * the asynchronous file IO stops. Call \ref Wait() to ensure that the asynchronous file IO operation has stopped.
	 * \return A reference to this IONotifier. */
	IONotifier &			Cancel();
};

//////////////////////////////////////////////////////////////////////
///////////////////////////// Point Cloud IO//////////////////////////
//////////////////////////////////////////////////////////////////////

/*!	The PointCloud class contains objects and enumerations used for importing and exporting XYZ, PTX, and PTS files. */
class HPS_API PointCloud
{
public:
	/*! The ImportResultsKit class contains the results of a successful point cloud import. */
class HPS_API ImportResultsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportResultsKit object. */
		ImportResultsKit();

		/*! The copy constructor creates a new ImportResultsKit object that contains the same settings as the source ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		ImportResultsKit(ImportResultsKit const & in_kit);

		/*! The move constructor creates an ImportResultsKit by transferring the underlying impl of the rvalue reference to this ImportResultsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from. */
		ImportResultsKit(ImportResultsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportResultsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit & operator=(ImportResultsKit && in_that);

		virtual ~ImportResultsKit();

	static const HPS::Type staticType = HPS::Type::PointCloudImportResultsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		void					Set(ImportResultsKit const & in_kit);

		/*! Copies this ImportResultsKit into the given ImportResultsKit.
		 * 	\param out_kit The ImportResultsKit to populate with the contents of this ImportResultsKit. */
		void					Show(ImportResultsKit & out_kit) const;

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		operator=(ImportResultsKit const & in_kit);

		/*! Indicates whether this ImportResultsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportResultsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is not equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportResultsKit const & in_kit) const;

		/*! Sets the root segment which the point cloud data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an point cloud import.
		 *	\param in_segment Segment the point cloud data was imported into.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment which the point cloud data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an point cloud import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetSegment();

		/*! Shows the root segment which the point cloud data was imported into.  This was either the root segment specified by the user in the ImportOptionsKit
		 * 	passed to OBJ::File::Import, or the root segment that was created for this purpose during import.
		 *	\param out_segment Segment the point cloud data was imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Removes all settings from this ImportResultsKit.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetEverything();
	};

	/*!	The ImportOptionsKit class contains any settings controlling the import of XYZ, PTX, and PTS files. */
	class HPS_API ImportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportOptionsKit object. */
		ImportOptionsKit();

		/*! The copy constructor creates a new ImportOptionsKit object that contains the same settings as the source ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		ImportOptionsKit(ImportOptionsKit const & in_kit);

		/*! The move constructor creates an ImportOptionsKit by transferring the underlying impl of the rvalue reference to this ImportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from. */
		ImportOptionsKit(ImportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit & operator=(ImportOptionsKit && in_that);

		virtual ~ImportOptionsKit();

	static const HPS::Type staticType = HPS::Type::PointCloudImportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		void					Set(ImportOptionsKit const & in_kit);

		/*! Copies this ImportOptionsKit into the given ImportOptionsKit.
		 * 	\param out_kit The ImportOptionsKit to populate with the contents of this ImportOptionsKit. */
		void					Show(ImportOptionsKit & out_kit) const;

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		operator=(ImportOptionsKit const & in_kit);

		/*! Indicates whether this ImportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is not equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportOptionsKit const & in_kit) const;

		/*! Sets the root segment where the point cloud data will be imported into.  If no segment is specified, a root segment will be created for this
		 * 	purpose during import.
		 *	\param in_segment Segment the point cloud data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment speciyfing where the point cloud data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetSegment();

		/*! Shows the root segment where the HSF data will be imported into.
		 *	\param out_segment Segment the HSF data will be imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Sets the point color for each point in the cloud. If the point cloud explicitly provides colors for points this option will be ignored unless in_override is specified. If the
		*	file only describes an intensity for each point the color provided will be multilplied by the intensity to resolve the final point coloration unless in_override is specified
		*	in which case the intensity will be ignored. If the file describes no intensity or color (or in_override is specified), this will set the vertex color at the containing segment.
		*	\param in_color The color to use.
		*	\param in_override Specifies whether to override the point colors specified in the file (if any) with the color provided
		*	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetPointColor(RGBColor const & in_color, bool in_override = false);

		/*! Remove the point color to use during import.
		*	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetPointColor();

		/*! Shows the point color to use during import.
		*	\param out_color The color being used.
		*	\param out_override Specifies whether the point colors specified in the file (if any) will be override with the color provided
		*	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowPointColor(RGBColor & out_color, bool & out_override) const;

		/*! Removes all settings from this ImportOptionsKit.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetEverything();
	};


	/*! The ImportNotifier class is a smart-pointer that is associated with an asynchronous file import. It is used to interact with an ongoing
	 * 	import or get the results from a completed import. */
	class HPS_API ImportNotifier : public IONotifier
	{
	public:
		/*! The default constructor creates an ImportNotifier object which is not associated with any file import. */
		ImportNotifier();

		/*! The copy constructor creates a new ImportNotifier object that is associated with the same file import as the source ImportNotifier.
		 * 	\param in_that The source ImportNotifier to copy. */
		ImportNotifier(ImportNotifier const & in_that);

		/*! The conversion constructor creates a new derived ImportNotifier object from a base IONotifier object.
		 * 	The copy will only be successful if the source notifier is really an upcast of this notifier type.
		 *	Otherwise the copy will fail and the resulting ImportNotifier will be invalid.
		 * 	\param in_that The source IONotifier to copy. */
		ImportNotifier(IONotifier const & in_that);

		/*! The move constructor creates an ImportNotifier by transferring the underlying impl of the rvalue reference to this ImportNotifier
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from. */
		ImportNotifier(ImportNotifier && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportNotifier thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from.
		 * 	\return A reference to this ImportNotfier. */
		ImportNotifier &		operator=(ImportNotifier && in_that);

		virtual ~ImportNotifier();

	static const HPS::Type staticType = HPS::Type::PointCloudImportNotifier;
		HPS::Type				ObjectType() const {return staticType;};

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment.
		 *	\return A reference to this ImportNotifier. */
		ImportNotifier &		operator=(ImportNotifier const & in_that);

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment. */
		void					Assign(ImportNotifier const & in_that);

		/*!	Get the ImportResultsKit for the file import.  Throws an IOException if the import is not complete or
		 *  was not successful.
		 *  \return The ImportResultsKit for a successful file import. */
		ImportResultsKit		GetResults() const;
	};


	/*!	The File class provides functions to import and export XYZ, PTX, and PTS files. */
	class HPS_API File
	{
	public:
		/*!	Performs an asynchronous import of the specified XYZ, PTX, or PTS file with the provided options.  May throw an IOException prior to starting
		 * 	the asynchronous import.
		 * 	\param in_file_name Name of XYZ, PTX, or PTS file to import.
		 *	\param in_options Options controlling the import of the XYZ, PTX, or PTS file (e.g., segment to import into).
		 *	\return An ImportNotfier object that can be used to query the import progress and status. */
		static ImportNotifier	Import(char const * in_file_name, ImportOptionsKit const & in_options);

	private:
		//! Private default constructor to prevent instantiation.
		File();
	};
private:
	//! Private default constructor to prevent instantiation.
	PointCloud();
};

//////////////////////////////////////////////////////////////////////
///////////////////////////// Stream File IO//////////////////////////
//////////////////////////////////////////////////////////////////////

/*!	The Stream class contains objects and enumerations used for importing and exporting HSF files. */
class HPS_API Stream
{
public:
	class ImportNotifier;
	class ImportOptionsKit;

	/*! The Toolkit class is the primary support class which manages streaming of HSF data. */
	class HPS_API Toolkit : public Object
	{
	public:
		/*! The Default constructor creates an empty Toolkit object. */
		Toolkit();

		/*! This constructor creates an Toolkit object that shares the underlying smart-pointer of the source Toolkit.
		 *	\param in_toolkit The source Toolkit to copy. */
		Toolkit(Toolkit const & in_toolkit);

		/*! The move constructor creates a Toolkit by transferring the underlying impl of the rvalue reference to this Toolkit
		  *	thereby avoiding a copy and allocation.
		  *	\param in_toolkit An rvalue reference to a Toolkit to take the impl from. */
		Toolkit(Toolkit && in_toolkit);

		/*! Associate this Toolkit with the same underlying impl as the source Toolkit.
		  *	\param in_toolkit The source Toolkit for the assignment.
		  *	\return A reference to this ShellKey. */
		Toolkit & operator=(Toolkit const & in_toolkit);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this Toolkit thereby avoiding a copy.
		  *	\param in_toolkit An rvalue reference to a Toolkit to take the impl from.
		  *	\return A reference to this Toolkit. */
		Toolkit & operator=(Toolkit && in_toolkit);

	static const HPS::Type staticType = HPS::Type::StreamToolkit;
		HPS::Type				ObjectType() const { return staticType; }

		/*! Restarts the Toolkit object so that it can be reused for importing or exporting. */
		virtual void			Restart();

		ImportNotifier			ParseBuffers(ByteArrayArray const & in_hsf_buffers, ImportOptionsKit const & in_options);
	};

	/*! Create a new Toolkit.
	*!	\return A new Toolkit. */
	static Toolkit				CreateToolkit();



	///////////////////////////////////////////////////

	/*!	The ExportEvent class is the base class for events signaled during Stream export. */
	class HPS_API ExportEvent
	{
	protected:
		ExportEvent() {}
	public:
		virtual ~ExportEvent();
		/*! Returns a unique identifier that is shared by all objects of the same class. */
		intptr_t			GetClassID() const;
		/*! A \ref HPS::ByteArray where the user may store data that is not associated with the database to be export by Stream.
		 * On import, this data will be reported to the user through a \ref HPS::Stream::NonDBuserDataEvent */
		HPS::ByteArray		non_db_user_data;
	};

	/*!	The ExportEventHandler class is the base class for user-defined ExportEvent handlers. */
	class HPS_API ExportEventHandler
	{
	public:
		ExportEventHandler() {}
		virtual ~ExportEventHandler();
		/*! The handler function for Stream ExportEvents. Override this function to process the <span class='code'>ExportEvent</span> to suit your needs.
		 * This function is called synchronously as data is exported by Stream; Stream export will be paused until this function returns.
		 * \param in_event A pointer to the ExportEvent data. */
		virtual void Handle(ExportEvent * in_event);
	};

	///////////////////////////////////////////////////

	/*!	The GeometryExportEvent class indicates that geometry is about to be exported by Stream. */
	class HPS_API GeometryExportEvent : public ExportEvent
	{
		GeometryExportEvent(GeometryExportEvent const &);
		GeometryExportEvent & operator=(GeometryExportEvent const &);
	public:
		GeometryExportEvent();
		virtual ~GeometryExportEvent();
		GeometryExportEvent(HPS::Key & in_key);

		/*! A key to geometry that is about to be exported by stream. */
		HPS::Key & key;
	};

	/*!	The SegmentExportEvent class indicates that a segment is about to be exported by Stream. */
	class HPS_API SegmentExportEvent : public ExportEvent
	{
		SegmentExportEvent(SegmentExportEvent const &);
		SegmentExportEvent & operator=(SegmentExportEvent const &);
	public:
		SegmentExportEvent();
		virtual ~SegmentExportEvent();
		SegmentExportEvent(HPS::SegmentKey & in_segment_key);

		/*! A SegmentKey that is about to be exported by stream. */
		HPS::SegmentKey & segment_key;
	};

	///////////////////////////////////////////////////

	/*!	The ImportEvent class is the base class for events signaled during Stream export. */
	class HPS_API ImportEvent
	{
	protected:
		ImportEvent() {}
	public:
		virtual ~ImportEvent();
		/*! Returns a unique identifier that is shared by all objects of the same class. */
		intptr_t			GetClassID() const;
	};

	/*!	The ImportEventHandler class is the base class for user-defined ImportEvent handlers.
	If your ImportEventHandler elects not to import incoming geometry, then subsequent operations on that geometry along with follow-up attributes (priority, user-data, etc...)
	will throw an InvalidObjectException.
	*/
	class HPS_API ImportEventHandler
	{
	public:
		ImportEventHandler() {}
		virtual ~ImportEventHandler();

		/*! The handler function for Stream ImportEvents. Override this function to process the ImportEvent to suit your needs.
		 * This function is called synchronously as data is imported by Stream; Stream import will be paused until this function returns.
		 * \param in_event A pointer to the ImportEvent representing the impending change to the database.
		 * \return A bool that specifies if the database change indicated by in_event should be applied.
		 * true means that the change will be applied to the database; false means that no change will be made. */
		virtual bool Handle(ImportEvent * in_event);
	};

	///////////////////////////////////////////////////

	class HPS_API AttributeLockImportEvent : public ImportEvent
	{
		AttributeLockImportEvent(AttributeLockImportEvent const &);
		AttributeLockImportEvent & operator=(AttributeLockImportEvent const &);
	public:
		AttributeLockImportEvent();
		virtual ~AttributeLockImportEvent();
		AttributeLockImportEvent(HPS::SegmentKey & in_segment_key, HPS::AttributeLockKit & in_attribute_lock_kit);

		HPS::SegmentKey & segment_key;
		HPS::AttributeLockKit & attribute_lock_kit;
	};

	class HPS_API BoundingImportEvent : public ImportEvent
	{
		BoundingImportEvent(BoundingImportEvent const &);
		BoundingImportEvent & operator=(BoundingImportEvent const &);
	public:
		BoundingImportEvent();
		virtual ~BoundingImportEvent();
		BoundingImportEvent(HPS::SegmentKey & in_segment_key, HPS::BoundingKit & in_bounding_kit);

		HPS::SegmentKey & segment_key;
		HPS::BoundingKit & bounding_kit;
	};

	class HPS_API CameraImportEvent : public ImportEvent
	{
		CameraImportEvent(CameraImportEvent const &);
		CameraImportEvent & operator=(CameraImportEvent const &);
	public:
		CameraImportEvent();
		virtual ~CameraImportEvent();
		CameraImportEvent(HPS::SegmentKey & in_segment_key, HPS::CameraKit & in_camera_kit);

		HPS::SegmentKey & segment_key;
		HPS::CameraKit & camera_kit;
	};

	class HPS_API CircleImportEvent : public ImportEvent
	{
		CircleImportEvent(CircleImportEvent const &);
		CircleImportEvent & operator=(CircleImportEvent const &);
	public:
		CircleImportEvent();
		virtual ~CircleImportEvent();
		CircleImportEvent(HPS::SegmentKey & in_segment_key, HPS::CircleKit & in_circle_kit);

		HPS::SegmentKey & segment_key;
		HPS::CircleKit & circle_kit;
	};

	class HPS_API CircularArcImportEvent : public ImportEvent
	{
		CircularArcImportEvent(CircularArcImportEvent const &);
		CircularArcImportEvent & operator=(CircularArcImportEvent const &);
	public:
		CircularArcImportEvent();
		virtual ~CircularArcImportEvent();
		CircularArcImportEvent(HPS::SegmentKey & in_segment_key, HPS::CircularArcKit & in_circular_arc_kit);

		HPS::SegmentKey & segment_key;
		HPS::CircularArcKit & circular_arc_kit;
	};

	class HPS_API CircularWedgeImportEvent : public ImportEvent
	{
		CircularWedgeImportEvent(CircularWedgeImportEvent const &);
		CircularWedgeImportEvent & operator=(CircularWedgeImportEvent const &);
	public:
		CircularWedgeImportEvent();
		virtual ~CircularWedgeImportEvent();
		CircularWedgeImportEvent(HPS::SegmentKey & in_segment_key, HPS::CircularWedgeKit & in_circular_wedge_kit);

		HPS::SegmentKey & segment_key;
		HPS::CircularWedgeKit & circular_wedge_kit;
	};

	class HPS_API ColorInterpolationImportEvent : public ImportEvent
	{
		ColorInterpolationImportEvent(ColorInterpolationImportEvent const &);
		ColorInterpolationImportEvent & operator=(ColorInterpolationImportEvent const &);
	public:
		ColorInterpolationImportEvent();
		virtual ~ColorInterpolationImportEvent();
		ColorInterpolationImportEvent(HPS::SegmentKey & in_segment_key, HPS::ColorInterpolationKit & in_color_interpolation_kit);

		HPS::SegmentKey & segment_key;
		HPS::ColorInterpolationKit & color_interpolation_kit;
	};

	class HPS_API CommentImportEvent : public ImportEvent
	{
		CommentImportEvent(CommentImportEvent const &);
		CommentImportEvent & operator=(CommentImportEvent const &);
	public:
		CommentImportEvent();
		virtual ~CommentImportEvent();
		CommentImportEvent(HPS::SegmentKey & in_segment_key, const char* in_comment);

		HPS::SegmentKey & segment_key;
		HPS::UTF8 const comment;
	};

	class HPS_API ConditionImportEvent : public ImportEvent
	{
		ConditionImportEvent(ConditionImportEvent const &);
		ConditionImportEvent & operator=(ConditionImportEvent const &);
	public:
		ConditionImportEvent();
		virtual ~ConditionImportEvent();
		ConditionImportEvent(HPS::SegmentKey & in_segment_key);

		HPS::SegmentKey & segment_key;
		HPS::UTF8Array conditions;
	};

	class HPS_API ContourLineImportEvent : public ImportEvent
	{
		ContourLineImportEvent(ContourLineImportEvent const &);
		ContourLineImportEvent & operator=(ContourLineImportEvent const &);
	public:
		ContourLineImportEvent();
		virtual ~ContourLineImportEvent();
		ContourLineImportEvent(HPS::SegmentKey & in_segment_key, HPS::ContourLineKit & in_contour_line_kit);

		HPS::SegmentKey & segment_key;
		HPS::ContourLineKit & contour_line_kit;
	};

	class HPS_API CuttingSectionImportEvent : public ImportEvent
	{
		CuttingSectionImportEvent(CuttingSectionImportEvent const &);
		CuttingSectionImportEvent & operator=(CuttingSectionImportEvent const &);
	public:
		CuttingSectionImportEvent();
		virtual ~CuttingSectionImportEvent();
		CuttingSectionImportEvent(HPS::SegmentKey & in_segment_key, HPS::CuttingSectionKit & in_cutting_section_kit);

		HPS::SegmentKey & segment_key;
		HPS::CuttingSectionKit & cutting_section_kit;
	};

	class HPS_API CuttingSectionAttributeImportEvent : public ImportEvent
	{
		CuttingSectionAttributeImportEvent(CuttingSectionAttributeImportEvent const &);
		CuttingSectionAttributeImportEvent & operator=(CuttingSectionAttributeImportEvent const &);
	public:
		CuttingSectionAttributeImportEvent();
		virtual ~CuttingSectionAttributeImportEvent();
		CuttingSectionAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::CuttingSectionAttributeKit & in_cutting_section_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::CuttingSectionAttributeKit & cutting_section_attribute_kit;
	};

	class HPS_API CubeMapDefinitionImportEvent : public ImportEvent
	{
		CubeMapDefinitionImportEvent(CubeMapDefinitionImportEvent const &);
		CubeMapDefinitionImportEvent & operator=(CubeMapDefinitionImportEvent const &);
	public:
		CubeMapDefinitionImportEvent();
		virtual ~CubeMapDefinitionImportEvent();
		CubeMapDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name,
									HPS::ImageDefinition & in_negative_z, HPS::ImageDefinition & in_positive_z,
									HPS::ImageDefinition & in_negative_x, HPS::ImageDefinition & in_positive_x,
									HPS::ImageDefinition & in_negative_y, HPS::ImageDefinition & in_positive_y,
									HPS::TextureOptionsKit & in_texture_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::ImageDefinition & negative_z;
		HPS::ImageDefinition & positive_z;
		HPS::ImageDefinition & negative_x;
		HPS::ImageDefinition & positive_x;
		HPS::ImageDefinition & negative_y;
		HPS::ImageDefinition & positive_y;
		HPS::TextureOptionsKit & texture_kit;
	};

	class HPS_API CullingImportEvent : public ImportEvent
	{
		CullingImportEvent(CullingImportEvent const &);
		CullingImportEvent & operator=(CullingImportEvent const &);
	public:
		CullingImportEvent();
		virtual ~CullingImportEvent();
		CullingImportEvent(HPS::SegmentKey & in_segment_key, HPS::CullingKit & in_culling_kit);

		HPS::SegmentKey &				segment_key;
		HPS::CullingKit &				culling_kit;
	};

	class HPS_API CurveAttributeImportEvent : public ImportEvent
	{
		CurveAttributeImportEvent(CurveAttributeImportEvent const &);
		CurveAttributeImportEvent & operator=(CurveAttributeImportEvent const &);
	public:
		CurveAttributeImportEvent();
		virtual ~CurveAttributeImportEvent();
		CurveAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::CurveAttributeKit & in_curve_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::CurveAttributeKit & curve_attribute_kit;
	};

	class HPS_API CylinderAttributeImportEvent : public ImportEvent
	{
		CylinderAttributeImportEvent(CylinderAttributeImportEvent const &);
		CylinderAttributeImportEvent & operator=(CylinderAttributeImportEvent const &);
	public:
		CylinderAttributeImportEvent();
		virtual ~CylinderAttributeImportEvent();
		CylinderAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::CylinderAttributeKit & in_cylinder_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::CylinderAttributeKit & cylinder_attribute_kit;
	};

	class HPS_API CylinderImportEvent : public ImportEvent
	{
		CylinderImportEvent(CylinderImportEvent const &);
		CylinderImportEvent & operator=(CylinderImportEvent const &);
	public:
		CylinderImportEvent();
		virtual ~CylinderImportEvent();
		CylinderImportEvent(HPS::SegmentKey & in_segment_key, HPS::CylinderKit & in_cylinder_kit);

		HPS::SegmentKey & segment_key;
		HPS::CylinderKit & cylinder_kit;
	};

	class HPS_API DistantLightPropertyImportEvent : public ImportEvent
	{
		DistantLightPropertyImportEvent(DistantLightPropertyImportEvent const &);
		DistantLightPropertyImportEvent & operator=(DistantLightPropertyImportEvent const &);
	public:
		DistantLightPropertyImportEvent();
		virtual ~DistantLightPropertyImportEvent();
		DistantLightPropertyImportEvent(HPS::DistantLightKey & in_distant_light_key, HPS::DistantLightKit & in_distant_light_kit);

		HPS::DistantLightKey & distant_light_key;
		HPS::DistantLightKit & distant_light_kit;
	};

	class HPS_API DistantLightImportEvent : public ImportEvent
	{
		DistantLightImportEvent(DistantLightImportEvent const &);
		DistantLightImportEvent & operator=(DistantLightImportEvent const &);
	public:
		DistantLightImportEvent();
		virtual ~DistantLightImportEvent();
		DistantLightImportEvent(HPS::SegmentKey & in_segment_key, HPS::DistantLightKit & in_distantlight_kit);

		HPS::SegmentKey & segment_key;
		HPS::DistantLightKit & distant_light_kit;
	};

	class HPS_API DrawingAttributeImportEvent : public ImportEvent
	{
		DrawingAttributeImportEvent(DrawingAttributeImportEvent const &);
		DrawingAttributeImportEvent & operator=(DrawingAttributeImportEvent const &);
	public:
		DrawingAttributeImportEvent();
		virtual ~DrawingAttributeImportEvent();
		DrawingAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::DrawingAttributeKit & in_drawing_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::DrawingAttributeKit & drawing_attribute_kit;
	};

	class HPS_API EdgeAttributeImportEvent : public ImportEvent
	{
		EdgeAttributeImportEvent(EdgeAttributeImportEvent const &);
		EdgeAttributeImportEvent & operator=(EdgeAttributeImportEvent const &);
	public:
		EdgeAttributeImportEvent();
		virtual ~EdgeAttributeImportEvent();
		EdgeAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::EdgeAttributeKit & in_edge_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::EdgeAttributeKit & edge_attribute_kit;
	};

	class HPS_API EllipseImportEvent : public ImportEvent
	{
		EllipseImportEvent(EllipseImportEvent const &);
		EllipseImportEvent & operator=(EllipseImportEvent const &);
	public:
		EllipseImportEvent();
		virtual ~EllipseImportEvent();
		EllipseImportEvent(HPS::SegmentKey & in_segment_key, HPS::EllipseKit & in_ellipse_kit);

		HPS::SegmentKey & segment_key;
		HPS::EllipseKit & ellipse_kit;
	};

	class HPS_API EllipticalArcImportEvent : public ImportEvent
	{
		EllipticalArcImportEvent(EllipticalArcImportEvent const &);
		EllipticalArcImportEvent & operator=(EllipticalArcImportEvent const &);
	public:
		EllipticalArcImportEvent();
		virtual ~EllipticalArcImportEvent();
		EllipticalArcImportEvent(HPS::SegmentKey & in_segment_key, HPS::EllipticalArcKit & in_elliptical_arc_kit);

		HPS::SegmentKey & segment_key;
		HPS::EllipticalArcKit & elliptical_arc_kit;
	};

	class HPS_API GlyphDefinitionImportEvent : public ImportEvent
	{
		GlyphDefinitionImportEvent(GlyphDefinitionImportEvent const &);
		GlyphDefinitionImportEvent & operator=(GlyphDefinitionImportEvent const &);
	public:
		GlyphDefinitionImportEvent();
		virtual ~GlyphDefinitionImportEvent();
		GlyphDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::GlyphKit & in_glyph_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::GlyphKit & glyph_kit;
	};

	class HPS_API ShapeDefinitionImportEvent : public ImportEvent
	{
		ShapeDefinitionImportEvent(ShapeDefinitionImportEvent const &);
		ShapeDefinitionImportEvent & operator=(ShapeDefinitionImportEvent const &);
	public:
		ShapeDefinitionImportEvent();
		virtual ~ShapeDefinitionImportEvent();
		ShapeDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::ShapeKit & in_shape_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::ShapeKit & shape_kit;
	};

	class HPS_API GridImportEvent : public ImportEvent
	{
		GridImportEvent(GridImportEvent const &);
		GridImportEvent & operator=(GridImportEvent const &);
	public:
		GridImportEvent();
		virtual ~GridImportEvent();
		GridImportEvent(HPS::SegmentKey & in_segment_key, HPS::GridKit & in_grid_kit);

		HPS::SegmentKey & segment_key;
		HPS::GridKit & grid_kit;
	};

	class HPS_API HiddenLineAttributeImportEvent : public ImportEvent
	{
		HiddenLineAttributeImportEvent(HiddenLineAttributeImportEvent const &);
		HiddenLineAttributeImportEvent & operator=(HiddenLineAttributeImportEvent const &);
	public:
		HiddenLineAttributeImportEvent();
		virtual ~HiddenLineAttributeImportEvent();
		HiddenLineAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::HiddenLineAttributeKit & in_hidden_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::HiddenLineAttributeKit & hidden_line_attribute_kit;
	};

	class HPS_API ImageDefinitionImportEvent : public ImportEvent
	{
		ImageDefinitionImportEvent(ImageDefinitionImportEvent const &);
		ImageDefinitionImportEvent & operator=(ImageDefinitionImportEvent const &);
	public:
		ImageDefinitionImportEvent();
		virtual ~ImageDefinitionImportEvent();
		ImageDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::ImageKit & in_image_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::ImageKit & image_kit;
	};

	class HPS_API IncludeSegmentImportEvent : public ImportEvent
	{
		IncludeSegmentImportEvent(IncludeSegmentImportEvent const &);
		IncludeSegmentImportEvent & operator=(IncludeSegmentImportEvent const &);
	public:
		IncludeSegmentImportEvent();
		virtual ~IncludeSegmentImportEvent();
		IncludeSegmentImportEvent(HPS::SegmentKey & in_segment_key, HPS::SegmentKey & in_reference_segment_key, HPS::ConditionalExpression & in_conditional, HPS::AttributeLockTypeArray && in_filter_types);

		HPS::SegmentKey & segment_key;
		HPS::SegmentKey & reference_segment_key;
		HPS::ConditionalExpression & condition;
		HPS::AttributeLockTypeArray	filter_types;
	};

	class HPS_API InfiniteLineImportEvent : public ImportEvent
	{
		InfiniteLineImportEvent(InfiniteLineImportEvent const &);
		InfiniteLineImportEvent & operator=(InfiniteLineImportEvent const &);
	public:
		InfiniteLineImportEvent();
		virtual ~InfiniteLineImportEvent();
		InfiniteLineImportEvent(HPS::SegmentKey & in_segment_key, HPS::InfiniteLineKit & in_infinite_line_kit);

		HPS::SegmentKey & segment_key;
		HPS::InfiniteLineKit & infinite_line_kit;
	};

	class HPS_API LightingAttributeImportEvent : public ImportEvent
	{
		LightingAttributeImportEvent(LightingAttributeImportEvent const &);
		LightingAttributeImportEvent & operator=(LightingAttributeImportEvent const &);
	public:
		LightingAttributeImportEvent();
		virtual ~LightingAttributeImportEvent();
		LightingAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::LightingAttributeKit & in_lighting_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::LightingAttributeKit & lighting_attribute_kit;
	};

	class HPS_API LineAttributeImportEvent : public ImportEvent
	{
		LineAttributeImportEvent(LineAttributeImportEvent const &);
		LineAttributeImportEvent & operator=(LineAttributeImportEvent const &);
	public:
		LineAttributeImportEvent();
		virtual ~LineAttributeImportEvent();
		LineAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::LineAttributeKit & in_line_attribute_kit);

		HPS::SegmentKey &				segment_key;
		HPS::LineAttributeKit &			line_attribute_kit;
	};

	class HPS_API LineImportEvent : public ImportEvent
	{
		LineImportEvent(LineImportEvent const &);
		LineImportEvent & operator=(LineImportEvent const &);
	public:
		LineImportEvent();
		virtual ~LineImportEvent();
		LineImportEvent(HPS::SegmentKey & in_segment_key, HPS::LineKit & in_line_kit);

		HPS::SegmentKey & segment_key;
		HPS::LineKit & line_kit;
	};

	class HPS_API LinePatternDefinitionImportEvent : public ImportEvent
	{
		LinePatternDefinitionImportEvent(LinePatternDefinitionImportEvent const &);
		LinePatternDefinitionImportEvent & operator=(LinePatternDefinitionImportEvent const &);
	public:
		LinePatternDefinitionImportEvent();
		virtual ~LinePatternDefinitionImportEvent();
		LinePatternDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::LinePatternKit & in_line_pattern_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::LinePatternKit & line_pattern_kit;
	};

	class HPS_API MarkerImportEvent : public ImportEvent
	{
		MarkerImportEvent(MarkerImportEvent const &);
		MarkerImportEvent & operator=(MarkerImportEvent const &);
	public:
		MarkerImportEvent();
		virtual ~MarkerImportEvent();
		MarkerImportEvent(HPS::SegmentKey & in_segment_key, HPS::MarkerKit & in_marker_kit);

		HPS::SegmentKey & segment_key;
		HPS::MarkerKit & marker_kit;
	};

	class HPS_API MarkerAttributeImportEvent : public ImportEvent
	{
		MarkerAttributeImportEvent(MarkerAttributeImportEvent const &);
		MarkerAttributeImportEvent & operator=(MarkerAttributeImportEvent const &);
	public:
		MarkerAttributeImportEvent();
		virtual ~MarkerAttributeImportEvent();
		MarkerAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::MarkerAttributeKit & in_marker_attribute_kit);

		HPS::SegmentKey &				segment_key;
		HPS::MarkerAttributeKit &		marker_attribute_kit;
	};

	class HPS_API MaterialImportEvent : public ImportEvent
	{
		MaterialImportEvent(MaterialImportEvent const &);
		MaterialImportEvent & operator=(MaterialImportEvent const &);
	public:
		MaterialImportEvent();
		virtual ~MaterialImportEvent();
		MaterialImportEvent(HPS::Key & in_key, HPS::MaterialMappingKit & in_material_mapping_kit);

		HPS::Key & key;
		HPS::MaterialMappingKit & material_mapping_kit;
	};

	class HPS_API MaterialPaletteDefinitionImportEvent : public ImportEvent
	{
		MaterialPaletteDefinitionImportEvent(MaterialPaletteDefinitionImportEvent const &);
		MaterialPaletteDefinitionImportEvent & operator=(MaterialPaletteDefinitionImportEvent const &);
	public:
		MaterialPaletteDefinitionImportEvent();
		virtual ~MaterialPaletteDefinitionImportEvent();
		MaterialPaletteDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::MaterialKitArray & in_material_mapping_kit_array);

		HPS::PortfolioKey & portfolio_key;
		HPS::UTF8 name;
		HPS::MaterialKitArray & material_mapping_kit_array;
	};

	class HPS_API MaterialPaletteImportEvent : public ImportEvent
	{
		MaterialPaletteImportEvent(MaterialPaletteImportEvent const &);
		MaterialPaletteImportEvent & operator=(MaterialPaletteImportEvent const &);
	public:
		MaterialPaletteImportEvent();
		virtual ~MaterialPaletteImportEvent();
		MaterialPaletteImportEvent(HPS::SegmentKey & in_segment_key, const char * in_name);

		HPS::SegmentKey & segment_key;
		HPS::UTF8 name;
	};

	class HPS_API MatrixImportEvent : public ImportEvent
	{
		MatrixImportEvent(MatrixImportEvent const &);
		MatrixImportEvent & operator=(MatrixImportEvent const &);
	public:
		MatrixImportEvent();
		virtual ~MatrixImportEvent();
		MatrixImportEvent(HPS::Key & in_key, HPS::MatrixKit & in_matrix_kit);

		HPS::Key & key;
		HPS::MatrixKit & matrix_kit;
	};

	class HPS_API MeshImportEvent : public ImportEvent
	{
		MeshImportEvent(MeshImportEvent const &);
		MeshImportEvent & operator=(MeshImportEvent const &);
	public:
		MeshImportEvent();
		virtual ~MeshImportEvent();
		MeshImportEvent(HPS::SegmentKey & in_segment_key, HPS::MeshKit & in_mesh_kit);

		HPS::SegmentKey & segment_key;
		HPS::MeshKit & mesh_kit;
	};

	class HPS_API MeshInstanceImportEvent : public ImportEvent
	{
		MeshInstanceImportEvent(MeshInstanceImportEvent const &);
		MeshInstanceImportEvent & operator=(MeshInstanceImportEvent const &);
	public:
		MeshInstanceImportEvent();
		virtual ~MeshInstanceImportEvent();
		MeshInstanceImportEvent(HPS::SegmentKey & in_segment_key, HPS::MeshKit & in_mesh_kit, HPS::MatrixKit & in_modelling_matrix);

		HPS::SegmentKey & segment_key;
		HPS::MeshKit & mesh_kit;
		HPS::MatrixKit & modelling_matrix;
	};

	class HPS_API NamedStyleDefinitionImportEvent : public ImportEvent
	{
		NamedStyleDefinitionImportEvent(NamedStyleDefinitionImportEvent const &);
		NamedStyleDefinitionImportEvent & operator=(NamedStyleDefinitionImportEvent const &);
	public:
		NamedStyleDefinitionImportEvent();
		virtual ~NamedStyleDefinitionImportEvent();
		NamedStyleDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::SegmentKey & in_style_key);

		HPS::PortfolioKey & portfolio_key;
		HPS::UTF8 name;
		HPS::SegmentKey & style_key;
	};

	class HPS_API NamedStyleImportEvent : public ImportEvent
	{
		NamedStyleImportEvent(NamedStyleImportEvent const &);
		NamedStyleImportEvent & operator=(NamedStyleImportEvent const &);
	public:
		NamedStyleImportEvent();
		virtual ~NamedStyleImportEvent();
		NamedStyleImportEvent(HPS::SegmentKey & in_segment_key, const char * in_name, HPS::ConditionalExpression & in_conditional, HPS::AttributeLockTypeArray && in_filter_types);

		HPS::SegmentKey & segment_key;
		HPS::UTF8 name;
		HPS::ConditionalExpression & condition;
		HPS::AttributeLockTypeArray	filter_types;
	};

	class HPS_API NURBSCurveImportEvent : public ImportEvent
	{
		NURBSCurveImportEvent(NURBSCurveImportEvent const &);
		NURBSCurveImportEvent & operator=(NURBSCurveImportEvent const &);
	public:
		NURBSCurveImportEvent();
		virtual ~NURBSCurveImportEvent();
		NURBSCurveImportEvent(HPS::SegmentKey & in_segment_key, HPS::NURBSCurveKit & in_nurbs_curve_kit);

		HPS::SegmentKey & segment_key;
		HPS::NURBSCurveKit & nurbs_curve_kit;
	};

	class HPS_API NURBSSurfaceImportEvent : public ImportEvent
	{
		NURBSSurfaceImportEvent(NURBSSurfaceImportEvent const &);
		NURBSSurfaceImportEvent & operator=(NURBSSurfaceImportEvent const &);
	public:
		NURBSSurfaceImportEvent();
		virtual ~NURBSSurfaceImportEvent();
		NURBSSurfaceImportEvent(HPS::SegmentKey & in_segment_key, HPS::NURBSSurfaceKit & in_nurbs_surface_kit);

		HPS::SegmentKey & segment_key;
		HPS::NURBSSurfaceKit & nurbs_surface_kit;
	};

	class HPS_API NURBSSurfaceAttributeImportEvent : public ImportEvent
	{
		NURBSSurfaceAttributeImportEvent(NURBSSurfaceAttributeImportEvent const &);
		NURBSSurfaceAttributeImportEvent & operator=(NURBSSurfaceAttributeImportEvent const &);
	public:
		NURBSSurfaceAttributeImportEvent();
		virtual ~NURBSSurfaceAttributeImportEvent();
		NURBSSurfaceAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::NURBSSurfaceAttributeKit & in_nurbs_surface_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::NURBSSurfaceAttributeKit & nurbs_surface_attribute_kit;
	};

	class HPS_API PerformanceImportEvent : public ImportEvent
	{
		PerformanceImportEvent(PerformanceImportEvent const &);
		PerformanceImportEvent & operator=(PerformanceImportEvent const &);
	public:
		PerformanceImportEvent();
		virtual ~PerformanceImportEvent();
		PerformanceImportEvent(HPS::SegmentKey & in_segment_key, HPS::PerformanceKit & in_performance_kit);

		HPS::SegmentKey &				segment_key;
		HPS::PerformanceKit &			performance_kit;
	};

	class HPS_API PolygonImportEvent : public ImportEvent
	{
		PolygonImportEvent(PolygonImportEvent const &);
		PolygonImportEvent & operator=(PolygonImportEvent const &);
	public:
		PolygonImportEvent();
		virtual ~PolygonImportEvent();
		PolygonImportEvent(HPS::SegmentKey & in_segment_key, HPS::PolygonKit & in_polygon_kit);

		HPS::SegmentKey & segment_key;
		HPS::PolygonKit & polygon_kit;
	};

	class HPS_API PriorityImportEvent : public ImportEvent
	{
		PriorityImportEvent(PriorityImportEvent const &);
		PriorityImportEvent & operator=(PriorityImportEvent const &);
	public:
		PriorityImportEvent();
		virtual ~PriorityImportEvent();
		PriorityImportEvent(HPS::Key & in_key, int in_priority);

		HPS::Key & key;
		int priority;
	};

	class HPS_API ReferenceGeometryImportEvent : public ImportEvent
	{
		ReferenceGeometryImportEvent(ReferenceGeometryImportEvent const &);
		ReferenceGeometryImportEvent & operator=(ReferenceGeometryImportEvent const &);
	public:
		ReferenceGeometryImportEvent();
		virtual ~ReferenceGeometryImportEvent();
		ReferenceGeometryImportEvent(HPS::SegmentKey & in_segment_key, HPS::Key & in_reference_geometry_key, HPS::ConditionalExpression & in_conditional);

		HPS::SegmentKey & segment_key;
		HPS::Key & reference_geometry_key;
		HPS::ConditionalExpression & condition;
	};

	class HPS_API SegmentImportEvent : public ImportEvent
	{
		SegmentImportEvent(SegmentImportEvent const &);
		SegmentImportEvent & operator=(SegmentImportEvent const &);
	public:
		SegmentImportEvent();
		virtual ~SegmentImportEvent();
		SegmentImportEvent(HPS::SegmentKey & in_segment_key, const char * in_name);

		HPS::SegmentKey & segment_key;
		HPS::UTF8 name;
	};

	class HPS_API SelectabilityImportEvent : public ImportEvent
	{
		SelectabilityImportEvent(SelectabilityImportEvent const &);
		SelectabilityImportEvent & operator=(SelectabilityImportEvent const &);
	public:
		SelectabilityImportEvent();
		virtual ~SelectabilityImportEvent();
		SelectabilityImportEvent(HPS::SegmentKey & in_segment_key, HPS::SelectabilityKit & in_selectability_kit);

		HPS::SegmentKey & segment_key;
		HPS::SelectabilityKit & selectability_kit;
	};

	class HPS_API ShaderDefinitionImportEvent : public ImportEvent
	{
		ShaderDefinitionImportEvent(ShaderDefinitionImportEvent const &);
		ShaderDefinitionImportEvent & operator=(ShaderDefinitionImportEvent const &);
	public:
		ShaderDefinitionImportEvent();
		virtual ~ShaderDefinitionImportEvent();
		ShaderDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name, HPS::ShaderKit & in_shader_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::ShaderKit & shader_kit;
	};

	class HPS_API ShellImportEvent : public ImportEvent
	{
		ShellImportEvent(ShellImportEvent const &);
		ShellImportEvent & operator=(ShellImportEvent const &);
	public:
		ShellImportEvent();
		virtual ~ShellImportEvent();
		ShellImportEvent(HPS::SegmentKey & in_segment_key, HPS::ShellKit & in_shell_kit);

		HPS::SegmentKey & segment_key;
		HPS::ShellKit & shell_kit;
	};

	class HPS_API ShellInstanceImportEvent : public ImportEvent
	{
		ShellInstanceImportEvent(ShellInstanceImportEvent const &);
		ShellInstanceImportEvent & operator=(ShellInstanceImportEvent const &);
	public:
		ShellInstanceImportEvent();
		virtual ~ShellInstanceImportEvent();
		ShellInstanceImportEvent(HPS::SegmentKey & in_segment_key, HPS::ShellKit & in_shell_kit, HPS::MatrixKit & in_modelling_matrix);

		HPS::SegmentKey & segment_key;
		HPS::ShellKit & shell_kit;
		HPS::MatrixKit & modelling_matrix;
	};

	class HPS_API SphereImportEvent : public ImportEvent
	{
		SphereImportEvent(SphereImportEvent const &);
		SphereImportEvent & operator=(SphereImportEvent const &);
	public:
		SphereImportEvent();
		virtual ~SphereImportEvent();
		SphereImportEvent(HPS::SegmentKey & in_segment_key, HPS::SphereKit & in_sphere_kit);

		HPS::SegmentKey & segment_key;
		HPS::SphereKit & sphere_kit;
	};

	class HPS_API SphereAttributeImportEvent : public ImportEvent
	{
		SphereAttributeImportEvent(SphereAttributeImportEvent const &);
		SphereAttributeImportEvent & operator=(SphereAttributeImportEvent const &);
	public:
		SphereAttributeImportEvent();
		virtual ~SphereAttributeImportEvent();
		SphereAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::SphereAttributeKit & in_sphere_attribute_kit);

		HPS::SegmentKey & segment_key;
		HPS::SphereAttributeKit & sphere_attribute_kit;
	};

	class HPS_API SpotlightImportEvent : public ImportEvent
	{
		SpotlightImportEvent(SpotlightImportEvent const &);
		SpotlightImportEvent & operator=(SpotlightImportEvent const &);
	public:
		SpotlightImportEvent();
		virtual ~SpotlightImportEvent();
		SpotlightImportEvent(HPS::SegmentKey & in_segment_key, HPS::SpotlightKit & in_spotlight_kit);

		HPS::SegmentKey & segment_key;
		HPS::SpotlightKit & spotlight_kit;
	};

	class HPS_API StyleSegmentImportEvent : public ImportEvent
	{
		StyleSegmentImportEvent(StyleSegmentImportEvent const &);
		StyleSegmentImportEvent & operator=(StyleSegmentImportEvent const &);
	public:
		StyleSegmentImportEvent();
		virtual ~StyleSegmentImportEvent();
		StyleSegmentImportEvent(HPS::SegmentKey & in_segment_key, HPS::SegmentKey & in_style_segment_key, HPS::ConditionalExpression & in_conditional, HPS::AttributeLockTypeArray && in_filter_types);

		HPS::SegmentKey & segment_key;
		HPS::SegmentKey & style_segment_key;
		HPS::ConditionalExpression & condition;
		HPS::AttributeLockTypeArray	filter_types;
	};

	class HPS_API TextImportEvent : public ImportEvent
	{
		TextImportEvent(TextImportEvent const &);
		TextImportEvent & operator=(TextImportEvent const &);
	public:
		TextImportEvent();
		virtual ~TextImportEvent();
		TextImportEvent(HPS::SegmentKey & in_segment_key, HPS::TextKit & in_text_kit);

		HPS::SegmentKey & segment_key;
		HPS::TextKit & text_kit;
	};

	class HPS_API TextAttributeImportEvent : public ImportEvent
	{
		TextAttributeImportEvent(TextAttributeImportEvent const &);
		TextAttributeImportEvent & operator=(TextAttributeImportEvent const &);
	public:
		TextAttributeImportEvent();
		virtual ~TextAttributeImportEvent();
		TextAttributeImportEvent(HPS::TextKey & in_text_key, HPS::TextAttributeKit & in_text_attribute_kit);
		TextAttributeImportEvent(HPS::SegmentKey & in_segment_key, HPS::TextAttributeKit & in_text_attribute_kit);

		HPS::Key & key;
		HPS::TextAttributeKit & text_attribute_kit;
	};

	class HPS_API TextureDefinitionImportEvent : public ImportEvent
	{
		TextureDefinitionImportEvent(TextureDefinitionImportEvent const &);
		TextureDefinitionImportEvent & operator=(TextureDefinitionImportEvent const &);
	public:
		TextureDefinitionImportEvent();
		virtual ~TextureDefinitionImportEvent();
		TextureDefinitionImportEvent(HPS::PortfolioKey & in_portfolio_key, const char * in_name,
									HPS::ImageDefinition & in_source_definition, HPS::TextureOptionsKit & in_texture_kit);

		HPS::PortfolioKey & portfolio_key;
		UTF8 name;
		HPS::ImageDefinition & source_definition;
		HPS::TextureOptionsKit & texture_kit;
	};

	class HPS_API TransformMaskImportEvent : public ImportEvent
	{
		TransformMaskImportEvent(TransformMaskImportEvent const &);
		TransformMaskImportEvent & operator=(TransformMaskImportEvent const &);
	public:
		TransformMaskImportEvent();
		virtual ~TransformMaskImportEvent();
		TransformMaskImportEvent(HPS::SegmentKey & in_segment_key, HPS::TransformMaskKit & in_transform_mask_kit);

		HPS::SegmentKey &				segment_key;
		HPS::TransformMaskKit &			transform_mask_kit;
	};

	class HPS_API TransparencyImportEvent : public ImportEvent
	{
		TransparencyImportEvent(TransparencyImportEvent const &);
		TransparencyImportEvent & operator=(TransparencyImportEvent const &);
	public:
		TransparencyImportEvent();
		virtual ~TransparencyImportEvent();
		TransparencyImportEvent(HPS::SegmentKey & in_segment_key, HPS::TransparencyKit & in_transparency_kit);

		HPS::SegmentKey &				segment_key;
		HPS::TransparencyKit &			transparency_kit;
	};

	class HPS_API SubwindowImportEvent : public ImportEvent
	{
		SubwindowImportEvent(SubwindowImportEvent const &);
		SubwindowImportEvent & operator=(SubwindowImportEvent const &);
	public:
		SubwindowImportEvent();
		virtual ~SubwindowImportEvent();
		SubwindowImportEvent(HPS::SegmentKey & in_segment_key, HPS::SubwindowKit & in_subwindow_kit);

		HPS::SegmentKey &				segment_key;
		HPS::SubwindowKit &				subwindow_kit;
	};

	/*!	This class indicates non-database user data is being imported by Stream. */
	class HPS_API NonDBUserDataImportEvent : public ImportEvent
	{
		NonDBUserDataImportEvent(NonDBUserDataImportEvent const &);
		NonDBUserDataImportEvent & operator=(NonDBUserDataImportEvent const &);
	public:
		NonDBUserDataImportEvent() {}
		virtual ~NonDBUserDataImportEvent();
		NonDBUserDataImportEvent(size_t in_count, HPS::byte const in_data[]);

		/*! An HPS::ByteArray of user data that is not associated with the database. */
		HPS::ByteArray user_data;
	};

	/*!	This class indicates that user data contained within the database (associated with either a segment or geometry key) is being imported by Stream. */
	class HPS_API UserDataImportEvent : public ImportEvent
	{
		UserDataImportEvent(UserDataImportEvent const &);
		UserDataImportEvent & operator=(UserDataImportEvent const &);
	public:
		virtual ~UserDataImportEvent();
		UserDataImportEvent();
		UserDataImportEvent(HPS::Key & in_key, intptr_t in_index, size_t in_count, HPS::byte const in_data[]);

		HPS::Key key;
		intptr_t index;

		/*! An HPS::ByteArray of user data that is associated with the database. */
		HPS::ByteArray user_data;
	};

	class HPS_API VisibilityImportEvent : public ImportEvent
	{
		VisibilityImportEvent(VisibilityImportEvent const &);
		VisibilityImportEvent & operator=(VisibilityImportEvent const &);
	public:
		VisibilityImportEvent();
		virtual ~VisibilityImportEvent();
		VisibilityImportEvent(HPS::SegmentKey & in_segment_key, HPS::VisibilityKit & in_visibility_kit);

		HPS::SegmentKey & segment_key;
		HPS::VisibilityKit & visibility_kit;
	};

	class HPS_API VisualEffectsImportEvent : public ImportEvent
	{
		VisualEffectsImportEvent(VisualEffectsImportEvent const &);
		VisualEffectsImportEvent & operator=(VisualEffectsImportEvent const &);
	public:
		VisualEffectsImportEvent();
		virtual ~VisualEffectsImportEvent();
		VisualEffectsImportEvent(HPS::SegmentKey & in_segment_key, HPS::VisualEffectsKit & in_visual_effects_kit);

		HPS::SegmentKey &				segment_key;
		HPS::VisualEffectsKit &			visual_effects_kit;
	};

	/////////////////////////////////////////////////////////////////////////////


	/*!	The ImportOptionsKit class contains any settings controlling the import of HSF files. */
	class HPS_API ImportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportOptionsKit object. */
		ImportOptionsKit();

		/*! The copy constructor creates a new ImportOptionsKit object that contains the same settings as the source ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		ImportOptionsKit(ImportOptionsKit const & in_kit);

		/*! The move constructor creates an ImportOptionsKit by transferring the underlying impl of the rvalue reference to this ImportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from. */
		ImportOptionsKit(ImportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit & operator=(ImportOptionsKit && in_that);

		virtual ~ImportOptionsKit();

	static const HPS::Type staticType = HPS::Type::StreamImportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		void					Set(ImportOptionsKit const & in_kit);

		/*! Copies this ImportOptionsKit into the given ImportOptionsKit.
		 * 	\param out_kit The ImportOptionsKit to populate with the contents of this ImportOptionsKit. */
		void					Show(ImportOptionsKit & out_kit) const;

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		operator=(ImportOptionsKit const & in_kit);

		/*! Indicates whether this ImportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is not equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportOptionsKit const & in_kit) const;

		/*! Sets the toolkit used for the import process. If no tooklkit is specified, a default tookit will be used during import.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetToolkit(Toolkit const & in_toolkit);

		/*! Removes the toolkit used for the import process.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetToolkit();

		/*! Shows the root toolkit used for the import process.
		 *	\param out_toolkit The Toolkit used for the import process.
		 *	\return <span class='code'>true</span> if a toolkit was specified, <span class='code'>false</span> otherwise. */
		bool					ShowToolkit(HPS::Stream::Toolkit & out_toolkit) const;

		/*! Sets the root segment where the HSF data will be imported into.  If no segment is specified, a root segment will be created for this
		 * 	purpose during import.
		 *	\param in_segment Segment the HSF data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment speciyfing where the HSF data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetSegment();

		/*! Shows the root segment where the HSF data will be imported into.
		 *	\param out_segment Segment the HSF data will be imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Sets the segment which will be used when the import file tries to access segments above the root segment.
		 * 	If no segment is specified, a root segment will be created for this purpose during import.
		 *	\param in_segment Segment that will be used when the import file tries to access segments above the root segment.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetAlternateRoot(SegmentKey const & in_segment);

		/*! Removes the segment which will be used when the import file tries to access segments above the root segment.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetAlternateRoot();

		/*! Shows the segment which will be used when the import file tries to access segments above the root segment.
		 *	\param out_segment Segment that will be used when the import file tries to access segments above the root segment.
		 *	\return <span class='code'>true</span> if an alternate root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowAlternateRoot(SegmentKey & out_segment) const;

		/*! Sets the portfolio which will be used for any definitions that need to be created during import.
		 * 	If no portfolio is specified, a portfolio will be created for this purpose during import.
		 *	\param in_portfolio Portfolio that will be used for any definitions that need to be created during import.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetPortfolio(PortfolioKey const & in_portfolio);

		/*! Removes the portfolio which will be used for any definitions that need to be created during import.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetPortfolio();

		/*! Shows the portfolio which will be used for any definitions that need to be created during import.
		 *	\param out_portfolio Portfolio that will be used for any definitions that need to be created during import.
		 *	\return <span class='code'>true</span> if a portfolio was specified, <span class='code'>false</span> otherwise. */
		bool					ShowPortfolio(PortfolioKey & out_portfolio) const;

		/*! Removes all settings from this ImportOptionsKit.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetEverything();

		/*! Sets the specified ImportEventHandler for the indicated ImportEvent type.
		 * \param in_handler An ImportEventHandler to be set.
		 * \param in_type The type of the Stream ImportEvent for which the given event handler will be used.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit & SetEventHandler(HPS::Stream::ImportEventHandler & in_handler, intptr_t in_type);

		/*! Unsets the ImportEventHandler for the indicated ImportEvent type.
		 * \param in_type The type of the Stream ImportEvent to unset.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit & UnsetEventHandler(intptr_t in_type);

		/*! Unsets the ImportEventHandler for all ImportEvent types.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit & UnsetEventHandlers();
	};

	/*! The ImportResultsKit class contains the results of a successful HSF import. */
	class HPS_API ImportResultsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportResultsKit object. */
		ImportResultsKit();

		/*! The copy constructor creates a new ImportResultsKit object that contains the same settings as the source ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		ImportResultsKit(ImportResultsKit const & in_kit);

		/*! The move constructor creates an ImportResultsKit by transferring the underlying impl of the rvalue reference to this ImportResultsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from. */
		ImportResultsKit(ImportResultsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportResultsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit & operator=(ImportResultsKit && in_that);

		virtual ~ImportResultsKit();

		static const HPS::Type staticType = HPS::Type::StreamImportResultsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		void					Set(ImportResultsKit const & in_kit);

		/*! Copies this ImportResultsKit into the given ImportResultsKit.
		 * 	\param out_kit The ImportResultsKit to populate with the contents of this ImportResultsKit. */
		void					Show(ImportResultsKit & out_kit) const;

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		operator=(ImportResultsKit const & in_kit);

		/*! Indicates whether this ImportResultsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportResultsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is not equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportResultsKit const & in_kit) const;

		/*! Sets the root segment which the HSF data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an HSF import.
		 *	\param in_segment Segment the HSF data was imported into.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment which the HSF data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an HSF import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetSegment();

		/*! Shows the root segment which the HSF data was imported into.  This was either the root segment specified by the user in the ImportOptionsKit
		 * 	passed to Stream::File::Import, or the root segment that was created for this purpose during import.
		 *	\param out_segment Segment the HSF data was imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Sets the segment which was used when the import file tried to access segments above the root segment.  This is really only
		 * 	used when generating an ImportResultsKit which is being returned to a user following an HSF import.
		 *	\param in_segment Segment that was used when the import file tried to access segments above the root segment during import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetAlternateRoot(SegmentKey const & in_segment);

		/*! Removes the segment which was used when the import file tried to access segments above the root segment.  This is really only
		 * 	used when generating an ImportResultsKit which is being returned to a user following an HSF import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetAlternateRoot();

		/*! Shows the segment which was used when the import file tried to access segments above the root segment.  This was either the alternate root
		 * 	specified by the user in the ImportOptionsKit passed to Stream::File::Import, or the root segment that was created for this purpose during
		 * 	import.
		 *	\param out_segment Segment that was used when the import file tried to access segments above the root segment.
		 *	\return <span class='code'>true</span> if an alternate root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowAlternateRoot(SegmentKey & out_segment) const;

		/*! Sets the portfolio which was used for any definitions that had to be created during import.  This is really only
		 *	used when generating an ImportResultsKit which is being returned to a user following an HSF import.
		 *	\param in_portfolio Portfolio that was used for any definitions that had to be created during import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetPortfolio(PortfolioKey const & in_portfolio);

		/*! Removes the portfolio which was used for any definitions that had to be created during import.  This is really only
		 *	used when generating an ImportResultsKit which is being returned to a user following an HSF import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetPortfolio();

		/*! Shows the portfolio which was used for any definitions that had to be created during import.  This was either the portfolio
		 *	specified by the user in the ImportOptionsKit passed to Stream::File::Import, or the portfolio that was created for this purpose during
		 *	import.
		 *	\param out_portfolio Portfolio that was used for any definitions that had to be created during import.
		 *	\return <span class='code'>true</span> if a portfolio was specified, <span class='code'>false</span> otherwise. */
		bool					ShowPortfolio(PortfolioKey & out_portfolio) const;

		/*! Sets the "default" camera for this ImportResultsKit. This is generally only used during a Stream Import to record the default
		 * camera read from the Stream file.
		 *	\param in_camera The "default" named camera from the HSF file.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetDefaultCamera(CameraKit const & in_camera);

		/*! Removes the "default" camera from this ImportResultsKit. This is generally only used for ImportResultsKits that are
		 * 	generated from a Stream import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetDefaultCamera();

		/*! Shows the "default" camera for this ImportOptionsKit. The "default" camera is set during a Stream Import.
		 *  There can only be a single default camera in a Stream file.
		 *	\param out_camera The "default" camera from the Stream file.
		 *	\return <span class='code'>true</span> if a default camera was specified, <span class='code'>false</span> otherwise. */
		bool					ShowDefaultCamera(CameraKit & out_camera) const;


		/*! Sets the alternate named cameras that were present in the HSF file.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an HSF import.
		 *	\param in_names The names of the cameras in the HSF file.
		 *	\param in_cameras The cameras in the HSF file.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetAlternateCameras(UTF8Array const & in_names, CameraKitArray & in_cameras);

		/*! Removes the alternate named cameras that were present in the HSF file.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an HSF import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetAlternateCameras();

		/*! Shows the alternate named cameras that were present in the HSF file.  This includes all cameras other than "default".
		 *	\param out_names The names of the cameras in the HSF file.
		 *	\param out_cameras The cameras in the HSF file.
		 *	\return <span class='code'>true</span> if alternate cameras were specified, <span class='code'>false</span> otherwise. */
		bool					ShowAlternateCameras(UTF8Array & out_names, CameraKitArray & out_cameras) const;


		/*! Removes all settings from this ImportResultsKit.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetEverything();
	};

	/*!	The HPS::Stream::ExportOptionsKit class contains settings controlling the export of HSF files. Calling HPS::Stream::ExportOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">this table</a>. */
	class HPS_API ExportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ExportOptionsKit object. */
		ExportOptionsKit();

		/*! The copy constructor creates a new ExportOptionsKit object that contains the same settings as the source ExportOptionsKit.
		 * 	\param in_kit The source ExportOptionsKit to copy. */
		ExportOptionsKit(ExportOptionsKit const & in_kit);

		/*! The move constructor creates an ExportOptionsKit by transferring the underlying impl of the rvalue reference to this ExportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from. */
		ExportOptionsKit(ExportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ExportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from.
		 * 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		operator=(ExportOptionsKit && in_that);

		/*! Creates a ExportOptionsKit which contains the default settings.  The returned object will not necessarily have values
		 *	set for every option, but it will have settings for those options where it is reasonable to have a default.
		 *	\return A ExportOptionsKit with the default settings. */
		static ExportOptionsKit GetDefault();

		virtual ~ExportOptionsKit();

		static const HPS::Type staticType = HPS::Type::StreamExportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
		 * 	\param in_kit The source ExportOptionsKit to copy. */
		void					Set(ExportOptionsKit const & in_kit);

		/*! Copies this ExportOptionsKit into the given ExportOptionsKit.
		 * 	\param out_kit The ExportOptionsKit to populate with the contents of this ExportOptionsKit. */
		void					Show(ExportOptionsKit & out_kit) const;

		/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
		 * 	\param in_kit The source ExportOptionsKit to copy.
		 * 	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		operator=(ExportOptionsKit const & in_kit);

		/*! Indicates whether this ExportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ExportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
		 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ExportOptionsKit const & in_kit) const;

		/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
		 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ExportOptionsKit const & in_kit) const;

		/*!	Check if the source ExportOptionsKit is not equivalent to this ExportOptionsKit.
		 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ExportOptionsKit const & in_kit) const;

		/*! Sets the toolkit used for the export process. If no toolkit is specified, a default tookit will be used during export.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		SetToolkit(Toolkit const & in_toolkit);

		/*! Sets the default camera used for the export process. If no camera is specified, no default camera will be used during export.
		 *	\param in_camera The camera to apply as default.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		SetDefaultCamera(CameraKit const & in_camera);

		/*! Sets vertex compression state and maximum number of bits to use for each (x,y,z) vertex.  Defaults to no compression.
		 *	\param in_state Whether vertex compression is enabled or not.
		 *	\param in_bits_per_vertex Number of bits to use per vertex when performing vertex compression.  Value must be in the range
		 *		<span class='code'>[0, 72]</span>.  Defaults to <span class='code'>24</span>.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetVertexCompression(bool in_state, unsigned int in_bits_per_vertex = 24);

		/*! Sets normal compression state and maximum number of bits to use for each (x,y,z) normal.  Defaults to no compression.
		 *	\param in_state Whether normal compression is enabled or not.
		 *	\param in_bits_per_normal Number of bits to use per normal when performing normal compression.  Value must be in the range
		 *		<span class='code'>[0, 72]</span>.  Defaults to <span class='code'>10</span>.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetNormalCompression(bool in_state, unsigned int in_bits_per_normal = 10);

		/*! Sets vertex parameter compression state and maximum number of bits to use for each (single) vertex parameter.  Defaults to no compression.
		 *	\param in_state Whether parameter compression is enabled or not.
		 *	\param in_bits_per_parameter Number of bits to use per parameter when performing parameter compression.  Value must be in the range
		 *		<span class='code'>[0, 24]</span>.  Defaults to <span class='code'>8</span>.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		SetParameterCompression(bool in_state, unsigned int in_bits_per_parameter = 8);

		/*! Sets color compression state and maximum number of bits to use for each (r,g,b) color.  Defaults to no compression.
		 *	\param in_state Whether color compression is enabled or not.
		 *	\param in_bits_per_color Number of bits to use per color when performing color compression.  Value must be in the range
		 *		<span class='code'>[0, 72]</span>.  Defaults to <span class='code'>24</span>.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetColorCompression(bool in_state, unsigned int in_bits_per_color = 24);

		/*! Sets color index compression state and maximum number of bits to use for each float index.  Defaults to no compression.
		 *	\param in_state Whether color index compression is enabled or not.
		 *	\param in_bits_per_index Number of bits to use per index when performing color index compression.  Value must be in the range
		 *		<span class='code'>[0, 24]</span>.  Defaults to <span class='code'>8</span>.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetIndexCompression(bool in_state, unsigned int in_bits_per_index = 8);

		/*! Sets connectivity (face list) compression state.  Defaults to no compression.
		 *	\param in_state Whether color index compression is enabled or not.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetConnectivityCompression(bool in_state);

		/*! Sets tristrips serialization state.  Defaults to tristrips are serialized.
		 *	\param in_state Whether tristrips serialization is enabled or not.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetSerializeTristrips(bool in_state);

		/*! Sets image compression state for uncompressed images in segment tree.  Defaults to no compression, though the images will be converted
		 * 	to lossless PNG data within the file.
		 *	\param in_state Whether to compress uncompressed images.  If <span class='code'>false</span>, uncompressed images
		 *		will be exported as lossless PNG, if <span class='code'>true</span>, they are exported as JPEG with the specified quality.
		 *	\param in_quality Float in the range [0,1] indicating the quality of the JPEG image.  Defaults to <span class='code'>0.75f</span>.
		 *	\return A reference to this ExportOptionsKit.
		 *  \sa <a href="../../prog_guide/appendix_default_attribute_values.html#stream-io">Default value</a>
		 */
		ExportOptionsKit &		SetImageCompression(bool in_state, float in_quality = 0.75f);

		/*! Removes the toolkit used for the export process.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetToolkit();

		/*! Removes the default camera used for the export process.
		* \return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetDefaultCamera();

		/*! Removes vertex compression state and maximum number of bits to use for each (x,y,z) vertex.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetVertexCompression();

		/*! Removes normal compression state and maximum number of bits to use for each (x,y,z) normal.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetNormalCompression();

		/*! Removes vertex parameter compression state and maximum number of bits to use for each (single) vertex parameter.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetParameterCompression();

		/*! Removes color compression state and maximum number of bits to use for each (r,g,b) color.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetColorCompression();

		/*! Removes color index compression state and maximum number of bits to use for each float index.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetIndexCompression();

		/*! Removes connectivity (face list) compression state.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetConnectivityCompression();

		/*! Removes image compression state for uncompressed images in segment tree.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetImageCompression();

		/*! Removes tristrips serialization state.
		 *	\return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetSerializeTristrips();

		/*! Removes all settings from this ExportOptionsKit.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit &		UnsetEverything();

		/*! Shows the root toolkit used for the export process.
		 *	\param out_toolkit The Toolkit used for the export process.
		 *	\return <span class='code'>true</span> if a toolkit was specified, <span class='code'>false</span> otherwise. */
		bool					ShowToolkit(HPS::Stream::Toolkit & out_toolkit) const;

		/*! Shows the default camera used for the export process.
		 *	\param out_camera The camera being used as default.
		 * \return A reference to this ExportOptionsKit. */
		bool					ShowDefaultCamera(CameraKit & out_camera) const;

		/*! Shows vertex compression state and maximum number of bits to use for each (x,y,z) vertex.
		 *	\param out_state Whether vertex compression is enabled or not.
		 *	\param out_bits_per_vertex Number of bits to use per vertex when performing vertex compression.
		 *	\return <span class='code'>true</span> if a vertex compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowVertexCompression(bool & out_state, unsigned int & out_bits_per_vertex) const;

		/*! Shows normal compression state and maximum number of bits to use for each (x,y,z) normal.
		 *	\param out_state Whether normal compression is enabled or not.
		 *	\param out_bits_per_normal Number of bits to use per normal when performing normal compression.
		 *	\return <span class='code'>true</span> if a normal compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowNormalCompression(bool & out_state, unsigned int & out_bits_per_normal) const;

		/*! Shows vertex parameter compression state and maximum number of bits to use for each (single) vertex parameter.
		 *	\param out_state Whether parameter compression is enabled or not.
		 *	\param out_bits_per_parameter Number of bits to use per parameter when performing parameter compression.
		 *	\return <span class='code'>true</span> if a parameter compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowParameterCompression(bool & out_state, unsigned int & out_bits_per_parameter) const;

		/*! Shows color compression state and maximum number of bits to use for each (r,g,b) color.
		 *	\param out_state Whether color compression is enabled or not.
		 *	\param out_bits_per_color Number of bits to use per color when performing color compression.
		 *	\return <span class='code'>true</span> if a color compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowColorCompression(bool & out_state, unsigned int & out_bits_per_color) const;

		/*! Shows color index compression state and maximum number of bits to use for each float index.
		 *	\param out_state Whether color index compression is enabled or not.
		 *	\param out_bits_per_index Number of bits to use per index when performing color index compression.
		 *	\return <span class='code'>true</span> if a color index compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowIndexCompression(bool & out_state, unsigned int & out_bits_per_index) const;

		/*! Shows connectivity (face list) compression state.
		 *	\param out_state Whether connectivity compression is enabled or not.
		 *	\return <span class='code'>true</span> if a connectivity compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowConnectivityCompression(bool & out_state) const;

		/*! Shows image compression state for uncompressed images in segment tree.
		 *	\param out_state Whether image compression is enabled or not.
		 *	\param out_quality  Float in the range [0,1] indicating the quality of the JPEG image.
		 *	\return <span class='code'>true</span> if an image compression setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowImageCompression(bool & out_state, float & out_quality) const;

		/*! Shows tristrips serialization state.
		 *	\param out_state Whether tristrips serialization is enabled or not.
		 *	\return <span class='code'>true</span> if a tristrips serialization setting was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSerializeTristrips(bool & out_state) const;

		/*! Sets the specified ExportEventHandler for the indicated ExportEvent type.
		 * \param in_handler An ExportEventHandler to be set.
		 * \param in_type The type of the Stream ExportEvent for which the given event handler will be used.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit & SetEventHandler(HPS::Stream::ExportEventHandler & in_handler, intptr_t in_type);

		/*! Unsets the ExportEventHandler for the indicated ExportEvent type.
		 * \param in_type The type of the Stream ExportEvent to unset.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit & UnsetEventHandler(intptr_t in_type);

		/*! Unsets the ExportEventHandler for all ExportEvent types.
		 * \return A reference to this ExportOptionsKit. */
		ExportOptionsKit & UnsetEventHandlers();
	};

	/*! The ImportNotifier class is a smart-pointer that is associated with an asynchronous file import.  It is used to interact with an ongoing
	 * 	import or get the results from a completed import. */
	class HPS_API ImportNotifier : public IONotifier
	{
	public:
		/*! The default constructor creates an ImportNotifier object which is not associated with any file import. */
		ImportNotifier();

		/*! The copy constructor creates a new ImportNotifier object that is associated with the same file import as the source ImportNotifier.
		 * 	\param in_that The source ImportNotifier to copy. */
		ImportNotifier(ImportNotifier const & in_that);

		/*! The conversion constructor creates a new derived ImportNotifier object from a base IONotifier object.
		 * 	The copy will only be successful if the source notifier is really an upcast of this notifier type.
		 *	Otherwise the copy will fail and the resulting ImportNotifier will be invalid.
		 * 	\param in_that The source IONotifier to copy. */
		ImportNotifier(IONotifier const & in_that);

		/*! The move constructor creates an ImportNotifier by transferring the underlying impl of the rvalue reference to this ImportNotifier
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from. */
		ImportNotifier(ImportNotifier && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportNotifier thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from.
		 * 	\return A reference to this ImportNotfier. */
		ImportNotifier &		operator=(ImportNotifier && in_that);

		virtual ~ImportNotifier();

	static const HPS::Type staticType = HPS::Type::StreamImportNotifier;
		HPS::Type				ObjectType() const {return staticType;};

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment.
		 *	\return A reference to this ImportNotifier. */
		ImportNotifier &		operator=(ImportNotifier const & in_that);

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment. */
		void					Assign(ImportNotifier const & in_that);

		/*!	Get the ImportResultsKit for the file import.  Throws an IOException if the import is not complete or
		 *  was not successful.
		 *  \return The ImportResultsKit for a successful file import. */
		ImportResultsKit		GetResults() const;
	};

	/*! The ExportNotifier class is a smart-pointer that is associated with an asynchronous file export.  It is used to interact with an ongoing
	 * 	export or get the results from a completed export. */
	class HPS_API ExportNotifier : public IONotifier
	{
	public:
		/*! The default constructor creates an ExportNotifier object which is not associated with any file export. */
		ExportNotifier();

		/*! The copy constructor creates a new ExportNotifier object that is associated with the same file export as the source ExportNotifier.
		 * 	\param in_that The source ExportNotifier to copy. */
		ExportNotifier(ExportNotifier const & in_that);

		/*! The conversion constructor creates a new derived ExportNotifier object from a base IONotifier object.
		 * 	The copy will only be successful if the source notifier is really an upcast of this notifier type.
		 *	Otherwise the copy will fail and the resulting ExportNotifier will be invalid.
		 * 	\param in_that The source IONotifier to copy. */
		ExportNotifier(IONotifier const & in_that);

		/*! The move constructor creates an ExportNotifier by transferring the underlying impl of the rvalue reference to this ExportNotifier
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ExportNotifier to take the impl from. */
		ExportNotifier(ExportNotifier && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ExportNotifier thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ExportNotifier to take the impl from.
		 * 	\return A reference to this ExportNotifier. */
		ExportNotifier &		operator=(ExportNotifier && in_that);

		virtual ~ExportNotifier();

	static const HPS::Type staticType = HPS::Type::StreamExportNotifier;
		HPS::Type				ObjectType() const {return staticType;};

		/*! Associate this ExportNotifier with the same file export as the source ExportNotifier.
		 *	\param in_that The source ExportNotifier for the assignment.
		 *	\return A reference to this ExportNotifier. */
		ExportNotifier &		operator=(ExportNotifier const & in_that);

		/*! Associate this ExportNotifier with the same file export as the source ExportNotifier.
		 *	\param in_that The source ExportNotifier for the assignment. */
		void					Assign(ExportNotifier const & in_that);
	};


	/*!	The File class provides functions to import and export HSF files. */
	class HPS_API File
	{
	public:
		/*!	Performs an asynchronous import of the specified HSF file with the provided options.  May throw an IOException prior to starting
		 * 	the asynchronous import.
		 * 	\param in_file_name Name of HSF file to import.
		 *	\param in_options Options controlling the import of the HSF file (e.g., segment to import into).
		 *	\return An ImportNotfier object that can be used to query the import progress and status. */
		static ImportNotifier	Import(char const * in_file_name, ImportOptionsKit const & in_options);

		/*!	Performs an asynchronous import of the specified HSF file with the provided options.  May throw an IOException prior to starting
		* 	the asynchronous import.
		* 	\param in_hsf_buffers The buffer of HSF data to import.
		*	\param in_options Options controlling the import of the HSF file (e.g., segment to import into).
		*	\return An ImportNotfier object that can be used to query the import progress and status. */
		static ImportNotifier	Import(ByteArrayArray const & in_hsf_buffers, ImportOptionsKit const & in_options);

		/*! Performs an asynchronous HSF export of the given segment with the provided options to a given filename.  An exception will be thrown
		 * 	if a problem is encountered during export.
		 * 	\param in_file_name Name of the file to write the HSF data to.
		 * 	\param in_segment Segment containing the data to export.
		 * 	\param in_options Options controlling the export of the HSF data.
		 *	\return An ExportNotifier object that can be used to query the export progress and status. */
		static ExportNotifier	Export(char const * in_file_name, SegmentKey const & in_segment, ExportOptionsKit const & in_options);

		/*! Performs an asynchronous HSF export of the given segment with the provided options to a list of output buffers.
		 *  An exception will be thrown if a problem is encountered during export.
		 * 	\param in_segment Segment containing the data to export.
		 * 	\param in_options Options controlling the export of the HSF data.
		 * 	\param out_hsf_buffers The output buffers the exported HSF data is written to.
		 *	\return An ExportNotifier object that can be used to query the export progress and status. */
		static ExportNotifier	Export(SegmentKey const & in_segment, ExportOptionsKit const & in_options, ByteArrayArray & out_hsf_buffers);

	private:
		//! Private default constructor to prevent instantiation.
		File();
	};
private:
	//! Private default constructor to prevent instantiation.
	Stream();
};

//////////////////////////////////////////////////////////////////////
///////////////////////////// Hardcopy File IO//////////////////////////
//////////////////////////////////////////////////////////////////////
/*!
<p>The Hardcopy class attempts to reproduce the scene graph to each of its supported export types. This includes printing to physical paper and 2D PDF.</p>

<p>Default values for the various fields of the Hardcopy class can be found <a href="../../prog_guide/appendix_default_attribute_values.html#hardcopy">here</a>.</p>
*/
class HPS_API Hardcopy
{
public:

	/*! The Hardcopy::Size class is a concept class for hardcopy output-size-related enum classes. */
	enum class SizeUnits : uint32_t
	{
		Centimeters,					//!< Centimeters
		Inches,							//!< Inches
	};

	/*! The Hardcopy::Resolution class is a concept class for hardcopy output-resolution-related enum classes. */
	enum class ResolutionUnits : uint32_t
	{
		DPCM,						//!< Dots Per Centimeter
		DPI,						//!< Dots Per Inch
		DotsPerCentimeter = DPCM,	//!< Dots Per Centimeter
		DotsPerInch = DPI,			//!< Dots Per Inch
	};

	/*! The Hardcopy::BackgroundPreference class is used to decide what the Hardcopy background looks like. */
	enum class BackgroundPreference : uint32_t
	{
		UseBackgroundColor,			//!< The current scene background is exported to Hardcopy
		ForceSolidWhite,			//!< The exported Hardcopy background will be white
	};

	/*! The Hardcopy::RenderingOptions class is used to decide how the Hardcopy export will be conducted. */
	enum class RenderingAlgorithm : uint32_t
	{
		TwoPassPrint,				//!< The default Hardcopy export. Two passes are used to ensure that vector data is as detailed as possible, while saving on file size by rendering non-vector data at lower resolution.
		SinglePassPrint,			//!< The Hardcopy export completes in a single pass. Non-vector data may take up large amount of space on disk. If your on-screen scene was rendered using the Priority HSRA, using SinglePassPrint is required in order for the Hardcopy export to be accurate.
	};

	/*! The Hardcopy::PDFFontPreference  class is used to decide how fonts are treated during PDF exports */
	enum class PDFFontPreference : uint32_t
	{
		DoNotEmbedFonts,			//!< Fonts used are not embedded in exported PDF files. The resulting file will only look correct when opened on platforms which have the fonts used in the PDF document installed
		EmbedFonts,					//!< Fonts used in the PDF are embedded into it. The exported PDF file will render the same way on any platform. Its size will be larger than if fonts were not embedded.
	};

	/*! Encapsulates all the functions and options related to exporting HPS::Hardcopy files. */
	class HPS_API File
	{
	public:

		/*!	The HPS::Hardcopy::File::ExportOptionsKit class contains settings controlling hardcopy export. Calling HPS::Hardcopy::File::ExportOptionsKit::GetDefault() will return an options kit with values found in <a href="../../prog_guide/appendix_default_attribute_values.html#hardcopy">here.</a> */
		class HPS_API ExportOptionsKit : public Kit
		{
		public:
			/*! The default constructor creates an empty ExportOptionsKit object. */
			ExportOptionsKit();

			/*! The copy constructor creates a new ExportOptionsKit object that contains the same settings as the source ExportOptionsKit.
			 * 	\param in_kit The source ExportOptionsKit to copy. */
			ExportOptionsKit(ExportOptionsKit const & in_kit);

			/*! The move constructor creates an ExportOptionsKit by transferring the underlying impl of the rvalue reference to this ExportOptionsKit
			 * 	thereby avoiding a copy and allocation.
			 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from. */
			ExportOptionsKit(ExportOptionsKit && in_that);

			/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ExportOptionsKit thereby avoiding a copy.
			 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit & operator=(ExportOptionsKit && in_that);

			virtual ~ExportOptionsKit();

			static const HPS::Type staticType = HPS::Type::HardcopyExportOptionsKit;
			HPS::Type				ObjectType() const { return staticType; };

			/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
			 * 	\param in_kit The source ExportOptionsKit to copy. */
			void					Set(ExportOptionsKit const & in_kit);

			/*! Copies this ExportOptionsKit into the given ExportOptionsKit.
			 * 	\param out_kit The ExportOptionsKit to populate with the contents of this ExportOptionsKit. */
			void					Show(ExportOptionsKit & out_kit) const;

			/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
			 * 	\param in_kit The source ExportOptionsKit to copy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		operator=(ExportOptionsKit const & in_kit);

			/*! Indicates whether this ExportOptionsKit has any values set on it.
			 * 	\return <span class='code'>true</span> if no values are set on this ExportOptionsKit, <span class='code'>false</span> otherwise. */
			bool					Empty() const;

			/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
			 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
			 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
			bool					Equals(ExportOptionsKit const & in_kit) const;

			/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
			 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
			 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
			bool					operator==(ExportOptionsKit const & in_kit) const;

			/*!	Check if the source ExportOptionsKit is not equivalent to this ExportOptionsKit.
			 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
			 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
			bool					operator!=(ExportOptionsKit const & in_kit) const;




			/*! Shows the size of the image to be inserted into the Hardcopy.
			 * 	\param out_width Width.
			 * 	\param out_height Height.
			 *  \param out_units Units of preceding arguments.
			 *	\return <span class='code'>true</span> if a size setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowSize(float & out_width, float & out_height, Hardcopy::SizeUnits & out_units) const;

			/*! Sets the size of the image to be inserted into the Hardcopy.
			 * 	\param in_width Width in inches.
			 * 	\param in_height Height in inches.
			 *  \param in_units Units of preceding arguments. Defaults to Inches
			 * 	\return A reference to this ExportOptionsKit.
			 *   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#hardcopy">Default value</a>
			 */
			ExportOptionsKit &		SetSize(float in_width, float in_height, Hardcopy::SizeUnits in_units = Hardcopy::SizeUnits::Inches);

			/*! Removes the size of the image to be inserted into the Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetSize();



			/*! Shows the resolution of the image to be inserted into the Hardcopy.
			 * 	\param out_resolution Resolution (dots per inch or dots per centimeter).
			 * 	\param out_units Units of preceding arguments.
			 *	\return <span class='code'>true</span> if a size setting was specified, <span class='code'>false</span> otherwise.
			 */
			bool					ShowResolution(float & out_resolution, Hardcopy::ResolutionUnits & out_units) const;

			/*! Sets the resolution of the image to be inserted into the Hardcopy.
			 * 	\param in_resolution Resolution (dots per inch or dots per centimeter).
			 * 	\param in_units Units of preceding arguments. Defaults to Inches.
			 * 	\return A reference to this ExportOptionsKit.
			 *   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#hardcopy">Default value</a>
			 */
			ExportOptionsKit &		SetResolution(float in_resolution, Hardcopy::ResolutionUnits in_units = Hardcopy::ResolutionUnits::DPI);

			/*! Removes the resolution of the image to be inserted into the Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetResolution();

			/*! Shows the hidden line sorting options of Hardcopy.
			*	\param out_state Whether hidden line sorting is on or off.
			*	\param out_threshold The minimum width at which hidden lines are sorted.
			*	\param out_units The units that out_threshold is measured in.
			*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
			bool					ShowHiddenLineSorting(bool & out_state, float & out_threshold, HPS::Line::SizeUnits & out_units) const;

			/*!	Species whether hidden lines are sorted, and if so, what the threshold for sorting is.
			*	If Hidden %Line Sorting is activated, lines will be printed in proper z-order. If this option
			*	is not activated, the order in which lines are printed is non-deterministic.
			*	Enabling this option will result in slower performance.
			*	\param in_on Whether to sort hidden lines or not.
			*	\param in_activation_weight What is the minimum size of hidden lines that are sorted.
			*	Lines thinner than this will not be sorted.
			*	\param in_units Units applied to in_activation_weight.
			* 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetHiddenLineSorting(bool in_on, float in_activation_weight = 2.0f, HPS::Line::SizeUnits in_units = HPS::Line::SizeUnits::Pixels);

			/*! Removes the line sorting settings for hidden lines from Hardcopy
			*	\return A reference to this object. */
			ExportOptionsKit &		UnsetHiddenLineSorting();


			/*! Shows true if wysiwyg has been enabled
			 *  \param out_onoff whether 'what you see is what you get' is turned on or off
			 *	\return <span class='code'>true</span> if a wysiwyg setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowWYSIWYG(bool & out_onoff) const;

			/*! Enables or disables WYSIWYG hardcopy output. The WYSIWYG setting (which stands for What You See Is What You Get)
			 *  works as follows:
			 *  <ul>
			 *  <li>If true, what you see on the screen is what will be printed. This is the default.</li>
			 *  <li>If false, everything which will fit on the page size you have specified will be printed, even if some of that
			 *  is not on screen when you issue the command.
			 *  </ul>
			 *  \param in_onoff true is on, false is off.
			 * 	\return A reference to this ExportOptionsKit.
			 *   \sa <a href="../../prog_guide/appendix_default_attribute_values.html#hardcopy">Default value</a>
			 */
			ExportOptionsKit &		SetWYSIWYG(bool in_onoff);

			/*! Removes the wysiwyg setting from Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetWYSIWYG();

			/*! Shows true if a scale has been set
			 * 	\param out_scale the scale specified.
			 * 	\param out_units the units out_scale is specified in.
			 *	\return <span class='code'>true</span> if a scale setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowScale(float & out_scale, HPS::Hardcopy::SizeUnits & out_units) const;

			/*! Scales Visualize units to correspond to real world units.
			 *  For example, SetScale(1.0f, Hardcopy::SizeUnits::Inches), will make it so that every Visualize unit corresponds to 1 inch for this export,
			 *  SetScale(2.0f, Hardcopy::SizeUnits::Centimeters), will make it so that every Visualize unit corresponds to 2 centimeters for this export.
			 *  SetScale(0.2, Hardcopy::SizeUnits::Centimeters), will make it so that every Visualize unit corresponds to 2 millimeters for this export.
			 *  Setting a scale is not defined for perspective cameras.
			 *  \param in_scale the unit scale. in_scale is required to be a positive number.
			 *  \param in_units the unit in_scale is expressed in.
			 * 	\return A reference to this ExportOptionsKit.
			 */
			ExportOptionsKit &		SetScale(float in_scale, Hardcopy::SizeUnits in_units = Hardcopy::SizeUnits::Inches);

			/*! Removes the scale setting from Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetScale();

			/*! Shows the background preference for this Hardcopy export.
			 * 	\param out_background_preference the preference for the background of this Hardcopy export.
			 *	\return <span class='code'>true</span> if a background preference setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowBackgroundPreference(Hardcopy::BackgroundPreference & out_background_preference) const;

			/*! The background preference setting is used to decide how the background of this Hardcopy operation will be handled.
			 *  If no preference is specified, the background will be forced to be white.
			 *  \param in_background_preference how the background for this Hardcopy export will be handled.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetBackgroundPreference(Hardcopy::BackgroundPreference in_background_preference);

			/*! Removes the background preference setting from this Hardcopy export.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetBackgroundPreference();


			/*! Shows the rendering algorithm for this Hardcopy export.
			 * 	\param out_rendering_algorithm the rendering algorithm setting of this Hardcopy export.
			 *	\return <span class='code'>true</span> if a rendering algorithm setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowRenderingAlgorithm(Hardcopy::RenderingAlgorithm & out_rendering_algorithm) const;

			/*! The rendering algorithm setting is used to decide how the Hardcopy export will be performed.
			 *  If no preference is specified, two passes will be used for the Hardcopy export.
			 *  \param in_rendering_algorithm how the Hardcopy export will be handled.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetRenderingAlgorithm(Hardcopy::RenderingAlgorithm in_rendering_algorithm);

			/*! Removes the rendering algorithm setting from this Hardcopy export.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetRenderingAlgorithm();

			/*! Shows the PDF font preference for this Hardcopy export.
			* 	\param out_pdf_font_preference the PDF font preference of this Hardcopy export.
			*	\return <span class='code'>true</span> if a PDF font preference was specified, <span class='code'>false</span> otherwise. */
			bool					ShowPDFFontPreference(Hardcopy::PDFFontPreference & out_pdf_font_preference) const;

			/*! The PDF font preference setting is used to decide whether fonts will be embedded in an expored PDF file.
			*  If no preference is specified, fonts will not be embedded in the exported PDF file.
			*  Embedding fonts makes sure that text included in exported PDF files will render the same way on any platform, but has
			*  the side effect of increasing the size of exported PDF.
			*  The 14 default PDF fonts are never embedded, regardless of this setting, since they are guaranteed to be available to 
			*  conforming PDF readers.
			*  \param in_pdf_font_preference the PDF font preference for this Hardcopy export
			*  \return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetPDFFontPreference(Hardcopy::PDFFontPreference in_pdf_font_preference);

			/*! Removes the PDF font preference setting from this Hardcopy export.
			* 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetPDFFontPreference();


			/*! Removes all settings from this ExportOptionsKit.
			 * \return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetEverything();


			/*! Creates a ExportOptionsKit which contains the default settings.  The returned object will not necessarily have values
			 *	set for every option, but it will have settings for those options where it is reasonable to have a default.
			 *	\return A ExportOptionsKit with the default settings. */
			static ExportOptionsKit	GetDefault();
		};

		/*! The Driver indicates whether the hardcopy will be exported as PDF or Postscript */
		enum class Driver : uint32_t
		{
			PDF,
			Postscript
		};

		/*! Export to a PDF or Postscript file
		 *  \param in_filename The name of the output file to export
		 *  \param in_driver_type The hardcopy driver to use.
		 *  \param in_window The window to print.
		 *  \param in_options Export options such as resolution, size and wysiwyg. */
		static IOResult Export(char const * in_filename, Driver in_driver_type, HPS::WindowKey const & in_window, ExportOptionsKit const & in_options);
	private:
		File();
	};

#ifdef _MSC_VER
	class HPS_API GDI
	{
	public:

		/*!	The ExportOptionsKit class contains settings controlling hardcopy export. */
		class HPS_API ExportOptionsKit : public Kit
		{
		public:
			/*! The default constructor creates an empty ExportOptionsKit object. */
			ExportOptionsKit();

			/*! The copy constructor creates a new ExportOptionsKit object that contains the same settings as the source ExportOptionsKit.
			 * 	\param in_kit The source ExportOptionsKit to copy. */
			ExportOptionsKit(ExportOptionsKit const & in_kit);

			/*! The move constructor creates an ExportOptionsKit by transferring the underlying impl of the rvalue reference to this ExportOptionsKit
			 * 	thereby avoiding a copy and allocation.
			 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from. */
			ExportOptionsKit(ExportOptionsKit && in_that);

			/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ExportOptionsKit thereby avoiding a copy.
			 * 	\param in_that An rvalue reference to an ExportOptionsKit to take the impl from.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit & operator=(ExportOptionsKit && in_that);

			virtual ~ExportOptionsKit();

			static const HPS::Type staticType = HPS::Type::HardcopyGDIExportOptionsKit;
			HPS::Type				ObjectType() const { return staticType; };

			/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
			 * 	\param in_kit The source ExportOptionsKit to copy. */
			void					Set(ExportOptionsKit const & in_kit);

			/*! Copies this ExportOptionsKit into the given ExportOptionsKit.
			 * 	\param out_kit The ExportOptionsKit to populate with the contents of this ExportOptionsKit. */
			void					Show(ExportOptionsKit & out_kit) const;

			/*! Copies the source ExportOptionsKit into this ExportOptionsKit.
			 * 	\param in_kit The source ExportOptionsKit to copy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		operator=(ExportOptionsKit const & in_kit);

			/*! Indicates whether this ExportOptionsKit has any values set on it.
			 * 	\return <span class='code'>true</span> if no values are set on this ExportOptionsKit, <span class='code'>false</span> otherwise. */
			bool					Empty() const;

			/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
			 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
			 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
			bool					Equals(ExportOptionsKit const & in_kit) const;

			/*!	Check if the source ExportOptionsKit is equivalent to this ExportOptionsKit.
			 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
			 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
			bool					operator==(ExportOptionsKit const & in_kit) const;

			/*!	Check if the source ExportOptionsKit is not equivalent to this ExportOptionsKit.
			 *	\param in_kit The source ExportOptionsKit to compare to this ExportOptionsKit.
			 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
			bool					operator!=(ExportOptionsKit const & in_kit) const;


			/*! Shows the size of the image to be exported to the Clipboard or EMF file. This value is ignored for printer export.
			 *	\param out_width Width in inches.
			 *	\param out_height Height in inches.
			 *	\return <span class='code'>true</span> if a size setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowSize(float & out_width, float & out_height) const;

			/*! Sets the size of the image to be exported to the Clipboard or EMF file. This value is ignored for printer export.
			 *	\param in_width Width in inches.
			 *	\param in_height Height in inches.
			 *	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetSize(float in_width, float in_height);

			/*! Removes the size of the image to be inserted into the Hardcopy.
			 *	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetSize();


			/*! Shows the resolution of the image to be inserted into the Hardcopy.
			 * 	\param out_resolution Resolution in specified units (dots per unit).
			 *	\return <span class='code'>true</span> if a size setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowResolution(float & out_resolution) const;

			/*! Sets the resolution of the image to be inserted into the Hardcopy.
			 * 	\param in_resolution Resolution in DPI (dots per unit).
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetResolution(float in_resolution);

			/*! Removes the resolution of the image to be inserted into the Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetResolution();

			/*! Shows the hidden line sorting options of Hardcopy.
			*	\param out_state Whether hidden line sorting is on or off.
			*	\param out_threshold The minimum width at which hidden lines are sorted.
			*	\param out_units The units that out_threshold is measured in.
			*	\return <span class='code'>true</span> if the setting is valid, <span class='code'>false</span> otherwise. */
			bool					ShowHiddenLineSorting(bool & out_state, float & out_threshold, HPS::Line::SizeUnits & out_units) const;

			/*!	Species whether hidden lines are sorted, and if so, what the threshold for sorting is.
			*	If Hidden %Line Sorting is activated, lines will be printed in proper z-order. If this option
			*	is not activated, the order in which lines are printed is non-deterministic.
			*	Enabling this option will result in slower performance.
			*	\param in_on Whether to sort hidden lines or not.
			*	\param in_activation_weight What is the minimum size of hidden lines that are sorted.
			*	Lines thinner than this will not be sorted.
			*	\param in_units Units applied to in_activation_weight.
			* 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetHiddenLineSorting(bool in_on, float in_activation_weight = 2.0f, HPS::Line::SizeUnits in_units = HPS::Line::SizeUnits::Pixels);

			/*! Removes the line sorting settings for hidden lines from Hardcopy
			*	\return A reference to this object. */
			ExportOptionsKit &		UnsetHiddenLineSorting();

			/*! Shows true if wysiwyg has been enabled
			 *	\return <span class='code'>true</span> if a size setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowWYSIWYG(bool & out_onoff) const;

			/*! Enables or disables wysiwyg hardcopy output
			 *  \param onoff true is on, false is off
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetWYSIWYG(bool in_onoff);

			/*! Removes the wysiwyg setting from Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetWYSIWYG();

			/*! Shows true if a scale has been set
			 * 	\param out_scale the scale specified.
			 * 	\param out_units the units out_scale is specified in.
			 *	\return <span class='code'>true</span> if a scale setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowScale(float & out_scale, HPS::Hardcopy::SizeUnits & out_units) const;

			/*! Scales Visualize units to correspond to real world units.
			 *  For example, SetScale(1.0f, Hardcopy::SizeUnits::Inches), will make it so that every Visualize unit corresponds to 1 inch for this export,
			 *  SetScale(2.0f, Hardcopy::SizeUnits::Centimeters), will make it so that every Visualize unit corresponds to 2 centimeters for this export.
			 *  SetScale(0.2, Hardcopy::SizeUnits::Centimeters), will make it so that every Visualize unit corresponds to 2 millimeters for this export.
			 *  Setting a scale is not defined for perspective cameras.
			 *  \param in_scale the unit scale. in_scale is required to be a positive number.
			 *  \param in_units the unit in_scale is expressed in.
			 * 	\return A reference to this ExportOptionsKit.
			 */
			ExportOptionsKit &		SetScale(float in_scale, Hardcopy::SizeUnits in_units = Hardcopy::SizeUnits::Inches);

			/*! Removes the scale setting from Hardcopy.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetScale();

			/*! Shows the background preference for this Hardcopy export.
			 * 	\param out_background_preference the preference for the background of this Hardcopy export.
			 *	\return <span class='code'>true</span> if a background preference setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowBackgroundPreference(Hardcopy::BackgroundPreference & out_background_preference) const;

			/*! The background preference setting is used to decide how the background of this Hardcopy operation will be handled.
			 *  If no preference is specified, the background will be forced to be white.
			 *  \param in_background_preference how the background for this Hardcopy export will be handled.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetBackgroundPreference(Hardcopy::BackgroundPreference in_background_preference);

			/*! Removes the background preference setting from this Hardcopy export.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetBackgroundPreference();


			/*! Shows the rendering algorithm for this Hardcopy export.
			* 	\param out_rendering_algorithm the rendering algorithm setting of this Hardcopy export.
			*	\return <span class='code'>true</span> if a rendering algorithm setting was specified, <span class='code'>false</span> otherwise. */
			bool					ShowRenderingAlgorithm(Hardcopy::RenderingAlgorithm & out_rendering_algorithm) const;

			/*! The rendering algorithm setting is used to decide how the Hardcopy export will be performed.
			 *  If no preference is specified, two passes will be used for the Hardcopy export.
			 *  \param in_rendering_algorithm how the Hardcopy export will be handled.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		SetRenderingAlgorithm(Hardcopy::RenderingAlgorithm in_rendering_algorithm);

			/*! Removes the rendering algorithm setting from this Hardcopy export.
			 * 	\return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetRenderingAlgorithm();


			/*! Removes all settings from this ExportOptionsKit.
			 * \return A reference to this ExportOptionsKit. */
			ExportOptionsKit &		UnsetEverything();
		};

		/*! Export to a printer HDC
		 *	\param in_hdc The handle to the output device context.
		 *	\param in_attribdc The handle to the output attribute device context.
		 *	\param in_window The window to print
		 *	\param in_options Options for performing the export
		 */
		static IOResult Export(intptr_t in_hdc, intptr_t in_attribdc, HPS::WindowKey const & in_window, ExportOptionsKit const & in_options);

		/*! Export to the Clipboard.
		 *	\param in_window The window to export
		 *	\param in_options Options for performing the export
		 */
		static IOResult ExportClipboard(HPS::WindowKey const & in_window, ExportOptionsKit const & in_options);

		/*! Export to an Enhanced MetaFile.
		 *	\param in_filename The name of the file to export
		 *	\param in_window The window to export
		 *	\param in_options Options for performing the export
		 */
		static IOResult ExportEMF(char const * in_filename, WindowKey const & in_window, ExportOptionsKit const & in_options);

	private:
		GDI();
	};
#endif

private:
	Hardcopy();
};

//////////////////////////////////////////////////////////////////////
///////////////////////////// OBJ File IO//////////////////////////
//////////////////////////////////////////////////////////////////////

/*!	The OBJ class contains objects and enumerations used for importing OBJ files. */
class HPS_API OBJ
{
public:

	/*!	The ImportOptionsKit class contains any settings controlling the import of OBJ files. */
	class HPS_API ImportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportOptionsKit object. */
		ImportOptionsKit();

		/*! The copy constructor creates a new ImportOptionsKit object that contains the same settings as the source ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		ImportOptionsKit(ImportOptionsKit const & in_kit);

		/*! The move constructor creates an ImportOptionsKit by transferring the underlying impl of the rvalue reference to this ImportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from. */
		ImportOptionsKit(ImportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit & operator=(ImportOptionsKit && in_that);

		virtual ~ImportOptionsKit();

	static const HPS::Type staticType = HPS::Type::OBJImportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		void					Set(ImportOptionsKit const & in_kit);

		/*! Copies this ImportOptionsKit into the given ImportOptionsKit.
		 * 	\param out_kit The ImportOptionsKit to populate with the contents of this ImportOptionsKit. */
		void					Show(ImportOptionsKit & out_kit) const;

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		operator=(ImportOptionsKit const & in_kit);

		/*! Indicates whether this ImportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is not equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportOptionsKit const & in_kit) const;

		/*! Sets the root segment where the OBJ data will be imported into.  If no segment is specified, a root segment will be created for this
		 * 	purpose during import.
		 *	\param in_segment Segment the OBJ data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment specifying where the OBJ data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetSegment();

		/*! Shows the root segment where the OBJ data will be imported into.
		 *	\param out_segment Segment the OBJ data will be imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Sets the portfolio which will be used when the importing images and textures.
		 * 	If no segment is specified, a portfolio will be created for this purpose during import.
		 *	\param in_portfolio Portfolio that will be used when importing images and textures
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetPortfolio(PortfolioKey const & in_portfolio);

		/*! Removes the portfolio which will be used when importing images and textures.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetPortfolio();

		/*! Shows the portfolio which will be used when importing images and textures.
		 *	\param out_portfolio Portfolio that will be used when importing images and textures.
		 *	\return <span class='code'>true</span> if a portfolio was specified, <span class='code'>false</span> otherwise. */
		bool					ShowPortfolio(PortfolioKey & out_portfolio) const;

		/*! Sets the handedness used to import geometry by the OBJ importer.
		 *  It should match the World Handedness for best results.
		 *  Defaults to Right if not set.
		 *	\param in_handedness The handedness used to import geometry.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetHandedness(Drawing::Handedness const & in_handedness);

		/*! Removes handedness information from this kit.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetHandedness();

		/*! Shows the handedness used to import geometry.
		 *	\param out_handedness Handedness used to import geometry.
		 *	\return <span class='code'>true</span> if a handedness was specified, <span class='code'>false</span> otherwise. */
		bool					ShowHandedness(Drawing::Handedness & out_handedness) const;

		/*! Removes all settings from this ImportOptionsKit.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetEverything();
	};

	/*! The ImportResultsKit class contains the results of a successful OBJ import. */
	class HPS_API ImportResultsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportResultsKit object. */
		ImportResultsKit();

		/*! The copy constructor creates a new ImportResultsKit object that contains the same settings as the source ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		ImportResultsKit(ImportResultsKit const & in_kit);

		/*! The move constructor creates an ImportResultsKit by transferring the underlying impl of the rvalue reference to this ImportResultsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from. */
		ImportResultsKit(ImportResultsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportResultsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit & operator=(ImportResultsKit && in_that);

		virtual ~ImportResultsKit();

	static const HPS::Type staticType = HPS::Type::OBJImportResultsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		void					Set(ImportResultsKit const & in_kit);

		/*! Copies this ImportResultsKit into the given ImportResultsKit.
		 * 	\param out_kit The ImportResultsKit to populate with the contents of this ImportResultsKit. */
		void					Show(ImportResultsKit & out_kit) const;

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		operator=(ImportResultsKit const & in_kit);

		/*! Indicates whether this ImportResultsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportResultsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is not equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportResultsKit const & in_kit) const;

		/*! Sets the root segment which the OBJ data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an OBJ import.
		 *	\param in_segment Segment the OBJ data was imported into.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment which the OBJ data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an OBJ import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetSegment();

		/*! Shows the root segment which the OBJ data was imported into.  This was either the root segment specified by the user in the ImportOptionsKit
		 * 	passed to OBJ::File::Import, or the root segment that was created for this purpose during import.
		 *	\param out_segment Segment the OBJ data was imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Sets the portfolio which was used when the import file read in images and textures.  This is really only
		 * 	used when generating an ImportResultsKit which is being returned to a user following an OBJ import.
		 *	\param in_portfolio Portfolio that was used when the file imported images and textures.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetPortfolio(PortfolioKey const & in_portfolio);

		/*! Removes the portfolio which was used when the import file imported images and textures.  This is really only
		 * 	used when generating an ImportResultsKit which is being returned to a user following an OBJ import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetPortfolio();

		/*! Shows the portfolio which was used when the import file read in images and textures.  This was either the portfolio
		 * 	specified by the user in the ImportOptionsKit passed to OBJ::File::Import, or the portfolio that was created for this purpose during
		 * 	import.
		 *	\param in_portfolio Portfolio that was used when the import file read in images and textures.
		 *	\return <span class='code'>true</span> if portfolio was specified, <span class='code'>false</span> otherwise. */
		bool					ShowPortfolio(PortfolioKey & out_portfolio) const;

		/*! Sets the handedness used when importing geometry. This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an OBJ import.
		 *	\param in_handedness Handedness used to import geometry.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetHandedness(Drawing::Handedness const & in_handedness);

		/*! Removes the handedness used to import geometry.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an OBJ import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetHandedness();

		/*! Shows handedness used to import geometry.  This was either the root segment specified by the user in the ImportOptionsKit
		 * 	passed to OBJ::File::Import, or the root segment that was created for this purpose during import.
		 *	\param out_handedness Segment the OBJ data was imported into.
		 *	\return <span class='code'>true</span> if a handedness was specified, <span class='code'>false</span> otherwise. */
		bool					ShowHandedness(Drawing::Handedness & out_handedness) const;

		/*! Removes all settings from this ImportResultsKit.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetEverything();
	};

	/*! The ImportNotifier class is a smart-pointer that is associated with an asynchronous file import.  It is used to interact with an ongoing
	 * 	import or get the results from a completed import. */
	class HPS_API ImportNotifier : public IONotifier
	{
	public:
		/*! The default constructor creates an ImportNotifier object which is not associated with any file import. */
		ImportNotifier();

		/*! The copy constructor creates a new ImportNotifier object that is associated with the same file import as the source ImportNotifier.
		 * 	\param in_that The source ImportNotifier to copy. */
		ImportNotifier(ImportNotifier const & in_that);

		/*! The conversion constructor creates a new derived ImportNotifier object from a base IONotifier object.
		 * 	The copy will only be successful if the source notifier is really an upcast of this notifier type.
		 *	Otherwise the copy will fail and the resulting ImportNotifier will be invalid.
		 * 	\param in_that The source IONotifier to copy. */
		ImportNotifier(IONotifier const & in_that);

		/*! The move constructor creates an ImportNotifier by transferring the underlying impl of the rvalue reference to this ImportNotifier
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from. */
		ImportNotifier(ImportNotifier && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportNotifier thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from.
		 * 	\return A reference to this ImportNotfier. */
		ImportNotifier &		operator=(ImportNotifier && in_that);

		virtual ~ImportNotifier();

	static const HPS::Type staticType = HPS::Type::OBJImportNotifier;
		HPS::Type				ObjectType() const {return staticType;};

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment.
		 *	\return A reference to this ImportNotifier. */
		ImportNotifier &		operator=(ImportNotifier const & in_that);

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment. */
		void					Assign(ImportNotifier const & in_that);

		/*!	Get the ImportResultsKit for the file import.  Throws an IOException if the import is not complete or
		 *  was not successful.
		 *  \return The ImportResultsKit for a successful file import. */
		ImportResultsKit		GetResults() const;
	};

	/*! The ExportNotifier class is a smart-pointer that is associated with an asynchronous file export.  It is used to interact with an ongoing
	* 	export or get the results from a completed export. */
	class HPS_API ExportNotifier : public IONotifier
	{
	public:
		/*! The default constructor creates an ExportNotifier object which is not associated with any file export. */
		ExportNotifier();

		/*! The copy constructor creates a new ExportNotifier object that is associated with the same file export as the source ExportNotifier.
		* 	\param in_that The source ExportNotifier to copy. */
		ExportNotifier(ExportNotifier const & in_that);

		/*! The conversion constructor creates a new derived ExportNotifier object from a base IONotifier object.
		* 	The copy will only be successful if the source notifier is really an upcast of this notifier type.
		*	Otherwise the copy will fail and the resulting ExportNotifier will be invalid.
		* 	\param in_that The source IONotifier to copy. */
		ExportNotifier(IONotifier const & in_that);

		/*! The move constructor creates an ExportNotifier by transferring the underlying impl of the rvalue reference to this ExportNotifier
		* 	thereby avoiding a copy and allocation.
		* 	\param in_that An rvalue reference to an ExportNotifier to take the impl from. */
		ExportNotifier(ExportNotifier && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ExportNotifier thereby avoiding a copy.
		* 	\param in_that An rvalue reference to an ExportNotifier to take the impl from.
		* 	\return A reference to this ExportNotifier. */
		ExportNotifier &		operator=(ExportNotifier && in_that);

		virtual ~ExportNotifier();

		static const HPS::Type staticType = HPS::Type::OBJExportNotifier;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Associate this ExportNotifier with the same file export as the source ExportNotifier.
		*	\param in_that The source ExportNotifier for the assignment.
		*	\return A reference to this ExportNotifier. */
		ExportNotifier &		operator=(ExportNotifier const & in_that);

		/*! Associate this ExportNotifier with the same file export as the source ExportNotifier.
		*	\param in_that The source ExportNotifier for the assignment. */
		void					Assign(ExportNotifier const & in_that);
	};


	/*!	The File class provides functions to import and export OBJ files. */
	class HPS_API File
	{
	public:
		/*!	Performs an asynchronous import of the specified OBJ file with the provided options.  May throw an IOException prior to starting
		 * 	the asynchronous import.
		 * 	\param in_file_name Name of OBJ file to import.
		 *	\param in_options Options controlling the import of the OBJ file (e.g., segment to import into).
		 *	\return An ImportNotfier object that can be used to query the import progress and status. */
		static ImportNotifier	Import(char const * in_file_name, ImportOptionsKit const & in_options);

		/*!	Performs an asynchronous export of the specified key path to an OBJ file.
		*   May throw IOException in case of errors.
		* 	\param in_file_name Name of OBJ file to export.
		*	\param in_key_path_to_export KeyPath from the segment where to start the export to the WindowKey.
		*   When using Sprocket, if you wish to export the Model, construct a SprocketPath and pass the KeyPath obtained from its GetKeyPath() method.
		*	\return An ExportNotfier object that can be used to query the export progress and status. */
		static ExportNotifier	Export(char const * in_file_name, HPS::KeyPath const & in_key_path_to_export);

	private:
		//! Private default constructor to prevent instantiation.
		File();
	};
private:
	//! Private default constructor to prevent instantiation.
	OBJ();
};

//////////////////////////////////////////////////////////////////////
///////////////////////////// STL File IO//////////////////////////
//////////////////////////////////////////////////////////////////////

/*!	The STL class contains objects and enumerations used for importing STL files. */
class HPS_API STL
{
public:

	/*!	The ImportOptionsKit class contains any settings controlling the import of STL files. */
	class HPS_API ImportOptionsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportOptionsKit object. */
		ImportOptionsKit();

		/*! The copy constructor creates a new ImportOptionsKit object that contains the same settings as the source ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		ImportOptionsKit(ImportOptionsKit const & in_kit);

		/*! The move constructor creates an ImportOptionsKit by transferring the underlying impl of the rvalue reference to this ImportOptionsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from. */
		ImportOptionsKit(ImportOptionsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportOptionsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportOptionsKit to take the impl from.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit & operator=(ImportOptionsKit && in_that);

		virtual ~ImportOptionsKit();

	static const HPS::Type staticType = HPS::Type::STLImportOptionsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy. */
		void					Set(ImportOptionsKit const & in_kit);

		/*! Copies this ImportOptionsKit into the given ImportOptionsKit.
		 * 	\param out_kit The ImportOptionsKit to populate with the contents of this ImportOptionsKit. */
		void					Show(ImportOptionsKit & out_kit) const;

		/*! Copies the source ImportOptionsKit into this ImportOptionsKit.
		 * 	\param in_kit The source ImportOptionsKit to copy.
		 * 	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		operator=(ImportOptionsKit const & in_kit);

		/*! Indicates whether this ImportOptionsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportOptionsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportOptionsKit const & in_kit) const;

		/*!	Check if the source ImportOptionsKit is not equivalent to this ImportOptionsKit.
		 *	\param in_kit The source ImportOptionsKit to compare to this ImportOptionsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportOptionsKit const & in_kit) const;

		/*! Creates an ImportOptionsKit which contains the default settings.  The returned object will not necessarily have values
		 *	set for every option, but it will have settings for those options where it is reasonable to have a default.
		 *	\return An ImportOptionsKit with the default settings. */
		static ImportOptionsKit GetDefault();

		/*! Sets the root segment where the STL data will be imported into.  If no segment is specified, a root segment will be created for this
		 * 	purpose during import.
		 *	\param in_segment Segment the STL data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Sets the options for the optimization performed on the shells created as a result of this import. Turning off optimization generally results in slightly faster load times and better visual fidelity, but has the downside of impacting performance.

Turning optimization on increases the load time at the expense of visual fidelity but increases performance, based on the options chosen. The tolerances set as part of the optimization kit are particularly responsible for downgrading the visual fidelity.
		 *  Supplying an empty optimization kit will disable optimization.
		 *	\param in_state Whether the optimization should be enabled.
		 *	\param in_optimization_kit The optimization options for this import
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetOptimization(bool in_state, ShellOptimizationOptionsKit const & in_optimization_kit);

		/*! Sets the options for the optimization performed on the shells created as a result of this import. Turning off optimization generally results in slightly faster load times and better visual fidelity, but has the downside of impacting performance.

Turning optimization on increases the load time at the expense of visual fidelity but increases performance, based on the options chosen. The tolerances set as part of the optimization kit are particularly responsible for downgrading the visual fidelity.
		 *  Supplying an empty optimization kit will disable optimization.
		 *	\param in_optimization_kit The optimization options for this import
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		SetOptimization(ShellOptimizationOptionsKit const & in_optimization_kit);


		/*! Removes the root segment specifying where the STL data will be imported into.
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetSegment();

		/*! Removes the optimization options for this import
		 *	\return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetOptimization();

		/*! Removes all settings from this ImportOptionsKit.
		 * \return A reference to this ImportOptionsKit. */
		ImportOptionsKit &		UnsetEverything();


		/*! Shows the root segment where the STL data will be imported into.
		 *	\param out_segment Segment the STL data will be imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Shows the optimization options for this import
		*	\param out_state Whether optimization is enabled.
		 *	\param out_optimization_options Optimization options for this import.
		 *	\return <span class='code'>true</span> if optimization options were specified, <span class='code'>false</span> otherwise. */
		bool					ShowOptimization(bool & out_state, ShellOptimizationOptionsKit & out_optimization_options) const;
	};

	/*! The ImportResultsKit class contains the results of a successful STL import. */
	class HPS_API ImportResultsKit : public Kit
	{
	public:
		/*! The default constructor creates an empty ImportResultsKit object. */
		ImportResultsKit();

		/*! The copy constructor creates a new ImportResultsKit object that contains the same settings as the source ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		ImportResultsKit(ImportResultsKit const & in_kit);

		/*! The move constructor creates an ImportResultsKit by transferring the underlying impl of the rvalue reference to this ImportResultsKit
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from. */
		ImportResultsKit(ImportResultsKit && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportResultsKit thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportResultsKit to take the impl from.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit & operator=(ImportResultsKit && in_that);

		virtual ~ImportResultsKit();

	static const HPS::Type staticType = HPS::Type::STLImportResultsKit;
		HPS::Type				ObjectType() const { return staticType; };

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy. */
		void					Set(ImportResultsKit const & in_kit);

		/*! Copies this ImportResultsKit into the given ImportResultsKit.
		 * 	\param out_kit The ImportResultsKit to populate with the contents of this ImportResultsKit. */
		void					Show(ImportResultsKit & out_kit) const;

		/*! Copies the source ImportResultsKit into this ImportResultsKit.
		 * 	\param in_kit The source ImportResultsKit to copy.
		 * 	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		operator=(ImportResultsKit const & in_kit);

		/*! Indicates whether this ImportResultsKit has any values set on it.
		 * 	\return <span class='code'>true</span> if no values are set on this ImportResultsKit, <span class='code'>false</span> otherwise. */
		bool					Empty() const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					Equals(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are equivalent, <span class='code'>false</span> otherwise. */
		bool					operator==(ImportResultsKit const & in_kit) const;

		/*!	Check if the source ImportResultsKit is not equivalent to this ImportResultsKit.
		 *	\param in_kit The source ImportResultsKit to compare to this ImportResultsKit.
		 *	\return <span class='code'>true</span> if the objects are not equivalent, <span class='code'>false</span> otherwise. */
		bool					operator!=(ImportResultsKit const & in_kit) const;

		/*! Sets the root segment which the OBJ data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an OBJ import.
		 *	\param in_segment Segment the OBJ data was imported into.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		SetSegment(SegmentKey const & in_segment);

		/*! Removes the root segment which the OBJ data was imported into.  This is really only used when generating an ImportResultsKit which is
		 * 	being returned to a user following an OBJ import.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetSegment();

		/*! Shows the root segment which the OBJ data was imported into.  This was either the root segment specified by the user in the ImportOptionsKit
		 * 	passed to OBJ::File::Import, or the root segment that was created for this purpose during import.
		 *	\param out_segment Segment the OBJ data was imported into.
		 *	\return <span class='code'>true</span> if a root segment was specified, <span class='code'>false</span> otherwise. */
		bool					ShowSegment(SegmentKey & out_segment) const;

		/*! Removes all settings from this ImportResultsKit.
		 *	\return A reference to this ImportResultsKit. */
		ImportResultsKit &		UnsetEverything();
	};

	/*! The ImportNotifier class is a smart-pointer that is associated with an asynchronous file import.  It is used to interact with an ongoing
	 * 	import or get the results from a completed import. */
	class HPS_API ImportNotifier : public IONotifier
	{
	public:
		/*! The default constructor creates an ImportNotifier object which is not associated with any file import. */
		ImportNotifier();

		/*! The copy constructor creates a new ImportNotifier object that is associated with the same file import as the source ImportNotifier.
		 * 	\param in_that The source ImportNotifier to copy. */
		ImportNotifier(ImportNotifier const & in_that);

		/*! The conversion constructor creates a new derived ImportNotifier object from a base IONotifier object.
		 * 	The copy will only be successful if the source notifier is really an upcast of this notifier type.
		 *	Otherwise the copy will fail and the resulting ImportNotifier will be invalid.
		 * 	\param in_that The source IONotifier to copy. */
		ImportNotifier(IONotifier const & in_that);

		/*! The move constructor creates an ImportNotifier by transferring the underlying impl of the rvalue reference to this ImportNotifier
		 * 	thereby avoiding a copy and allocation.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from. */
		ImportNotifier(ImportNotifier && in_that);

		/*! The move assignment operator transfers the underlying impl of the rvalue reference to this ImportNotifier thereby avoiding a copy.
		 * 	\param in_that An rvalue reference to an ImportNotifier to take the impl from.
		 * 	\return A reference to this ImportNotfier. */
		ImportNotifier &		operator=(ImportNotifier && in_that);

		virtual ~ImportNotifier();

	static const HPS::Type staticType = HPS::Type::STLImportNotifier;
		HPS::Type				ObjectType() const {return staticType;};

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment.
		 *	\return A reference to this ImportNotifier. */
		ImportNotifier &		operator=(ImportNotifier const & in_that);

		/*! Associate this ImportNotifier with the same file import as the source ImportNotifier.
		 *	\param in_that The source ImportNotifier for the assignment. */
		void					Assign(ImportNotifier const & in_that);

		/*!	Get the ImportResultsKit for the file import.  Throws an IOException if the import is not complete or
		 *  was not successful.
		 *  \return The ImportResultsKit for a successful file import. */
		ImportResultsKit		GetResults() const;
	};


	/*!	The File class provides functions to import and export STL files. */
	class HPS_API File
	{
	public:
		/*!	Performs an asynchronous import of the specified STL file with the provided options.  May throw an IOException prior to starting
		 * 	the asynchronous import.
		 * 	\param in_file_name Name of STL file to import.
		 *	\param in_options Options controlling the import of the STL file (e.g., segment to import into).
		 *	\return An ImportNotfier object that can be used to query the import progress and status. */
		static ImportNotifier	Import(char const * in_file_name, ImportOptionsKit const & in_options);

	private:
		//! Private default constructor to prevent instantiation.
		File();
	};
private:
	//! Private default constructor to prevent instantiation.
	STL();
};

}

#ifdef _MSC_VER
#	pragma warning(pop)
#endif

#endif


